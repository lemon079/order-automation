{"version":3,"sources":["../../../../../node_modules/langsmith/node_modules/eventemitter3/index.js","../../../../../node_modules/p-finally/index.js","../../../../../node_modules/langsmith/node_modules/p-timeout/index.js","../../../../../node_modules/langsmith/node_modules/p-queue/dist/lower-bound.js","../../../../../node_modules/langsmith/node_modules/p-queue/dist/priority-queue.js","../../../../../node_modules/langsmith/node_modules/p-queue/dist/index.js","../../../../../node_modules/langsmith/node_modules/semver/internal/constants.js","../../../../../node_modules/langsmith/node_modules/semver/internal/debug.js","../../../../../node_modules/langsmith/node_modules/semver/internal/re.js","../../../../../node_modules/langsmith/node_modules/semver/internal/parse-options.js","../../../../../node_modules/langsmith/node_modules/semver/internal/identifiers.js","../../../../../node_modules/langsmith/node_modules/semver/classes/semver.js","../../../../../node_modules/langsmith/node_modules/semver/functions/parse.js","../../../../../node_modules/langsmith/node_modules/semver/functions/valid.js","../../../../../node_modules/langsmith/node_modules/semver/functions/clean.js","../../../../../node_modules/langsmith/node_modules/semver/functions/inc.js","../../../../../node_modules/langsmith/node_modules/semver/functions/diff.js","../../../../../node_modules/langsmith/node_modules/semver/functions/major.js","../../../../../node_modules/langsmith/node_modules/semver/functions/minor.js","../../../../../node_modules/langsmith/node_modules/semver/functions/patch.js","../../../../../node_modules/langsmith/node_modules/semver/functions/prerelease.js","../../../../../node_modules/langsmith/node_modules/semver/functions/compare.js","../../../../../node_modules/langsmith/node_modules/semver/functions/rcompare.js","../../../../../node_modules/langsmith/node_modules/semver/functions/compare-loose.js","../../../../../node_modules/langsmith/node_modules/semver/functions/compare-build.js","../../../../../node_modules/langsmith/node_modules/semver/functions/sort.js","../../../../../node_modules/langsmith/node_modules/semver/functions/rsort.js","../../../../../node_modules/langsmith/node_modules/semver/functions/gt.js","../../../../../node_modules/langsmith/node_modules/semver/functions/lt.js","../../../../../node_modules/langsmith/node_modules/semver/functions/eq.js","../../../../../node_modules/langsmith/node_modules/semver/functions/neq.js","../../../../../node_modules/langsmith/node_modules/semver/functions/gte.js","../../../../../node_modules/langsmith/node_modules/semver/functions/lte.js","../../../../../node_modules/langsmith/node_modules/semver/functions/cmp.js","../../../../../node_modules/langsmith/node_modules/semver/functions/coerce.js","../../../../../node_modules/langsmith/node_modules/semver/internal/lrucache.js","../../../../../node_modules/langsmith/node_modules/semver/classes/range.js","../../../../../node_modules/langsmith/node_modules/semver/classes/comparator.js","../../../../../node_modules/langsmith/node_modules/semver/functions/satisfies.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/to-comparators.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/max-satisfying.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/min-satisfying.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/min-version.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/valid.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/outside.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/gtr.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/ltr.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/intersects.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/simplify.js","../../../../../node_modules/langsmith/node_modules/semver/ranges/subset.js","../../../../../node_modules/langsmith/node_modules/semver/index.js","../../../../../node_modules/eventemitter3/index.js","../../../../../node_modules/base64-js/index.js","../../../../../apps/web/src/app/api/orders/resolve/route.ts","../../../../../node_modules/uuid/dist/esm-node/native.js","../../../../../node_modules/langsmith/dist/utils/warn.js","../../../../../node_modules/langsmith/dist/utils/_uuid.js","../../../../../node_modules/next/dist/esm/build/templates/app-route.js","../../../../../node_modules/langsmith/dist/utils/is-network-error/index.js","../../../../../node_modules/langsmith/dist/utils/prompts.js","../../../../../node_modules/langsmith/dist/utils/error.js","../../../../../node_modules/langsmith/dist/singletons/traceable.js","../../../../../node_modules/eventemitter3/index.mjs","../../../../../node_modules/%40langchain/core/dist/_virtual/rolldown_runtime.js","../../../../../node_modules/zod/v4/core/registries.js","../../../../../node_modules/zod/v3/index.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/format.js","../../../../../node_modules/js-tiktoken/dist/chunk-VL2OQCWN.js","../../../../../node_modules/mustache/mustache.mjs","../../../../../node_modules/zod/v4/classic/index.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/pointer.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/types.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/ucs2-length.js","../../../../../node_modules/langsmith/dist/singletons/constants.js","../../../../../node_modules/zod/v4/core/doc.js","../../../../../node_modules/zod/v4/core/versions.js","../../../../../node_modules/p-timeout/index.js","../../../../../node_modules/zod/v3/helpers/util.js","../../../../../node_modules/zod/v3/helpers/errorUtil.js","../../../../../node_modules/langsmith/dist/utils/messages.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/deep-compare-strict.js","../../../../../node_modules/uuid/dist/esm-node/regex.js","../../../../../node_modules/zod/v3/errors.js","../../../../../node_modules/langsmith/dist/utils/async_caller.js","../../../../../node_modules/uuid/dist/esm-node/rng.js","../../../../../node_modules/uuid/dist/esm-node/validate.js","../../../../../node_modules/langsmith/dist/singletons/fetch.js","../../../../../node_modules/uuid/dist/esm-node/parse.js","../../../../../node_modules/uuid/dist/esm-node/sha1.js","../../../../../node_modules/zod/v4/locales/ar.js","../../../../../node_modules/zod/v4/locales/az.js","../../../../../node_modules/zod/v4/locales/be.js","../../../../../node_modules/zod/v4/locales/ca.js","../../../../../node_modules/zod/v4/locales/cs.js","../../../../../node_modules/zod/v4/locales/da.js","../../../../../node_modules/zod/v4/locales/de.js","../../../../../node_modules/zod/v4/locales/es.js","../../../../../node_modules/zod/v4/locales/fa.js","../../../../../node_modules/zod/v4/locales/fi.js","../../../../../node_modules/zod/v4/locales/fr.js","../../../../../node_modules/zod/v4/locales/fr-CA.js","../../../../../node_modules/zod/v4/locales/he.js","../../../../../node_modules/zod/v4/locales/hu.js","../../../../../node_modules/zod/v4/locales/id.js","../../../../../node_modules/zod/v4/locales/it.js","../../../../../node_modules/zod/v4/locales/ja.js","../../../../../node_modules/zod/v4/locales/km.js","../../../../../node_modules/zod/v4/locales/ko.js","../../../../../node_modules/zod/v4/locales/mk.js","../../../../../node_modules/zod/v4/locales/ms.js","../../../../../node_modules/zod/v4/locales/nl.js","../../../../../node_modules/zod/v4/locales/no.js","../../../../../node_modules/zod/v4/locales/ota.js","../../../../../node_modules/zod/v4/locales/ps.js","../../../../../node_modules/zod/v4/locales/pl.js","../../../../../node_modules/zod/v4/locales/pt.js","../../../../../node_modules/zod/v4/locales/ru.js","../../../../../node_modules/zod/v4/locales/sl.js","../../../../../node_modules/zod/v4/locales/sv.js","../../../../../node_modules/zod/v4/locales/ta.js","../../../../../node_modules/zod/v4/locales/th.js","../../../../../node_modules/zod/v4/locales/uk.js","../../../../../node_modules/zod/v4/locales/ur.js","../../../../../node_modules/zod/v4/locales/vi.js","../../../../../node_modules/zod/v4/locales/zh-CN.js","../../../../../node_modules/zod/v4/locales/zh-TW.js","../../../../../node_modules/zod/v4/locales/yo.js","../../../../../node_modules/%40langchain/langgraph/src/pregel/types.ts","../../../../../node_modules/langsmith/dist/env.js","../../../../../node_modules/zod/v4/locales/ka.js","../../../../../node_modules/zod/v4/locales/tr.js","../../../../../node_modules/zod/v4/locales/is.js","../../../../../node_modules/zod/v4/locales/lt.js","../../../../../node_modules/zod/v3/ZodError.js","../../../../../node_modules/langsmith/dist/experimental/otel/constants.js","../../../../../node_modules/langsmith/dist/utils/project.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/dereference.js","../../../../../node_modules/zod/v4/core/core.js","../../../../../node_modules/zod/v4/core/util.js","../../../../../node_modules/zod/v4/core/regexes.js","../../../../../node_modules/zod/v4/locales/bg.js","../../../../../node_modules/zod/v4/locales/en.js","../../../../../node_modules/zod/v4/locales/eo.js","../../../../../node_modules/p-queue/dist/priority-queue.js","../../../../../node_modules/%40langchain/core/src/utils/json.ts","../../../../../node_modules/node_modules/.pnpm/decamelize%406.0.1/node_modules/decamelize/index.js","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/errorMessages.ts","../../../../../apps/web/src/lib/langgraph/tools/driver.ts","../../../../../node_modules/langsmith/dist/utils/env.js","../../../../../node_modules/langsmith/dist/singletons/otel.js","../../../../../node_modules/langsmith/dist/experimental/otel/translator.js","../../../../../node_modules/zod/v4/core/errors.js","../../../../../node_modules/zod/v3/locales/en.js","../../../../../node_modules/uuid/dist/esm-node/stringify.js","../../../../../node_modules/uuid/dist/esm-node/v35.js","../../../../../node_modules/uuid/dist/esm-node/v5.js","../../../../../apps/web/src/lib/langgraph/tools/warehouse.ts","../../../../../node_modules/zod/v4/core/to-json-schema.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/validator.js","../../../../../node_modules/zod/v4/classic/iso.js","../../../../../node_modules/zod/v4/classic/parse.js","../../../../../node_modules/zod/v4/classic/coerce.js","../../../../../node_modules/zod/v3/helpers/parseUtil.js","../../../../../node_modules/p-queue/dist/lower-bound.js","../../../../../node_modules/zod/v4/locales/kh.js","../../../../../node_modules/zod/v4/locales/ua.js","../../../../../node_modules/zod/v4/index.js","../../../../../node_modules/%40langchain/core/src/messages/block_translators/utils.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/utils/subgraph.ts","../../../../../node_modules/%40langchain/core/src/runnables/utils.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/literal.ts","../../../../../node_modules/%40langchain/core/src/messages/format.ts","../../../../../node_modules/%40langchain/core/src/language_models/utils.ts","../../../../../node_modules/node_modules/.pnpm/is-network-error%401.3.0/node_modules/is-network-error/index.js","../../../../../node_modules/%40langchain/langgraph/src/hash.ts","../../../../../node_modules/node_modules/.pnpm/ansi-styles%406.2.3/node_modules/ansi-styles/index.js","../../../../../node_modules/next/src/build/templates/app-route.ts","../../../../../node_modules/%40langchain/core/src/tools/utils.ts","../../../../../node_modules/uuid/dist/esm-node/v7.js","../../../../../node_modules/uuid/dist/esm-node/v1.js","../../../../../node_modules/zod/v4/classic/errors.js","../../../../../node_modules/uuid/dist/esm-node/v4.js","../../../../../node_modules/langsmith/dist/utils/fast-safe-stringify/index.js","../../../../../node_modules/zod/v4/core/parse.js","../../../../../apps/web/src/lib/langgraph/state.ts","../../../../../node_modules/zod/v4/classic/compat.js","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/enum.ts","../../../../../node_modules/%40langchain/core/src/utils/ml-distance-euclidean/euclidean.ts","../../../../../node_modules/%40langchain/core/src/errors/index.ts","../../../../../node_modules/zod/v4/core/checks.js","../../../../../node_modules/zod/v4/core/api.js","../../../../../node_modules/%40langchain/core/src/messages/block_translators/google_genai.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/never.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/memory.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/named_barrier_value.ts","../../../../../node_modules/%40langchain/core/src/messages/block_translators/anthropic.ts","../../../../../node_modules/langsmith/dist/utils/p-retry/index.js","../../../../../node_modules/zod/v3/types.js","../../../../../node_modules/langsmith/dist/uuid.js","../../../../../node_modules/langsmith/dist/utils/context_vars.js","../../../../../node_modules/zod/v4/classic/schemas.js","../../../../../node_modules/%40cfworker/json-schema/dist/esm/validate.js","../../../../../apps/web/src/lib/langgraph/nodes/resolve-order.ts","../../../../../apps/web/src/lib/langgraph/nodes/confirm-dispatch.ts","../../../../../node_modules/%40langchain/langgraph/src/setup/async_local_storage.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/pipeline.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/optional.ts","../../../../../node_modules/%40langchain/core/src/prompts/structured.ts","../../../../../node_modules/%40langchain/core/src/messages/content/data.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/effects.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/date.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/serde/jsonplus.ts","../../../../../node_modules/%40langchain/core/src/messages/block_translators/google_vertexai.ts","../../../../../node_modules/langsmith/dist/index.js","../../../../../apps/web/src/lib/langgraph/nodes/check-warehouse.ts","../../../../../apps/web/src/lib/langgraph/nodes/assign-driver.ts","../../../../../node_modules/p-queue/dist/index.js","../../../../../node_modules/%40langchain/langgraph/src/pregel/write.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/retrievers.ts","../../../../../node_modules/%40langchain/core/src/runnables/iter.ts","../../../../../node_modules/node_modules/.pnpm/camelcase%409.0.0/node_modules/camelcase/index.js","../../../../../node_modules/%40langchain/core/src/runnables/wrappers.ts","../../../../../node_modules/%40langchain/langgraph/src/errors.ts","../../../../../node_modules/%40langchain/langgraph/src/writer.ts","../../../../../node_modules/zod/v4/core/schemas.js","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/tuple.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/zodToJsonSchema.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/nativeEnum.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/output_parsers.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/id.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/array.ts","../../../../../node_modules/%40langchain/core/src/runnables/config.ts","../../../../../node_modules/%40langchain/core/src/singletons/tracer.ts","../../../../../node_modules/%40langchain/core/src/prompts/template.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/utils/index.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/list.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/store/batch.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/base.ts","../../../../../node_modules/%40langchain/core/src/messages/message.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/record.ts","../../../../../node_modules/zod/v4/classic/external.js","../../../../../node_modules/%40langchain/langgraph/src/constants.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/openai_tools/json_output_tools_parsers.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/number.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parseDef.ts","../../../../../node_modules/%40langchain/core/src/load/index.ts","../../../../../node_modules/node_modules/.pnpm/p-retry%407.1.0/node_modules/p-retry/index.js","../../../../../node_modules/%40langchain/core/src/messages/metadata.ts","../../../../../node_modules/%40langchain/core/src/tracers/event_stream.ts","../../../../../node_modules/uuid/dist/esm-node/v1ToV6.js","../../../../../node_modules/%40langchain/core/src/utils/ml-distance/distances.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/validate.ts","../../../../../node_modules/langsmith/dist/run_trees.js","../../../../../node_modules/uuid/dist/esm-node/v6.js","../../../../../node_modules/%40langchain/core/src/tracers/root_listener.ts","../../../../../node_modules/%40langchain/core/src/utils/types/zod.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/nullable.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/bigint.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/any.ts","../../../../../apps/web/src/lib/langgraph/graph.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/object.ts","../../../../../node_modules/%40langchain/core/src/load/map_keys.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/transform.ts","../../../../../node_modules/langsmith/dist/client.js","../../../../../node_modules/%40langchain/langgraph/src/graph/message.ts","../../../../../node_modules/%40langchain/core/src/runnables/graph_mermaid.ts","../../../../../node_modules/%40langchain/core/src/structured_query/utils.ts","../../../../../node_modules/%40langchain/core/src/utils/tiktoken.ts","../../../../../node_modules/%40langchain/core/src/runnables/graph.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/union.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/embeddings.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/cache/memory.ts","../../../../../node_modules/%40langchain/core/src/utils/fast-json-patch/src/duplex.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/set.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/binop.ts","../../../../../node_modules/%40langchain/langgraph/src/utils.ts","../../../../../node_modules/%40langchain/core/src/load/serializable.ts","../../../../../node_modules/%40langchain/core/src/documents/document.ts","../../../../../node_modules/%40langchain/core/src/utils/stream.ts","../../../../../node_modules/%40langchain/core/src/messages/base.ts","../../../../../node_modules/%40langchain/core/src/utils/env.ts","../../../../../node_modules/%40langchain/core/src/messages/chat.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/vectorstores.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/read.ts","../../../../../node_modules/%40langchain/core/src/messages/transformers.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/string.ts","../../../../../node_modules/%40langchain/core/src/embeddings.ts","../../../../../node_modules/%40langchain/core/src/structured_query/functional.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/algo.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/any_value.ts","../../../../../node_modules/%40langchain/langgraph/src/graph/graph.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/store/base.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/messages.ts","../../../../../node_modules/%40langchain/core/src/tracers/console.ts","../../../../../node_modules/%40langchain/core/src/prompts/prompt.ts","../../../../../node_modules/%40langchain/core/src/prompts/dict.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/loop.ts","../../../../../node_modules/%40langchain/core/src/tools/types.ts","../../../../../node_modules/%40langchain/core/src/utils/async_caller.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/llms.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/chat_models.ts","../../../../../node_modules/%40langchain/core/src/messages/ai.ts","../../../../../node_modules/%40langchain/core/src/language_models/base.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/retry.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/debug.ts","../../../../../node_modules/%40langchain/core/src/messages/utils.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/last_value.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/store/utils.ts","../../../../../node_modules/%40langchain/core/src/utils/fast-json-patch/src/core.ts","../../../../../node_modules/%40langchain/core/src/runnables/base.ts","../../../../../node_modules/%40langchain/core/src/tracers/base.ts","../../../../../node_modules/%40langchain/core/src/utils/function_calling.ts","../../../../../node_modules/%40langchain/core/src/caches/index.ts","../../../../../node_modules/%40langchain/core/src/structured_query/ir.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/ephemeral_value.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/parsers/intersection.ts","../../../../../node_modules/%40langchain/core/src/messages/human.ts","../../../../../node_modules/%40langchain/core/src/utils/testing/message_history.ts","../../../../../node_modules/%40langchain/core/src/chat_history.ts","../../../../../node_modules/%40langchain/core/src/utils/math.ts","../../../../../node_modules/%40langchain/core/src/tracers/log_stream.ts","../../../../../node_modules/%40langchain/core/src/callbacks/manager.ts","../../../../../node_modules/%40langchain/core/src/language_models/chat_models.ts","../../../../../node_modules/%40langchain/core/src/messages/block_translators/data.ts","../../../../../node_modules/%40langchain/core/src/singletons/async_local_storage/index.ts","../../../../../node_modules/%40langchain/core/src/singletons/callbacks.ts","../../../../../node_modules/%40langchain/core/src/messages/block_translators/bedrock_converse.ts","../../../../../node_modules/%40langchain/core/src/messages/function.ts","../../../../../node_modules/%40langchain/core/src/memory.ts","../../../../../node_modules/%40langchain/core/src/tracers/run_collector.ts","../../../../../node_modules/%40langchain/core/src/language_models/llms.ts","../../../../../node_modules/%40langchain/core/src/indexing/base.ts","../../../../../node_modules/%40langchain/core/src/prompts/image.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/openai_functions/json_output_functions_parsers.ts","../../../../../node_modules/%40langchain/core/src/structured_query/base.ts","../../../../../node_modules/%40langchain/core/src/utils/zod-to-json-schema/selectParser.ts","../../../../../node_modules/%40langchain/core/src/example_selectors/semantic_similarity.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/dynamic_barrier_value.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/structured.ts","../../../../../node_modules/%40langchain/core/src/example_selectors/conditional.ts","../../../../../node_modules/%40langchain/core/src/documents/transformers.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/stream.ts","../../../../../node_modules/%40langchain/langgraph/src/graph/zod/meta.ts","../../../../../node_modules/%40langchain/core/src/messages/system.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/call.ts","../../../../../node_modules/%40langchain/core/src/utils/json_schema.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/base.ts","../../../../../node_modules/%40langchain/core/src/prompts/base.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/index.ts","../../../../../node_modules/%40langchain/langgraph/src/graph/messages_annotation.ts","../../../../../node_modules/%40langchain/core/src/messages/block_translators/openai.ts","../../../../../node_modules/%40langchain/core/src/prompts/few_shot.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/utils/config.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/io.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/store/memory.ts","../../../../../node_modules/%40langchain/core/src/prompt_values.ts","../../../../../node_modules/%40langchain/langgraph/src/pregel/runner.ts","../../../../../node_modules/%40langchain/core/src/messages/tool.ts","../../../../../node_modules/%40langchain/core/src/callbacks/base.ts","../../../../../node_modules/%40langchain/core/src/utils/sax-js/sax.ts","../../../../../node_modules/%40langchain/core/src/runnables/router.ts","../../../../../node_modules/%40langchain/core/src/prompts/chat.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/xml.ts","../../../../../node_modules/%40langchain/core/src/prompts/pipeline.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/topic.ts","../../../../../node_modules/%40langchain/core/src/runnables/passthrough.ts","../../../../../node_modules/%40langchain/core/src/tracers/tracer_langchain.ts","../../../../../node_modules/%40langchain/core/src/utils/fast-json-patch/src/helpers.ts","../../../../../node_modules/%40langchain/langgraph/src/interrupt.ts","../../../../../node_modules/%40langchain/core/src/singletons/async_local_storage/context.ts","../../../../../node_modules/%40langchain/core/src/stores.ts","../../../../../node_modules/%40langchain/langgraph-checkpoint/src/serde/utils/fast-safe-stringify/index.ts","../../../../../node_modules/%40langchain/core/src/output_parsers/string.ts","../../../../../node_modules/%40langchain/langgraph/src/func/index.ts","../../../../../node_modules/%40langchain/core/src/utils/event_source_parse.ts","../../../../../node_modules/%40langchain/langgraph/src/channels/base.ts","../../../../../node_modules/%40langchain/core/src/document_loaders/langsmith.ts","../../../../../node_modules/%40langchain/core/src/tools/index.ts","../../../../../node_modules/%40langchain/core/src/runnables/history.ts","../../../../../node_modules/%40langchain/core/src/runnables/branch.ts","../../../../../node_modules/%40langchain/core/src/example_selectors/length_based.ts","../../../../../node_modules/%40langchain/core/src/retrievers/index.ts","../../../../../node_modules/%40langchain/core/src/utils/js-sha256/hash.ts","../../../../../node_modules/%40langchain/langgraph/src/graph/annotation.ts","../../../../../node_modules/%40langchain/langgraph/src/graph/state.ts","../../../../../node_modules/%40langchain/core/src/vectorstores.ts"],"sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict';\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n","'use strict';\n\nconst pFinally = require('p-finally');\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t}\n\n\tif (milliseconds === Infinity) {\n\t\tresolve(promise);\n\t\treturn;\n\t}\n\n\tconst timer = setTimeout(() => {\n\t\tif (typeof fallback === 'function') {\n\t\t\ttry {\n\t\t\t\tresolve(fallback());\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\tif (typeof promise.cancel === 'function') {\n\t\t\tpromise.cancel();\n\t\t}\n\n\t\treject(timeoutError);\n\t}, milliseconds);\n\n\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\tpFinally(\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tpromise.then(resolve, reject),\n\t\t() => {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t);\n});\n\nmodule.exports = pTimeout;\n// TODO: Remove this for the next major release\nmodule.exports.default = pTimeout;\n\nmodule.exports.TimeoutError = TimeoutError;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = (count / 2) | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports.default = lowerBound;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lower_bound_1 = require(\"./lower-bound\");\nclass PriorityQueue {\n    constructor() {\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({ priority: 0 }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports.default = PriorityQueue;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst EventEmitter = require(\"eventemitter3\");\nconst p_timeout_1 = require(\"p-timeout\");\nconst priority_queue_1 = require(\"./priority-queue\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports.default = PQueue;\n","'use strict'\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nconst SEMVER_SPEC_VERSION = '2.0.0'\n\nconst MAX_LENGTH = 256\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n/* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nconst MAX_SAFE_COMPONENT_LENGTH = 16\n\n// Max safe length for a build identifier. The max length minus 6 characters for\n// the shortest version with a build 0.0.0+BUILD.\nconst MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6\n\nconst RELEASE_TYPES = [\n  'major',\n  'premajor',\n  'minor',\n  'preminor',\n  'patch',\n  'prepatch',\n  'prerelease',\n]\n\nmodule.exports = {\n  MAX_LENGTH,\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_SAFE_INTEGER,\n  RELEASE_TYPES,\n  SEMVER_SPEC_VERSION,\n  FLAG_INCLUDE_PRERELEASE: 0b001,\n  FLAG_LOOSE: 0b010,\n}\n","'use strict'\n\nconst debug = (\n  typeof process === 'object' &&\n  process.env &&\n  process.env.NODE_DEBUG &&\n  /\\bsemver\\b/i.test(process.env.NODE_DEBUG)\n) ? (...args) => console.error('SEMVER', ...args)\n  : () => {}\n\nmodule.exports = debug\n","'use strict'\n\nconst {\n  MAX_SAFE_COMPONENT_LENGTH,\n  MAX_SAFE_BUILD_LENGTH,\n  MAX_LENGTH,\n} = require('./constants')\nconst debug = require('./debug')\nexports = module.exports = {}\n\n// The actual regexps go on exports.re\nconst re = exports.re = []\nconst safeRe = exports.safeRe = []\nconst src = exports.src = []\nconst safeSrc = exports.safeSrc = []\nconst t = exports.t = {}\nlet R = 0\n\nconst LETTERDASHNUMBER = '[a-zA-Z0-9-]'\n\n// Replace some greedy regex tokens to prevent regex dos issues. These regex are\n// used internally via the safeRe object since all inputs in this library get\n// normalized first to trim and collapse all extra whitespace. The original\n// regexes are exported for userland consumption and lower level usage. A\n// future breaking change could export the safer regex only with a note that\n// all input should have extra whitespace removed.\nconst safeRegexReplacements = [\n  ['\\\\s', 1],\n  ['\\\\d', MAX_LENGTH],\n  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],\n]\n\nconst makeSafeRegex = (value) => {\n  for (const [token, max] of safeRegexReplacements) {\n    value = value\n      .split(`${token}*`).join(`${token}{0,${max}}`)\n      .split(`${token}+`).join(`${token}{1,${max}}`)\n  }\n  return value\n}\n\nconst createToken = (name, value, isGlobal) => {\n  const safe = makeSafeRegex(value)\n  const index = R++\n  debug(name, index, value)\n  t[name] = index\n  src[index] = value\n  safeSrc[index] = safe\n  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)\n  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined)\n}\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\ncreateToken('NUMERICIDENTIFIER', '0|[1-9]\\\\d*')\ncreateToken('NUMERICIDENTIFIERLOOSE', '\\\\d+')\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\ncreateToken('NONNUMERICIDENTIFIER', `\\\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`)\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\ncreateToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})\\\\.` +\n                   `(${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\\\.` +\n                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n// Non-numberic identifiers include numberic identifiers but can be longer.\n// Therefore non-numberic identifiers must go first.\n\ncreateToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIER]})`)\n\ncreateToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]\n}|${src[t.NUMERICIDENTIFIERLOOSE]})`)\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\ncreateToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIER]})*))`)\n\ncreateToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]\n}(?:\\\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\ncreateToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`)\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\ncreateToken('BUILD', `(?:\\\\+(${src[t.BUILDIDENTIFIER]\n}(?:\\\\.${src[t.BUILDIDENTIFIER]})*))`)\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\ncreateToken('FULLPLAIN', `v?${src[t.MAINVERSION]\n}${src[t.PRERELEASE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('FULL', `^${src[t.FULLPLAIN]}$`)\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\ncreateToken('LOOSEPLAIN', `[v=\\\\s]*${src[t.MAINVERSIONLOOSE]\n}${src[t.PRERELEASELOOSE]}?${\n  src[t.BUILD]}?`)\n\ncreateToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)\n\ncreateToken('GTLT', '((?:<|>)?=?)')\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\ncreateToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`)\ncreateToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\\\*`)\n\ncreateToken('XRANGEPLAIN', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:\\\\.(${src[t.XRANGEIDENTIFIER]})` +\n                   `(?:${src[t.PRERELEASE]})?${\n                     src[t.BUILD]}?` +\n                   `)?)?`)\n\ncreateToken('XRANGEPLAINLOOSE', `[v=\\\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:\\\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +\n                        `(?:${src[t.PRERELEASELOOSE]})?${\n                          src[t.BUILD]}?` +\n                        `)?)?`)\n\ncreateToken('XRANGE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAIN]}$`)\ncreateToken('XRANGELOOSE', `^${src[t.GTLT]}\\\\s*${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\ncreateToken('COERCEPLAIN', `${'(^|[^\\\\d])' +\n              '(\\\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +\n              `(?:\\\\.(\\\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`)\ncreateToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\\\d])`)\ncreateToken('COERCEFULL', src[t.COERCEPLAIN] +\n              `(?:${src[t.PRERELEASE]})?` +\n              `(?:${src[t.BUILD]})?` +\n              `(?:$|[^\\\\d])`)\ncreateToken('COERCERTL', src[t.COERCE], true)\ncreateToken('COERCERTLFULL', src[t.COERCEFULL], true)\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\ncreateToken('LONETILDE', '(?:~>?)')\n\ncreateToken('TILDETRIM', `(\\\\s*)${src[t.LONETILDE]}\\\\s+`, true)\nexports.tildeTrimReplace = '$1~'\n\ncreateToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\ncreateToken('LONECARET', '(?:\\\\^)')\n\ncreateToken('CARETTRIM', `(\\\\s*)${src[t.LONECARET]}\\\\s+`, true)\nexports.caretTrimReplace = '$1^'\n\ncreateToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)\ncreateToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\ncreateToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\\\s*(${src[t.LOOSEPLAIN]})$|^$`)\ncreateToken('COMPARATOR', `^${src[t.GTLT]}\\\\s*(${src[t.FULLPLAIN]})$|^$`)\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\ncreateToken('COMPARATORTRIM', `(\\\\s*)${src[t.GTLT]\n}\\\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)\nexports.comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\ncreateToken('HYPHENRANGE', `^\\\\s*(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s+-\\\\s+` +\n                   `(${src[t.XRANGEPLAIN]})` +\n                   `\\\\s*$`)\n\ncreateToken('HYPHENRANGELOOSE', `^\\\\s*(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s+-\\\\s+` +\n                        `(${src[t.XRANGEPLAINLOOSE]})` +\n                        `\\\\s*$`)\n\n// Star ranges basically just allow anything at all.\ncreateToken('STAR', '(<|>)?=?\\\\s*\\\\*')\n// >=0.0.0 is like a star\ncreateToken('GTE0', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0\\\\s*$')\ncreateToken('GTE0PRE', '^\\\\s*>=\\\\s*0\\\\.0\\\\.0-0\\\\s*$')\n","'use strict'\n\n// parse out just the options we care about\nconst looseOption = Object.freeze({ loose: true })\nconst emptyOpts = Object.freeze({ })\nconst parseOptions = options => {\n  if (!options) {\n    return emptyOpts\n  }\n\n  if (typeof options !== 'object') {\n    return looseOption\n  }\n\n  return options\n}\nmodule.exports = parseOptions\n","'use strict'\n\nconst numeric = /^[0-9]+$/\nconst compareIdentifiers = (a, b) => {\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b ? 0 : a < b ? -1 : 1\n  }\n\n  const anum = numeric.test(a)\n  const bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nconst rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)\n\nmodule.exports = {\n  compareIdentifiers,\n  rcompareIdentifiers,\n}\n","'use strict'\n\nconst debug = require('../internal/debug')\nconst { MAX_LENGTH, MAX_SAFE_INTEGER } = require('../internal/constants')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst parseOptions = require('../internal/parse-options')\nconst { compareIdentifiers } = require('../internal/identifiers')\nclass SemVer {\n  constructor (version, options) {\n    options = parseOptions(options)\n\n    if (version instanceof SemVer) {\n      if (version.loose === !!options.loose &&\n        version.includePrerelease === !!options.includePrerelease) {\n        return version\n      } else {\n        version = version.version\n      }\n    } else if (typeof version !== 'string') {\n      throw new TypeError(`Invalid version. Must be a string. Got type \"${typeof version}\".`)\n    }\n\n    if (version.length > MAX_LENGTH) {\n      throw new TypeError(\n        `version is longer than ${MAX_LENGTH} characters`\n      )\n    }\n\n    debug('SemVer', version, options)\n    this.options = options\n    this.loose = !!options.loose\n    // this isn't actually relevant for versions, but keep it so that we\n    // don't run into trouble passing this.options around.\n    this.includePrerelease = !!options.includePrerelease\n\n    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])\n\n    if (!m) {\n      throw new TypeError(`Invalid Version: ${version}`)\n    }\n\n    this.raw = version\n\n    // these are actually numbers\n    this.major = +m[1]\n    this.minor = +m[2]\n    this.patch = +m[3]\n\n    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n      throw new TypeError('Invalid major version')\n    }\n\n    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n      throw new TypeError('Invalid minor version')\n    }\n\n    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n      throw new TypeError('Invalid patch version')\n    }\n\n    // numberify any prerelease numeric ids\n    if (!m[4]) {\n      this.prerelease = []\n    } else {\n      this.prerelease = m[4].split('.').map((id) => {\n        if (/^[0-9]+$/.test(id)) {\n          const num = +id\n          if (num >= 0 && num < MAX_SAFE_INTEGER) {\n            return num\n          }\n        }\n        return id\n      })\n    }\n\n    this.build = m[5] ? m[5].split('.') : []\n    this.format()\n  }\n\n  format () {\n    this.version = `${this.major}.${this.minor}.${this.patch}`\n    if (this.prerelease.length) {\n      this.version += `-${this.prerelease.join('.')}`\n    }\n    return this.version\n  }\n\n  toString () {\n    return this.version\n  }\n\n  compare (other) {\n    debug('SemVer.compare', this.version, this.options, other)\n    if (!(other instanceof SemVer)) {\n      if (typeof other === 'string' && other === this.version) {\n        return 0\n      }\n      other = new SemVer(other, this.options)\n    }\n\n    if (other.version === this.version) {\n      return 0\n    }\n\n    return this.compareMain(other) || this.comparePre(other)\n  }\n\n  compareMain (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    if (this.major < other.major) {\n      return -1\n    }\n    if (this.major > other.major) {\n      return 1\n    }\n    if (this.minor < other.minor) {\n      return -1\n    }\n    if (this.minor > other.minor) {\n      return 1\n    }\n    if (this.patch < other.patch) {\n      return -1\n    }\n    if (this.patch > other.patch) {\n      return 1\n    }\n    return 0\n  }\n\n  comparePre (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    // NOT having a prerelease is > having one\n    if (this.prerelease.length && !other.prerelease.length) {\n      return -1\n    } else if (!this.prerelease.length && other.prerelease.length) {\n      return 1\n    } else if (!this.prerelease.length && !other.prerelease.length) {\n      return 0\n    }\n\n    let i = 0\n    do {\n      const a = this.prerelease[i]\n      const b = other.prerelease[i]\n      debug('prerelease compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  compareBuild (other) {\n    if (!(other instanceof SemVer)) {\n      other = new SemVer(other, this.options)\n    }\n\n    let i = 0\n    do {\n      const a = this.build[i]\n      const b = other.build[i]\n      debug('build compare', i, a, b)\n      if (a === undefined && b === undefined) {\n        return 0\n      } else if (b === undefined) {\n        return 1\n      } else if (a === undefined) {\n        return -1\n      } else if (a === b) {\n        continue\n      } else {\n        return compareIdentifiers(a, b)\n      }\n    } while (++i)\n  }\n\n  // preminor will bump the version up to the next minor release, and immediately\n  // down to pre-release. premajor and prepatch work the same way.\n  inc (release, identifier, identifierBase) {\n    if (release.startsWith('pre')) {\n      if (!identifier && identifierBase === false) {\n        throw new Error('invalid increment argument: identifier is empty')\n      }\n      // Avoid an invalid semver results\n      if (identifier) {\n        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE])\n        if (!match || match[1] !== identifier) {\n          throw new Error(`invalid identifier: ${identifier}`)\n        }\n      }\n    }\n\n    switch (release) {\n      case 'premajor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor = 0\n        this.major++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'preminor':\n        this.prerelease.length = 0\n        this.patch = 0\n        this.minor++\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'prepatch':\n        // If this is already a prerelease, it will bump to the next version\n        // drop any prereleases that might already exist, since they are not\n        // relevant at this point.\n        this.prerelease.length = 0\n        this.inc('patch', identifier, identifierBase)\n        this.inc('pre', identifier, identifierBase)\n        break\n      // If the input is a non-prerelease version, this acts the same as\n      // prepatch.\n      case 'prerelease':\n        if (this.prerelease.length === 0) {\n          this.inc('patch', identifier, identifierBase)\n        }\n        this.inc('pre', identifier, identifierBase)\n        break\n      case 'release':\n        if (this.prerelease.length === 0) {\n          throw new Error(`version ${this.raw} is not a prerelease`)\n        }\n        this.prerelease.length = 0\n        break\n\n      case 'major':\n        // If this is a pre-major version, bump up to the same major version.\n        // Otherwise increment major.\n        // 1.0.0-5 bumps to 1.0.0\n        // 1.1.0 bumps to 2.0.0\n        if (\n          this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0\n        ) {\n          this.major++\n        }\n        this.minor = 0\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'minor':\n        // If this is a pre-minor version, bump up to the same minor version.\n        // Otherwise increment minor.\n        // 1.2.0-5 bumps to 1.2.0\n        // 1.2.1 bumps to 1.3.0\n        if (this.patch !== 0 || this.prerelease.length === 0) {\n          this.minor++\n        }\n        this.patch = 0\n        this.prerelease = []\n        break\n      case 'patch':\n        // If this is not a pre-release version, it will increment the patch.\n        // If it is a pre-release it will bump up to the same patch version.\n        // 1.2.0-5 patches to 1.2.0\n        // 1.2.0 patches to 1.2.1\n        if (this.prerelease.length === 0) {\n          this.patch++\n        }\n        this.prerelease = []\n        break\n      // This probably shouldn't be used publicly.\n      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.\n      case 'pre': {\n        const base = Number(identifierBase) ? 1 : 0\n\n        if (this.prerelease.length === 0) {\n          this.prerelease = [base]\n        } else {\n          let i = this.prerelease.length\n          while (--i >= 0) {\n            if (typeof this.prerelease[i] === 'number') {\n              this.prerelease[i]++\n              i = -2\n            }\n          }\n          if (i === -1) {\n            // didn't increment anything\n            if (identifier === this.prerelease.join('.') && identifierBase === false) {\n              throw new Error('invalid increment argument: identifier already exists')\n            }\n            this.prerelease.push(base)\n          }\n        }\n        if (identifier) {\n          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n          let prerelease = [identifier, base]\n          if (identifierBase === false) {\n            prerelease = [identifier]\n          }\n          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {\n            if (isNaN(this.prerelease[1])) {\n              this.prerelease = prerelease\n            }\n          } else {\n            this.prerelease = prerelease\n          }\n        }\n        break\n      }\n      default:\n        throw new Error(`invalid increment argument: ${release}`)\n    }\n    this.raw = this.format()\n    if (this.build.length) {\n      this.raw += `+${this.build.join('.')}`\n    }\n    return this\n  }\n}\n\nmodule.exports = SemVer\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst parse = (version, options, throwErrors = false) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    if (!throwErrors) {\n      return null\n    }\n    throw er\n  }\n}\n\nmodule.exports = parse\n","'use strict'\n\nconst parse = require('./parse')\nconst valid = (version, options) => {\n  const v = parse(version, options)\n  return v ? v.version : null\n}\nmodule.exports = valid\n","'use strict'\n\nconst parse = require('./parse')\nconst clean = (version, options) => {\n  const s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\nmodule.exports = clean\n","'use strict'\n\nconst SemVer = require('../classes/semver')\n\nconst inc = (version, release, options, identifier, identifierBase) => {\n  if (typeof (options) === 'string') {\n    identifierBase = identifier\n    identifier = options\n    options = undefined\n  }\n\n  try {\n    return new SemVer(\n      version instanceof SemVer ? version.version : version,\n      options\n    ).inc(release, identifier, identifierBase).version\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = inc\n","'use strict'\n\nconst parse = require('./parse.js')\n\nconst diff = (version1, version2) => {\n  const v1 = parse(version1, null, true)\n  const v2 = parse(version2, null, true)\n  const comparison = v1.compare(v2)\n\n  if (comparison === 0) {\n    return null\n  }\n\n  const v1Higher = comparison > 0\n  const highVersion = v1Higher ? v1 : v2\n  const lowVersion = v1Higher ? v2 : v1\n  const highHasPre = !!highVersion.prerelease.length\n  const lowHasPre = !!lowVersion.prerelease.length\n\n  if (lowHasPre && !highHasPre) {\n    // Going from prerelease -> no prerelease requires some special casing\n\n    // If the low version has only a major, then it will always be a major\n    // Some examples:\n    // 1.0.0-1 -> 1.0.0\n    // 1.0.0-1 -> 1.1.1\n    // 1.0.0-1 -> 2.0.0\n    if (!lowVersion.patch && !lowVersion.minor) {\n      return 'major'\n    }\n\n    // If the main part has no difference\n    if (lowVersion.compareMain(highVersion) === 0) {\n      if (lowVersion.minor && !lowVersion.patch) {\n        return 'minor'\n      }\n      return 'patch'\n    }\n  }\n\n  // add the `pre` prefix if we are going to a prerelease version\n  const prefix = highHasPre ? 'pre' : ''\n\n  if (v1.major !== v2.major) {\n    return prefix + 'major'\n  }\n\n  if (v1.minor !== v2.minor) {\n    return prefix + 'minor'\n  }\n\n  if (v1.patch !== v2.patch) {\n    return prefix + 'patch'\n  }\n\n  // high and low are preleases\n  return 'prerelease'\n}\n\nmodule.exports = diff\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst major = (a, loose) => new SemVer(a, loose).major\nmodule.exports = major\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst minor = (a, loose) => new SemVer(a, loose).minor\nmodule.exports = minor\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst patch = (a, loose) => new SemVer(a, loose).patch\nmodule.exports = patch\n","'use strict'\n\nconst parse = require('./parse')\nconst prerelease = (version, options) => {\n  const parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\nmodule.exports = prerelease\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst compare = (a, b, loose) =>\n  new SemVer(a, loose).compare(new SemVer(b, loose))\n\nmodule.exports = compare\n","'use strict'\n\nconst compare = require('./compare')\nconst rcompare = (a, b, loose) => compare(b, a, loose)\nmodule.exports = rcompare\n","'use strict'\n\nconst compare = require('./compare')\nconst compareLoose = (a, b) => compare(a, b, true)\nmodule.exports = compareLoose\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst compareBuild = (a, b, loose) => {\n  const versionA = new SemVer(a, loose)\n  const versionB = new SemVer(b, loose)\n  return versionA.compare(versionB) || versionA.compareBuild(versionB)\n}\nmodule.exports = compareBuild\n","'use strict'\n\nconst compareBuild = require('./compare-build')\nconst sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))\nmodule.exports = sort\n","'use strict'\n\nconst compareBuild = require('./compare-build')\nconst rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))\nmodule.exports = rsort\n","'use strict'\n\nconst compare = require('./compare')\nconst gt = (a, b, loose) => compare(a, b, loose) > 0\nmodule.exports = gt\n","'use strict'\n\nconst compare = require('./compare')\nconst lt = (a, b, loose) => compare(a, b, loose) < 0\nmodule.exports = lt\n","'use strict'\n\nconst compare = require('./compare')\nconst eq = (a, b, loose) => compare(a, b, loose) === 0\nmodule.exports = eq\n","'use strict'\n\nconst compare = require('./compare')\nconst neq = (a, b, loose) => compare(a, b, loose) !== 0\nmodule.exports = neq\n","'use strict'\n\nconst compare = require('./compare')\nconst gte = (a, b, loose) => compare(a, b, loose) >= 0\nmodule.exports = gte\n","'use strict'\n\nconst compare = require('./compare')\nconst lte = (a, b, loose) => compare(a, b, loose) <= 0\nmodule.exports = lte\n","'use strict'\n\nconst eq = require('./eq')\nconst neq = require('./neq')\nconst gt = require('./gt')\nconst gte = require('./gte')\nconst lt = require('./lt')\nconst lte = require('./lte')\n\nconst cmp = (a, op, b, loose) => {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object') {\n        a = a.version\n      }\n      if (typeof b === 'object') {\n        b = b.version\n      }\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError(`Invalid operator: ${op}`)\n  }\n}\nmodule.exports = cmp\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst parse = require('./parse')\nconst { safeRe: re, t } = require('../internal/re')\n\nconst coerce = (version, options) => {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version === 'number') {\n    version = String(version)\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  options = options || {}\n\n  let match = null\n  if (!options.rtl) {\n    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE])\n  } else {\n    // Find the right-most coercible string that does not share\n    // a terminus with a more left-ward coercible string.\n    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'\n    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'\n    //\n    // Walk through the string checking with a /g regexp\n    // Manually set the index so as to pick up overlapping matches.\n    // Stop when we get a match that ends at the string end, since no\n    // coercible string can be more right-ward without the same terminus.\n    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL]\n    let next\n    while ((next = coerceRtlRegex.exec(version)) &&\n        (!match || match.index + match[0].length !== version.length)\n    ) {\n      if (!match ||\n            next.index + next[0].length !== match.index + match[0].length) {\n        match = next\n      }\n      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length\n    }\n    // leave it in a clean state\n    coerceRtlRegex.lastIndex = -1\n  }\n\n  if (match === null) {\n    return null\n  }\n\n  const major = match[2]\n  const minor = match[3] || '0'\n  const patch = match[4] || '0'\n  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : ''\n  const build = options.includePrerelease && match[6] ? `+${match[6]}` : ''\n\n  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)\n}\nmodule.exports = coerce\n","'use strict'\n\nclass LRUCache {\n  constructor () {\n    this.max = 1000\n    this.map = new Map()\n  }\n\n  get (key) {\n    const value = this.map.get(key)\n    if (value === undefined) {\n      return undefined\n    } else {\n      // Remove the key from the map and add it to the end\n      this.map.delete(key)\n      this.map.set(key, value)\n      return value\n    }\n  }\n\n  delete (key) {\n    return this.map.delete(key)\n  }\n\n  set (key, value) {\n    const deleted = this.delete(key)\n\n    if (!deleted && value !== undefined) {\n      // If cache is full, delete the least recently used item\n      if (this.map.size >= this.max) {\n        const firstKey = this.map.keys().next().value\n        this.delete(firstKey)\n      }\n\n      this.map.set(key, value)\n    }\n\n    return this\n  }\n}\n\nmodule.exports = LRUCache\n","'use strict'\n\nconst SPACE_CHARACTERS = /\\s+/g\n\n// hoisted class for cyclic dependency\nclass Range {\n  constructor (range, options) {\n    options = parseOptions(options)\n\n    if (range instanceof Range) {\n      if (\n        range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease\n      ) {\n        return range\n      } else {\n        return new Range(range.raw, options)\n      }\n    }\n\n    if (range instanceof Comparator) {\n      // just put it in the set and return\n      this.raw = range.value\n      this.set = [[range]]\n      this.formatted = undefined\n      return this\n    }\n\n    this.options = options\n    this.loose = !!options.loose\n    this.includePrerelease = !!options.includePrerelease\n\n    // First reduce all whitespace as much as possible so we do not have to rely\n    // on potentially slow regexes like \\s*. This is then stored and used for\n    // future error messages as well.\n    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ')\n\n    // First, split on ||\n    this.set = this.raw\n      .split('||')\n      // map the range to a 2d array of comparators\n      .map(r => this.parseRange(r.trim()))\n      // throw out any comparator lists that are empty\n      // this generally means that it was not a valid range, which is allowed\n      // in loose mode, but will still throw if the WHOLE range is invalid.\n      .filter(c => c.length)\n\n    if (!this.set.length) {\n      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)\n    }\n\n    // if we have any that are not the null set, throw out null sets.\n    if (this.set.length > 1) {\n      // keep the first one, in case they're all null sets\n      const first = this.set[0]\n      this.set = this.set.filter(c => !isNullSet(c[0]))\n      if (this.set.length === 0) {\n        this.set = [first]\n      } else if (this.set.length > 1) {\n        // if we have any that are *, then the range is just *\n        for (const c of this.set) {\n          if (c.length === 1 && isAny(c[0])) {\n            this.set = [c]\n            break\n          }\n        }\n      }\n    }\n\n    this.formatted = undefined\n  }\n\n  get range () {\n    if (this.formatted === undefined) {\n      this.formatted = ''\n      for (let i = 0; i < this.set.length; i++) {\n        if (i > 0) {\n          this.formatted += '||'\n        }\n        const comps = this.set[i]\n        for (let k = 0; k < comps.length; k++) {\n          if (k > 0) {\n            this.formatted += ' '\n          }\n          this.formatted += comps[k].toString().trim()\n        }\n      }\n    }\n    return this.formatted\n  }\n\n  format () {\n    return this.range\n  }\n\n  toString () {\n    return this.range\n  }\n\n  parseRange (range) {\n    // memoize range parsing for performance.\n    // this is a very hot path, and fully deterministic.\n    const memoOpts =\n      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |\n      (this.options.loose && FLAG_LOOSE)\n    const memoKey = memoOpts + ':' + range\n    const cached = cache.get(memoKey)\n    if (cached) {\n      return cached\n    }\n\n    const loose = this.options.loose\n    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]\n    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))\n    debug('hyphen replace', range)\n\n    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)\n    debug('comparator trim', range)\n\n    // `~ 1.2.3` => `~1.2.3`\n    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)\n    debug('tilde trim', range)\n\n    // `^ 1.2.3` => `^1.2.3`\n    range = range.replace(re[t.CARETTRIM], caretTrimReplace)\n    debug('caret trim', range)\n\n    // At this point, the range is completely trimmed and\n    // ready to be split into comparators.\n\n    let rangeList = range\n      .split(' ')\n      .map(comp => parseComparator(comp, this.options))\n      .join(' ')\n      .split(/\\s+/)\n      // >=0.0.0 is equivalent to *\n      .map(comp => replaceGTE0(comp, this.options))\n\n    if (loose) {\n      // in loose mode, throw out any that are not valid comparators\n      rangeList = rangeList.filter(comp => {\n        debug('loose invalid filter', comp, this.options)\n        return !!comp.match(re[t.COMPARATORLOOSE])\n      })\n    }\n    debug('range list', rangeList)\n\n    // if any comparators are the null set, then replace with JUST null set\n    // if more than one comparator, remove any * comparators\n    // also, don't include the same comparator more than once\n    const rangeMap = new Map()\n    const comparators = rangeList.map(comp => new Comparator(comp, this.options))\n    for (const comp of comparators) {\n      if (isNullSet(comp)) {\n        return [comp]\n      }\n      rangeMap.set(comp.value, comp)\n    }\n    if (rangeMap.size > 1 && rangeMap.has('')) {\n      rangeMap.delete('')\n    }\n\n    const result = [...rangeMap.values()]\n    cache.set(memoKey, result)\n    return result\n  }\n\n  intersects (range, options) {\n    if (!(range instanceof Range)) {\n      throw new TypeError('a Range is required')\n    }\n\n    return this.set.some((thisComparators) => {\n      return (\n        isSatisfiable(thisComparators, options) &&\n        range.set.some((rangeComparators) => {\n          return (\n            isSatisfiable(rangeComparators, options) &&\n            thisComparators.every((thisComparator) => {\n              return rangeComparators.every((rangeComparator) => {\n                return thisComparator.intersects(rangeComparator, options)\n              })\n            })\n          )\n        })\n      )\n    })\n  }\n\n  // if ANY of the sets match ALL of its comparators, then pass\n  test (version) {\n    if (!version) {\n      return false\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    for (let i = 0; i < this.set.length; i++) {\n      if (testSet(this.set[i], version, this.options)) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports = Range\n\nconst LRU = require('../internal/lrucache')\nconst cache = new LRU()\n\nconst parseOptions = require('../internal/parse-options')\nconst Comparator = require('./comparator')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst {\n  safeRe: re,\n  t,\n  comparatorTrimReplace,\n  tildeTrimReplace,\n  caretTrimReplace,\n} = require('../internal/re')\nconst { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require('../internal/constants')\n\nconst isNullSet = c => c.value === '<0.0.0-0'\nconst isAny = c => c.value === ''\n\n// take a set of comparators and determine whether there\n// exists a version which can satisfy it\nconst isSatisfiable = (comparators, options) => {\n  let result = true\n  const remainingComparators = comparators.slice()\n  let testComparator = remainingComparators.pop()\n\n  while (result && remainingComparators.length) {\n    result = remainingComparators.every((otherComparator) => {\n      return testComparator.intersects(otherComparator, options)\n    })\n\n    testComparator = remainingComparators.pop()\n  }\n\n  return result\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nconst parseComparator = (comp, options) => {\n  comp = comp.replace(re[t.BUILD], '')\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nconst isX = id => !id || id.toLowerCase() === 'x' || id === '*'\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0\n// ~0.0.1 --> >=0.0.1 <0.1.0-0\nconst replaceTildes = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceTilde(c, options))\n    .join(' ')\n}\n\nconst replaceTilde = (comp, options) => {\n  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('tilde', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0-0\n      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = `>=${M}.${m}.${p}-${pr\n      } <${M}.${+m + 1}.0-0`\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0-0\n      ret = `>=${M}.${m}.${p\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0\n// ^1.2.3 --> >=1.2.3 <2.0.0-0\n// ^1.2.0 --> >=1.2.0 <2.0.0-0\n// ^0.0.1 --> >=0.0.1 <0.0.2-0\n// ^0.1.0 --> >=0.1.0 <0.2.0-0\nconst replaceCarets = (comp, options) => {\n  return comp\n    .trim()\n    .split(/\\s+/)\n    .map((c) => replaceCaret(c, options))\n    .join(' ')\n}\n\nconst replaceCaret = (comp, options) => {\n  debug('caret', comp, options)\n  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]\n  const z = options.includePrerelease ? '-0' : ''\n  return comp.replace(r, (_, M, m, p, pr) => {\n    debug('caret', comp, _, M, m, p, pr)\n    let ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`\n      } else {\n        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p}-${pr\n          } <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p}-${pr\n        } <${+M + 1}.0.0-0`\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${m}.${+p + 1}-0`\n        } else {\n          ret = `>=${M}.${m}.${p\n          }${z} <${M}.${+m + 1}.0-0`\n        }\n      } else {\n        ret = `>=${M}.${m}.${p\n        } <${+M + 1}.0.0-0`\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nconst replaceXRanges = (comp, options) => {\n  debug('replaceXRanges', comp, options)\n  return comp\n    .split(/\\s+/)\n    .map((c) => replaceXRange(c, options))\n    .join(' ')\n}\n\nconst replaceXRange = (comp, options) => {\n  comp = comp.trim()\n  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]\n  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    const xM = isX(M)\n    const xm = xM || isX(m)\n    const xp = xm || isX(p)\n    const anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    // if we're including prereleases in the match, then we need\n    // to fix this to -0, the lowest possible prerelease value\n    pr = options.includePrerelease ? '-0' : ''\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0-0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      if (gtlt === '<') {\n        pr = '-0'\n      }\n\n      ret = `${gtlt + M}.${m}.${p}${pr}`\n    } else if (xm) {\n      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`\n    } else if (xp) {\n      ret = `>=${M}.${m}.0${pr\n      } <${M}.${+m + 1}.0-0`\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nconst replaceStars = (comp, options) => {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp\n    .trim()\n    .replace(re[t.STAR], '')\n}\n\nconst replaceGTE0 = (comp, options) => {\n  debug('replaceGTE0', comp, options)\n  return comp\n    .trim()\n    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')\n}\n\n// This function is passed to string.replace(re[t.HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0-0\n// TODO build?\nconst hyphenReplace = incPr => ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr) => {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = `>=${fM}.0.0${incPr ? '-0' : ''}`\n  } else if (isX(fp)) {\n    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`\n  } else if (fpr) {\n    from = `>=${from}`\n  } else {\n    from = `>=${from}${incPr ? '-0' : ''}`\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = `<${+tM + 1}.0.0-0`\n  } else if (isX(tp)) {\n    to = `<${tM}.${+tm + 1}.0-0`\n  } else if (tpr) {\n    to = `<=${tM}.${tm}.${tp}-${tpr}`\n  } else if (incPr) {\n    to = `<${tM}.${tm}.${+tp + 1}-0`\n  } else {\n    to = `<=${to}`\n  }\n\n  return `${from} ${to}`.trim()\n}\n\nconst testSet = (set, version, options) => {\n  for (let i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (let i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === Comparator.ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        const allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n","'use strict'\n\nconst ANY = Symbol('SemVer ANY')\n// hoisted class for cyclic dependency\nclass Comparator {\n  static get ANY () {\n    return ANY\n  }\n\n  constructor (comp, options) {\n    options = parseOptions(options)\n\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp\n      } else {\n        comp = comp.value\n      }\n    }\n\n    comp = comp.trim().split(/\\s+/).join(' ')\n    debug('comparator', comp, options)\n    this.options = options\n    this.loose = !!options.loose\n    this.parse(comp)\n\n    if (this.semver === ANY) {\n      this.value = ''\n    } else {\n      this.value = this.operator + this.semver.version\n    }\n\n    debug('comp', this)\n  }\n\n  parse (comp) {\n    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]\n    const m = comp.match(r)\n\n    if (!m) {\n      throw new TypeError(`Invalid comparator: ${comp}`)\n    }\n\n    this.operator = m[1] !== undefined ? m[1] : ''\n    if (this.operator === '=') {\n      this.operator = ''\n    }\n\n    // if it literally is just '>' or '' then allow anything.\n    if (!m[2]) {\n      this.semver = ANY\n    } else {\n      this.semver = new SemVer(m[2], this.options.loose)\n    }\n  }\n\n  toString () {\n    return this.value\n  }\n\n  test (version) {\n    debug('Comparator.test', version, this.options.loose)\n\n    if (this.semver === ANY || version === ANY) {\n      return true\n    }\n\n    if (typeof version === 'string') {\n      try {\n        version = new SemVer(version, this.options)\n      } catch (er) {\n        return false\n      }\n    }\n\n    return cmp(version, this.operator, this.semver, this.options)\n  }\n\n  intersects (comp, options) {\n    if (!(comp instanceof Comparator)) {\n      throw new TypeError('a Comparator is required')\n    }\n\n    if (this.operator === '') {\n      if (this.value === '') {\n        return true\n      }\n      return new Range(comp.value, options).test(this.value)\n    } else if (comp.operator === '') {\n      if (comp.value === '') {\n        return true\n      }\n      return new Range(this.value, options).test(comp.semver)\n    }\n\n    options = parseOptions(options)\n\n    // Special cases where nothing can possibly be lower\n    if (options.includePrerelease &&\n      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n      return false\n    }\n    if (!options.includePrerelease &&\n      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n      return false\n    }\n\n    // Same direction increasing (> or >=)\n    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n      return true\n    }\n    // Same direction decreasing (< or <=)\n    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // same SemVer and both sides are inclusive (<= or >=)\n    if (\n      (this.semver.version === comp.semver.version) &&\n      this.operator.includes('=') && comp.operator.includes('=')) {\n      return true\n    }\n    // opposite directions less than\n    if (cmp(this.semver, '<', comp.semver, options) &&\n      this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n      return true\n    }\n    // opposite directions greater than\n    if (cmp(this.semver, '>', comp.semver, options) &&\n      this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n      return true\n    }\n    return false\n  }\n}\n\nmodule.exports = Comparator\n\nconst parseOptions = require('../internal/parse-options')\nconst { safeRe: re, t } = require('../internal/re')\nconst cmp = require('../functions/cmp')\nconst debug = require('../internal/debug')\nconst SemVer = require('./semver')\nconst Range = require('./range')\n","'use strict'\n\nconst Range = require('../classes/range')\nconst satisfies = (version, range, options) => {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\nmodule.exports = satisfies\n","'use strict'\n\nconst Range = require('../classes/range')\n\n// Mostly just for testing and legacy API reasons\nconst toComparators = (range, options) =>\n  new Range(range, options).set\n    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))\n\nmodule.exports = toComparators\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\n\nconst maxSatisfying = (versions, range, options) => {\n  let max = null\n  let maxSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\nmodule.exports = maxSatisfying\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst minSatisfying = (versions, range, options) => {\n  let min = null\n  let minSV = null\n  let rangeObj = null\n  try {\n    rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach((v) => {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\nmodule.exports = minSatisfying\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst Range = require('../classes/range')\nconst gt = require('../functions/gt')\n\nconst minVersion = (range, loose) => {\n  range = new Range(range, loose)\n\n  let minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let setMin = null\n    comparators.forEach((comparator) => {\n      // Clone to avoid manipulating the comparator's semver object.\n      const compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!setMin || gt(compver, setMin)) {\n            setMin = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error(`Unexpected operation: ${comparator.operator}`)\n      }\n    })\n    if (setMin && (!minver || gt(minver, setMin))) {\n      minver = setMin\n    }\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\nmodule.exports = minVersion\n","'use strict'\n\nconst Range = require('../classes/range')\nconst validRange = (range, options) => {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\nmodule.exports = validRange\n","'use strict'\n\nconst SemVer = require('../classes/semver')\nconst Comparator = require('../classes/comparator')\nconst { ANY } = Comparator\nconst Range = require('../classes/range')\nconst satisfies = require('../functions/satisfies')\nconst gt = require('../functions/gt')\nconst lt = require('../functions/lt')\nconst lte = require('../functions/lte')\nconst gte = require('../functions/gte')\n\nconst outside = (version, range, hilo, options) => {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  let gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisfies the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (let i = 0; i < range.set.length; ++i) {\n    const comparators = range.set[i]\n\n    let high = null\n    let low = null\n\n    comparators.forEach((comparator) => {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nmodule.exports = outside\n","'use strict'\n\n// Determine if version is greater than all the versions possible in the range.\nconst outside = require('./outside')\nconst gtr = (version, range, options) => outside(version, range, '>', options)\nmodule.exports = gtr\n","'use strict'\n\nconst outside = require('./outside')\n// Determine if version is less than all the versions possible in the range\nconst ltr = (version, range, options) => outside(version, range, '<', options)\nmodule.exports = ltr\n","'use strict'\n\nconst Range = require('../classes/range')\nconst intersects = (r1, r2, options) => {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2, options)\n}\nmodule.exports = intersects\n","'use strict'\n\n// given a set of versions and a range, create a \"simplified\" range\n// that includes the same versions that the original range does\n// If the original range is shorter than the simplified one, return that.\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\nmodule.exports = (versions, range, options) => {\n  const set = []\n  let first = null\n  let prev = null\n  const v = versions.sort((a, b) => compare(a, b, options))\n  for (const version of v) {\n    const included = satisfies(version, range, options)\n    if (included) {\n      prev = version\n      if (!first) {\n        first = version\n      }\n    } else {\n      if (prev) {\n        set.push([first, prev])\n      }\n      prev = null\n      first = null\n    }\n  }\n  if (first) {\n    set.push([first, null])\n  }\n\n  const ranges = []\n  for (const [min, max] of set) {\n    if (min === max) {\n      ranges.push(min)\n    } else if (!max && min === v[0]) {\n      ranges.push('*')\n    } else if (!max) {\n      ranges.push(`>=${min}`)\n    } else if (min === v[0]) {\n      ranges.push(`<=${max}`)\n    } else {\n      ranges.push(`${min} - ${max}`)\n    }\n  }\n  const simplified = ranges.join(' || ')\n  const original = typeof range.raw === 'string' ? range.raw : String(range)\n  return simplified.length < original.length ? simplified : range\n}\n","'use strict'\n\nconst Range = require('../classes/range.js')\nconst Comparator = require('../classes/comparator.js')\nconst { ANY } = Comparator\nconst satisfies = require('../functions/satisfies.js')\nconst compare = require('../functions/compare.js')\n\n// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:\n// - Every simple range `r1, r2, ...` is a null set, OR\n// - Every simple range `r1, r2, ...` which is not a null set is a subset of\n//   some `R1, R2, ...`\n//\n// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:\n// - If c is only the ANY comparator\n//   - If C is only the ANY comparator, return true\n//   - Else if in prerelease mode, return false\n//   - else replace c with `[>=0.0.0]`\n// - If C is only the ANY comparator\n//   - if in prerelease mode, return true\n//   - else replace C with `[>=0.0.0]`\n// - Let EQ be the set of = comparators in c\n// - If EQ is more than one, return true (null set)\n// - Let GT be the highest > or >= comparator in c\n// - Let LT be the lowest < or <= comparator in c\n// - If GT and LT, and GT.semver > LT.semver, return true (null set)\n// - If any C is a = range, and GT or LT are set, return false\n// - If EQ\n//   - If GT, and EQ does not satisfy GT, return true (null set)\n//   - If LT, and EQ does not satisfy LT, return true (null set)\n//   - If EQ satisfies every C, return true\n//   - Else return false\n// - If GT\n//   - If GT.semver is lower than any > or >= comp in C, return false\n//   - If GT is >=, and GT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the GT.semver tuple, return false\n// - If LT\n//   - If LT.semver is greater than any < or <= comp in C, return false\n//   - If LT is <=, and LT.semver does not satisfy every C, return false\n//   - If GT.semver has a prerelease, and not in prerelease mode\n//     - If no C has a prerelease and the LT.semver tuple, return false\n// - Else return true\n\nconst subset = (sub, dom, options = {}) => {\n  if (sub === dom) {\n    return true\n  }\n\n  sub = new Range(sub, options)\n  dom = new Range(dom, options)\n  let sawNonNull = false\n\n  OUTER: for (const simpleSub of sub.set) {\n    for (const simpleDom of dom.set) {\n      const isSub = simpleSubset(simpleSub, simpleDom, options)\n      sawNonNull = sawNonNull || isSub !== null\n      if (isSub) {\n        continue OUTER\n      }\n    }\n    // the null set is a subset of everything, but null simple ranges in\n    // a complex range should be ignored.  so if we saw a non-null range,\n    // then we know this isn't a subset, but if EVERY simple range was null,\n    // then it is a subset.\n    if (sawNonNull) {\n      return false\n    }\n  }\n  return true\n}\n\nconst minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')]\nconst minimumVersion = [new Comparator('>=0.0.0')]\n\nconst simpleSubset = (sub, dom, options) => {\n  if (sub === dom) {\n    return true\n  }\n\n  if (sub.length === 1 && sub[0].semver === ANY) {\n    if (dom.length === 1 && dom[0].semver === ANY) {\n      return true\n    } else if (options.includePrerelease) {\n      sub = minimumVersionWithPreRelease\n    } else {\n      sub = minimumVersion\n    }\n  }\n\n  if (dom.length === 1 && dom[0].semver === ANY) {\n    if (options.includePrerelease) {\n      return true\n    } else {\n      dom = minimumVersion\n    }\n  }\n\n  const eqSet = new Set()\n  let gt, lt\n  for (const c of sub) {\n    if (c.operator === '>' || c.operator === '>=') {\n      gt = higherGT(gt, c, options)\n    } else if (c.operator === '<' || c.operator === '<=') {\n      lt = lowerLT(lt, c, options)\n    } else {\n      eqSet.add(c.semver)\n    }\n  }\n\n  if (eqSet.size > 1) {\n    return null\n  }\n\n  let gtltComp\n  if (gt && lt) {\n    gtltComp = compare(gt.semver, lt.semver, options)\n    if (gtltComp > 0) {\n      return null\n    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {\n      return null\n    }\n  }\n\n  // will iterate one or zero times\n  for (const eq of eqSet) {\n    if (gt && !satisfies(eq, String(gt), options)) {\n      return null\n    }\n\n    if (lt && !satisfies(eq, String(lt), options)) {\n      return null\n    }\n\n    for (const c of dom) {\n      if (!satisfies(eq, String(c), options)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  let higher, lower\n  let hasDomLT, hasDomGT\n  // if the subset has a prerelease, we need a comparator in the superset\n  // with the same tuple and a prerelease, or it's not a subset\n  let needDomLTPre = lt &&\n    !options.includePrerelease &&\n    lt.semver.prerelease.length ? lt.semver : false\n  let needDomGTPre = gt &&\n    !options.includePrerelease &&\n    gt.semver.prerelease.length ? gt.semver : false\n  // exception: <1.2.3-0 is the same as <1.2.3\n  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&\n      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {\n    needDomLTPre = false\n  }\n\n  for (const c of dom) {\n    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='\n    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='\n    if (gt) {\n      if (needDomGTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomGTPre.major &&\n            c.semver.minor === needDomGTPre.minor &&\n            c.semver.patch === needDomGTPre.patch) {\n          needDomGTPre = false\n        }\n      }\n      if (c.operator === '>' || c.operator === '>=') {\n        higher = higherGT(gt, c, options)\n        if (higher === c && higher !== gt) {\n          return false\n        }\n      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (lt) {\n      if (needDomLTPre) {\n        if (c.semver.prerelease && c.semver.prerelease.length &&\n            c.semver.major === needDomLTPre.major &&\n            c.semver.minor === needDomLTPre.minor &&\n            c.semver.patch === needDomLTPre.patch) {\n          needDomLTPre = false\n        }\n      }\n      if (c.operator === '<' || c.operator === '<=') {\n        lower = lowerLT(lt, c, options)\n        if (lower === c && lower !== lt) {\n          return false\n        }\n      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {\n        return false\n      }\n    }\n    if (!c.operator && (lt || gt) && gtltComp !== 0) {\n      return false\n    }\n  }\n\n  // if there was a < or >, and nothing in the dom, then must be false\n  // UNLESS it was limited by another range in the other direction.\n  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0\n  if (gt && hasDomLT && !lt && gtltComp !== 0) {\n    return false\n  }\n\n  if (lt && hasDomGT && !gt && gtltComp !== 0) {\n    return false\n  }\n\n  // we needed a prerelease range in a specific tuple, but didn't get one\n  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,\n  // because it includes prereleases in the 1.2.3 tuple\n  if (needDomGTPre || needDomLTPre) {\n    return false\n  }\n\n  return true\n}\n\n// >=1.2.3 is lower than >1.2.3\nconst higherGT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp > 0 ? a\n    : comp < 0 ? b\n    : b.operator === '>' && a.operator === '>=' ? b\n    : a\n}\n\n// <=1.2.3 is higher than <1.2.3\nconst lowerLT = (a, b, options) => {\n  if (!a) {\n    return b\n  }\n  const comp = compare(a.semver, b.semver, options)\n  return comp < 0 ? a\n    : comp > 0 ? b\n    : b.operator === '<' && a.operator === '<=' ? b\n    : a\n}\n\nmodule.exports = subset\n","'use strict'\n\n// just pre-load all the stuff that index.js lazily exports\nconst internalRe = require('./internal/re')\nconst constants = require('./internal/constants')\nconst SemVer = require('./classes/semver')\nconst identifiers = require('./internal/identifiers')\nconst parse = require('./functions/parse')\nconst valid = require('./functions/valid')\nconst clean = require('./functions/clean')\nconst inc = require('./functions/inc')\nconst diff = require('./functions/diff')\nconst major = require('./functions/major')\nconst minor = require('./functions/minor')\nconst patch = require('./functions/patch')\nconst prerelease = require('./functions/prerelease')\nconst compare = require('./functions/compare')\nconst rcompare = require('./functions/rcompare')\nconst compareLoose = require('./functions/compare-loose')\nconst compareBuild = require('./functions/compare-build')\nconst sort = require('./functions/sort')\nconst rsort = require('./functions/rsort')\nconst gt = require('./functions/gt')\nconst lt = require('./functions/lt')\nconst eq = require('./functions/eq')\nconst neq = require('./functions/neq')\nconst gte = require('./functions/gte')\nconst lte = require('./functions/lte')\nconst cmp = require('./functions/cmp')\nconst coerce = require('./functions/coerce')\nconst Comparator = require('./classes/comparator')\nconst Range = require('./classes/range')\nconst satisfies = require('./functions/satisfies')\nconst toComparators = require('./ranges/to-comparators')\nconst maxSatisfying = require('./ranges/max-satisfying')\nconst minSatisfying = require('./ranges/min-satisfying')\nconst minVersion = require('./ranges/min-version')\nconst validRange = require('./ranges/valid')\nconst outside = require('./ranges/outside')\nconst gtr = require('./ranges/gtr')\nconst ltr = require('./ranges/ltr')\nconst intersects = require('./ranges/intersects')\nconst simplifyRange = require('./ranges/simplify')\nconst subset = require('./ranges/subset')\nmodule.exports = {\n  parse,\n  valid,\n  clean,\n  inc,\n  diff,\n  major,\n  minor,\n  patch,\n  prerelease,\n  compare,\n  rcompare,\n  compareLoose,\n  compareBuild,\n  sort,\n  rsort,\n  gt,\n  lt,\n  eq,\n  neq,\n  gte,\n  lte,\n  cmp,\n  coerce,\n  Comparator,\n  Range,\n  satisfies,\n  toComparators,\n  maxSatisfying,\n  minSatisfying,\n  minVersion,\n  validRange,\n  outside,\n  gtr,\n  ltr,\n  intersects,\n  simplifyRange,\n  subset,\n  SemVer,\n  re: internalRe.re,\n  src: internalRe.src,\n  tokens: internalRe.t,\n  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,\n  RELEASE_TYPES: constants.RELEASE_TYPES,\n  compareIdentifiers: identifiers.compareIdentifiers,\n  rcompareIdentifiers: identifiers.rcompareIdentifiers,\n}\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","import { NextRequest, NextResponse } from 'next/server';\r\nimport { executeOrderResolution } from '@/lib/langgraph';\r\n\r\nexport async function POST(request: NextRequest) {\r\n    try {\r\n        const body = await request.json();\r\n        const { orderId, orderDetails } = body;\r\n\r\n        if (!orderId || !orderDetails) {\r\n            return NextResponse.json(\r\n                { error: 'Missing orderId or orderDetails' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        // Execute the LangGraph workflow\r\n        const result = await executeOrderResolution(orderId, orderDetails);\r\n\r\n        // Check for errors in the workflow\r\n        if (result.error) {\r\n            return NextResponse.json(\r\n                {\r\n                    success: false,\r\n                    error: result.error,\r\n                    stepMessages: result.stepMessages\r\n                },\r\n                { status: 500 }\r\n            );\r\n        }\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            orderId: result.orderId,\r\n            currentStep: result.currentStep,\r\n            stepMessages: result.stepMessages,\r\n            warehouseResult: result.warehouseResult,\r\n            driverResult: result.driverResult,\r\n            dispatchConfirmed: result.dispatchConfirmed,\r\n            estimatedDeliveryTime: result.estimatedDeliveryTime,\r\n        });\r\n    } catch (error) {\r\n        console.error('Order resolution error:', error);\r\n        return NextResponse.json(\r\n            {\r\n                success: false,\r\n                error: error instanceof Error ? error.message : 'Internal server error'\r\n            },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n","import crypto from 'node:crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};","const warnedMessages = {};\nexport function warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n","// Relaxed UUID validation regex (allows any valid UUID format including nil UUIDs)\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nimport { v7 as uuidv7 } from \"uuid\";\nimport { warnOnce } from \"./warn.js\";\nlet UUID7_WARNING_EMITTED = false;\nexport function assertUuid(str, which) {\n    // Use relaxed regex validation instead of strict uuid.validate()\n    // This allows edge cases like nil UUIDs or test UUIDs that might not pass strict validation\n    if (!UUID_REGEX.test(str)) {\n        const msg = which !== undefined\n            ? `Invalid UUID for ${which}: ${str}`\n            : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n/**\n * Generate a UUID v7 from a timestamp.\n *\n * @param timestamp - The timestamp in milliseconds\n * @returns A UUID v7 string\n */\nexport function uuid7FromTime(timestamp) {\n    const msecs = typeof timestamp === \"string\" ? Date.parse(timestamp) : timestamp;\n    // Work around uuid@10 behavior where providing only { msecs }\n    // may not set the internal timestamp used for stringification.\n    // Providing a seq ensures the implementation updates its internal state\n    // and encodes the provided milliseconds into the UUID bytes.\n    return uuidv7({ msecs, seq: 0 });\n}\n/**\n * Get the version of a UUID string.\n * @param uuidStr - The UUID string to check\n * @returns The version number (1-7) or null if invalid\n */\nexport function getUuidVersion(uuidStr) {\n    if (!UUID_REGEX.test(uuidStr)) {\n        return null;\n    }\n    // Version is in bits 48-51\n    // Format: xxxxxxxx-xxxx-Vxxx-xxxx-xxxxxxxxxxxx\n    const versionChar = uuidStr[14];\n    return parseInt(versionChar, 16);\n}\n/**\n * Warn if a UUID is not version 7.\n *\n * @param uuidStr - The UUID string to check\n * @param idType - The type of ID (e.g., \"run_id\", \"trace_id\") for the warning message\n */\nexport function warnIfNotUuidV7(uuidStr, _idType) {\n    const version = getUuidVersion(uuidStr);\n    if (version !== null && version !== 7 && !UUID7_WARNING_EMITTED) {\n        UUID7_WARNING_EMITTED = true;\n        warnOnce(`LangSmith now uses UUID v7 for run and trace identifiers. ` +\n            `This warning appears when passing custom IDs. ` +\n            `Please use: import { uuidv7 } from 'langsmith'; const id = uuidv7(); ` +\n            `Future versions will require UUID v7.`);\n    }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { addRequestMeta, getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { setReferenceManifestsSingleton } from \"next/dist/esm/server/app-render/encryption-utils\";\nimport { createServerModuleMap } from \"next/dist/esm/server/app-render/action-utils\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/orders/resolve/route\",\n        pathname: \"/api/orders/resolve\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/apps/web/src/app/api/orders/resolve/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    if (routeModule.isDev) {\n        addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint());\n    }\n    let srcPage = \"/api/orders/resolve/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, parsedUrl, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname, clientReferenceManifest, serverActionsManifest } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    const render404 = async ()=>{\n        // TODO: should route-module itself handle rendering the 404\n        if (routerServerContext == null ? void 0 : routerServerContext.render404) {\n            await routerServerContext.render404(req, res, parsedUrl, false);\n        } else {\n            res.end('This page could not be found');\n        }\n        return null;\n    };\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                if (nextConfig.experimental.adapterPath) {\n                    return await render404();\n                }\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isStaticGeneration = isIsr && !supportsDynamicResponse;\n    // Before rendering (which initializes component tree modules), we have to\n    // set the reference manifests to our global store so Server Action's\n    // encryption util can access to them at the top level of the page module.\n    if (serverActionsManifest && clientReferenceManifest) {\n        setReferenceManifestsSingleton({\n            page: srcPage,\n            clientReferenceManifest,\n            serverActionsManifest,\n            serverModuleMap: createServerModuleMap({\n                serverActionsManifest\n            })\n        });\n    }\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            cacheComponents: Boolean(nextConfig.cacheComponents),\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: nextConfig.cacheLife,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${srcPage}`);\n                }\n            });\n        };\n        const isMinimalMode = Boolean(process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode'));\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!isMinimalMode && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isStaticGeneration,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil,\n                isMinimalMode\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!isMinimalMode) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(isMinimalMode && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n            new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${srcPage}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        if (!(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isStaticGeneration,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","/* eslint-disable */\n// @ts-nocheck\n// is-network-error vendored to avoid import issues\n// Source: https://github.com/sindresorhus/is-network-error\nconst objectToString = Object.prototype.toString;\nconst isError = (value) => objectToString.call(value) === \"[object Error]\";\nconst errorMessages = new Set([\n    \"network error\", // Chrome\n    \"Failed to fetch\", // Chrome\n    \"NetworkError when attempting to fetch resource.\", // Firefox\n    \"The Internet connection appears to be offline.\", // Safari 16\n    \"Network request failed\", // `cross-fetch`\n    \"fetch failed\", // Undici (Node.js)\n    \"terminated\", // Undici (Node.js)\n    \" A network error occurred.\", // Bun (WebKit)\n    \"Network connection lost\", // Cloudflare Workers (fetch)\n]);\nexport default function isNetworkError(error) {\n    const isValid = error &&\n        isError(error) &&\n        error.name === \"TypeError\" &&\n        typeof error.message === \"string\";\n    if (!isValid) {\n        return false;\n    }\n    const { message, stack } = error;\n    // Safari 17+ has generic message but no stack for network errors\n    if (message === \"Load failed\") {\n        return (stack === undefined ||\n            // Sentry adds its own stack trace to the fetch error, so also check for that\n            \"__sentry_captured__\" in error);\n    }\n    // Deno network errors start with specific text\n    if (message.startsWith(\"error sending request for url\")) {\n        return true;\n    }\n    // Standard network error messages\n    return errorMessages.has(message);\n}\n","import { parse as parseVersion } from \"semver\";\nexport function isVersionGreaterOrEqual(current_version, target_version) {\n    const current = parseVersion(current_version);\n    const target = parseVersion(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nexport function parsePromptIdentifier(identifier) {\n    if (!identifier ||\n        identifier.split(\"/\").length > 2 ||\n        identifier.startsWith(\"/\") ||\n        identifier.endsWith(\"/\") ||\n        identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [owner, name, commit];\n    }\n    else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\"-\", ownerNamePart, commit];\n    }\n}\n","function getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null)\n        return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\")\n        return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nexport function printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null)\n        return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */\nexport class LangSmithConflictError extends Error {\n    constructor(message) {\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithConflictError\";\n        this.status = 409;\n    }\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */\nexport async function raiseForStatus(response, context, consumeOnSuccess) {\n    let errorBody;\n    if (response.ok) {\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        if (consumeOnSuccess) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    if (response.status === 403) {\n        try {\n            const errorData = await response.json();\n            const errorCode = errorData?.error;\n            if (errorCode === \"org_scoped_key_requires_workspace\") {\n                errorBody =\n                    \"This API key is org-scoped and requires workspace specification. \" +\n                        \"Please provide 'workspaceId' parameter, \" +\n                        \"or set LANGSMITH_WORKSPACE_ID environment variable.\";\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            const errorWithStatus = new Error(`${response.status} ${response.statusText}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            errorWithStatus.status = response?.status;\n            throw errorWithStatus;\n        }\n    }\n    if (errorBody === undefined) {\n        try {\n            errorBody = await response.text();\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            errorBody = \"\";\n        }\n    }\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    const err = new Error(fullMessage);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    err.status = response.status;\n    throw err;\n}\nconst ERR_CONFLICTING_ENDPOINTS = \"ERR_CONFLICTING_ENDPOINTS\";\nexport class ConflictingEndpointsError extends Error {\n    constructor() {\n        super(\"You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT \" +\n            \"and LANGSMITH_RUNS_ENDPOINTS.\");\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ERR_CONFLICTING_ENDPOINTS\n        });\n        this.name = \"ConflictingEndpointsError\"; // helpful in logs\n    }\n}\nexport function isConflictingEndpointsError(err) {\n    return (typeof err === \"object\" &&\n        err !== null &&\n        err.code === ERR_CONFLICTING_ENDPOINTS);\n}\n","class MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nexport const AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nexport function getCurrentRunTree(permitAbsentRunTree = false) {\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!permitAbsentRunTree && runTree === undefined) {\n        throw new Error(\"Could not get the current run tree.\\n\\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.\");\n    }\n    return runTree;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject) => {\n        storage.run(runTree, () => void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nexport const ROOT = Symbol.for(\"langsmith:traceable:root\");\nexport function isTraceableFunction(x\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n};\n\n//#endregion\nexport { __export };","var _a;\nexport const $output = Symbol(\"ZodOutput\");\nexport const $input = Symbol(\"ZodInput\");\nexport class $ZodRegistry {\n    constructor() {\n        this._map = new WeakMap();\n        this._idmap = new Map();\n    }\n    add(schema, ..._meta) {\n        const meta = _meta[0];\n        this._map.set(schema, meta);\n        if (meta && typeof meta === \"object\" && \"id\" in meta) {\n            if (this._idmap.has(meta.id)) {\n                throw new Error(`ID ${meta.id} already exists in the registry`);\n            }\n            this._idmap.set(meta.id, schema);\n        }\n        return this;\n    }\n    clear() {\n        this._map = new WeakMap();\n        this._idmap = new Map();\n        return this;\n    }\n    remove(schema) {\n        const meta = this._map.get(schema);\n        if (meta && typeof meta === \"object\" && \"id\" in meta) {\n            this._idmap.delete(meta.id);\n        }\n        this._map.delete(schema);\n        return this;\n    }\n    get(schema) {\n        // return this._map.get(schema) as any;\n        // inherit metadata\n        const p = schema._zod.parent;\n        if (p) {\n            const pm = { ...(this.get(p) ?? {}) };\n            delete pm.id; // do not inherit id\n            const f = { ...pm, ...this._map.get(schema) };\n            return Object.keys(f).length ? f : undefined;\n        }\n        return this._map.get(schema);\n    }\n    has(schema) {\n        return this._map.has(schema);\n    }\n}\n// registries\nexport function registry() {\n    return new $ZodRegistry();\n}\n(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());\nexport const globalRegistry = globalThis.__zod_globalRegistry;\n","import * as z from \"./external.js\";\nexport * from \"./external.js\";\nexport { z };\nexport default z;\n","const DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nconst HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\nconst URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nconst URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\nconst URL_ = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nconst UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nconst JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nconst RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst EMAIL = (input) => {\n    if (input[0] === '\"')\n        return false;\n    const [name, host, ...rest] = input.split('@');\n    if (!name ||\n        !host ||\n        rest.length !== 0 ||\n        name.length > 64 ||\n        host.length > 253)\n        return false;\n    if (name[0] === '.' || name.endsWith('.') || name.includes('..'))\n        return false;\n    if (!/^[a-z0-9.-]+$/i.test(host) ||\n        !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name))\n        return false;\n    return host\n        .split('.')\n        .every(part => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part));\n};\nconst IPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst IPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst DURATION = (input) => input.length > 1 &&\n    input.length < 80 &&\n    (/^P\\d+([.,]\\d+)?W$/.test(input) ||\n        (/^P[\\dYMDTHS]*(\\d[.,]\\d+)?[YMDHS]$/.test(input) &&\n            /^P([.,\\d]+Y)?([.,\\d]+M)?([.,\\d]+D)?(T([.,\\d]+H)?([.,\\d]+M)?([.,\\d]+S)?)?$/.test(input)));\nfunction bind(r) {\n    return r.test.bind(r);\n}\nexport const format = {\n    date,\n    time: time.bind(undefined, false),\n    'date-time': date_time,\n    duration: DURATION,\n    uri,\n    'uri-reference': bind(URIREF),\n    'uri-template': bind(URITEMPLATE),\n    url: bind(URL_),\n    email: EMAIL,\n    hostname: bind(HOSTNAME),\n    ipv4: bind(IPV4),\n    ipv6: bind(IPV6),\n    regex: regex,\n    uuid: bind(UUID),\n    'json-pointer': bind(JSON_POINTER),\n    'json-pointer-uri-fragment': bind(JSON_POINTER_URI_FRAGMENT),\n    'relative-json-pointer': bind(RELATIVE_JSON_POINTER)\n};\nfunction isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\nfunction date(str) {\n    const matches = str.match(DATE);\n    if (!matches)\n        return false;\n    const year = +matches[1];\n    const month = +matches[2];\n    const day = +matches[3];\n    return (month >= 1 &&\n        month <= 12 &&\n        day >= 1 &&\n        day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]));\n}\nfunction time(full, str) {\n    const matches = str.match(TIME);\n    if (!matches)\n        return false;\n    const hour = +matches[1];\n    const minute = +matches[2];\n    const second = +matches[3];\n    const timeZone = !!matches[5];\n    return (((hour <= 23 && minute <= 59 && second <= 59) ||\n        (hour == 23 && minute == 59 && second == 60)) &&\n        (!full || timeZone));\n}\nconst DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n    const dateTime = str.split(DATE_TIME_SEPARATOR);\n    return dateTime.length == 2 && date(dateTime[0]) && time(true, dateTime[1]);\n}\nconst NOT_URI_FRAGMENT = /\\/|:/;\nconst URI_PATTERN = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nfunction uri(str) {\n    return NOT_URI_FRAGMENT.test(str) && URI_PATTERN.test(str);\n}\nconst Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n    if (Z_ANCHOR.test(str))\n        return false;\n    try {\n        new RegExp(str, 'u');\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\n","import base64 from 'base64-js';\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/utils.ts\nfunction never(_) {\n}\nfunction bytePairMerge(piece, ranks) {\n  let parts = Array.from(\n    { length: piece.length },\n    (_, i) => ({ start: i, end: i + 1 })\n  );\n  while (parts.length > 1) {\n    let minRank = null;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const slice = piece.slice(parts[i].start, parts[i + 1].end);\n      const rank = ranks.get(slice.join(\",\"));\n      if (rank == null)\n        continue;\n      if (minRank == null || rank < minRank[0]) {\n        minRank = [rank, i];\n      }\n    }\n    if (minRank != null) {\n      const i = minRank[1];\n      parts[i] = { start: parts[i].start, end: parts[i + 1].end };\n      parts.splice(i + 1, 1);\n    } else {\n      break;\n    }\n  }\n  return parts;\n}\nfunction bytePairEncode(piece, ranks) {\n  if (piece.length === 1)\n    return [ranks.get(piece.join(\",\"))];\n  return bytePairMerge(piece, ranks).map((p) => ranks.get(piece.slice(p.start, p.end).join(\",\"))).filter((x) => x != null);\n}\nfunction escapeRegex(str) {\n  return str.replace(/[\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nvar _Tiktoken = class {\n  /** @internal */\n  specialTokens;\n  /** @internal */\n  inverseSpecialTokens;\n  /** @internal */\n  patStr;\n  /** @internal */\n  textEncoder = new TextEncoder();\n  /** @internal */\n  textDecoder = new TextDecoder(\"utf-8\");\n  /** @internal */\n  rankMap = /* @__PURE__ */ new Map();\n  /** @internal */\n  textMap = /* @__PURE__ */ new Map();\n  constructor(ranks, extendedSpecialTokens) {\n    this.patStr = ranks.pat_str;\n    const uncompressed = ranks.bpe_ranks.split(\"\\n\").filter(Boolean).reduce((memo, x) => {\n      const [_, offsetStr, ...tokens] = x.split(\" \");\n      const offset = Number.parseInt(offsetStr, 10);\n      tokens.forEach((token, i) => memo[token] = offset + i);\n      return memo;\n    }, {});\n    for (const [token, rank] of Object.entries(uncompressed)) {\n      const bytes = base64.toByteArray(token);\n      this.rankMap.set(bytes.join(\",\"), rank);\n      this.textMap.set(rank, bytes);\n    }\n    this.specialTokens = { ...ranks.special_tokens, ...extendedSpecialTokens };\n    this.inverseSpecialTokens = Object.entries(this.specialTokens).reduce((memo, [text, rank]) => {\n      memo[rank] = this.textEncoder.encode(text);\n      return memo;\n    }, {});\n  }\n  encode(text, allowedSpecial = [], disallowedSpecial = \"all\") {\n    const regexes = new RegExp(this.patStr, \"ug\");\n    const specialRegex = _Tiktoken.specialTokenRegex(\n      Object.keys(this.specialTokens)\n    );\n    const ret = [];\n    const allowedSpecialSet = new Set(\n      allowedSpecial === \"all\" ? Object.keys(this.specialTokens) : allowedSpecial\n    );\n    const disallowedSpecialSet = new Set(\n      disallowedSpecial === \"all\" ? Object.keys(this.specialTokens).filter(\n        (x) => !allowedSpecialSet.has(x)\n      ) : disallowedSpecial\n    );\n    if (disallowedSpecialSet.size > 0) {\n      const disallowedSpecialRegex = _Tiktoken.specialTokenRegex([\n        ...disallowedSpecialSet\n      ]);\n      const specialMatch = text.match(disallowedSpecialRegex);\n      if (specialMatch != null) {\n        throw new Error(\n          `The text contains a special token that is not allowed: ${specialMatch[0]}`\n        );\n      }\n    }\n    let start = 0;\n    while (true) {\n      let nextSpecial = null;\n      let startFind = start;\n      while (true) {\n        specialRegex.lastIndex = startFind;\n        nextSpecial = specialRegex.exec(text);\n        if (nextSpecial == null || allowedSpecialSet.has(nextSpecial[0]))\n          break;\n        startFind = nextSpecial.index + 1;\n      }\n      const end = nextSpecial?.index ?? text.length;\n      for (const match of text.substring(start, end).matchAll(regexes)) {\n        const piece = this.textEncoder.encode(match[0]);\n        const token2 = this.rankMap.get(piece.join(\",\"));\n        if (token2 != null) {\n          ret.push(token2);\n          continue;\n        }\n        ret.push(...bytePairEncode(piece, this.rankMap));\n      }\n      if (nextSpecial == null)\n        break;\n      let token = this.specialTokens[nextSpecial[0]];\n      ret.push(token);\n      start = nextSpecial.index + nextSpecial[0].length;\n    }\n    return ret;\n  }\n  decode(tokens) {\n    const res = [];\n    let length = 0;\n    for (let i2 = 0; i2 < tokens.length; ++i2) {\n      const token = tokens[i2];\n      const bytes = this.textMap.get(token) ?? this.inverseSpecialTokens[token];\n      if (bytes != null) {\n        res.push(bytes);\n        length += bytes.length;\n      }\n    }\n    const mergedArray = new Uint8Array(length);\n    let i = 0;\n    for (const bytes of res) {\n      mergedArray.set(bytes, i);\n      i += bytes.length;\n    }\n    return this.textDecoder.decode(mergedArray);\n  }\n};\nvar Tiktoken = _Tiktoken;\n__publicField(Tiktoken, \"specialTokenRegex\", (tokens) => {\n  return new RegExp(tokens.map((i) => escapeRegex(i)).join(\"|\"), \"g\");\n});\nfunction getEncodingNameForModel(model) {\n  switch (model) {\n    case \"gpt2\": {\n      return \"gpt2\";\n    }\n    case \"code-cushman-001\":\n    case \"code-cushman-002\":\n    case \"code-davinci-001\":\n    case \"code-davinci-002\":\n    case \"cushman-codex\":\n    case \"davinci-codex\":\n    case \"davinci-002\":\n    case \"text-davinci-002\":\n    case \"text-davinci-003\": {\n      return \"p50k_base\";\n    }\n    case \"code-davinci-edit-001\":\n    case \"text-davinci-edit-001\": {\n      return \"p50k_edit\";\n    }\n    case \"ada\":\n    case \"babbage\":\n    case \"babbage-002\":\n    case \"code-search-ada-code-001\":\n    case \"code-search-babbage-code-001\":\n    case \"curie\":\n    case \"davinci\":\n    case \"text-ada-001\":\n    case \"text-babbage-001\":\n    case \"text-curie-001\":\n    case \"text-davinci-001\":\n    case \"text-search-ada-doc-001\":\n    case \"text-search-babbage-doc-001\":\n    case \"text-search-curie-doc-001\":\n    case \"text-search-davinci-doc-001\":\n    case \"text-similarity-ada-001\":\n    case \"text-similarity-babbage-001\":\n    case \"text-similarity-curie-001\":\n    case \"text-similarity-davinci-001\": {\n      return \"r50k_base\";\n    }\n    case \"gpt-3.5-turbo-instruct-0914\":\n    case \"gpt-3.5-turbo-instruct\":\n    case \"gpt-3.5-turbo-16k-0613\":\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo\":\n    case \"gpt-4-32k-0613\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k\":\n    case \"gpt-4-0613\":\n    case \"gpt-4-0314\":\n    case \"gpt-4\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-35-turbo\":\n    case \"gpt-4-1106-preview\":\n    case \"gpt-4-vision-preview\":\n    case \"gpt-3.5-turbo-0125\":\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-0125-preview\":\n    case \"text-embedding-ada-002\":\n    case \"text-embedding-3-small\":\n    case \"text-embedding-3-large\": {\n      return \"cl100k_base\";\n    }\n    case \"gpt-4o\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n    case \"gpt-4o-2024-11-20\":\n    case \"gpt-4o-mini-2024-07-18\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-search-preview\":\n    case \"gpt-4o-search-preview-2025-03-11\":\n    case \"gpt-4o-mini-search-preview\":\n    case \"gpt-4o-mini-search-preview-2025-03-11\":\n    case \"gpt-4o-audio-preview\":\n    case \"gpt-4o-audio-preview-2024-12-17\":\n    case \"gpt-4o-audio-preview-2024-10-01\":\n    case \"gpt-4o-mini-audio-preview\":\n    case \"gpt-4o-mini-audio-preview-2024-12-17\":\n    case \"o1\":\n    case \"o1-2024-12-17\":\n    case \"o1-mini\":\n    case \"o1-mini-2024-09-12\":\n    case \"o1-preview\":\n    case \"o1-preview-2024-09-12\":\n    case \"o1-pro\":\n    case \"o1-pro-2025-03-19\":\n    case \"o3\":\n    case \"o3-2025-04-16\":\n    case \"o3-mini\":\n    case \"o3-mini-2025-01-31\":\n    case \"o4-mini\":\n    case \"o4-mini-2025-04-16\":\n    case \"chatgpt-4o-latest\":\n    case \"gpt-4o-realtime\":\n    case \"gpt-4o-realtime-preview-2024-10-01\":\n    case \"gpt-4o-realtime-preview-2024-12-17\":\n    case \"gpt-4o-mini-realtime-preview\":\n    case \"gpt-4o-mini-realtime-preview-2024-12-17\":\n    case \"gpt-4.1\":\n    case \"gpt-4.1-2025-04-14\":\n    case \"gpt-4.1-mini\":\n    case \"gpt-4.1-mini-2025-04-14\":\n    case \"gpt-4.1-nano\":\n    case \"gpt-4.1-nano-2025-04-14\":\n    case \"gpt-4.5-preview\":\n    case \"gpt-4.5-preview-2025-02-27\":\n    case \"gpt-5\":\n    case \"gpt-5-2025-08-07\":\n    case \"gpt-5-nano\":\n    case \"gpt-5-nano-2025-08-07\":\n    case \"gpt-5-mini\":\n    case \"gpt-5-mini-2025-08-07\":\n    case \"gpt-5-chat-latest\": {\n      return \"o200k_base\";\n    }\n    default:\n      throw new Error(\"Unknown model\");\n  }\n}\n\nexport { Tiktoken, getEncodingNameForModel, never };\n","/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\nvar objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\n  return objectToString.call(object) === '[object Array]';\n};\n\nfunction isFunction (object) {\n  return typeof object === 'function';\n}\n\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */\nfunction typeStr (obj) {\n  return isArray(obj) ? 'array' : typeof obj;\n}\n\nfunction escapeRegExp (string) {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */\nfunction hasProperty (obj, propName) {\n  return obj != null && typeof obj === 'object' && (propName in obj);\n}\n\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */\nfunction primitiveHasOwnProperty (primitive, propName) {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasOwnProperty\n    && primitive.hasOwnProperty(propName)\n  );\n}\n\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp (re, string) {\n  return regExpTest.call(re, string);\n}\n\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace (string) {\n  return !testRegExp(nonSpaceRe, string);\n}\n\nvar entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\nfunction escapeHtml (string) {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n    return entityMap[s];\n  });\n}\n\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */\nfunction parseTemplate (template, tags) {\n  if (!template)\n    return [];\n  var lineHasNonSpace = false;\n  var sections = [];     // Stack to hold section tokens\n  var tokens = [];       // Buffer to hold the tokens\n  var spaces = [];       // Indices of whitespace tokens on the current line\n  var hasTag = false;    // Is there a {{tag}} on the current line?\n  var nonSpace = false;  // Is there a non-space char on the current line?\n  var indentation = '';  // Tracks indentation for tags that use it\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\n\n  // Strips all whitespace tokens array for the current line\n  // if there was a {{#tag}} on it and otherwise only space.\n  function stripSpace () {\n    if (hasTag && !nonSpace) {\n      while (spaces.length)\n        delete tokens[spaces.pop()];\n    } else {\n      spaces = [];\n    }\n\n    hasTag = false;\n    nonSpace = false;\n  }\n\n  var openingTagRe, closingTagRe, closingCurlyRe;\n  function compileTags (tagsToCompile) {\n    if (typeof tagsToCompile === 'string')\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n      throw new Error('Invalid tags: ' + tagsToCompile);\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n  }\n\n  compileTags(tags || mustache.tags);\n\n  var scanner = new Scanner(template);\n\n  var start, type, value, chr, token, openSection;\n  while (!scanner.eos()) {\n    start = scanner.pos;\n\n    // Match any text between tags.\n    value = scanner.scanUntil(openingTagRe);\n\n    if (value) {\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i);\n\n        if (isWhitespace(chr)) {\n          spaces.push(tokens.length);\n          indentation += chr;\n        } else {\n          nonSpace = true;\n          lineHasNonSpace = true;\n          indentation += ' ';\n        }\n\n        tokens.push([ 'text', chr, start, start + 1 ]);\n        start += 1;\n\n        // Check for whitespace on the current line.\n        if (chr === '\\n') {\n          stripSpace();\n          indentation = '';\n          tagIndex = 0;\n          lineHasNonSpace = false;\n        }\n      }\n    }\n\n    // Match the opening tag.\n    if (!scanner.scan(openingTagRe))\n      break;\n\n    hasTag = true;\n\n    // Get the tag type.\n    type = scanner.scan(tagRe) || 'name';\n    scanner.scan(whiteRe);\n\n    // Get the tag value.\n    if (type === '=') {\n      value = scanner.scanUntil(equalsRe);\n      scanner.scan(equalsRe);\n      scanner.scanUntil(closingTagRe);\n    } else if (type === '{') {\n      value = scanner.scanUntil(closingCurlyRe);\n      scanner.scan(curlyRe);\n      scanner.scanUntil(closingTagRe);\n      type = '&';\n    } else {\n      value = scanner.scanUntil(closingTagRe);\n    }\n\n    // Match the closing tag.\n    if (!scanner.scan(closingTagRe))\n      throw new Error('Unclosed tag at ' + scanner.pos);\n\n    if (type == '>') {\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\n    } else {\n      token = [ type, value, start, scanner.pos ];\n    }\n    tagIndex++;\n    tokens.push(token);\n\n    if (type === '#' || type === '^') {\n      sections.push(token);\n    } else if (type === '/') {\n      // Check section nesting.\n      openSection = sections.pop();\n\n      if (!openSection)\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n      if (openSection[1] !== value)\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n    } else if (type === 'name' || type === '{' || type === '&') {\n      nonSpace = true;\n    } else if (type === '=') {\n      // Set the tags for the next time around.\n      compileTags(value);\n    }\n  }\n\n  stripSpace();\n\n  // Make sure there are no open sections when we're done.\n  openSection = sections.pop();\n\n  if (openSection)\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n  return nestTokens(squashTokens(tokens));\n}\n\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */\nfunction squashTokens (tokens) {\n  var squashedTokens = [];\n\n  var token, lastToken;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    if (token) {\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        squashedTokens.push(token);\n        lastToken = token;\n      }\n    }\n  }\n\n  return squashedTokens;\n}\n\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */\nfunction nestTokens (tokens) {\n  var nestedTokens = [];\n  var collector = nestedTokens;\n  var sections = [];\n\n  var token, section;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n    }\n  }\n\n  return nestedTokens;\n}\n\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */\nfunction Scanner (string) {\n  this.string = string;\n  this.tail = string;\n  this.pos = 0;\n}\n\n/**\n * Returns `true` if the tail is empty (end of string).\n */\nScanner.prototype.eos = function eos () {\n  return this.tail === '';\n};\n\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */\nScanner.prototype.scan = function scan (re) {\n  var match = this.tail.match(re);\n\n  if (!match || match.index !== 0)\n    return '';\n\n  var string = match[0];\n\n  this.tail = this.tail.substring(string.length);\n  this.pos += string.length;\n\n  return string;\n};\n\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */\nScanner.prototype.scanUntil = function scanUntil (re) {\n  var index = this.tail.search(re), match;\n\n  switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = '';\n      break;\n    case 0:\n      match = '';\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n  }\n\n  this.pos += match.length;\n\n  return match;\n};\n\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */\nfunction Context (view, parentContext) {\n  this.view = view;\n  this.cache = { '.': this.view };\n  this.parent = parentContext;\n}\n\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */\nContext.prototype.push = function push (view) {\n  return new Context(view, this);\n};\n\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */\nContext.prototype.lookup = function lookup (name) {\n  var cache = this.cache;\n\n  var value;\n  if (cache.hasOwnProperty(name)) {\n    value = cache[name];\n  } else {\n    var context = this, intermediateValue, names, index, lookupHit = false;\n\n    while (context) {\n      if (name.indexOf('.') > 0) {\n        intermediateValue = context.view;\n        names = name.split('.');\n        index = 0;\n\n        /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/\n        while (intermediateValue != null && index < names.length) {\n          if (index === names.length - 1)\n            lookupHit = (\n              hasProperty(intermediateValue, names[index])\n              || primitiveHasOwnProperty(intermediateValue, names[index])\n            );\n\n          intermediateValue = intermediateValue[names[index++]];\n        }\n      } else {\n        intermediateValue = context.view[name];\n\n        /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/\n        lookupHit = hasProperty(context.view, name);\n      }\n\n      if (lookupHit) {\n        value = intermediateValue;\n        break;\n      }\n\n      context = context.parent;\n    }\n\n    cache[name] = value;\n  }\n\n  if (isFunction(value))\n    value = value.call(this.view);\n\n  return value;\n};\n\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */\nfunction Writer () {\n  this.templateCache = {\n    _cache: {},\n    set: function set (key, value) {\n      this._cache[key] = value;\n    },\n    get: function get (key) {\n      return this._cache[key];\n    },\n    clear: function clear () {\n      this._cache = {};\n    }\n  };\n}\n\n/**\n * Clears all cached templates in this writer.\n */\nWriter.prototype.clearCache = function clearCache () {\n  if (typeof this.templateCache !== 'undefined') {\n    this.templateCache.clear();\n  }\n};\n\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */\nWriter.prototype.parse = function parse (template, tags) {\n  var cache = this.templateCache;\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n  var isCacheEnabled = typeof cache !== 'undefined';\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n  if (tokens == undefined) {\n    tokens = parseTemplate(template, tags);\n    isCacheEnabled && cache.set(cacheKey, tokens);\n  }\n  return tokens;\n};\n\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */\nWriter.prototype.render = function render (template, view, partials, config) {\n  var tags = this.getConfigTags(config);\n  var tokens = this.parse(template, tags);\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\n  return this.renderTokens(tokens, context, partials, template, config);\n};\n\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\n  var buffer = '';\n\n  var token, symbol, value;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    value = undefined;\n    token = tokens[i];\n    symbol = token[0];\n\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n    else if (symbol === '&') value = this.unescapedValue(token, context);\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\n    else if (symbol === 'text') value = this.rawValue(token);\n\n    if (value !== undefined)\n      buffer += value;\n  }\n\n  return buffer;\n};\n\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\n  var self = this;\n  var buffer = '';\n  var value = context.lookup(token[1]);\n\n  // This function is used to render an arbitrary template\n  // in the current context by higher-order sections.\n  function subRender (template) {\n    return self.render(template, context, partials, config);\n  }\n\n  if (!value) return;\n\n  if (isArray(value)) {\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n    }\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n  } else if (isFunction(value)) {\n    if (typeof originalTemplate !== 'string')\n      throw new Error('Cannot use higher-order sections without the original template');\n\n    // Extract the portion of the original template that the section contains.\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n    if (value != null)\n      buffer += value;\n  } else {\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n  }\n  return buffer;\n};\n\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\n  var value = context.lookup(token[1]);\n\n  // Use JavaScript's definition of falsy. Include empty arrays.\n  // See https://github.com/janl/mustache.js/issues/186\n  if (!value || (isArray(value) && value.length === 0))\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\n\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n  var partialByNl = partial.split('\\n');\n  for (var i = 0; i < partialByNl.length; i++) {\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n      partialByNl[i] = filteredIndentation + partialByNl[i];\n    }\n  }\n  return partialByNl.join('\\n');\n};\n\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\n  if (!partials) return;\n  var tags = this.getConfigTags(config);\n\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n  if (value != null) {\n    var lineHasNonSpace = token[6];\n    var tagIndex = token[5];\n    var indentation = token[4];\n    var indentedValue = value;\n    if (tagIndex == 0 && indentation) {\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n    }\n    var tokens = this.parse(indentedValue, tags);\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\n  }\n};\n\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return value;\n};\n\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\n  var escape = this.getConfigEscape(config) || mustache.escape;\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n};\n\nWriter.prototype.rawValue = function rawValue (token) {\n  return token[1];\n};\n\nWriter.prototype.getConfigTags = function getConfigTags (config) {\n  if (isArray(config)) {\n    return config;\n  }\n  else if (config && typeof config === 'object') {\n    return config.tags;\n  }\n  else {\n    return undefined;\n  }\n};\n\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\n  if (config && typeof config === 'object' && !isArray(config)) {\n    return config.escape;\n  }\n  else {\n    return undefined;\n  }\n};\n\nvar mustache = {\n  name: 'mustache.js',\n  version: '4.2.0',\n  tags: [ '{{', '}}' ],\n  clearCache: undefined,\n  escape: undefined,\n  parse: undefined,\n  render: undefined,\n  Scanner: undefined,\n  Context: undefined,\n  Writer: undefined,\n  /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */\n  set templateCache (cache) {\n    defaultWriter.templateCache = cache;\n  },\n  /**\n   * Gets the default or overridden caching object from the default writer.\n   */\n  get templateCache () {\n    return defaultWriter.templateCache;\n  }\n};\n\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n\n/**\n * Clears all cached templates in the default writer.\n */\nmustache.clearCache = function clearCache () {\n  return defaultWriter.clearCache();\n};\n\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */\nmustache.parse = function parse (template, tags) {\n  return defaultWriter.parse(template, tags);\n};\n\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */\nmustache.render = function render (template, view, partials, config) {\n  if (typeof template !== 'string') {\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\n                        'argument for mustache#render(template, view, partials)');\n  }\n\n  return defaultWriter.render(template, view, partials, config);\n};\n\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\n\nexport default mustache;\n","import * as z from \"./external.js\";\nexport { z };\nexport * from \"./external.js\";\nexport default z;\n","export function encodePointer(p) {\n    return encodeURI(escapePointer(p));\n}\nexport function escapePointer(p) {\n    return p.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","export var OutputFormat;\n(function (OutputFormat) {\n    OutputFormat[OutputFormat[\"Flag\"] = 1] = \"Flag\";\n    OutputFormat[OutputFormat[\"Basic\"] = 2] = \"Basic\";\n    OutputFormat[OutputFormat[\"Detailed\"] = 4] = \"Detailed\";\n})(OutputFormat || (OutputFormat = {}));\n","export function ucs2length(s) {\n    let result = 0;\n    let length = s.length;\n    let index = 0;\n    let charCode;\n    while (index < length) {\n        result++;\n        charCode = s.charCodeAt(index++);\n        if (charCode >= 0xd800 && charCode <= 0xdbff && index < length) {\n            charCode = s.charCodeAt(index);\n            if ((charCode & 0xfc00) == 0xdc00) {\n                index++;\n            }\n        }\n    }\n    return result;\n}\n","export const _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nexport const _REPLICA_TRACE_ROOTS_KEY = Symbol.for(\"langsmith:replica_trace_roots\");\n","export class Doc {\n    constructor(args = []) {\n        this.content = [];\n        this.indent = 0;\n        if (this)\n            this.args = args;\n    }\n    indented(fn) {\n        this.indent += 1;\n        fn(this);\n        this.indent -= 1;\n    }\n    write(arg) {\n        if (typeof arg === \"function\") {\n            arg(this, { execution: \"sync\" });\n            arg(this, { execution: \"async\" });\n            return;\n        }\n        const content = arg;\n        const lines = content.split(\"\\n\").filter((x) => x);\n        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n        for (const line of dedented) {\n            this.content.push(line);\n        }\n    }\n    compile() {\n        const F = Function;\n        const args = this?.args;\n        const content = this?.content ?? [``];\n        const lines = [...content.map((x) => `  ${x}`)];\n        // console.log(lines.join(\"\\n\"));\n        return new F(...args, lines.join(\"\\n\"));\n    }\n}\n","export const version = {\n    major: 4,\n    minor: 1,\n    patch: 13,\n};\n","export class TimeoutError extends Error {\n\tname = 'TimeoutError';\n\n\tconstructor(message, options) {\n\t\tsuper(message, options);\n\t\tError.captureStackTrace?.(this, TimeoutError);\n\t}\n}\n\nconst getAbortedReason = signal => signal.reason ?? new DOMException('This operation was aborted.', 'AbortError');\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t\tsignal,\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (signal?.aborted) {\n\t\t\treject(getAbortedReason(signal));\n\t\t\treturn;\n\t\t}\n\n\t\tif (signal) {\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\t// Use .then() instead of async IIFE to preserve stack traces\n\t\t// eslint-disable-next-line promise/prefer-await-to-then, promise/prefer-catch\n\t\tpromise.then(resolve, reject);\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\t// `.call(undefined, ...)` is needed for custom timers to avoid context issues\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\t});\n\n\t// eslint-disable-next-line promise/prefer-await-to-then\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && signal) {\n\t\t\tsignal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\t// `.call(undefined, ...)` is needed for custom timers to avoid context issues\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","export var util;\n(function (util) {\n    util.assertEqual = (_) => { };\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val) => (typeof val === \"string\" ? `'${val}'` : val)).join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nexport var objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nexport const ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n","export var errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    // biome-ignore lint:\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n","export function isLangChainMessage(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nexport function convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: { content: message.content },\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs &&\n        Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = { ...message.additional_kwargs };\n    }\n    return converted;\n}\n","export function deepCompareStrict(a, b) {\n    const typeofa = typeof a;\n    if (typeofa !== typeof b) {\n        return false;\n    }\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b)) {\n            return false;\n        }\n        const length = a.length;\n        if (length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < length; i++) {\n            if (!deepCompareStrict(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeofa === 'object') {\n        if (!a || !b) {\n            return a === b;\n        }\n        const aKeys = Object.keys(a);\n        const bKeys = Object.keys(b);\n        const length = aKeys.length;\n        if (length !== bKeys.length) {\n            return false;\n        }\n        for (const k of aKeys) {\n            if (!deepCompareStrict(a[k], b[k])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b;\n}\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;","import defaultErrorMap from \"./locales/en.js\";\nlet overrideErrorMap = defaultErrorMap;\nexport { defaultErrorMap };\nexport function setErrorMap(map) {\n    overrideErrorMap = map;\n}\nexport function getErrorMap() {\n    return overrideErrorMap;\n}\n","import pRetry from \"../utils/p-retry/index.js\";\nimport PQueueMod from \"p-queue\";\nconst STATUS_RETRYABLE = [\n    408, // Request Timeout\n    425, // Too Early\n    429, // Too Many Requests\n    500, // Internal Server Error\n    502, // Bad Gateway\n    503, // Service Unavailable\n    504, // Gateway Timeout\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nexport class AsyncCaller {\n    constructor(params) {\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxQueueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.maxQueueSizeBytes = params.maxQueueSizeBytes;\n        if (\"default\" in PQueueMod) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new PQueueMod.default({\n                concurrency: this.maxConcurrency,\n            });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new PQueueMod({ concurrency: this.maxConcurrency });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.callWithOptions({}, callable, ...args);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        const sizeBytes = options.sizeBytes ?? 0;\n        // Check if adding this call would exceed the byte size limit\n        if (this.maxQueueSizeBytes !== undefined &&\n            sizeBytes > 0 &&\n            this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {\n            return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. ` +\n                `Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));\n        }\n        // Add to queue size tracking\n        if (sizeBytes > 0) {\n            this.queueSizeBytes += sizeBytes;\n        }\n        const onFailedResponseHook = this.onFailedResponseHook;\n        let promise = this.queue.add(() => pRetry(() => callable(...args).catch((error) => {\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (error instanceof Error) {\n                throw error;\n            }\n            else {\n                throw new Error(error);\n            }\n        }), {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            async onFailedAttempt({ error }) {\n                if (error.message.startsWith(\"Cancel\") ||\n                    error.message.startsWith(\"TimeoutError\") ||\n                    error.name === \"TimeoutError\" ||\n                    error.message.startsWith(\"AbortError\")) {\n                    throw error;\n                }\n                if (error?.code === \"ECONNABORTED\") {\n                    throw error;\n                }\n                const response = error?.response;\n                if (onFailedResponseHook) {\n                    const handled = await onFailedResponseHook(response);\n                    if (handled) {\n                        return;\n                    }\n                }\n                const status = response?.status ?? error?.status;\n                if (status) {\n                    if (!STATUS_RETRYABLE.includes(+status)) {\n                        throw error;\n                    }\n                }\n            },\n            retries: this.maxRetries,\n            randomize: true,\n        }), { throwOnTimeout: true });\n        // Decrement queue size when the call completes (success or failure)\n        if (sizeBytes > 0) {\n            promise = promise.finally(() => {\n                this.queueSizeBytes -= sizeBytes;\n            });\n        }\n        // Handle signal cancellation\n        if (options.signal) {\n            return Promise.race([\n                promise,\n                new Promise((_, reject) => {\n                    options.signal?.addEventListener(\"abort\", () => {\n                        reject(new Error(\"AbortError\"));\n                    });\n                }),\n            ]);\n        }\n        return promise;\n    }\n}\n","import crypto from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","import REGEX from './regex.js';\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;","import { getLangSmithEnvironmentVariable } from \"../utils/env.js\";\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args) => fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */\nexport const overrideFetchImplementation = (fetch) => {\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch;\n};\nexport const clearFetchImplementation = () => {\n    delete globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n};\nexport const _globalFetchImplementationIsNodeFetch = () => {\n    const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n    if (!fetchImpl)\n        return false;\n    // Check if the implementation has node-fetch specific properties\n    return (typeof fetchImpl === \"function\" &&\n        \"Headers\" in fetchImpl &&\n        \"Request\" in fetchImpl &&\n        \"Response\" in fetchImpl);\n};\n/**\n * @internal\n */\nexport const _getFetchImplementation = (debug) => {\n    return async (...args) => {\n        if (debug || getLangSmithEnvironmentVariable(\"DEBUG\") === \"true\") {\n            const [url, options] = args;\n            console.log(` ${options?.method || \"GET\"} ${url}`);\n        }\n        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ??\n            DEFAULT_FETCH_IMPLEMENTATION)(...args);\n        if (debug || getLangSmithEnvironmentVariable(\"DEBUG\") === \"true\") {\n            console.log(` ${res.status} ${res.statusText} ${res.url}`);\n        }\n        return res;\n    };\n};\n","import validate from './validate.js';\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  let v;\n  const arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\nexport default parse;","import crypto from 'node:crypto';\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n  return crypto.createHash('sha1').update(bytes).digest();\n}\nexport default sha1;","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \" \",\n        url: \"\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"   ISO\",\n        date: \"  ISO\",\n        time: \"  ISO\",\n        duration: \"  ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \"   IPv4\",\n        cidrv6: \"   IPv6\",\n        base64: \"  base64-encoded\",\n        base64url: \"  base64url-encoded\",\n        json_string: \"   JSON\",\n        e164: \"   E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `  :   ${issue.expected}    ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  :   ${util.stringifyPrimitive(issue.values[0])}`;\n                return `  :     : ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `   :    ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return `  :    ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `  :   ${issue.origin}   ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `  :   ${issue.origin}   ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `  :     \"${issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `  :     \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `  :    \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `  :     ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format}  `;\n            }\n            case \"not_multiple_of\":\n                return `  :      ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \" \")}`;\n            case \"invalid_key\":\n                return `    ${issue.origin}`;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `    ${issue.origin}`;\n            default:\n                return \"  \";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"simvol\", verb: \"olmaldr\" },\n        file: { unit: \"bayt\", verb: \"olmaldr\" },\n        array: { unit: \"element\", verb: \"olmaldr\" },\n        set: { unit: \"element\", verb: \"olmaldr\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"input\",\n        email: \"email address\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datetime\",\n        date: \"ISO date\",\n        time: \"ISO time\",\n        duration: \"ISO duration\",\n        ipv4: \"IPv4 address\",\n        ipv6: \"IPv6 address\",\n        cidrv4: \"IPv4 range\",\n        cidrv6: \"IPv6 range\",\n        base64: \"base64-encoded string\",\n        base64url: \"base64url-encoded string\",\n        json_string: \"JSON string\",\n        e164: \"E.164 number\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Yanl dyr: gzlniln ${issue.expected}, daxil olan ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Yanl dyr: gzlniln ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Yanl seim: aadaklardan biri olmaldr: ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ox byk: gzlniln ${issue.origin ?? \"dyr\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n                return `ox byk: gzlniln ${issue.origin ?? \"dyr\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ox kiik: gzlniln ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                return `ox kiik: gzlniln ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Yanl mtn: \"${_issue.prefix}\" il balamaldr`;\n                if (_issue.format === \"ends_with\")\n                    return `Yanl mtn: \"${_issue.suffix}\" il bitmlidir`;\n                if (_issue.format === \"includes\")\n                    return `Yanl mtn: \"${_issue.includes}\" daxil olmaldr`;\n                if (_issue.format === \"regex\")\n                    return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;\n                return `Yanl ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Yanl dd: ${issue.divisor} il bln biln olmaldr`;\n            case \"unrecognized_keys\":\n                return `Tannmayan aar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} daxilind yanl aar`;\n            case \"invalid_union\":\n                return \"Yanl dyr\";\n            case \"invalid_element\":\n                return `${issue.origin} daxilind yanl dyr`;\n            default:\n                return `Yanl dyr`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nfunction getBelarusianPlural(count, one, few, many) {\n    const absCount = Math.abs(count);\n    const lastDigit = absCount % 10;\n    const lastTwoDigits = absCount % 100;\n    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n        return many;\n    }\n    if (lastDigit === 1) {\n        return one;\n    }\n    if (lastDigit >= 2 && lastDigit <= 4) {\n        return few;\n    }\n    return many;\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        array: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        set: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        file: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"email \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"   base64\",\n        base64url: \"   base64url\",\n        json_string: \"JSON \",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const maxValue = Number(issue.maximum);\n                    const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return ` : ,  ${issue.origin ?? \"\"}  ${sizing.verb} ${adj}${issue.maximum.toString()} ${unit}`;\n                }\n                return ` : ,  ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const minValue = Number(issue.minimum);\n                    const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return ` : ,  ${issue.origin}  ${sizing.verb} ${adj}${issue.minimum.toString()} ${unit}`;\n                }\n                return ` : ,  ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` :    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return ` :    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :    ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"carcters\", verb: \"contenir\" },\n        file: { unit: \"bytes\", verb: \"contenir\" },\n        array: { unit: \"elements\", verb: \"contenir\" },\n        set: { unit: \"elements\", verb: \"contenir\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"entrada\",\n        email: \"adrea electrnica\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data i hora ISO\",\n        date: \"data ISO\",\n        time: \"hora ISO\",\n        duration: \"durada ISO\",\n        ipv4: \"adrea IPv4\",\n        ipv6: \"adrea IPv6\",\n        cidrv4: \"rang IPv4\",\n        cidrv6: \"rang IPv6\",\n        base64: \"cadena codificada en base64\",\n        base64url: \"cadena codificada en base64url\",\n        json_string: \"cadena JSON\",\n        e164: \"nmero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entrada\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${parsedType(issue.input)}`;\n            // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Valor invlid: s'esperava ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opci invlida: s'esperava una de ${util.joinValues(issue.values, \" o \")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"com a mxim\" : \"menys de\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} contingus ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n                return `Massa gran: s'esperava que ${issue.origin ?? \"el valor\"} fos ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"com a mnim\" : \"ms de\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Massa petit: s'esperava que ${issue.origin} contingus ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Massa petit: s'esperava que ${issue.origin} fos ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Format invlid: ha de comenar amb \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Format invlid: ha d'acabar amb \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Format invlid: ha d'incloure \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;\n                return `Format invlid per a ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nmero invlid: ha de ser mltiple de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Clau${issue.keys.length > 1 ? \"s\" : \"\"} no reconeguda${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Clau invlida a ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entrada invlida\"; // Could also be \"Tipus d'uni invlid\" but \"Entrada invlida\" is more general\n            case \"invalid_element\":\n                return `Element invlid a ${issue.origin}`;\n            default:\n                return `Entrada invlida`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"znak\", verb: \"mt\" },\n        file: { unit: \"bajt\", verb: \"mt\" },\n        array: { unit: \"prvk\", verb: \"mt\" },\n        set: { unit: \"prvk\", verb: \"mt\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"slo\";\n            }\n            case \"string\": {\n                return \"etzec\";\n            }\n            case \"boolean\": {\n                return \"boolean\";\n            }\n            case \"bigint\": {\n                return \"bigint\";\n            }\n            case \"function\": {\n                return \"funkce\";\n            }\n            case \"symbol\": {\n                return \"symbol\";\n            }\n            case \"undefined\": {\n                return \"undefined\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"pole\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"regulrn vraz\",\n        email: \"e-mailov adresa\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"datum a as ve formtu ISO\",\n        date: \"datum ve formtu ISO\",\n        time: \"as ve formtu ISO\",\n        duration: \"doba trvn ISO\",\n        ipv4: \"IPv4 adresa\",\n        ipv6: \"IPv6 adresa\",\n        cidrv4: \"rozsah IPv4\",\n        cidrv6: \"rozsah IPv6\",\n        base64: \"etzec zakdovan ve formtu base64\",\n        base64url: \"etzec zakdovan ve formtu base64url\",\n        json_string: \"etzec ve formtu JSON\",\n        e164: \"slo E.164\",\n        jwt: \"JWT\",\n        template_literal: \"vstup\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Neplatn vstup: oekvno ${issue.expected}, obdreno ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Neplatn vstup: oekvno ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Neplatn monost: oekvna jedna z hodnot ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Hodnota je pli velk: ${issue.origin ?? \"hodnota\"} mus mt ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"prvk\"}`;\n                }\n                return `Hodnota je pli velk: ${issue.origin ?? \"hodnota\"} mus bt ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Hodnota je pli mal: ${issue.origin ?? \"hodnota\"} mus mt ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"prvk\"}`;\n                }\n                return `Hodnota je pli mal: ${issue.origin ?? \"hodnota\"} mus bt ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Neplatn etzec: mus zanat na \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Neplatn etzec: mus konit na \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Neplatn etzec: mus obsahovat \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;\n                return `Neplatn formt ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Neplatn slo: mus bt nsobkem ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Neznm kle: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Neplatn kl v ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Neplatn vstup\";\n            case \"invalid_element\":\n                return `Neplatn hodnota v ${issue.origin}`;\n            default:\n                return `Neplatn vstup`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tegn\", verb: \"havde\" },\n        file: { unit: \"bytes\", verb: \"havde\" },\n        array: { unit: \"elementer\", verb: \"indeholdt\" },\n        set: { unit: \"elementer\", verb: \"indeholdt\" },\n    };\n    const TypeNames = {\n        string: \"streng\",\n        number: \"tal\",\n        boolean: \"boolean\",\n        array: \"liste\",\n        object: \"objekt\",\n        set: \"st\",\n        file: \"fil\",\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    function getTypeName(type) {\n        return TypeNames[type] ?? type;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"tal\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"liste\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n                return \"objekt\";\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"input\",\n        email: \"e-mailadresse\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO dato- og klokkeslt\",\n        date: \"ISO-dato\",\n        time: \"ISO-klokkeslt\",\n        duration: \"ISO-varighed\",\n        ipv4: \"IPv4-omrde\",\n        ipv6: \"IPv6-omrde\",\n        cidrv4: \"IPv4-spektrum\",\n        cidrv6: \"IPv6-spektrum\",\n        base64: \"base64-kodet streng\",\n        base64url: \"base64url-kodet streng\",\n        json_string: \"JSON-streng\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Ugyldigt input: forventede ${getTypeName(issue.expected)}, fik ${getTypeName(parsedType(issue.input))}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ugyldig vrdi: forventede ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ugyldigt valg: forventede en af flgende ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                const origin = getTypeName(issue.origin);\n                if (sizing)\n                    return `For stor: forventede ${origin ?? \"value\"} ${sizing.verb} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n                return `For stor: forventede ${origin ?? \"value\"} havde ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                const origin = getTypeName(issue.origin);\n                if (sizing) {\n                    return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `For lille: forventede ${origin} havde ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Ugyldig streng: skal starte med \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Ugyldig streng: skal ende med \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Ugyldig streng: skal indeholde \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;\n                return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ugyldigt tal: skal vre deleligt med ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Ukendte ngler\" : \"Ukendt ngle\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ugyldig ngle i ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ugyldigt input: matcher ingen af de tilladte typer\";\n            case \"invalid_element\":\n                return `Ugyldig vrdi i ${issue.origin}`;\n            default:\n                return `Ugyldigt input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"Zeichen\", verb: \"zu haben\" },\n        file: { unit: \"Bytes\", verb: \"zu haben\" },\n        array: { unit: \"Elemente\", verb: \"zu haben\" },\n        set: { unit: \"Elemente\", verb: \"zu haben\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"Zahl\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"Array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"Eingabe\",\n        email: \"E-Mail-Adresse\",\n        url: \"URL\",\n        emoji: \"Emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-Datum und -Uhrzeit\",\n        date: \"ISO-Datum\",\n        time: \"ISO-Uhrzeit\",\n        duration: \"ISO-Dauer\",\n        ipv4: \"IPv4-Adresse\",\n        ipv6: \"IPv6-Adresse\",\n        cidrv4: \"IPv4-Bereich\",\n        cidrv6: \"IPv6-Bereich\",\n        base64: \"Base64-codierter String\",\n        base64url: \"Base64-URL-codierter String\",\n        json_string: \"JSON-String\",\n        e164: \"E.164-Nummer\",\n        jwt: \"JWT\",\n        template_literal: \"Eingabe\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Ungltige Eingabe: erwartet ${issue.expected}, erhalten ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ungltige Eingabe: erwartet ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ungltige Option: erwartet eine von ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Zu gro: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"Elemente\"} hat`;\n                return `Zu gro: erwartet, dass ${issue.origin ?? \"Wert\"} ${adj}${issue.maximum.toString()} ist`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit} hat`;\n                }\n                return `Zu klein: erwartet, dass ${issue.origin} ${adj}${issue.minimum.toString()} ist`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Ungltiger String: muss mit \"${_issue.prefix}\" beginnen`;\n                if (_issue.format === \"ends_with\")\n                    return `Ungltiger String: muss mit \"${_issue.suffix}\" enden`;\n                if (_issue.format === \"includes\")\n                    return `Ungltiger String: muss \"${_issue.includes}\" enthalten`;\n                if (_issue.format === \"regex\")\n                    return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;\n                return `Ungltig: ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ungltige Zahl: muss ein Vielfaches von ${issue.divisor} sein`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Unbekannte Schlssel\" : \"Unbekannter Schlssel\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ungltiger Schlssel in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ungltige Eingabe\";\n            case \"invalid_element\":\n                return `Ungltiger Wert in ${issue.origin}`;\n            default:\n                return `Ungltige Eingabe`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caracteres\", verb: \"tener\" },\n        file: { unit: \"bytes\", verb: \"tener\" },\n        array: { unit: \"elementos\", verb: \"tener\" },\n        set: { unit: \"elementos\", verb: \"tener\" },\n    };\n    const TypeNames = {\n        string: \"texto\",\n        number: \"nmero\",\n        boolean: \"booleano\",\n        array: \"arreglo\",\n        object: \"objeto\",\n        set: \"conjunto\",\n        file: \"archivo\",\n        date: \"fecha\",\n        bigint: \"nmero grande\",\n        symbol: \"smbolo\",\n        undefined: \"indefinido\",\n        null: \"nulo\",\n        function: \"funcin\",\n        map: \"mapa\",\n        record: \"registro\",\n        tuple: \"tupla\",\n        enum: \"enumeracin\",\n        union: \"unin\",\n        literal: \"literal\",\n        promise: \"promesa\",\n        void: \"vaco\",\n        never: \"nunca\",\n        unknown: \"desconocido\",\n        any: \"cualquiera\",\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    function getTypeName(type) {\n        return TypeNames[type] ?? type;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype) {\n                    return data.constructor.name;\n                }\n                return \"object\";\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"entrada\",\n        email: \"direccin de correo electrnico\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"fecha y hora ISO\",\n        date: \"fecha ISO\",\n        time: \"hora ISO\",\n        duration: \"duracin ISO\",\n        ipv4: \"direccin IPv4\",\n        ipv6: \"direccin IPv6\",\n        cidrv4: \"rango IPv4\",\n        cidrv6: \"rango IPv6\",\n        base64: \"cadena codificada en base64\",\n        base64url: \"URL codificada en base64\",\n        json_string: \"cadena JSON\",\n        e164: \"nmero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entrada\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Entrada invlida: se esperaba ${getTypeName(issue.expected)}, recibido ${getTypeName(parsedType(issue.input))}`;\n            // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entrada invlida: se esperaba ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opcin invlida: se esperaba una de ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                const origin = getTypeName(issue.origin);\n                if (sizing)\n                    return `Demasiado grande: se esperaba que ${origin ?? \"valor\"} tuviera ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n                return `Demasiado grande: se esperaba que ${origin ?? \"valor\"} fuera ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                const origin = getTypeName(issue.origin);\n                if (sizing) {\n                    return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Cadena invlida: debe comenzar con \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Cadena invlida: debe terminar en \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Cadena invlida: debe incluir \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;\n                return `Invlido ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nmero invlido: debe ser mltiplo de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Llave${issue.keys.length > 1 ? \"s\" : \"\"} desconocida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Llave invlida en ${getTypeName(issue.origin)}`;\n            case \"invalid_union\":\n                return \"Entrada invlida\";\n            case \"invalid_element\":\n                return `Valor invlido en ${getTypeName(issue.origin)}`;\n            default:\n                return `Entrada invlida`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"   \",\n        date: \" \",\n        time: \" \",\n        duration: \"  \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64-encoded \",\n        base64url: \"base64url-encoded \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected}  ${parsedType(issue.input)}  `;\n            case \"invalid_value\":\n                if (issue.values.length === 1) {\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])} `;\n                }\n                return ` :    ${util.joinValues(issue.values, \"|\")} `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"} `;\n                }\n                return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit} `;\n                }\n                return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :   \"${_issue.prefix}\"  `;\n                }\n                if (_issue.format === \"ends_with\") {\n                    return ` :   \"${_issue.suffix}\"  `;\n                }\n                if (_issue.format === \"includes\") {\n                    return ` :   \"${_issue.includes}\" `;\n                }\n                if (_issue.format === \"regex\") {\n                    return ` :    ${_issue.pattern}   `;\n                }\n                return `${Nouns[_issue.format] ?? issue.format} `;\n            }\n            case \"not_multiple_of\":\n                return ` :   ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return ` `;\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"merkki\", subject: \"merkkijonon\" },\n        file: { unit: \"tavua\", subject: \"tiedoston\" },\n        array: { unit: \"alkiota\", subject: \"listan\" },\n        set: { unit: \"alkiota\", subject: \"joukon\" },\n        number: { unit: \"\", subject: \"luvun\" },\n        bigint: { unit: \"\", subject: \"suuren kokonaisluvun\" },\n        int: { unit: \"\", subject: \"kokonaisluvun\" },\n        date: { unit: \"\", subject: \"pivmrn\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"snnllinen lauseke\",\n        email: \"shkpostiosoite\",\n        url: \"URL-osoite\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-aikaleima\",\n        date: \"ISO-pivmr\",\n        time: \"ISO-aika\",\n        duration: \"ISO-kesto\",\n        ipv4: \"IPv4-osoite\",\n        ipv6: \"IPv6-osoite\",\n        cidrv4: \"IPv4-alue\",\n        cidrv6: \"IPv6-alue\",\n        base64: \"base64-koodattu merkkijono\",\n        base64url: \"base64url-koodattu merkkijono\",\n        json_string: \"JSON-merkkijono\",\n        e164: \"E.164-luku\",\n        jwt: \"JWT\",\n        template_literal: \"templaattimerkkijono\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Virheellinen tyyppi: odotettiin ${issue.expected}, oli ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Virheellinen syte: tytyy olla ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Virheellinen valinta: tytyy olla yksi seuraavista: ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue.maximum.toString()} ${sizing.unit}`.trim();\n                }\n                return `Liian suuri: arvon tytyy olla ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue.minimum.toString()} ${sizing.unit}`.trim();\n                }\n                return `Liian pieni: arvon tytyy olla ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Virheellinen syte: tytyy alkaa \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Virheellinen syte: tytyy loppua \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Virheellinen syte: tytyy sislt \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\") {\n                    return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;\n                }\n                return `Virheellinen ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Virheellinen luku: tytyy olla luvun ${issue.divisor} monikerta`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Tuntemattomat avaimet\" : \"Tuntematon avain\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return \"Virheellinen avain tietueessa\";\n            case \"invalid_union\":\n                return \"Virheellinen unioni\";\n            case \"invalid_element\":\n                return \"Virheellinen arvo joukossa\";\n            default:\n                return `Virheellinen syte`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caractres\", verb: \"avoir\" },\n        file: { unit: \"octets\", verb: \"avoir\" },\n        array: { unit: \"lments\", verb: \"avoir\" },\n        set: { unit: \"lments\", verb: \"avoir\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"nombre\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"tableau\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"entre\",\n        email: \"adresse e-mail\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"date et heure ISO\",\n        date: \"date ISO\",\n        time: \"heure ISO\",\n        duration: \"dure ISO\",\n        ipv4: \"adresse IPv4\",\n        ipv6: \"adresse IPv6\",\n        cidrv4: \"plage IPv4\",\n        cidrv6: \"plage IPv6\",\n        base64: \"chane encode en base64\",\n        base64url: \"chane encode en base64url\",\n        json_string: \"chane JSON\",\n        e164: \"numro E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entre\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Entre invalide : ${issue.expected} attendu, ${parsedType(issue.input)} reu`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entre invalide : ${util.stringifyPrimitive(issue.values[0])} attendu`;\n                return `Option invalide : une valeur parmi ${util.joinValues(issue.values, \"|\")} attendue`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Trop grand : ${issue.origin ?? \"valeur\"} doit ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"lment(s)\"}`;\n                return `Trop grand : ${issue.origin ?? \"valeur\"} doit tre ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Trop petit : ${issue.origin} doit ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Trop petit : ${issue.origin} doit tre ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Chane invalide : doit commencer par \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Chane invalide : doit se terminer par \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Chane invalide : doit inclure \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format} invalide`;\n            }\n            case \"not_multiple_of\":\n                return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Cl invalide dans ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entre invalide\";\n            case \"invalid_element\":\n                return `Valeur invalide dans ${issue.origin}`;\n            default:\n                return `Entre invalide`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caractres\", verb: \"avoir\" },\n        file: { unit: \"octets\", verb: \"avoir\" },\n        array: { unit: \"lments\", verb: \"avoir\" },\n        set: { unit: \"lments\", verb: \"avoir\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"entre\",\n        email: \"adresse courriel\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"date-heure ISO\",\n        date: \"date ISO\",\n        time: \"heure ISO\",\n        duration: \"dure ISO\",\n        ipv4: \"adresse IPv4\",\n        ipv6: \"adresse IPv6\",\n        cidrv4: \"plage IPv4\",\n        cidrv6: \"plage IPv6\",\n        base64: \"chane encode en base64\",\n        base64url: \"chane encode en base64url\",\n        json_string: \"chane JSON\",\n        e164: \"numro E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entre\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Entre invalide : attendu ${issue.expected}, reu ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entre invalide : attendu ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Option invalide : attendu l'une des valeurs suivantes ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} ait ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n                return `Trop grand : attendu que ${issue.origin ?? \"la valeur\"} soit ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Trop petit : attendu que ${issue.origin} ait ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Trop petit : attendu que ${issue.origin} soit ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Chane invalide : doit commencer par \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Chane invalide : doit se terminer par \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Chane invalide : doit inclure \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format} invalide`;\n            }\n            case \"not_multiple_of\":\n                return `Nombre invalide : doit tre un multiple de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Cl${issue.keys.length > 1 ? \"s\" : \"\"} non reconnue${issue.keys.length > 1 ? \"s\" : \"\"} : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Cl invalide dans ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entre invalide\";\n            case \"invalid_element\":\n                return `Valeur invalide dans ${issue.origin}`;\n            default:\n                return `Entre invalide`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    // Hebrew labels + grammatical gender\n    const TypeNames = {\n        string: { label: \"\", gender: \"f\" },\n        number: { label: \"\", gender: \"m\" },\n        boolean: { label: \" \", gender: \"m\" },\n        bigint: { label: \"BigInt\", gender: \"m\" },\n        date: { label: \"\", gender: \"m\" },\n        array: { label: \"\", gender: \"m\" },\n        object: { label: \"\", gender: \"m\" },\n        null: { label: \"  (null)\", gender: \"m\" },\n        undefined: { label: \"   (undefined)\", gender: \"m\" },\n        symbol: { label: \" (Symbol)\", gender: \"m\" },\n        function: { label: \"\", gender: \"f\" },\n        map: { label: \" (Map)\", gender: \"f\" },\n        set: { label: \" (Set)\", gender: \"f\" },\n        file: { label: \"\", gender: \"m\" },\n        promise: { label: \"Promise\", gender: \"m\" },\n        NaN: { label: \"NaN\", gender: \"m\" },\n        unknown: { label: \"  \", gender: \"m\" },\n        value: { label: \"\", gender: \"m\" },\n    };\n    // Sizing units for size-related messages + localized origin labels\n    const Sizable = {\n        string: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        file: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        array: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        set: { unit: \"\", shortLabel: \"\", longLabel: \"\" },\n        number: { unit: \"\", shortLabel: \"\", longLabel: \"\" }, // no unit\n    };\n    // Helpers  labels, articles, and verbs\n    const typeEntry = (t) => (t ? TypeNames[t] : undefined);\n    const typeLabel = (t) => {\n        const e = typeEntry(t);\n        if (e)\n            return e.label;\n        // fallback: show raw string if unknown\n        return t ?? TypeNames.unknown.label;\n    };\n    const withDefinite = (t) => `${typeLabel(t)}`;\n    const verbFor = (t) => {\n        const e = typeEntry(t);\n        const gender = e?.gender ?? \"m\";\n        return gender === \"f\" ? \" \" : \" \";\n    };\n    const getSizing = (origin) => {\n        if (!origin)\n            return null;\n        return Sizable[origin] ?? null;\n    };\n    // Robust type parser for \"received\"  returns a key we understand or a constructor name\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\":\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            case \"object\": {\n                if (Array.isArray(data))\n                    return \"array\";\n                if (data === null)\n                    return \"null\";\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name; // keep as-is (e.g., \"Date\")\n                }\n                return \"object\";\n            }\n            default:\n                return t;\n        }\n    };\n    const Nouns = {\n        regex: { label: \"\", gender: \"m\" },\n        email: { label: \" \", gender: \"f\" },\n        url: { label: \" \", gender: \"f\" },\n        emoji: { label: \"'\", gender: \"m\" },\n        uuid: { label: \"UUID\", gender: \"m\" },\n        nanoid: { label: \"nanoid\", gender: \"m\" },\n        guid: { label: \"GUID\", gender: \"m\" },\n        cuid: { label: \"cuid\", gender: \"m\" },\n        cuid2: { label: \"cuid2\", gender: \"m\" },\n        ulid: { label: \"ULID\", gender: \"m\" },\n        xid: { label: \"XID\", gender: \"m\" },\n        ksuid: { label: \"KSUID\", gender: \"m\" },\n        datetime: { label: \"  ISO\", gender: \"m\" },\n        date: { label: \" ISO\", gender: \"m\" },\n        time: { label: \" ISO\", gender: \"m\" },\n        duration: { label: \"  ISO\", gender: \"m\" },\n        ipv4: { label: \" IPv4\", gender: \"f\" },\n        ipv6: { label: \" IPv6\", gender: \"f\" },\n        cidrv4: { label: \" IPv4\", gender: \"m\" },\n        cidrv6: { label: \" IPv6\", gender: \"m\" },\n        base64: { label: \"  64\", gender: \"f\" },\n        base64url: { label: \"  64  \", gender: \"f\" },\n        json_string: { label: \" JSON\", gender: \"f\" },\n        e164: { label: \" E.164\", gender: \"m\" },\n        jwt: { label: \"JWT\", gender: \"m\" },\n        ends_with: { label: \"\", gender: \"m\" },\n        includes: { label: \"\", gender: \"m\" },\n        lowercase: { label: \"\", gender: \"m\" },\n        starts_with: { label: \"\", gender: \"m\" },\n        uppercase: { label: \"\", gender: \"m\" },\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\": {\n                // Expected type: show without definite article for clearer Hebrew\n                const expectedKey = issue.expected;\n                const expected = typeLabel(expectedKey);\n                // Received: show localized label if known, otherwise constructor/raw\n                const receivedKey = parsedType(issue.input);\n                const received = TypeNames[receivedKey]?.label ?? receivedKey;\n                return `  :   ${expected},  ${received}`;\n            }\n            case \"invalid_value\": {\n                if (issue.values.length === 1) {\n                    return `  :    ${util.stringifyPrimitive(issue.values[0])}`;\n                }\n                // Join values with proper Hebrew formatting\n                const stringified = issue.values.map((v) => util.stringifyPrimitive(v));\n                if (issue.values.length === 2) {\n                    return `  :    ${stringified[0]}  ${stringified[1]}`;\n                }\n                // For 3+ values: \"a\", \"b\"  \"c\"\n                const lastValue = stringified[stringified.length - 1];\n                const restValues = stringified.slice(0, -1).join(\", \");\n                return `  :    ${restValues}  ${lastValue}`;\n            }\n            case \"too_big\": {\n                const sizing = getSizing(issue.origin);\n                const subject = withDefinite(issue.origin ?? \"value\");\n                if (issue.origin === \"string\") {\n                    // Special handling for strings - more natural Hebrew\n                    return `${sizing?.longLabel ?? \"\"} : ${subject}   ${issue.maximum.toString()} ${sizing?.unit ?? \"\"} ${issue.inclusive ? \" \" : \" \"}`.trim();\n                }\n                if (issue.origin === \"number\") {\n                    // Natural Hebrew for numbers\n                    const comparison = issue.inclusive ? `   -${issue.maximum}` : ` -${issue.maximum}`;\n                    return ` : ${subject}   ${comparison}`;\n                }\n                if (issue.origin === \"array\" || issue.origin === \"set\") {\n                    // Natural Hebrew for arrays and sets\n                    const verb = issue.origin === \"set\" ? \"\" : \"\";\n                    const comparison = issue.inclusive\n                        ? `${issue.maximum} ${sizing?.unit ?? \"\"}  `\n                        : ` -${issue.maximum} ${sizing?.unit ?? \"\"}`;\n                    return ` : ${subject} ${verb}  ${comparison}`.trim();\n                }\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const be = verbFor(issue.origin ?? \"value\");\n                if (sizing?.unit) {\n                    return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n                }\n                return `${sizing?.longLabel ?? \"\"} : ${subject} ${be} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const sizing = getSizing(issue.origin);\n                const subject = withDefinite(issue.origin ?? \"value\");\n                if (issue.origin === \"string\") {\n                    // Special handling for strings - more natural Hebrew\n                    return `${sizing?.shortLabel ?? \"\"} : ${subject}   ${issue.minimum.toString()} ${sizing?.unit ?? \"\"} ${issue.inclusive ? \" \" : \"\"}`.trim();\n                }\n                if (issue.origin === \"number\") {\n                    // Natural Hebrew for numbers\n                    const comparison = issue.inclusive ? `   -${issue.minimum}` : ` -${issue.minimum}`;\n                    return ` : ${subject}   ${comparison}`;\n                }\n                if (issue.origin === \"array\" || issue.origin === \"set\") {\n                    // Natural Hebrew for arrays and sets\n                    const verb = issue.origin === \"set\" ? \"\" : \"\";\n                    // Special case for singular (minimum === 1)\n                    if (issue.minimum === 1 && issue.inclusive) {\n                        const singularPhrase = issue.origin === \"set\" ? \"  \" : \"  \";\n                        return ` : ${subject} ${verb}  ${singularPhrase}`;\n                    }\n                    const comparison = issue.inclusive\n                        ? `${issue.minimum} ${sizing?.unit ?? \"\"}  `\n                        : ` -${issue.minimum} ${sizing?.unit ?? \"\"}`;\n                    return ` : ${subject} ${verb}  ${comparison}`.trim();\n                }\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const be = verbFor(issue.origin ?? \"value\");\n                if (sizing?.unit) {\n                    return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `${sizing?.shortLabel ?? \"\"} : ${subject} ${be} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                // These apply to strings  use feminine grammar +  \n                if (_issue.format === \"starts_with\")\n                    return `    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `    ${_issue.pattern}`;\n                // Handle gender agreement for formats\n                const nounEntry = Nouns[_issue.format];\n                const noun = nounEntry?.label ?? _issue.format;\n                const gender = nounEntry?.gender ?? \"m\";\n                const adjective = gender === \"f\" ? \"\" : \"\";\n                return `${noun}  ${adjective}`;\n            }\n            case \"not_multiple_of\":\n                return `  :     ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"}  ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\": {\n                return `   `;\n            }\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\": {\n                const place = withDefinite(issue.origin ?? \"array\");\n                return `   ${place}`;\n            }\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karakter\", verb: \"legyen\" },\n        file: { unit: \"byte\", verb: \"legyen\" },\n        array: { unit: \"elem\", verb: \"legyen\" },\n        set: { unit: \"elem\", verb: \"legyen\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"szm\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"tmb\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"bemenet\",\n        email: \"email cm\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO idblyeg\",\n        date: \"ISO dtum\",\n        time: \"ISO id\",\n        duration: \"ISO idintervallum\",\n        ipv4: \"IPv4 cm\",\n        ipv6: \"IPv6 cm\",\n        cidrv4: \"IPv4 tartomny\",\n        cidrv6: \"IPv6 tartomny\",\n        base64: \"base64-kdolt string\",\n        base64url: \"base64url-kdolt string\",\n        json_string: \"JSON string\",\n        e164: \"E.164 szm\",\n        jwt: \"JWT\",\n        template_literal: \"bemenet\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `rvnytelen bemenet: a vrt rtk ${issue.expected}, a kapott rtk ${parsedType(issue.input)}`;\n            // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `rvnytelen bemenet: a vrt rtk ${util.stringifyPrimitive(issue.values[0])}`;\n                return `rvnytelen opci: valamelyik rtk vrt ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Tl nagy: ${issue.origin ?? \"rtk\"} mrete tl nagy ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elem\"}`;\n                return `Tl nagy: a bemeneti rtk ${issue.origin ?? \"rtk\"} tl nagy: ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Tl kicsi: a bemeneti rtk ${issue.origin} mrete tl kicsi ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Tl kicsi: a bemeneti rtk ${issue.origin} tl kicsi ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `rvnytelen string: \"${_issue.prefix}\" rtkkel kell kezddnie`;\n                if (_issue.format === \"ends_with\")\n                    return `rvnytelen string: \"${_issue.suffix}\" rtkkel kell vgzdnie`;\n                if (_issue.format === \"includes\")\n                    return `rvnytelen string: \"${_issue.includes}\" rtket kell tartalmaznia`;\n                if (_issue.format === \"regex\")\n                    return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;\n                return `rvnytelen ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `rvnytelen szm: ${issue.divisor} tbbszrsnek kell lennie`;\n            case \"unrecognized_keys\":\n                return `Ismeretlen kulcs${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `rvnytelen kulcs ${issue.origin}`;\n            case \"invalid_union\":\n                return \"rvnytelen bemenet\";\n            case \"invalid_element\":\n                return `rvnytelen rtk: ${issue.origin}`;\n            default:\n                return `rvnytelen bemenet`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karakter\", verb: \"memiliki\" },\n        file: { unit: \"byte\", verb: \"memiliki\" },\n        array: { unit: \"item\", verb: \"memiliki\" },\n        set: { unit: \"item\", verb: \"memiliki\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"input\",\n        email: \"alamat email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"tanggal dan waktu format ISO\",\n        date: \"tanggal format ISO\",\n        time: \"jam format ISO\",\n        duration: \"durasi format ISO\",\n        ipv4: \"alamat IPv4\",\n        ipv6: \"alamat IPv6\",\n        cidrv4: \"rentang alamat IPv4\",\n        cidrv6: \"rentang alamat IPv6\",\n        base64: \"string dengan enkode base64\",\n        base64url: \"string dengan enkode base64url\",\n        json_string: \"string JSON\",\n        e164: \"angka E.164\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Input tidak valid: diharapkan ${issue.expected}, diterima ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Input tidak valid: diharapkan ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Pilihan tidak valid: diharapkan salah satu dari ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} memiliki ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n                return `Terlalu besar: diharapkan ${issue.origin ?? \"value\"} menjadi ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Terlalu kecil: diharapkan ${issue.origin} memiliki ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Terlalu kecil: diharapkan ${issue.origin} menjadi ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `String tidak valid: harus dimulai dengan \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `String tidak valid: harus berakhir dengan \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `String tidak valid: harus menyertakan \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `String tidak valid: harus sesuai pola ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format} tidak valid`;\n            }\n            case \"not_multiple_of\":\n                return `Angka tidak valid: harus kelipatan dari ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Kunci tidak dikenali ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Kunci tidak valid di ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Input tidak valid\";\n            case \"invalid_element\":\n                return `Nilai tidak valid di ${issue.origin}`;\n            default:\n                return `Input tidak valid`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caratteri\", verb: \"avere\" },\n        file: { unit: \"byte\", verb: \"avere\" },\n        array: { unit: \"elementi\", verb: \"avere\" },\n        set: { unit: \"elementi\", verb: \"avere\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"numero\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"vettore\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"input\",\n        email: \"indirizzo email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data e ora ISO\",\n        date: \"data ISO\",\n        time: \"ora ISO\",\n        duration: \"durata ISO\",\n        ipv4: \"indirizzo IPv4\",\n        ipv6: \"indirizzo IPv6\",\n        cidrv4: \"intervallo IPv4\",\n        cidrv6: \"intervallo IPv6\",\n        base64: \"stringa codificata in base64\",\n        base64url: \"URL codificata in base64\",\n        json_string: \"stringa JSON\",\n        e164: \"numero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Input non valido: atteso ${issue.expected}, ricevuto ${parsedType(issue.input)}`;\n            // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Input non valido: atteso ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opzione non valida: atteso uno tra ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Troppo grande: ${issue.origin ?? \"valore\"} deve avere ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementi\"}`;\n                return `Troppo grande: ${issue.origin ?? \"valore\"} deve essere ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Troppo piccolo: ${issue.origin} deve avere ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Troppo piccolo: ${issue.origin} deve essere ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Stringa non valida: deve iniziare con \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Stringa non valida: deve terminare con \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Stringa non valida: deve includere \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;\n                return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Numero non valido: deve essere un multiplo di ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Chiav${issue.keys.length > 1 ? \"i\" : \"e\"} non riconosciut${issue.keys.length > 1 ? \"e\" : \"a\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Chiave non valida in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Input non valido\";\n            case \"invalid_element\":\n                return `Valore non valido in ${issue.origin}`;\n            default:\n                return `Input non valido`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO\",\n        date: \"ISO\",\n        time: \"ISO\",\n        duration: \"ISO\",\n        ipv4: \"IPv4\",\n        ipv6: \"IPv6\",\n        cidrv4: \"IPv4\",\n        cidrv6: \"IPv6\",\n        base64: \"base64\",\n        base64url: \"base64url\",\n        json_string: \"JSON\",\n        e164: \"E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `: ${issue.expected}${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `: ${util.stringifyPrimitive(issue.values[0])}`;\n                return `: ${util.joinValues(issue.values, \"\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `: ${issue.origin ?? \"\"}${issue.maximum.toString()}${sizing.unit ?? \"\"}${adj}`;\n                return `: ${issue.origin ?? \"\"}${issue.maximum.toString()}${adj}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `: ${issue.origin}${issue.minimum.toString()}${sizing.unit}${adj}`;\n                return `: ${issue.origin}${issue.minimum.toString()}${adj}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `: \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `: \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `: \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `: ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `: ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \"\")}`;\n            case \"invalid_key\":\n                return `${issue.origin}`;\n            case \"invalid_union\":\n                return \"\";\n            case \"invalid_element\":\n                return `${issue.origin}`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \" (NaN)\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \" (Array)\";\n                }\n                if (data === null) {\n                    return \" (null)\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"  ISO\",\n        date: \" ISO\",\n        time: \" ISO\",\n        duration: \" ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \" IPv4\",\n        cidrv6: \" IPv6\",\n        base64: \" base64\",\n        base64url: \" base64url\",\n        json_string: \" JSON\",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `  ${issue.expected}  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  ${util.stringifyPrimitive(issue.values[0])}`;\n                return `  ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `  ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return `  ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `  ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `  ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `  \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `  \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `  \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `  ${_issue.pattern}`;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `  ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return ` ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return ` ${issue.origin}`;\n            case \"invalid_union\":\n                return ``;\n            case \"invalid_element\":\n                return ` ${issue.origin}`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"to have\" },\n        file: { unit: \"\", verb: \"to have\" },\n        array: { unit: \"\", verb: \"to have\" },\n        set: { unit: \"\", verb: \"to have\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64  \",\n        base64url: \"base64url  \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :   ${issue.expected},   ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}  `;\n                return ` : ${util.joinValues(issue.values, \" \")}   `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const suffix = adj === \"\" ? \" \" : \" \";\n                const sizing = getSizing(issue.origin);\n                const unit = sizing?.unit ?? \"\";\n                if (sizing)\n                    return `${issue.origin ?? \"\"}  : ${issue.maximum.toString()}${unit} ${adj}${suffix}`;\n                return `${issue.origin ?? \"\"}  : ${issue.maximum.toString()} ${adj}${suffix}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const suffix = adj === \"\" ? \" \" : \" \";\n                const sizing = getSizing(issue.origin);\n                const unit = sizing?.unit ?? \"\";\n                if (sizing) {\n                    return `${issue.origin ?? \"\"}  : ${issue.minimum.toString()}${unit} ${adj}${suffix}`;\n                }\n                return `${issue.origin ?? \"\"}  : ${issue.minimum.toString()} ${adj}${suffix}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` : \"${_issue.prefix}\"()  `;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` : \"${_issue.suffix}\"()  `;\n                if (_issue.format === \"includes\")\n                    return ` : \"${_issue.includes}\"()  `;\n                if (_issue.format === \"regex\")\n                    return ` :  ${_issue.pattern}   `;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` : ${issue.divisor}  `;\n            case \"unrecognized_keys\":\n                return `   : ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return ` : ${issue.origin}`;\n            case \"invalid_union\":\n                return ` `;\n            case \"invalid_element\":\n                return ` : ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"  -\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64- \",\n        base64url: \"base64url- \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :   ${issue.expected},  ${parsedType(issue.input)}`;\n            // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :     \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` :     \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :    \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :      ${_issue.pattern}`;\n                return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :      ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \" \" : \" \"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"aksara\", verb: \"mempunyai\" },\n        file: { unit: \"bait\", verb: \"mempunyai\" },\n        array: { unit: \"elemen\", verb: \"mempunyai\" },\n        set: { unit: \"elemen\", verb: \"mempunyai\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"nombor\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"input\",\n        email: \"alamat e-mel\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"tarikh masa ISO\",\n        date: \"tarikh ISO\",\n        time: \"masa ISO\",\n        duration: \"tempoh ISO\",\n        ipv4: \"alamat IPv4\",\n        ipv6: \"alamat IPv6\",\n        cidrv4: \"julat IPv4\",\n        cidrv6: \"julat IPv6\",\n        base64: \"string dikodkan base64\",\n        base64url: \"string dikodkan base64url\",\n        json_string: \"string JSON\",\n        e164: \"nombor E.164\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Input tidak sah: dijangka ${issue.expected}, diterima ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Input tidak sah: dijangka ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Pilihan tidak sah: dijangka salah satu daripada ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elemen\"}`;\n                return `Terlalu besar: dijangka ${issue.origin ?? \"nilai\"} adalah ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Terlalu kecil: dijangka ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Terlalu kecil: dijangka ${issue.origin} adalah ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `String tidak sah: mesti bermula dengan \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `String tidak sah: mesti berakhir dengan \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `String tidak sah: mesti mengandungi \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format} tidak sah`;\n            }\n            case \"not_multiple_of\":\n                return `Nombor tidak sah: perlu gandaan ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Kunci tidak dikenali: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Kunci tidak sah dalam ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Input tidak sah\";\n            case \"invalid_element\":\n                return `Nilai tidak sah dalam ${issue.origin}`;\n            default:\n                return `Input tidak sah`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tekens\", verb: \"te hebben\" },\n        file: { unit: \"bytes\", verb: \"te hebben\" },\n        array: { unit: \"elementen\", verb: \"te hebben\" },\n        set: { unit: \"elementen\", verb: \"te hebben\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"getal\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"invoer\",\n        email: \"emailadres\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datum en tijd\",\n        date: \"ISO datum\",\n        time: \"ISO tijd\",\n        duration: \"ISO duur\",\n        ipv4: \"IPv4-adres\",\n        ipv6: \"IPv6-adres\",\n        cidrv4: \"IPv4-bereik\",\n        cidrv6: \"IPv6-bereik\",\n        base64: \"base64-gecodeerde tekst\",\n        base64url: \"base64 URL-gecodeerde tekst\",\n        json_string: \"JSON string\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"invoer\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Ongeldige invoer: verwacht ${issue.expected}, ontving ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ongeldige invoer: verwacht ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ongeldige optie: verwacht n van ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Te groot: verwacht dat ${issue.origin ?? \"waarde\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementen\"}`;\n                return `Te groot: verwacht dat ${issue.origin ?? \"waarde\"} ${adj}${issue.maximum.toString()} is`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Te klein: verwacht dat ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Te klein: verwacht dat ${issue.origin} ${adj}${issue.minimum.toString()} is`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Ongeldige tekst: moet met \"${_issue.prefix}\" beginnen`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Ongeldige tekst: moet op \"${_issue.suffix}\" eindigen`;\n                if (_issue.format === \"includes\")\n                    return `Ongeldige tekst: moet \"${_issue.includes}\" bevatten`;\n                if (_issue.format === \"regex\")\n                    return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;\n                return `Ongeldig: ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ongeldig getal: moet een veelvoud van ${issue.divisor} zijn`;\n            case \"unrecognized_keys\":\n                return `Onbekende key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ongeldige key in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ongeldige invoer\";\n            case \"invalid_element\":\n                return `Ongeldige waarde in ${issue.origin}`;\n            default:\n                return `Ongeldige invoer`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tegn\", verb: \" ha\" },\n        file: { unit: \"bytes\", verb: \" ha\" },\n        array: { unit: \"elementer\", verb: \" inneholde\" },\n        set: { unit: \"elementer\", verb: \" inneholde\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"tall\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"liste\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"input\",\n        email: \"e-postadresse\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO dato- og klokkeslett\",\n        date: \"ISO-dato\",\n        time: \"ISO-klokkeslett\",\n        duration: \"ISO-varighet\",\n        ipv4: \"IPv4-omrde\",\n        ipv6: \"IPv6-omrde\",\n        cidrv4: \"IPv4-spekter\",\n        cidrv6: \"IPv6-spekter\",\n        base64: \"base64-enkodet streng\",\n        base64url: \"base64url-enkodet streng\",\n        json_string: \"JSON-streng\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Ugyldig input: forventet ${issue.expected}, fikk ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ugyldig verdi: forventet ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ugyldig valg: forventet en av ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `For stor(t): forventet ${issue.origin ?? \"value\"} til  ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementer\"}`;\n                return `For stor(t): forventet ${issue.origin ?? \"value\"} til  ha ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `For lite(n): forventet ${issue.origin} til  ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `For lite(n): forventet ${issue.origin} til  ha ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Ugyldig streng: m starte med \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Ugyldig streng: m ende med \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Ugyldig streng: m inneholde \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;\n                return `Ugyldig ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ugyldig tall: m vre et multiplum av ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Ukjente nkler\" : \"Ukjent nkkel\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ugyldig nkkel i ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Ugyldig input\";\n            case \"invalid_element\":\n                return `Ugyldig verdi i ${issue.origin}`;\n            default:\n                return `Ugyldig input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"harf\", verb: \"olmaldr\" },\n        file: { unit: \"bayt\", verb: \"olmaldr\" },\n        array: { unit: \"unsur\", verb: \"olmaldr\" },\n        set: { unit: \"unsur\", verb: \"olmaldr\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"numara\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"saf\";\n                }\n                if (data === null) {\n                    return \"gayb\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"giren\",\n        email: \"epostagh\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO hengm\",\n        date: \"ISO tarihi\",\n        time: \"ISO zaman\",\n        duration: \"ISO mddeti\",\n        ipv4: \"IPv4 nin\",\n        ipv6: \"IPv6 nin\",\n        cidrv4: \"IPv4 menzili\",\n        cidrv6: \"IPv6 menzili\",\n        base64: \"base64-ifreli metin\",\n        base64url: \"base64url-ifreli metin\",\n        json_string: \"JSON metin\",\n        e164: \"E.164 says\",\n        jwt: \"JWT\",\n        template_literal: \"giren\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Fsit giren: umulan ${issue.expected}, alnan ${parsedType(issue.input)}`;\n            // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Fsit giren: umulan ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Fsit tercih: mteberler ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Fazla byk: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"} sahip olmalyd.`;\n                return `Fazla byk: ${issue.origin ?? \"value\"}, ${adj}${issue.maximum.toString()} olmalyd.`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Fazla kk: ${issue.origin}, ${adj}${issue.minimum.toString()} ${sizing.unit} sahip olmalyd.`;\n                }\n                return `Fazla kk: ${issue.origin}, ${adj}${issue.minimum.toString()} olmalyd.`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Fsit metin: \"${_issue.prefix}\" ile balamal.`;\n                if (_issue.format === \"ends_with\")\n                    return `Fsit metin: \"${_issue.suffix}\" ile bitmeli.`;\n                if (_issue.format === \"includes\")\n                    return `Fsit metin: \"${_issue.includes}\" ihtiv etmeli.`;\n                if (_issue.format === \"regex\")\n                    return `Fsit metin: ${_issue.pattern} nakna uymal.`;\n                return `Fsit ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Fsit say: ${issue.divisor} kat olmalyd.`;\n            case \"unrecognized_keys\":\n                return `Tannmayan anahtar ${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} iin tannmayan anahtar var.`;\n            case \"invalid_union\":\n                return \"Giren tannamad.\";\n            case \"invalid_element\":\n                return `${issue.origin} iin tannmayan kymet var.`;\n            default:\n                return `Kymet tannamad.`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"\",\n        url: \"  \",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"  \",\n        date: \"\",\n        time: \"\",\n        duration: \"\",\n        ipv4: \" IPv4 \",\n        ipv6: \" IPv6 \",\n        cidrv4: \" IPv4 \",\n        cidrv6: \" IPv6 \",\n        base64: \"base64-encoded \",\n        base64url: \"base64url-encoded \",\n        json_string: \"JSON \",\n        e164: \" E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected} ,  ${parsedType(issue.input)}  `;\n            case \"invalid_value\":\n                if (issue.values.length === 1) {\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])} `;\n                }\n                return ` :    ${util.joinValues(issue.values, \"|\")}  `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"} `;\n                }\n                return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit} `;\n                }\n                return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :   \"${_issue.prefix}\"   `;\n                }\n                if (_issue.format === \"ends_with\") {\n                    return ` :   \"${_issue.suffix}\"    `;\n                }\n                if (_issue.format === \"includes\") {\n                    return ` :  \"${_issue.includes}\" `;\n                }\n                if (_issue.format === \"regex\") {\n                    return ` :   ${_issue.pattern}   `;\n                }\n                return `${Nouns[_issue.format] ?? issue.format}  `;\n            }\n            case \"not_multiple_of\":\n                return ` :   ${issue.divisor}  `;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin} `;\n            case \"invalid_union\":\n                return ` `;\n            case \"invalid_element\":\n                return `   ${issue.origin} `;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"znakw\", verb: \"mie\" },\n        file: { unit: \"bajtw\", verb: \"mie\" },\n        array: { unit: \"elementw\", verb: \"mie\" },\n        set: { unit: \"elementw\", verb: \"mie\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"liczba\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"tablica\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"wyraenie\",\n        email: \"adres email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data i godzina w formacie ISO\",\n        date: \"data w formacie ISO\",\n        time: \"godzina w formacie ISO\",\n        duration: \"czas trwania ISO\",\n        ipv4: \"adres IPv4\",\n        ipv6: \"adres IPv6\",\n        cidrv4: \"zakres IPv4\",\n        cidrv6: \"zakres IPv6\",\n        base64: \"cig znakw zakodowany w formacie base64\",\n        base64url: \"cig znakw zakodowany w formacie base64url\",\n        json_string: \"cig znakw w formacie JSON\",\n        e164: \"liczba E.164\",\n        jwt: \"JWT\",\n        template_literal: \"wejcie\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Nieprawidowe dane wejciowe: oczekiwano ${issue.expected}, otrzymano ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Nieprawidowe dane wejciowe: oczekiwano ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Za dua warto: oczekiwano, e ${issue.origin ?? \"warto\"} bdzie mie ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementw\"}`;\n                }\n                return `Zbyt du(y/a/e): oczekiwano, e ${issue.origin ?? \"warto\"} bdzie wynosi ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Za maa warto: oczekiwano, e ${issue.origin ?? \"warto\"} bdzie mie ${adj}${issue.minimum.toString()} ${sizing.unit ?? \"elementw\"}`;\n                }\n                return `Zbyt ma(y/a/e): oczekiwano, e ${issue.origin ?? \"warto\"} bdzie wynosi ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Nieprawidowy cig znakw: musi zaczyna si od \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Nieprawidowy cig znakw: musi koczy si na \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Nieprawidowy cig znakw: musi zawiera \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;\n                return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nieprawidowa liczba: musi by wielokrotnoci ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Nierozpoznane klucze${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Nieprawidowy klucz w ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Nieprawidowe dane wejciowe\";\n            case \"invalid_element\":\n                return `Nieprawidowa warto w ${issue.origin}`;\n            default:\n                return `Nieprawidowe dane wejciowe`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"caracteres\", verb: \"ter\" },\n        file: { unit: \"bytes\", verb: \"ter\" },\n        array: { unit: \"itens\", verb: \"ter\" },\n        set: { unit: \"itens\", verb: \"ter\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"nmero\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"nulo\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"padro\",\n        email: \"endereo de e-mail\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"data e hora ISO\",\n        date: \"data ISO\",\n        time: \"hora ISO\",\n        duration: \"durao ISO\",\n        ipv4: \"endereo IPv4\",\n        ipv6: \"endereo IPv6\",\n        cidrv4: \"faixa de IPv4\",\n        cidrv6: \"faixa de IPv6\",\n        base64: \"texto codificado em base64\",\n        base64url: \"URL codificada em base64\",\n        json_string: \"texto JSON\",\n        e164: \"nmero E.164\",\n        jwt: \"JWT\",\n        template_literal: \"entrada\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Tipo invlido: esperado ${issue.expected}, recebido ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Entrada invlida: esperado ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Opo invlida: esperada uma das ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Muito grande: esperado que ${issue.origin ?? \"valor\"} tivesse ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementos\"}`;\n                return `Muito grande: esperado que ${issue.origin ?? \"valor\"} fosse ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Muito pequeno: esperado que ${issue.origin} tivesse ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Muito pequeno: esperado que ${issue.origin} fosse ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Texto invlido: deve comear com \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Texto invlido: deve terminar com \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Texto invlido: deve incluir \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format} invlido`;\n            }\n            case \"not_multiple_of\":\n                return `Nmero invlido: deve ser mltiplo de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Chave${issue.keys.length > 1 ? \"s\" : \"\"} desconhecida${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Chave invlida em ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Entrada invlida\";\n            case \"invalid_element\":\n                return `Valor invlido em ${issue.origin}`;\n            default:\n                return `Campo invlido`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nfunction getRussianPlural(count, one, few, many) {\n    const absCount = Math.abs(count);\n    const lastDigit = absCount % 10;\n    const lastTwoDigits = absCount % 100;\n    if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {\n        return many;\n    }\n    if (lastDigit === 1) {\n        return one;\n    }\n    if (lastDigit >= 2 && lastDigit <= 4) {\n        return few;\n    }\n    return many;\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        file: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        array: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n        set: {\n            unit: {\n                one: \"\",\n                few: \"\",\n                many: \"\",\n            },\n            verb: \"\",\n        },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"email \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO   \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"   base64\",\n        base64url: \"   base64url\",\n        json_string: \"JSON \",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const maxValue = Number(issue.maximum);\n                    const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return `  : ,  ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${unit}`;\n                }\n                return `  : ,  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    const minValue = Number(issue.minimum);\n                    const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);\n                    return `  : ,  ${issue.origin}   ${adj}${issue.minimum.toString()} ${unit}`;\n                }\n                return `  : ,  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` :    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return ` :    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :    ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"znakov\", verb: \"imeti\" },\n        file: { unit: \"bajtov\", verb: \"imeti\" },\n        array: { unit: \"elementov\", verb: \"imeti\" },\n        set: { unit: \"elementov\", verb: \"imeti\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"tevilo\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"tabela\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"vnos\",\n        email: \"e-potni naslov\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datum in as\",\n        date: \"ISO datum\",\n        time: \"ISO as\",\n        duration: \"ISO trajanje\",\n        ipv4: \"IPv4 naslov\",\n        ipv6: \"IPv6 naslov\",\n        cidrv4: \"obseg IPv4\",\n        cidrv6: \"obseg IPv6\",\n        base64: \"base64 kodiran niz\",\n        base64url: \"base64url kodiran niz\",\n        json_string: \"JSON niz\",\n        e164: \"E.164 tevilka\",\n        jwt: \"JWT\",\n        template_literal: \"vnos\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Neveljaven vnos: priakovano ${issue.expected}, prejeto ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Neveljaven vnos: priakovano ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Neveljavna monost: priakovano eno izmed ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Preveliko: priakovano, da bo ${issue.origin ?? \"vrednost\"} imelo ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementov\"}`;\n                return `Preveliko: priakovano, da bo ${issue.origin ?? \"vrednost\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Premajhno: priakovano, da bo ${issue.origin} imelo ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Premajhno: priakovano, da bo ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Neveljaven niz: mora se zaeti z \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Neveljaven niz: mora se konati z \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Neveljaven niz: mora vsebovati \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;\n                return `Neveljaven ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Neveljavno tevilo: mora biti vekratnik ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Neprepoznan${issue.keys.length > 1 ? \"i kljui\" : \" klju\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Neveljaven klju v ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Neveljaven vnos\";\n            case \"invalid_element\":\n                return `Neveljavna vrednost v ${issue.origin}`;\n            default:\n                return \"Neveljaven vnos\";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"tecken\", verb: \"att ha\" },\n        file: { unit: \"bytes\", verb: \"att ha\" },\n        array: { unit: \"objekt\", verb: \"att innehlla\" },\n        set: { unit: \"objekt\", verb: \"att innehlla\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"antal\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"lista\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"reguljrt uttryck\",\n        email: \"e-postadress\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-datum och tid\",\n        date: \"ISO-datum\",\n        time: \"ISO-tid\",\n        duration: \"ISO-varaktighet\",\n        ipv4: \"IPv4-intervall\",\n        ipv6: \"IPv6-intervall\",\n        cidrv4: \"IPv4-spektrum\",\n        cidrv6: \"IPv6-spektrum\",\n        base64: \"base64-kodad strng\",\n        base64url: \"base64url-kodad strng\",\n        json_string: \"JSON-strng\",\n        e164: \"E.164-nummer\",\n        jwt: \"JWT\",\n        template_literal: \"mall-literal\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Ogiltig inmatning: frvntat ${issue.expected}, fick ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Ogiltig inmatning: frvntat ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ogiltigt val: frvntade en av ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Fr stor(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n                }\n                return `Fr stor(t): frvntat ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Fr lite(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Fr lite(t): frvntade ${issue.origin ?? \"vrdet\"} att ha ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Ogiltig strng: mste brja med \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Ogiltig strng: mste sluta med \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Ogiltig strng: mste innehlla \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Ogiltig strng: mste matcha mnstret \"${_issue.pattern}\"`;\n                return `Ogiltig(t) ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Ogiltigt tal: mste vara en multipel av ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"Oknda nycklar\" : \"Oknd nyckel\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Ogiltig nyckel i ${issue.origin ?? \"vrdet\"}`;\n            case \"invalid_union\":\n                return \"Ogiltig input\";\n            case \"invalid_element\":\n                return `Ogiltigt vrde i ${issue.origin ?? \"vrdet\"}`;\n            default:\n                return `Ogiltig input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \" \" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO  \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO  \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64-encoded \",\n        base64url: \"base64url-encoded \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :  ${util.joinValues(issue.values, \"|\")}  `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :  ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}   `;\n                }\n                return ` :  ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()}   `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :  ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}   `; //\n                }\n                return ` :  ${issue.origin} ${adj}${issue.minimum.toString()}   `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` : \"${_issue.prefix}\"   `;\n                if (_issue.format === \"ends_with\")\n                    return ` : \"${_issue.suffix}\"   `;\n                if (_issue.format === \"includes\")\n                    return ` : \"${_issue.includes}\"   `;\n                if (_issue.format === \"regex\")\n                    return ` : ${_issue.pattern}   `;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` : ${issue.divisor}    `;\n            case \"unrecognized_keys\":\n                return `  ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin}   `;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `${issue.origin}   `;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \" (NaN)\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \" (Array)\";\n                }\n                if (data === null) {\n                    return \" (null)\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \" ISO\",\n        date: \" ISO\",\n        time: \" ISO\",\n        duration: \" ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \" IP  IPv4\",\n        cidrv6: \" IP  IPv6\",\n        base64: \" Base64\",\n        base64url: \" Base64  URL\",\n        json_string: \" JSON\",\n        e164: \" (E.164)\",\n        jwt: \" JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `:  ${issue.expected}  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `:  ${util.stringifyPrimitive(issue.values[0])}`;\n                return `:  ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `: ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return `: ${issue.origin ?? \"\"} ${adj} ${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \"\" : \"\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `: ${issue.origin} ${adj} ${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `: ${issue.origin} ${adj} ${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `:  \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `:  \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `:  \"${_issue.includes}\" `;\n                if (_issue.format === \"regex\")\n                    return `:  ${_issue.pattern}`;\n                return `: ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `:  ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return ` ${issue.origin}`;\n            case \"invalid_union\":\n                return \": \";\n            case \"invalid_element\":\n                return ` ${issue.origin}`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \" \",\n        email: \"  \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"   ISO\",\n        date: \" ISO\",\n        time: \" ISO\",\n        duration: \" ISO\",\n        ipv4: \" IPv4\",\n        ipv6: \" IPv6\",\n        cidrv4: \" IPv4\",\n        cidrv6: \" IPv6\",\n        base64: \"   base64\",\n        base64url: \"   base64url\",\n        json_string: \" JSON\",\n        e164: \" E.164\",\n        jwt: \"JWT\",\n        template_literal: \" \",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `  :  ${issue.expected},  ${parsedType(issue.input)}`;\n            // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` : ,  ${issue.origin ?? \"\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` : ,  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ,  ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` : ,  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` :    \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return ` :    \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :    ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \" \",\n        email: \"  \",\n        url: \"  \",\n        emoji: \"\",\n        uuid: \"   \",\n        uuidv4: \"     4\",\n        uuidv6: \"     6\",\n        nanoid: \"  \",\n        guid: \"   \",\n        cuid: \"   \",\n        cuid2: \"    2\",\n        ulid: \"   \",\n        xid: \"  \",\n        ksuid: \"    \",\n        datetime: \"    \",\n        date: \"   \",\n        time: \"   \",\n        duration: \"   \",\n        ipv4: \"   4 \",\n        ipv6: \"   6 \",\n        cidrv4: \"   4 \",\n        cidrv6: \"   6 \",\n        base64: \" 64   \",\n        base64url: \" 64      \",\n        json_string: \"    \",\n        e164: \" 164 \",\n        jwt: \"  \",\n        template_literal: \" \",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `  : ${issue.expected}   ${parsedType(issue.input)}  `;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `  : ${util.stringifyPrimitive(issue.values[0])}  `;\n                return ` : ${util.joinValues(issue.values, \"|\")}     `;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}   `;\n                return ` : ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}   `;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` : ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit}   `;\n                }\n                return ` : ${issue.origin}  ${adj}${issue.minimum.toString()}   `;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` : \"${_issue.prefix}\"    `;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` : \"${_issue.suffix}\"    `;\n                if (_issue.format === \"includes\")\n                    return ` : \"${_issue.includes}\"   `;\n                if (_issue.format === \"regex\")\n                    return ` :  ${_issue.pattern}    `;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` : ${issue.divisor}    `;\n            case \"unrecognized_keys\":\n                return `   ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \" \")}`;\n            case \"invalid_key\":\n                return `${issue.origin}   `;\n            case \"invalid_union\":\n                return \"  \";\n            case \"invalid_element\":\n                return `${issue.origin}   `;\n            default:\n                return `  `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"k t\", verb: \"c\" },\n        file: { unit: \"byte\", verb: \"c\" },\n        array: { unit: \"phn t\", verb: \"c\" },\n        set: { unit: \"phn t\", verb: \"c\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"s\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"mng\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"u vo\",\n        email: \"a ch email\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ngy gi ISO\",\n        date: \"ngy ISO\",\n        time: \"gi ISO\",\n        duration: \"khong thi gian ISO\",\n        ipv4: \"a ch IPv4\",\n        ipv6: \"a ch IPv6\",\n        cidrv4: \"di IPv4\",\n        cidrv6: \"di IPv6\",\n        base64: \"chui m ha base64\",\n        base64url: \"chui m ha base64url\",\n        json_string: \"chui JSON\",\n        e164: \"s E.164\",\n        jwt: \"JWT\",\n        template_literal: \"u vo\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `u vo khng hp l: mong i ${issue.expected}, nhn c ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `u vo khng hp l: mong i ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Ty chn khng hp l: mong i mt trong cc gi tr ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Qu ln: mong i ${issue.origin ?? \"gi tr\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"phn t\"}`;\n                return `Qu ln: mong i ${issue.origin ?? \"gi tr\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Qu nh: mong i ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Qu nh: mong i ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Chui khng hp l: phi bt u bng \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Chui khng hp l: phi kt thc bng \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Chui khng hp l: phi bao gm \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format} khng hp l`;\n            }\n            case \"not_multiple_of\":\n                return `S khng hp l: phi l bi s ca ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Kha khng c nhn dng: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Kha khng hp l trong ${issue.origin}`;\n            case \"invalid_union\":\n                return \"u vo khng hp l\";\n            case \"invalid_element\":\n                return `Gi tr khng hp l trong ${issue.origin}`;\n            default:\n                return `u vo khng hp l`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"(NaN)\" : \"\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"\";\n                }\n                if (data === null) {\n                    return \"(null)\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO\",\n        date: \"ISO\",\n        time: \"ISO\",\n        duration: \"ISO\",\n        ipv4: \"IPv4\",\n        ipv6: \"IPv6\",\n        cidrv4: \"IPv4\",\n        cidrv6: \"IPv6\",\n        base64: \"base64\",\n        base64url: \"base64url\",\n        json_string: \"JSON\",\n        e164: \"E.164\",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` ${issue.expected} ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` ${issue.origin ?? \"\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return ` \"${_issue.prefix}\" `;\n                if (_issue.format === \"ends_with\")\n                    return ` \"${_issue.suffix}\" `;\n                if (_issue.format === \"includes\")\n                    return ` \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` ${_issue.pattern}`;\n                return `${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `(key): ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} (key)`;\n            case \"invalid_union\":\n                return \"\";\n            case \"invalid_element\":\n                return `${issue.origin} (value)`;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \"\" },\n        file: { unit: \"\", verb: \"\" },\n        array: { unit: \"\", verb: \"\" },\n        set: { unit: \"\", verb: \"\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"number\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"array\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"\",\n        email: \"\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64 \",\n        base64url: \"base64url \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` ${issue.expected} ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` ${issue.origin}  ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` \"${_issue.prefix}\" `;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` \"${_issue.suffix}\" `;\n                if (_issue.format === \"includes\")\n                    return ` \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` ${_issue.pattern}`;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` ${issue.divisor} `;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"}${util.joinValues(issue.keys, \"\")}`;\n            case \"invalid_key\":\n                return `${issue.origin} `;\n            case \"invalid_union\":\n                return \"\";\n            case \"invalid_element\":\n                return `${issue.origin} `;\n            default:\n                return ``;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"mi\", verb: \"n\" },\n        file: { unit: \"bytes\", verb: \"n\" },\n        array: { unit: \"nkan\", verb: \"n\" },\n        set: { unit: \"nkan\", verb: \"n\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const parsedType = (data) => {\n        const t = typeof data;\n        switch (t) {\n            case \"number\": {\n                return Number.isNaN(data) ? \"NaN\" : \"nmb\";\n            }\n            case \"object\": {\n                if (Array.isArray(data)) {\n                    return \"akop\";\n                }\n                if (data === null) {\n                    return \"null\";\n                }\n                if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                    return data.constructor.name;\n                }\n            }\n        }\n        return t;\n    };\n    const Nouns = {\n        regex: \"r bwl\",\n        email: \"drs ml\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"kk ISO\",\n        date: \"j ISO\",\n        time: \"kk ISO\",\n        duration: \"kk t p ISO\",\n        ipv4: \"drs IPv4\",\n        ipv6: \"drs IPv6\",\n        cidrv4: \"gbgb IPv4\",\n        cidrv6: \"gbgb IPv6\",\n        base64: \"r t a k n base64\",\n        base64url: \"r base64url\",\n        json_string: \"r JSON\",\n        e164: \"nmb E.164\",\n        jwt: \"JWT\",\n        template_literal: \"r bwl\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `bwl ae: a n lti fi ${issue.expected}, m a r ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `bwl ae: a n lti fi ${util.stringifyPrimitive(issue.values[0])}`;\n                return `yn ae: yan kan lra ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `T p j: a n lti j p ${issue.origin ?? \"iye\"} ${sizing.verb} ${adj}${issue.maximum} ${sizing.unit}`;\n                return `T p j: a n lti j ${adj}${issue.maximum}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Kr ju: a n lti j p ${issue.origin} ${sizing.verb} ${adj}${issue.minimum} ${sizing.unit}`;\n                return `Kr ju: a n lti j ${adj}${issue.minimum}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `r ae: gbd br pl \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `r ae: gbd par pl \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `r ae: gbd n \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `r ae: gbd b pr mu ${_issue.pattern}`;\n                return `Ae: ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nmb ae: gbd j y ppn ti ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Btn m: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Btn ae nn ${issue.origin}`;\n            case \"invalid_union\":\n                return \"bwl ae\";\n            case \"invalid_element\":\n                return `Iye ae nn ${issue.origin}`;\n            default:\n                return \"bwl ae\";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  All,\n  PendingWrite,\n  CheckpointMetadata,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  BaseCache,\n} from \"@langchain/langgraph-checkpoint\";\nimport { Graph as DrawableGraph } from \"@langchain/core/runnables/graph\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelNode } from \"./read.js\";\nimport type { Interrupt } from \"../constants.js\";\nimport { CachePolicy, RetryPolicy } from \"./utils/index.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Selects the type of output you'll receive when streaming from the graph. See [Streaming](/langgraphjs/how-tos/#streaming) for more details.\n */\nexport type StreamMode =\n  | \"values\"\n  | \"updates\"\n  | \"debug\"\n  | \"messages\"\n  | \"checkpoints\"\n  | \"tasks\"\n  | \"custom\";\n\nexport type Durability = \"exit\" | \"async\" | \"sync\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype StreamMessageOutput = [BaseMessage, Record<string, any>];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype StreamDebugOutput = Record<string, any>;\n\ntype StreamCheckpointsOutput<StreamValues> = {\n  values: StreamValues;\n  next: string[];\n  config: RunnableConfig;\n  metadata?: CheckpointMetadata;\n  parentConfig?: RunnableConfig | undefined;\n  tasks: PregelTaskDescription[];\n};\n\ninterface StreamTasksOutputBase {\n  id: string;\n  name: string;\n  interrupts: Interrupt[];\n}\n\ninterface StreamTasksCreateOutput<StreamValues> extends StreamTasksOutputBase {\n  input: StreamValues;\n  triggers: string[];\n}\n\ninterface StreamTasksResultOutput<Keys, StreamUpdates>\n  extends StreamTasksOutputBase {\n  result: [Keys, StreamUpdates][];\n}\n\ntype StreamTasksOutput<StreamUpdates, StreamValues, Nodes = string> =\n  | StreamTasksCreateOutput<StreamValues>\n  | StreamTasksResultOutput<Nodes, StreamUpdates>;\n\ntype DefaultStreamMode = \"updates\";\n\nexport type IsEventStream<T> = [T] extends [\"text/event-stream\"]\n  ? [\"text/event-stream\"] extends [T]\n    ? true\n    : false\n  : false;\n\nexport type StreamOutputMap<\n  TStreamMode extends StreamMode | StreamMode[] | undefined,\n  TStreamSubgraphs extends boolean,\n  StreamUpdates,\n  StreamValues,\n  Nodes,\n  NodeReturnType,\n  StreamCustom,\n  TEncoding extends \"text/event-stream\" | undefined\n> = IsEventStream<TEncoding> extends true\n  ? Uint8Array\n  : (\n      undefined extends TStreamMode\n        ? []\n        : StreamMode | StreamMode[] extends TStreamMode\n        ? TStreamMode extends StreamMode[]\n          ? TStreamMode[number]\n          : TStreamMode\n        : TStreamMode extends StreamMode[]\n        ? TStreamMode[number]\n        : []\n    ) extends infer Multiple extends StreamMode\n  ? [TStreamSubgraphs] extends [true]\n    ? {\n        values: [string[], \"values\", StreamValues];\n        updates: [\n          string[],\n          \"updates\",\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [string[], \"messages\", StreamMessageOutput];\n        custom: [string[], \"custom\", StreamCustom];\n        checkpoints: [\n          string[],\n          \"checkpoints\",\n          StreamCheckpointsOutput<StreamValues>\n        ];\n        tasks: [\n          string[],\n          \"tasks\",\n          StreamTasksOutput<StreamUpdates, StreamValues>\n        ];\n        debug: [string[], \"debug\", StreamDebugOutput];\n      }[Multiple]\n    : {\n        values: [\"values\", StreamValues];\n        updates: [\n          \"updates\",\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [\"messages\", StreamMessageOutput];\n        custom: [\"custom\", StreamCustom];\n        checkpoints: [\"checkpoints\", StreamCheckpointsOutput<StreamValues>];\n        tasks: [\"tasks\", StreamTasksOutput<StreamUpdates, StreamValues, Nodes>];\n        debug: [\"debug\", StreamDebugOutput];\n      }[Multiple]\n  : (\n      undefined extends TStreamMode ? DefaultStreamMode : TStreamMode\n    ) extends infer Single extends StreamMode\n  ? [TStreamSubgraphs] extends [true]\n    ? {\n        values: [string[], StreamValues];\n        updates: [\n          string[],\n          NodeReturnType extends Record<string, unknown>\n            ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n            : Record<Nodes extends string ? Nodes : string, StreamUpdates>\n        ];\n        messages: [string[], StreamMessageOutput];\n        custom: [string[], StreamCustom];\n        checkpoints: [string[], StreamCheckpointsOutput<StreamValues>];\n        tasks: [\n          string[],\n          StreamTasksOutput<StreamUpdates, StreamValues, Nodes>\n        ];\n        debug: [string[], StreamDebugOutput];\n      }[Single]\n    : {\n        values: StreamValues;\n        updates: NodeReturnType extends Record<string, unknown>\n          ? { [K in keyof NodeReturnType]?: NodeReturnType[K] }\n          : Record<Nodes extends string ? Nodes : string, StreamUpdates>;\n        messages: StreamMessageOutput;\n        custom: StreamCustom;\n        checkpoints: StreamCheckpointsOutput<StreamValues>;\n        tasks: StreamTasksOutput<StreamUpdates, StreamValues, Nodes>;\n        debug: StreamDebugOutput;\n      }[Single]\n  : never;\n\n/**\n * Configuration options for executing a Pregel graph.\n * These options control how the graph executes, what data is streamed, and how interrupts are handled.\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n */\nexport interface PregelOptions<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = Record<string, any>,\n  TStreamMode extends StreamMode | StreamMode[] | undefined =\n    | StreamMode\n    | StreamMode[]\n    | undefined,\n  TSubgraphs extends boolean = boolean,\n  TEncoding extends \"text/event-stream\" | undefined =\n    | \"text/event-stream\"\n    | undefined\n> extends RunnableConfig<ContextType> {\n  /**\n   * Controls what information is streamed during graph execution.\n   * Multiple modes can be enabled simultaneously.\n   *\n   * Supported modes:\n   * - \"values\": Streams complete state after each step\n   * - \"updates\": Streams only state changes after each step\n   * - \"messages\": Streams messages from within nodes\n   * - \"custom\": Streams custom events from within nodes\n   * - \"debug\": Streams detailed execution events for tracing & debugging\n   *\n   * @example\n   * ```typescript\n   * // Stream only values\n   * streamMode: \"values\"\n   *\n   * // Stream both values and debug info\n   * streamMode: [\"values\", \"debug\"]\n   * ```\n   *\n   * @default [\"values\"]\n   */\n  streamMode?: TStreamMode;\n\n  /**\n   * Specifies which channel keys to retrieve from the checkpoint when resuming execution.\n   * This is an advanced option that you generally don't need to set manually.\n   * The graph will automatically determine the appropriate input keys based on its configuration.\n   */\n  inputKeys?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * Specifies which channel keys to include in the output stream and final result.\n   * Use this to filter which parts of the graph state you want to observe.\n   *\n   * @example\n   * ```typescript\n   * // Stream only the 'result' channel\n   * outputKeys: \"result\"\n   *\n   * // Stream multiple channels\n   * outputKeys: [\"result\", \"intermediateState\"]\n   * ```\n   */\n  outputKeys?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * List of nodes where execution should be interrupted BEFORE the node runs.\n   * Can be used for debugging and advanced state manipulation use cases. For\n   * human-in-the-loop workflows, developers should prefer the\n   * @link {interrupt} function instead.\n   *\n   * When interrupted, a resume @link {Command} must be provided to continue\n   * execution.\n   *\n   * @example\n   * ```typescript\n   * // Interrupt before specific nodes\n   * interruptBefore: [\"humanReview\", \"qualityCheck\"]\n   *\n   * // Interrupt before all nodes\n   * interruptBefore: \"all\"\n   * ```\n   */\n  interruptBefore?: All | Array<keyof Nodes>;\n\n  /**\n   * List of nodes where execution should be interrupted AFTER the node runs.\n   * Similar to interruptBefore, but interrupts after node completion.\n   * Useful when the node's output needs to be reviewed before proceeding.\n   *\n   * @example\n   * ```typescript\n   * // Interrupt after specific nodes\n   * interruptAfter: [\"generateContent\", \"analyze\"]\n   *\n   * // Interrupt after all nodes\n   * interruptAfter: \"all\"\n   * ```\n   */\n  interruptAfter?: All | Array<keyof Nodes>;\n\n  /**\n   * Enables detailed debug logging during graph execution.\n   * When enabled, prints information about:\n   * - Task execution\n   * - Channel updates\n   * - Checkpoint writes\n   *\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Whether to include subgraph execution details in the stream.\n   * When true, state updates from nested graphs will also be streamed.\n   *\n   * @default false\n   */\n  subgraphs?: TSubgraphs;\n\n  /**\n   * Whether to checkpoint intermediate steps, defaults to `true`.\n   * If `false`, only the final checkpoint is saved.\n   * @deprecated Use `durability` instead.\n   */\n  checkpointDuring?: boolean;\n\n  /**\n   * Whether to checkpoint during the run (or only at the end/interruption).\n   * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n   * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n   * - `\"exit\"`: Save checkpoint only when the graph exits.\n   * @default \"async\"\n   */\n  durability?: Durability;\n\n  /**\n   * A shared value store that allows you to store and retrieve state across\n   * threads. Useful for implementing long-term memory patterns.\n   */\n  store?: BaseStore;\n\n  /**\n   * Optional cache for the graph, useful for caching tasks.\n   */\n  cache?: BaseCache;\n\n  /**\n   * Static context for the graph run, like `userId`, `dbConnection` etc.\n   */\n  context?: ContextType;\n\n  /**\n   * The encoding to use for the stream.\n   * - `undefined`: Use the default format.\n   * - `\"text/event-stream\"`: Use the Server-Sent Events format.\n   * @default undefined\n   */\n  encoding?: TEncoding;\n}\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport interface PregelInterface<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = StrRecord<string, any>\n> {\n  lg_is_pregel: boolean;\n\n  withConfig(config: RunnableConfig): PregelInterface<Nodes, Channels>;\n\n  getGraphAsync(\n    config: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph>;\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, PregelInterface<any, any>]>;\n\n  getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, PregelInterface<any, any>]>;\n\n  getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot>;\n\n  getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot>;\n\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nodes | string\n  ): Promise<RunnableConfig>;\n\n  stream(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nodes, Channels, ContextType>>\n  ): Promise<IterableReadableStream<PregelOutputType>>;\n\n  invoke(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nodes, Channels, ContextType>>\n  ): Promise<PregelOutputType>;\n}\n\n/**\n * Parameters for creating a Pregel graph.\n * @internal\n */\nexport type PregelParams<\n  Nodes extends StrRecord<string, PregelNode>,\n  Channels extends StrRecord<string, BaseChannel>\n> = {\n  /**\n   * The name of the graph. @see {@link Runnable.name}\n   */\n  name?: string;\n\n  /**\n   * The nodes in the graph.\n   */\n  nodes: Nodes;\n\n  /**\n   * The channels in the graph.\n   */\n  channels: Channels;\n\n  /**\n   * Whether to validate the graph.\n   *\n   * @default true\n   */\n  autoValidate?: boolean;\n\n  /**\n   * The stream mode for the graph run. See [Streaming](/langgraphjs/how-tos/#streaming) for more details.\n   *\n   * @default [\"values\"]\n   */\n  streamMode?: StreamMode | StreamMode[];\n\n  /**\n   * The input channels for the graph run.\n   */\n  inputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * The output channels for the graph run.\n   */\n  outputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * After processing one of the nodes named in this list, the graph will be interrupted and a resume {@link Command} must be provided to proceed with the execution of this thread.\n   * @default []\n   */\n  interruptAfter?: Array<keyof Nodes> | All;\n\n  /**\n   * Before processing one of the nodes named in this list, the graph will be interrupted and a resume {@link Command} must be provided to proceed with the execution of this thread.\n   * @default []\n   */\n  interruptBefore?: Array<keyof Nodes> | All;\n\n  /**\n   * The channels to stream from the graph run.\n   * @default []\n   */\n  streamChannels?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * @default undefined\n   */\n  stepTimeout?: number;\n\n  /**\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * The {@link BaseCheckpointSaver | checkpointer} to use for the graph run.\n   */\n  checkpointer?: BaseCheckpointSaver | boolean;\n\n  /**\n   * The default retry policy for this graph. For defaults, see {@link RetryPolicy}.\n   */\n  retryPolicy?: RetryPolicy;\n\n  /**\n   * The configuration for the graph run.\n   */\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * External key-value store.\n   */\n  store?: BaseStore;\n\n  /**\n   * Storage used for node caching.\n   */\n  cache?: BaseCache;\n\n  /**\n   * The trigger to node mapping for the graph run.\n   * @internal\n   */\n  triggerToNodes?: Record<string, string[]>;\n\n  /**\n   * Interrupt helper function.\n   * @internal\n   */\n  userInterrupt?: unknown;\n};\n\nexport interface PregelTaskDescription {\n  readonly id: string;\n  readonly name: string;\n  readonly error?: unknown;\n  readonly interrupts: Interrupt[];\n  readonly state?: LangGraphRunnableConfig | StateSnapshot;\n  readonly path?: TaskPath;\n  readonly result?: unknown;\n}\n\ninterface CacheKey {\n  ns: string[];\n  key: string;\n  ttl?: number;\n}\n\nexport interface PregelExecutableTask<\n  NodeKey extends PropertyKey,\n  ChannelKey extends PropertyKey\n> {\n  readonly name: NodeKey;\n  readonly input: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly proc: Runnable<any, any, LangGraphRunnableConfig>;\n  readonly writes: PendingWrite<ChannelKey>[];\n  readonly config?: LangGraphRunnableConfig;\n  readonly triggers: Array<string>;\n  readonly retry_policy?: RetryPolicy;\n  readonly cache_key?: CacheKey;\n  readonly id: string;\n  readonly path?: TaskPath;\n  readonly subgraphs?: Runnable[];\n  readonly writers: Runnable[];\n}\n\nexport interface StateSnapshot {\n  /**\n   * Current values of channels\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly values: Record<string, any> | any;\n  /**\n   * Nodes to execute in the next step, if any\n   */\n  readonly next: Array<string>;\n  /**\n   * Config used to fetch this snapshot\n   */\n  readonly config: RunnableConfig;\n  /**\n   * Metadata about the checkpoint\n   */\n  readonly metadata?: CheckpointMetadata;\n  /**\n   * Time when the snapshot was created\n   */\n  readonly createdAt?: string;\n  /**\n   * Config used to fetch the parent snapshot, if any\n   * @default undefined\n   */\n  readonly parentConfig?: RunnableConfig | undefined;\n  /**\n   * Tasks to execute in this step. If already attempted, may contain an error.\n   */\n  readonly tasks: PregelTaskDescription[];\n}\n\n/**\n * Options for subscribing to multiple channels.\n */\nexport type MultipleChannelSubscriptionOptions = {\n  /**\n   * Optional tags to associate with the subscription.\n   */\n  tags?: string[];\n};\n\n/**\n * Options for subscribing to a single channel.\n */\nexport type SingleChannelSubscriptionOptions = {\n  /**\n   * When specified, the channel mapping will be an object with this key pointing\n   * to the array of channels to subscribe to. Otherwise, the channel mapping\n   * will be an array of channels.\n   */\n  key?: string;\n  /**\n   * Optional tags to associate with the subscription.\n   */\n  tags?: string[];\n};\n\n/**\n * Options for getting the state of the graph.\n */\nexport type GetStateOptions = {\n  /**\n   * Whether to include subgraph states.\n   * @default false\n   */\n  subgraphs?: boolean;\n};\n\n/**\n * Used for storing/retrieving internal execution state.\n *\n * @internal\n */\nexport type PregelScratchpad<Resume = unknown> = {\n  /** Counter for tracking call invocations */\n  callCounter: number;\n  /** Counter for tracking interrupts */\n  interruptCounter: number;\n  /** List of resume values */\n  resume: Resume[];\n  /** Single resume value for null task ID */\n  nullResume: Resume;\n\n  consumeNullResume: () => Resume | undefined;\n  /** Counter for tracking subgraph invocations */\n  subgraphCounter: number;\n\n  /** The input to the currently executing task */\n  currentTaskInput: unknown;\n};\n\n/**\n * @internal\n */\nexport type PregelAbortSignals = {\n  /** Aborts when the user calls `stream.cancel()` or aborts the {@link AbortSignal} that they passed in via the `signal` option */\n  externalAbortSignal?: AbortSignal;\n\n  /**\n   * Aborts when the currently executing task throws any error other than a {@link GraphBubbleUp}\n   */\n  timeoutAbortSignal?: AbortSignal;\n\n  /**\n   * A reference to the AbortSignal that is passed to the node. Aborts on step timeout, stream cancel, or when an error is thrown.\n   */\n  composedAbortSignal?: AbortSignal;\n};\n\nexport type CallOptions = {\n  func: (...args: unknown[]) => unknown | Promise<unknown>;\n  name: string;\n  input: unknown;\n  cache?: CachePolicy;\n  retry?: RetryPolicy;\n  callbacks?: unknown;\n};\n\nexport class Call {\n  func: (...args: unknown[]) => unknown | Promise<unknown>;\n\n  name: string;\n\n  input: unknown;\n\n  retry?: RetryPolicy;\n\n  cache?: CachePolicy;\n\n  callbacks?: unknown;\n\n  readonly __lg_type = \"call\";\n\n  constructor({ func, name, input, retry, cache, callbacks }: CallOptions) {\n    this.func = func;\n    this.name = name;\n    this.input = input;\n    this.retry = retry;\n    this.cache = cache;\n    this.callbacks = callbacks;\n  }\n}\n\nexport function isCall(value: unknown): value is Call {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"__lg_type\" in value &&\n    value.__lg_type === \"call\"\n  );\n}\n\nexport type SimpleTaskPath = [string, string | number];\nexport type VariadicTaskPath = [string, ...(string | number)[], boolean];\nexport type CallTaskPath =\n  | [string, ...(string | number)[], Call]\n  | [string, TaskPath, ...(string | number)[], Call];\nexport type TaskPath = SimpleTaskPath | CallTaskPath | VariadicTaskPath;\n","import { getLangSmithEnvironmentVariable } from \"./utils/env.js\";\nexport const isTracingEnabled = (tracingEnabled) => {\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\"TRACING_V2\", \"TRACING\"];\n    return !!envVars.find((envVar) => getLangSmithEnvironmentVariable(envVar) === \"true\");\n};\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"\";\n        }\n        case \"object\": {\n            if (Array.isArray(data)) {\n                return \"\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n        }\n    }\n    const typeMap = {\n        string: \"\",\n        boolean: \"\",\n        undefined: \"undefined\",\n        bigint: \"bigint\",\n        symbol: \"symbol\",\n        function: \"\",\n    };\n    return typeMap[t] ?? t;\n};\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const Nouns = {\n        regex: \"\",\n        email: \"- \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"-\",\n        date: \"\",\n        time: \"\",\n        duration: \"\",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64- \",\n        base64url: \"base64url- \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :  - ${util.joinValues(issue.values, \"|\")}-`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` :  ${issue.origin ?? \"\"} ${sizing.verb} ${adj}${issue.maximum.toString()} ${sizing.unit}`;\n                return ` :  ${issue.origin ?? \"\"}  ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :  ${issue.origin} ${sizing.verb} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` :  ${issue.origin}  ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :   \"${_issue.prefix}\"-`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` :   \"${_issue.suffix}\"-`;\n                if (_issue.format === \"includes\")\n                    return ` :   \"${_issue.includes}\"-`;\n                if (_issue.format === \"regex\")\n                    return ` :    ${_issue.pattern}`;\n                return ` ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :   ${issue.divisor}- `;\n            case \"unrecognized_keys\":\n                return ` ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `  ${issue.origin}-`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `  ${issue.origin}-`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n        case \"object\": {\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n        }\n    }\n    return t;\n};\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karakter\", verb: \"olmal\" },\n        file: { unit: \"bayt\", verb: \"olmal\" },\n        array: { unit: \"e\", verb: \"olmal\" },\n        set: { unit: \"e\", verb: \"olmal\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const Nouns = {\n        regex: \"girdi\",\n        email: \"e-posta adresi\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO tarih ve saat\",\n        date: \"ISO tarih\",\n        time: \"ISO saat\",\n        duration: \"ISO sre\",\n        ipv4: \"IPv4 adresi\",\n        ipv6: \"IPv6 adresi\",\n        cidrv4: \"IPv4 aral\",\n        cidrv6: \"IPv6 aral\",\n        base64: \"base64 ile ifrelenmi metin\",\n        base64url: \"base64url ile ifrelenmi metin\",\n        json_string: \"JSON dizesi\",\n        e164: \"E.164 says\",\n        jwt: \"JWT\",\n        template_literal: \"ablon dizesi\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Geersiz deer: beklenen ${issue.expected}, alnan ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Geersiz deer: beklenen ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Geersiz seenek: aadakilerden biri olmal: ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ok byk: beklenen ${issue.origin ?? \"deer\"} ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"e\"}`;\n                return `ok byk: beklenen ${issue.origin ?? \"deer\"} ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `ok kk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                return `ok kk: beklenen ${issue.origin} ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Geersiz metin: \"${_issue.prefix}\" ile balamal`;\n                if (_issue.format === \"ends_with\")\n                    return `Geersiz metin: \"${_issue.suffix}\" ile bitmeli`;\n                if (_issue.format === \"includes\")\n                    return `Geersiz metin: \"${_issue.includes}\" iermeli`;\n                if (_issue.format === \"regex\")\n                    return `Geersiz metin: ${_issue.pattern} desenine uymal`;\n                return `Geersiz ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Geersiz say: ${issue.divisor} ile tam blnebilmeli`;\n            case \"unrecognized_keys\":\n                return `Tannmayan anahtar${issue.keys.length > 1 ? \"lar\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `${issue.origin} iinde geersiz anahtar`;\n            case \"invalid_union\":\n                return \"Geersiz deer\";\n            case \"invalid_element\":\n                return `${issue.origin} iinde geersiz deer`;\n            default:\n                return `Geersiz deer`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"nmer\";\n        }\n        case \"object\": {\n            if (Array.isArray(data)) {\n                return \"fylki\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n        }\n    }\n    return t;\n};\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"stafi\", verb: \"a hafa\" },\n        file: { unit: \"bti\", verb: \"a hafa\" },\n        array: { unit: \"hluti\", verb: \"a hafa\" },\n        set: { unit: \"hluti\", verb: \"a hafa\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const Nouns = {\n        regex: \"gildi\",\n        email: \"netfang\",\n        url: \"vefsl\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO dagsetning og tmi\",\n        date: \"ISO dagsetning\",\n        time: \"ISO tmi\",\n        duration: \"ISO tmalengd\",\n        ipv4: \"IPv4 address\",\n        ipv6: \"IPv6 address\",\n        cidrv4: \"IPv4 range\",\n        cidrv6: \"IPv6 range\",\n        base64: \"base64-encoded strengur\",\n        base64url: \"base64url-encoded strengur\",\n        json_string: \"JSON strengur\",\n        e164: \"E.164 tlugildi\",\n        jwt: \"JWT\",\n        template_literal: \"gildi\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Rangt gildi:  slst inn ${parsedType(issue.input)} ar sem  a vera ${issue.expected}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Rangt gildi: gert r fyrir ${util.stringifyPrimitive(issue.values[0])}`;\n                return `gilt val: m vera eitt af eftirfarandi ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Of strt: gert er r fyrir a ${issue.origin ?? \"gildi\"} hafi ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"hluti\"}`;\n                return `Of strt: gert er r fyrir a ${issue.origin ?? \"gildi\"} s ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Of lti: gert er r fyrir a ${issue.origin} hafi ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Of lti: gert er r fyrir a ${issue.origin} s ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `gildur strengur: verur a byrja  \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `gildur strengur: verur a enda  \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `gildur strengur: verur a innihalda \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;\n                return `Rangt ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Rng tala: verur a vera margfeldi af ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `ekkt ${issue.keys.length > 1 ? \"ir lyklar\" : \"ur lykill\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Rangur lykill  ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Rangt gildi\";\n            case \"invalid_element\":\n                return `Rangt gildi  ${issue.origin}`;\n            default:\n                return `Rangt gildi`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    return parsedTypeFromType(t, data);\n};\nconst parsedTypeFromType = (t, data = undefined) => {\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"skaiius\";\n        }\n        case \"bigint\": {\n            return \"sveikasis skaiius\";\n        }\n        case \"string\": {\n            return \"eilut\";\n        }\n        case \"boolean\": {\n            return \"login reikm\";\n        }\n        case \"undefined\":\n        case \"void\": {\n            return \"neapibrta reikm\";\n        }\n        case \"function\": {\n            return \"funkcija\";\n        }\n        case \"symbol\": {\n            return \"simbolis\";\n        }\n        case \"object\": {\n            if (data === undefined)\n                return \"neinomas objektas\";\n            if (data === null)\n                return \"nulin reikm\";\n            if (Array.isArray(data))\n                return \"masyvas\";\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n            return \"objektas\";\n        }\n        //Zod types below\n        case \"null\": {\n            return \"nulin reikm\";\n        }\n    }\n    return t;\n};\nconst capitalizeFirstCharacter = (text) => {\n    return text.charAt(0).toUpperCase() + text.slice(1);\n};\nfunction getUnitTypeFromNumber(number) {\n    const abs = Math.abs(number);\n    const last = abs % 10;\n    const last2 = abs % 100;\n    if ((last2 >= 11 && last2 <= 19) || last === 0)\n        return \"many\";\n    if (last === 1)\n        return \"one\";\n    return \"few\";\n}\nconst error = () => {\n    const Sizable = {\n        string: {\n            unit: {\n                one: \"simbolis\",\n                few: \"simboliai\",\n                many: \"simboli\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi bti ne ilgesn kaip\",\n                    notInclusive: \"turi bti trumpesn kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi bti ne trumpesn kaip\",\n                    notInclusive: \"turi bti ilgesn kaip\",\n                },\n            },\n        },\n        file: {\n            unit: {\n                one: \"baitas\",\n                few: \"baitai\",\n                many: \"bait\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi bti ne didesnis kaip\",\n                    notInclusive: \"turi bti maesnis kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi bti ne maesnis kaip\",\n                    notInclusive: \"turi bti didesnis kaip\",\n                },\n            },\n        },\n        array: {\n            unit: {\n                one: \"element\",\n                few: \"elementus\",\n                many: \"element\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi turti ne daugiau kaip\",\n                    notInclusive: \"turi turti maiau kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi turti ne maiau kaip\",\n                    notInclusive: \"turi turti daugiau kaip\",\n                },\n            },\n        },\n        set: {\n            unit: {\n                one: \"element\",\n                few: \"elementus\",\n                many: \"element\",\n            },\n            verb: {\n                smaller: {\n                    inclusive: \"turi turti ne daugiau kaip\",\n                    notInclusive: \"turi turti maiau kaip\",\n                },\n                bigger: {\n                    inclusive: \"turi turti ne maiau kaip\",\n                    notInclusive: \"turi turti daugiau kaip\",\n                },\n            },\n        },\n    };\n    function getSizing(origin, unitType, inclusive, targetShouldBe) {\n        const result = Sizable[origin] ?? null;\n        if (result === null)\n            return result;\n        return {\n            unit: result.unit[unitType],\n            verb: result.verb[targetShouldBe][inclusive ? \"inclusive\" : \"notInclusive\"],\n        };\n    }\n    const Nouns = {\n        regex: \"vestis\",\n        email: \"el. pato adresas\",\n        url: \"URL\",\n        emoji: \"jaustukas\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO data ir laikas\",\n        date: \"ISO data\",\n        time: \"ISO laikas\",\n        duration: \"ISO trukm\",\n        ipv4: \"IPv4 adresas\",\n        ipv6: \"IPv6 adresas\",\n        cidrv4: \"IPv4 tinklo prefiksas (CIDR)\",\n        cidrv6: \"IPv6 tinklo prefiksas (CIDR)\",\n        base64: \"base64 ukoduota eilut\",\n        base64url: \"base64url ukoduota eilut\",\n        json_string: \"JSON eilut\",\n        e164: \"E.164 numeris\",\n        jwt: \"JWT\",\n        template_literal: \"vestis\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Gautas tipas ${parsedType(issue.input)}, o tiktasi - ${parsedTypeFromType(issue.expected)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Privalo bti ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Privalo bti vienas i ${util.joinValues(issue.values, \"|\")} pasirinkim`;\n            case \"too_big\": {\n                const origin = parsedTypeFromType(issue.origin);\n                const sizing = getSizing(issue.origin, getUnitTypeFromNumber(Number(issue.maximum)), issue.inclusive ?? false, \"smaller\");\n                if (sizing?.verb)\n                    return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} ${sizing.verb} ${issue.maximum.toString()} ${sizing.unit ?? \"element\"}`;\n                const adj = issue.inclusive ? \"ne didesnis kaip\" : \"maesnis kaip\";\n                return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} turi bti ${adj} ${issue.maximum.toString()} ${sizing?.unit}`;\n            }\n            case \"too_small\": {\n                const origin = parsedTypeFromType(issue.origin);\n                const sizing = getSizing(issue.origin, getUnitTypeFromNumber(Number(issue.minimum)), issue.inclusive ?? false, \"bigger\");\n                if (sizing?.verb)\n                    return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} ${sizing.verb} ${issue.minimum.toString()} ${sizing.unit ?? \"element\"}`;\n                const adj = issue.inclusive ? \"ne maesnis kaip\" : \"didesnis kaip\";\n                return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} turi bti ${adj} ${issue.minimum.toString()} ${sizing?.unit}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Eilut privalo prasidti \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Eilut privalo pasibaigti \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Eilut privalo traukti \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Eilut privalo atitikti ${_issue.pattern}`;\n                return `Neteisingas ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Skaiius privalo bti ${issue.divisor} kartotinis.`;\n            case \"unrecognized_keys\":\n                return `Neatpaint${issue.keys.length > 1 ? \"i\" : \"as\"} rakt${issue.keys.length > 1 ? \"ai\" : \"as\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return \"Rastas klaidingas raktas\";\n            case \"invalid_union\":\n                return \"Klaidinga vestis\";\n            case \"invalid_element\": {\n                const origin = parsedTypeFromType(issue.origin);\n                return `${capitalizeFirstCharacter(origin ?? issue.origin ?? \"reikm\")} turi klaiding vest`;\n            }\n            default:\n                return \"Klaidinga vestis\";\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import { util } from \"./helpers/util.js\";\nexport const ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nexport const quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nexport class ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = Object.create(null);\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                const firstEl = sub.path[0];\n                fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n                fieldErrors[firstEl].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n","// OpenTelemetry GenAI semantic convention attribute names\nexport const GEN_AI_OPERATION_NAME = \"gen_ai.operation.name\";\nexport const GEN_AI_SYSTEM = \"gen_ai.system\";\nexport const GEN_AI_REQUEST_MODEL = \"gen_ai.request.model\";\nexport const GEN_AI_RESPONSE_MODEL = \"gen_ai.response.model\";\nexport const GEN_AI_USAGE_INPUT_TOKENS = \"gen_ai.usage.input_tokens\";\nexport const GEN_AI_USAGE_OUTPUT_TOKENS = \"gen_ai.usage.output_tokens\";\nexport const GEN_AI_USAGE_TOTAL_TOKENS = \"gen_ai.usage.total_tokens\";\nexport const GEN_AI_REQUEST_MAX_TOKENS = \"gen_ai.request.max_tokens\";\nexport const GEN_AI_REQUEST_TEMPERATURE = \"gen_ai.request.temperature\";\nexport const GEN_AI_REQUEST_TOP_P = \"gen_ai.request.top_p\";\nexport const GEN_AI_REQUEST_FREQUENCY_PENALTY = \"gen_ai.request.frequency_penalty\";\nexport const GEN_AI_REQUEST_PRESENCE_PENALTY = \"gen_ai.request.presence_penalty\";\nexport const GEN_AI_RESPONSE_FINISH_REASONS = \"gen_ai.response.finish_reasons\";\nexport const GENAI_PROMPT = \"gen_ai.prompt\";\nexport const GENAI_COMPLETION = \"gen_ai.completion\";\nexport const GEN_AI_REQUEST_EXTRA_QUERY = \"gen_ai.request.extra_query\";\nexport const GEN_AI_REQUEST_EXTRA_BODY = \"gen_ai.request.extra_body\";\nexport const GEN_AI_SERIALIZED_NAME = \"gen_ai.serialized.name\";\nexport const GEN_AI_SERIALIZED_SIGNATURE = \"gen_ai.serialized.signature\";\nexport const GEN_AI_SERIALIZED_DOC = \"gen_ai.serialized.doc\";\nexport const GEN_AI_RESPONSE_ID = \"gen_ai.response.id\";\nexport const GEN_AI_RESPONSE_SERVICE_TIER = \"gen_ai.response.service_tier\";\nexport const GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = \"gen_ai.response.system_fingerprint\";\nexport const GEN_AI_USAGE_INPUT_TOKEN_DETAILS = \"gen_ai.usage.input_token_details\";\nexport const GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = \"gen_ai.usage.output_token_details\";\n// LangSmith custom attributes\nexport const LANGSMITH_SESSION_ID = \"langsmith.trace.session_id\";\nexport const LANGSMITH_SESSION_NAME = \"langsmith.trace.session_name\";\nexport const LANGSMITH_RUN_TYPE = \"langsmith.span.kind\";\nexport const LANGSMITH_NAME = \"langsmith.trace.name\";\nexport const LANGSMITH_METADATA = \"langsmith.metadata\";\nexport const LANGSMITH_TAGS = \"langsmith.span.tags\";\nexport const LANGSMITH_RUNTIME = \"langsmith.span.runtime\";\nexport const LANGSMITH_REQUEST_STREAMING = \"langsmith.request.streaming\";\nexport const LANGSMITH_REQUEST_HEADERS = \"langsmith.request.headers\";\nexport const LANGSMITH_RUN_ID = \"langsmith.span.id\";\nexport const LANGSMITH_TRACE_ID = \"langsmith.trace.id\";\nexport const LANGSMITH_DOTTED_ORDER = \"langsmith.span.dotted_order\";\nexport const LANGSMITH_PARENT_RUN_ID = \"langsmith.span.parent_id\";\nexport const LANGSMITH_USAGE_METADATA = \"langsmith.usage_metadata\";\nexport const LANGSMITH_REFERENCE_EXAMPLE_ID = \"langsmith.reference_example_id\";\nexport const LANGSMITH_TRACEABLE = \"langsmith.traceable\";\nexport const LANGSMITH_IS_ROOT = \"langsmith.is_root\";\nexport const LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = \"langsmith.traceable_parent_otel_span_id\";\n// GenAI event names\nexport const GEN_AI_SYSTEM_MESSAGE = \"gen_ai.system.message\";\nexport const GEN_AI_USER_MESSAGE = \"gen_ai.user.message\";\nexport const GEN_AI_ASSISTANT_MESSAGE = \"gen_ai.assistant.message\";\nexport const GEN_AI_CHOICE = \"gen_ai.choice\";\nexport const AI_SDK_LLM_OPERATIONS = [\n    \"ai.generateText.doGenerate\",\n    \"ai.streamText.doStream\",\n    \"ai.generateObject.doGenerate\",\n    \"ai.streamObject.doStream\",\n];\nexport const AI_SDK_TOOL_OPERATIONS = [\"ai.toolCall\"];\n","import { getEnvironmentVariable, getLangSmithEnvironmentVariable, } from \"./env.js\";\nexport const getDefaultProjectName = () => {\n    return (getLangSmithEnvironmentVariable(\"PROJECT\") ??\n        getEnvironmentVariable(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n        \"default\");\n};\n","import { encodePointer } from './pointer.js';\nexport const schemaKeyword = {\n    additionalItems: true,\n    unevaluatedItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    unevaluatedProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true\n};\nexport const schemaArrayKeyword = {\n    prefixItems: true,\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n};\nexport const schemaMapKeyword = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependentSchemas: true\n};\nexport const ignoredKeyword = {\n    id: true,\n    $id: true,\n    $ref: true,\n    $schema: true,\n    $anchor: true,\n    $vocabulary: true,\n    $comment: true,\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    type: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true\n};\nexport let initialBaseURI = typeof self !== 'undefined' &&\n    self.location &&\n    self.location.origin !== 'null'\n    ?\n        new URL(self.location.origin + self.location.pathname + location.search)\n    : new URL('https://github.com/cfworker');\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = '') {\n    if (schema && typeof schema === 'object' && !Array.isArray(schema)) {\n        const id = schema.$id || schema.id;\n        if (id) {\n            const url = new URL(id, baseURI.href);\n            if (url.hash.length > 1) {\n                lookup[url.href] = schema;\n            }\n            else {\n                url.hash = '';\n                if (basePointer === '') {\n                    baseURI = url;\n                }\n                else {\n                    dereference(schema, lookup, baseURI);\n                }\n            }\n        }\n    }\n    else if (schema !== true && schema !== false) {\n        return lookup;\n    }\n    const schemaURI = baseURI.href + (basePointer ? '#' + basePointer : '');\n    if (lookup[schemaURI] !== undefined) {\n        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n    }\n    lookup[schemaURI] = schema;\n    if (schema === true || schema === false) {\n        return lookup;\n    }\n    if (schema.__absolute_uri__ === undefined) {\n        Object.defineProperty(schema, '__absolute_uri__', {\n            enumerable: false,\n            value: schemaURI\n        });\n    }\n    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n        const url = new URL(schema.$ref, baseURI.href);\n        url.hash = url.hash;\n        Object.defineProperty(schema, '__absolute_ref__', {\n            enumerable: false,\n            value: url.href\n        });\n    }\n    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n        const url = new URL(schema.$recursiveRef, baseURI.href);\n        url.hash = url.hash;\n        Object.defineProperty(schema, '__absolute_recursive_ref__', {\n            enumerable: false,\n            value: url.href\n        });\n    }\n    if (schema.$anchor) {\n        const url = new URL('#' + schema.$anchor, baseURI.href);\n        lookup[url.href] = schema;\n    }\n    for (let key in schema) {\n        if (ignoredKeyword[key]) {\n            continue;\n        }\n        const keyBase = `${basePointer}/${encodePointer(key)}`;\n        const subSchema = schema[key];\n        if (Array.isArray(subSchema)) {\n            if (schemaArrayKeyword[key]) {\n                const length = subSchema.length;\n                for (let i = 0; i < length; i++) {\n                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n                }\n            }\n        }\n        else if (schemaMapKeyword[key]) {\n            for (let subKey in subSchema) {\n                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n            }\n        }\n        else {\n            dereference(subSchema, lookup, baseURI, keyBase);\n        }\n    }\n    return lookup;\n}\n","/** A special constant with type `never` */\nexport const NEVER = Object.freeze({\n    status: \"aborted\",\n});\nexport /*@__NO_SIDE_EFFECTS__*/ function $constructor(name, initializer, params) {\n    function init(inst, def) {\n        if (!inst._zod) {\n            Object.defineProperty(inst, \"_zod\", {\n                value: {\n                    def,\n                    constr: _,\n                    traits: new Set(),\n                },\n                enumerable: false,\n            });\n        }\n        if (inst._zod.traits.has(name)) {\n            return;\n        }\n        inst._zod.traits.add(name);\n        initializer(inst, def);\n        // support prototype modifications\n        const proto = _.prototype;\n        const keys = Object.keys(proto);\n        for (let i = 0; i < keys.length; i++) {\n            const k = keys[i];\n            if (!(k in inst)) {\n                inst[k] = proto[k].bind(inst);\n            }\n        }\n    }\n    // doesn't work if Parent has a constructor with arguments\n    const Parent = params?.Parent ?? Object;\n    class Definition extends Parent {\n    }\n    Object.defineProperty(Definition, \"name\", { value: name });\n    function _(def) {\n        var _a;\n        const inst = params?.Parent ? new Definition() : this;\n        init(inst, def);\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        for (const fn of inst._zod.deferred) {\n            fn();\n        }\n        return inst;\n    }\n    Object.defineProperty(_, \"init\", { value: init });\n    Object.defineProperty(_, Symbol.hasInstance, {\n        value: (inst) => {\n            if (params?.Parent && inst instanceof params.Parent)\n                return true;\n            return inst?._zod?.traits?.has(name);\n        },\n    });\n    Object.defineProperty(_, \"name\", { value: name });\n    return _;\n}\n//////////////////////////////   UTILITIES   ///////////////////////////////////////\nexport const $brand = Symbol(\"zod_brand\");\nexport class $ZodAsyncError extends Error {\n    constructor() {\n        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n    }\n}\nexport class $ZodEncodeError extends Error {\n    constructor(name) {\n        super(`Encountered unidirectional transform during encode: ${name}`);\n        this.name = \"ZodEncodeError\";\n    }\n}\nexport const globalConfig = {};\nexport function config(newConfig) {\n    if (newConfig)\n        Object.assign(globalConfig, newConfig);\n    return globalConfig;\n}\n","// functions\nexport function assertEqual(val) {\n    return val;\n}\nexport function assertNotEqual(val) {\n    return val;\n}\nexport function assertIs(_arg) { }\nexport function assertNever(_x) {\n    throw new Error();\n}\nexport function assert(_) { }\nexport function getEnumValues(entries) {\n    const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n    const values = Object.entries(entries)\n        .filter(([k, _]) => numericValues.indexOf(+k) === -1)\n        .map(([_, v]) => v);\n    return values;\n}\nexport function joinValues(array, separator = \"|\") {\n    return array.map((val) => stringifyPrimitive(val)).join(separator);\n}\nexport function jsonStringifyReplacer(_, value) {\n    if (typeof value === \"bigint\")\n        return value.toString();\n    return value;\n}\nexport function cached(getter) {\n    const set = false;\n    return {\n        get value() {\n            if (!set) {\n                const value = getter();\n                Object.defineProperty(this, \"value\", { value });\n                return value;\n            }\n            throw new Error(\"cached value already set\");\n        },\n    };\n}\nexport function nullish(input) {\n    return input === null || input === undefined;\n}\nexport function cleanRegex(source) {\n    const start = source.startsWith(\"^\") ? 1 : 0;\n    const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n    return source.slice(start, end);\n}\nexport function floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepString = step.toString();\n    let stepDecCount = (stepString.split(\".\")[1] || \"\").length;\n    if (stepDecCount === 0 && /\\d?e-\\d?/.test(stepString)) {\n        const match = stepString.match(/\\d?e-(\\d?)/);\n        if (match?.[1]) {\n            stepDecCount = Number.parseInt(match[1]);\n        }\n    }\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nconst EVALUATING = Symbol(\"evaluating\");\nexport function defineLazy(object, key, getter) {\n    let value = undefined;\n    Object.defineProperty(object, key, {\n        get() {\n            if (value === EVALUATING) {\n                // Circular reference detected, return undefined to break the cycle\n                return undefined;\n            }\n            if (value === undefined) {\n                value = EVALUATING;\n                value = getter();\n            }\n            return value;\n        },\n        set(v) {\n            Object.defineProperty(object, key, {\n                value: v,\n                // configurable: true,\n            });\n            // object[key] = v;\n        },\n        configurable: true,\n    });\n}\nexport function objectClone(obj) {\n    return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n}\nexport function assignProp(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n}\nexport function mergeDefs(...defs) {\n    const mergedDescriptors = {};\n    for (const def of defs) {\n        const descriptors = Object.getOwnPropertyDescriptors(def);\n        Object.assign(mergedDescriptors, descriptors);\n    }\n    return Object.defineProperties({}, mergedDescriptors);\n}\nexport function cloneDef(schema) {\n    return mergeDefs(schema._zod.def);\n}\nexport function getElementAtPath(obj, path) {\n    if (!path)\n        return obj;\n    return path.reduce((acc, key) => acc?.[key], obj);\n}\nexport function promiseAllObject(promisesObj) {\n    const keys = Object.keys(promisesObj);\n    const promises = keys.map((key) => promisesObj[key]);\n    return Promise.all(promises).then((results) => {\n        const resolvedObj = {};\n        for (let i = 0; i < keys.length; i++) {\n            resolvedObj[keys[i]] = results[i];\n        }\n        return resolvedObj;\n    });\n}\nexport function randomString(length = 10) {\n    const chars = \"abcdefghijklmnopqrstuvwxyz\";\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n        str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n}\nexport function esc(str) {\n    return JSON.stringify(str);\n}\nexport function slugify(input) {\n    return input\n        .toLowerCase()\n        .trim()\n        .replace(/[^\\w\\s-]/g, \"\")\n        .replace(/[\\s_-]+/g, \"-\")\n        .replace(/^-+|-+$/g, \"\");\n}\nexport const captureStackTrace = (\"captureStackTrace\" in Error ? Error.captureStackTrace : (..._args) => { });\nexport function isObject(data) {\n    return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nexport const allowsEval = cached(() => {\n    // @ts-ignore\n    if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n        return false;\n    }\n    try {\n        const F = Function;\n        new F(\"\");\n        return true;\n    }\n    catch (_) {\n        return false;\n    }\n});\nexport function isPlainObject(o) {\n    if (isObject(o) === false)\n        return false;\n    // modified constructor\n    const ctor = o.constructor;\n    if (ctor === undefined)\n        return true;\n    if (typeof ctor !== \"function\")\n        return true;\n    // modified prototype\n    const prot = ctor.prototype;\n    if (isObject(prot) === false)\n        return false;\n    // ctor doesn't have static `isPrototypeOf`\n    if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n        return false;\n    }\n    return true;\n}\nexport function shallowClone(o) {\n    if (isPlainObject(o))\n        return { ...o };\n    if (Array.isArray(o))\n        return [...o];\n    return o;\n}\nexport function numKeys(data) {\n    let keyCount = 0;\n    for (const key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n            keyCount++;\n        }\n    }\n    return keyCount;\n}\nexport const getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return \"undefined\";\n        case \"string\":\n            return \"string\";\n        case \"number\":\n            return Number.isNaN(data) ? \"nan\" : \"number\";\n        case \"boolean\":\n            return \"boolean\";\n        case \"function\":\n            return \"function\";\n        case \"bigint\":\n            return \"bigint\";\n        case \"symbol\":\n            return \"symbol\";\n        case \"object\":\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return \"promise\";\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return \"map\";\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return \"set\";\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return \"date\";\n            }\n            // @ts-ignore\n            if (typeof File !== \"undefined\" && data instanceof File) {\n                return \"file\";\n            }\n            return \"object\";\n        default:\n            throw new Error(`Unknown data type: ${t}`);\n    }\n};\nexport const propertyKeyTypes = new Set([\"string\", \"number\", \"symbol\"]);\nexport const primitiveTypes = new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nexport function escapeRegex(str) {\n    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n// zod-specific utils\nexport function clone(inst, def, params) {\n    const cl = new inst._zod.constr(def ?? inst._zod.def);\n    if (!def || params?.parent)\n        cl._zod.parent = inst;\n    return cl;\n}\nexport function normalizeParams(_params) {\n    const params = _params;\n    if (!params)\n        return {};\n    if (typeof params === \"string\")\n        return { error: () => params };\n    if (params?.message !== undefined) {\n        if (params?.error !== undefined)\n            throw new Error(\"Cannot specify both `message` and `error` params\");\n        params.error = params.message;\n    }\n    delete params.message;\n    if (typeof params.error === \"string\")\n        return { ...params, error: () => params.error };\n    return params;\n}\nexport function createTransparentProxy(getter) {\n    let target;\n    return new Proxy({}, {\n        get(_, prop, receiver) {\n            target ?? (target = getter());\n            return Reflect.get(target, prop, receiver);\n        },\n        set(_, prop, value, receiver) {\n            target ?? (target = getter());\n            return Reflect.set(target, prop, value, receiver);\n        },\n        has(_, prop) {\n            target ?? (target = getter());\n            return Reflect.has(target, prop);\n        },\n        deleteProperty(_, prop) {\n            target ?? (target = getter());\n            return Reflect.deleteProperty(target, prop);\n        },\n        ownKeys(_) {\n            target ?? (target = getter());\n            return Reflect.ownKeys(target);\n        },\n        getOwnPropertyDescriptor(_, prop) {\n            target ?? (target = getter());\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        },\n        defineProperty(_, prop, descriptor) {\n            target ?? (target = getter());\n            return Reflect.defineProperty(target, prop, descriptor);\n        },\n    });\n}\nexport function stringifyPrimitive(value) {\n    if (typeof value === \"bigint\")\n        return value.toString() + \"n\";\n    if (typeof value === \"string\")\n        return `\"${value}\"`;\n    return `${value}`;\n}\nexport function optionalKeys(shape) {\n    return Object.keys(shape).filter((k) => {\n        return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n    });\n}\nexport const NUMBER_FORMAT_RANGES = {\n    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n    int32: [-2147483648, 2147483647],\n    uint32: [0, 4294967295],\n    float32: [-3.4028234663852886e38, 3.4028234663852886e38],\n    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],\n};\nexport const BIGINT_FORMAT_RANGES = {\n    int64: [/* @__PURE__*/ BigInt(\"-9223372036854775808\"), /* @__PURE__*/ BigInt(\"9223372036854775807\")],\n    uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt(\"18446744073709551615\")],\n};\nexport function pick(schema, mask) {\n    const currDef = schema._zod.def;\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const newShape = {};\n            for (const key in mask) {\n                if (!(key in currDef.shape)) {\n                    throw new Error(`Unrecognized key: \"${key}\"`);\n                }\n                if (!mask[key])\n                    continue;\n                newShape[key] = currDef.shape[key];\n            }\n            assignProp(this, \"shape\", newShape); // self-caching\n            return newShape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function omit(schema, mask) {\n    const currDef = schema._zod.def;\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const newShape = { ...schema._zod.def.shape };\n            for (const key in mask) {\n                if (!(key in currDef.shape)) {\n                    throw new Error(`Unrecognized key: \"${key}\"`);\n                }\n                if (!mask[key])\n                    continue;\n                delete newShape[key];\n            }\n            assignProp(this, \"shape\", newShape); // self-caching\n            return newShape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function extend(schema, shape) {\n    if (!isPlainObject(shape)) {\n        throw new Error(\"Invalid input to extend: expected a plain object\");\n    }\n    const checks = schema._zod.def.checks;\n    const hasChecks = checks && checks.length > 0;\n    if (hasChecks) {\n        throw new Error(\"Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.\");\n    }\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const _shape = { ...schema._zod.def.shape, ...shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function safeExtend(schema, shape) {\n    if (!isPlainObject(shape)) {\n        throw new Error(\"Invalid input to safeExtend: expected a plain object\");\n    }\n    const def = {\n        ...schema._zod.def,\n        get shape() {\n            const _shape = { ...schema._zod.def.shape, ...shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        checks: schema._zod.def.checks,\n    };\n    return clone(schema, def);\n}\nexport function merge(a, b) {\n    const def = mergeDefs(a._zod.def, {\n        get shape() {\n            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n            assignProp(this, \"shape\", _shape); // self-caching\n            return _shape;\n        },\n        get catchall() {\n            return b._zod.def.catchall;\n        },\n        checks: [], // delete existing checks\n    });\n    return clone(a, def);\n}\nexport function partial(Class, schema, mask) {\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const oldShape = schema._zod.def.shape;\n            const shape = { ...oldShape };\n            if (mask) {\n                for (const key in mask) {\n                    if (!(key in oldShape)) {\n                        throw new Error(`Unrecognized key: \"${key}\"`);\n                    }\n                    if (!mask[key])\n                        continue;\n                    // if (oldShape[key]!._zod.optin === \"optional\") continue;\n                    shape[key] = Class\n                        ? new Class({\n                            type: \"optional\",\n                            innerType: oldShape[key],\n                        })\n                        : oldShape[key];\n                }\n            }\n            else {\n                for (const key in oldShape) {\n                    // if (oldShape[key]!._zod.optin === \"optional\") continue;\n                    shape[key] = Class\n                        ? new Class({\n                            type: \"optional\",\n                            innerType: oldShape[key],\n                        })\n                        : oldShape[key];\n                }\n            }\n            assignProp(this, \"shape\", shape); // self-caching\n            return shape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\nexport function required(Class, schema, mask) {\n    const def = mergeDefs(schema._zod.def, {\n        get shape() {\n            const oldShape = schema._zod.def.shape;\n            const shape = { ...oldShape };\n            if (mask) {\n                for (const key in mask) {\n                    if (!(key in shape)) {\n                        throw new Error(`Unrecognized key: \"${key}\"`);\n                    }\n                    if (!mask[key])\n                        continue;\n                    // overwrite with non-optional\n                    shape[key] = new Class({\n                        type: \"nonoptional\",\n                        innerType: oldShape[key],\n                    });\n                }\n            }\n            else {\n                for (const key in oldShape) {\n                    // overwrite with non-optional\n                    shape[key] = new Class({\n                        type: \"nonoptional\",\n                        innerType: oldShape[key],\n                    });\n                }\n            }\n            assignProp(this, \"shape\", shape); // self-caching\n            return shape;\n        },\n        checks: [],\n    });\n    return clone(schema, def);\n}\n// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom\nexport function aborted(x, startIndex = 0) {\n    if (x.aborted === true)\n        return true;\n    for (let i = startIndex; i < x.issues.length; i++) {\n        if (x.issues[i]?.continue !== true) {\n            return true;\n        }\n    }\n    return false;\n}\nexport function prefixIssues(path, issues) {\n    return issues.map((iss) => {\n        var _a;\n        (_a = iss).path ?? (_a.path = []);\n        iss.path.unshift(path);\n        return iss;\n    });\n}\nexport function unwrapMessage(message) {\n    return typeof message === \"string\" ? message : message?.message;\n}\nexport function finalizeIssue(iss, ctx, config) {\n    const full = { ...iss, path: iss.path ?? [] };\n    // for backwards compatibility\n    if (!iss.message) {\n        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??\n            unwrapMessage(ctx?.error?.(iss)) ??\n            unwrapMessage(config.customError?.(iss)) ??\n            unwrapMessage(config.localeError?.(iss)) ??\n            \"Invalid input\";\n        full.message = message;\n    }\n    // delete (full as any).def;\n    delete full.inst;\n    delete full.continue;\n    if (!ctx?.reportInput) {\n        delete full.input;\n    }\n    return full;\n}\nexport function getSizableOrigin(input) {\n    if (input instanceof Set)\n        return \"set\";\n    if (input instanceof Map)\n        return \"map\";\n    // @ts-ignore\n    if (input instanceof File)\n        return \"file\";\n    return \"unknown\";\n}\nexport function getLengthableOrigin(input) {\n    if (Array.isArray(input))\n        return \"array\";\n    if (typeof input === \"string\")\n        return \"string\";\n    return \"unknown\";\n}\nexport function issue(...args) {\n    const [iss, input, inst] = args;\n    if (typeof iss === \"string\") {\n        return {\n            message: iss,\n            code: \"custom\",\n            input,\n            inst,\n        };\n    }\n    return { ...iss };\n}\nexport function cleanEnum(obj) {\n    return Object.entries(obj)\n        .filter(([k, _]) => {\n        // return true if NaN, meaning it's not a number, thus a string key\n        return Number.isNaN(Number.parseInt(k, 10));\n    })\n        .map((el) => el[1]);\n}\n// Codec utility functions\nexport function base64ToUint8Array(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n}\nexport function uint8ArrayToBase64(bytes) {\n    let binaryString = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n        binaryString += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binaryString);\n}\nexport function base64urlToUint8Array(base64url) {\n    const base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const padding = \"=\".repeat((4 - (base64.length % 4)) % 4);\n    return base64ToUint8Array(base64 + padding);\n}\nexport function uint8ArrayToBase64url(bytes) {\n    return uint8ArrayToBase64(bytes).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\nexport function hexToUint8Array(hex) {\n    const cleanHex = hex.replace(/^0x/, \"\");\n    if (cleanHex.length % 2 !== 0) {\n        throw new Error(\"Invalid hex string length\");\n    }\n    const bytes = new Uint8Array(cleanHex.length / 2);\n    for (let i = 0; i < cleanHex.length; i += 2) {\n        bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);\n    }\n    return bytes;\n}\nexport function uint8ArrayToHex(bytes) {\n    return Array.from(bytes)\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n}\n// instanceof\nexport class Class {\n    constructor(..._args) { }\n}\n","import * as util from \"./util.js\";\nexport const cuid = /^[cC][^\\s-]{8,}$/;\nexport const cuid2 = /^[0-9a-z]+$/;\nexport const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nexport const xid = /^[0-9a-vA-V]{20}$/;\nexport const ksuid = /^[A-Za-z0-9]{27}$/;\nexport const nanoid = /^[a-zA-Z0-9_-]{21}$/;\n/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */\nexport const duration = /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\n/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */\nexport const extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */\nexport const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\n/** Returns a regex for validating an RFC 9562/4122 UUID.\n *\n * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */\nexport const uuid = (version) => {\n    if (!version)\n        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;\n    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);\n};\nexport const uuid4 = /*@__PURE__*/ uuid(4);\nexport const uuid6 = /*@__PURE__*/ uuid(6);\nexport const uuid7 = /*@__PURE__*/ uuid(7);\n/** Practical email validation */\nexport const email = /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\n/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */\nexport const html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n/** The classic emailregex.com regex for RFC 5322-compliant emails */\nexport const rfc5322Email = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */\nexport const unicodeEmail = /^[^\\s@\"]{1,64}@[^\\s@]{1,255}$/u;\nexport const idnEmail = unicodeEmail;\nexport const browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nexport function emoji() {\n    return new RegExp(_emoji, \"u\");\n}\nexport const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nexport const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;\nexport const mac = (delimiter) => {\n    const escapedDelim = util.escapeRegex(delimiter ?? \":\");\n    return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);\n};\nexport const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nexport const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nexport const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nexport const base64url = /^[A-Za-z0-9_-]*$/;\n// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address\n// export const hostname: RegExp = /^([a-zA-Z0-9-]+\\.)*[a-zA-Z0-9-]+$/;\nexport const hostname = /^(?=.{1,253}\\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\\.?$/;\nexport const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/;\n// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)\nexport const e164 = /^\\+(?:[0-9]){6,14}[0-9]$/;\n// const dateSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nexport const date = /*@__PURE__*/ new RegExp(`^${dateSource}$`);\nfunction timeSource(args) {\n    const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n    const regex = typeof args.precision === \"number\"\n        ? args.precision === -1\n            ? `${hhmm}`\n            : args.precision === 0\n                ? `${hhmm}:[0-5]\\\\d`\n                : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}`\n        : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n    return regex;\n}\nexport function time(args) {\n    return new RegExp(`^${timeSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetime(args) {\n    const time = timeSource({ precision: args.precision });\n    const opts = [\"Z\"];\n    if (args.local)\n        opts.push(\"\");\n    // if (args.offset) opts.push(`([+-]\\\\d{2}:\\\\d{2})`);\n    if (args.offset)\n        opts.push(`([+-](?:[01]\\\\d|2[0-3]):[0-5]\\\\d)`);\n    const timeRegex = `${time}(?:${opts.join(\"|\")})`;\n    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}\nexport const string = (params) => {\n    const regex = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? \"\"}}` : `[\\\\s\\\\S]*`;\n    return new RegExp(`^${regex}$`);\n};\nexport const bigint = /^-?\\d+n?$/;\nexport const integer = /^-?\\d+$/;\nexport const number = /^-?\\d+(?:\\.\\d+)?/;\nexport const boolean = /^(?:true|false)$/i;\nconst _null = /^null$/i;\nexport { _null as null };\nconst _undefined = /^undefined$/i;\nexport { _undefined as undefined };\n// regex for string with no uppercase letters\nexport const lowercase = /^[^A-Z]*$/;\n// regex for string with no lowercase letters\nexport const uppercase = /^[^a-z]*$/;\n// regex for hexadecimal strings (any length)\nexport const hex = /^[0-9a-fA-F]*$/;\n// Hash regexes for different algorithms and encodings\n// Helper function to create base64 regex with exact length and padding\nfunction fixedBase64(bodyLength, padding) {\n    return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);\n}\n// Helper function to create base64url regex with exact length (no padding)\nfunction fixedBase64url(length) {\n    return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);\n}\n// MD5 (16 bytes): base64 = 24 chars total (22 + \"==\")\nexport const md5_hex = /^[0-9a-fA-F]{32}$/;\nexport const md5_base64 = /*@__PURE__*/ fixedBase64(22, \"==\");\nexport const md5_base64url = /*@__PURE__*/ fixedBase64url(22);\n// SHA1 (20 bytes): base64 = 28 chars total (27 + \"=\")\nexport const sha1_hex = /^[0-9a-fA-F]{40}$/;\nexport const sha1_base64 = /*@__PURE__*/ fixedBase64(27, \"=\");\nexport const sha1_base64url = /*@__PURE__*/ fixedBase64url(27);\n// SHA256 (32 bytes): base64 = 44 chars total (43 + \"=\")\nexport const sha256_hex = /^[0-9a-fA-F]{64}$/;\nexport const sha256_base64 = /*@__PURE__*/ fixedBase64(43, \"=\");\nexport const sha256_base64url = /*@__PURE__*/ fixedBase64url(43);\n// SHA384 (48 bytes): base64 = 64 chars total (no padding)\nexport const sha384_hex = /^[0-9a-fA-F]{96}$/;\nexport const sha384_base64 = /*@__PURE__*/ fixedBase64(64, \"\");\nexport const sha384_base64url = /*@__PURE__*/ fixedBase64url(64);\n// SHA512 (64 bytes): base64 = 88 chars total (86 + \"==\")\nexport const sha512_hex = /^[0-9a-fA-F]{128}$/;\nexport const sha512_base64 = /*@__PURE__*/ fixedBase64(86, \"==\");\nexport const sha512_base64url = /*@__PURE__*/ fixedBase64url(86);\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"\";\n        }\n        case \"object\": {\n            if (Array.isArray(data)) {\n                return \"\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n        }\n    }\n    return t;\n};\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"\", verb: \" \" },\n        file: { unit: \"\", verb: \" \" },\n        array: { unit: \"\", verb: \" \" },\n        set: { unit: \"\", verb: \" \" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const Nouns = {\n        regex: \"\",\n        email: \" \",\n        url: \"URL\",\n        emoji: \"\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO \",\n        date: \"ISO \",\n        time: \"ISO \",\n        duration: \"ISO \",\n        ipv4: \"IPv4 \",\n        ipv6: \"IPv6 \",\n        cidrv4: \"IPv4 \",\n        cidrv6: \"IPv6 \",\n        base64: \"base64- \",\n        base64url: \"base64url- \",\n        json_string: \"JSON \",\n        e164: \"E.164 \",\n        jwt: \"JWT\",\n        template_literal: \"\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return ` :  ${issue.expected},  ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return ` :  ${util.stringifyPrimitive(issue.values[0])}`;\n                return ` :    ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"\"}`;\n                return ` :   ${issue.origin ?? \"\"}   ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return ` :   ${issue.origin}   ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return ` :     \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return ` :     \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return ` :    \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return ` :     ${_issue.pattern}`;\n                let invalid_adj = \"\";\n                if (_issue.format === \"emoji\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"datetime\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"date\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"time\")\n                    invalid_adj = \"\";\n                if (_issue.format === \"duration\")\n                    invalid_adj = \"\";\n                return `${invalid_adj} ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return ` :      ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `${issue.keys.length > 1 ? \"\" : \"\"} ${issue.keys.length > 1 ? \"\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `   ${issue.origin}`;\n            case \"invalid_union\":\n                return \" \";\n            case \"invalid_element\":\n                return `   ${issue.origin}`;\n            default:\n                return ` `;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"number\";\n        }\n        case \"object\": {\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            if (data === null) {\n                return \"null\";\n            }\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n        }\n    }\n    return t;\n};\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"characters\", verb: \"to have\" },\n        file: { unit: \"bytes\", verb: \"to have\" },\n        array: { unit: \"items\", verb: \"to have\" },\n        set: { unit: \"items\", verb: \"to have\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const Nouns = {\n        regex: \"input\",\n        email: \"email address\",\n        url: \"URL\",\n        emoji: \"emoji\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO datetime\",\n        date: \"ISO date\",\n        time: \"ISO time\",\n        duration: \"ISO duration\",\n        ipv4: \"IPv4 address\",\n        ipv6: \"IPv6 address\",\n        mac: \"MAC address\",\n        cidrv4: \"IPv4 range\",\n        cidrv6: \"IPv6 range\",\n        base64: \"base64-encoded string\",\n        base64url: \"base64url-encoded string\",\n        json_string: \"JSON string\",\n        e164: \"E.164 number\",\n        jwt: \"JWT\",\n        template_literal: \"input\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Invalid input: expected ${issue.expected}, received ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Invalid input: expected ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Invalid option: expected one of ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Too big: expected ${issue.origin ?? \"value\"} to have ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elements\"}`;\n                return `Too big: expected ${issue.origin ?? \"value\"} to be ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Too small: expected ${issue.origin} to have ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Too small: expected ${issue.origin} to be ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\") {\n                    return `Invalid string: must start with \"${_issue.prefix}\"`;\n                }\n                if (_issue.format === \"ends_with\")\n                    return `Invalid string: must end with \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Invalid string: must include \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Invalid string: must match pattern ${_issue.pattern}`;\n                return `Invalid ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Invalid number: must be a multiple of ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Unrecognized key${issue.keys.length > 1 ? \"s\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Invalid key in ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Invalid input\";\n            case \"invalid_element\":\n                return `Invalid value in ${issue.origin}`;\n            default:\n                return `Invalid input`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import * as util from \"../core/util.js\";\nexport const parsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"number\": {\n            return Number.isNaN(data) ? \"NaN\" : \"nombro\";\n        }\n        case \"object\": {\n            if (Array.isArray(data)) {\n                return \"tabelo\";\n            }\n            if (data === null) {\n                return \"senvalora\";\n            }\n            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n                return data.constructor.name;\n            }\n        }\n    }\n    return t;\n};\nconst error = () => {\n    const Sizable = {\n        string: { unit: \"karaktrojn\", verb: \"havi\" },\n        file: { unit: \"bajtojn\", verb: \"havi\" },\n        array: { unit: \"elementojn\", verb: \"havi\" },\n        set: { unit: \"elementojn\", verb: \"havi\" },\n    };\n    function getSizing(origin) {\n        return Sizable[origin] ?? null;\n    }\n    const Nouns = {\n        regex: \"enigo\",\n        email: \"retadreso\",\n        url: \"URL\",\n        emoji: \"emoio\",\n        uuid: \"UUID\",\n        uuidv4: \"UUIDv4\",\n        uuidv6: \"UUIDv6\",\n        nanoid: \"nanoid\",\n        guid: \"GUID\",\n        cuid: \"cuid\",\n        cuid2: \"cuid2\",\n        ulid: \"ULID\",\n        xid: \"XID\",\n        ksuid: \"KSUID\",\n        datetime: \"ISO-datotempo\",\n        date: \"ISO-dato\",\n        time: \"ISO-tempo\",\n        duration: \"ISO-daro\",\n        ipv4: \"IPv4-adreso\",\n        ipv6: \"IPv6-adreso\",\n        cidrv4: \"IPv4-rango\",\n        cidrv6: \"IPv6-rango\",\n        base64: \"64-ume kodita karaktraro\",\n        base64url: \"URL-64-ume kodita karaktraro\",\n        json_string: \"JSON-karaktraro\",\n        e164: \"E.164-nombro\",\n        jwt: \"JWT\",\n        template_literal: \"enigo\",\n    };\n    return (issue) => {\n        switch (issue.code) {\n            case \"invalid_type\":\n                return `Nevalida enigo: atendiis ${issue.expected}, riceviis ${parsedType(issue.input)}`;\n            case \"invalid_value\":\n                if (issue.values.length === 1)\n                    return `Nevalida enigo: atendiis ${util.stringifyPrimitive(issue.values[0])}`;\n                return `Nevalida opcio: atendiis unu el ${util.joinValues(issue.values, \"|\")}`;\n            case \"too_big\": {\n                const adj = issue.inclusive ? \"<=\" : \"<\";\n                const sizing = getSizing(issue.origin);\n                if (sizing)\n                    return `Tro granda: atendiis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()} ${sizing.unit ?? \"elementojn\"}`;\n                return `Tro granda: atendiis ke ${issue.origin ?? \"valoro\"} havu ${adj}${issue.maximum.toString()}`;\n            }\n            case \"too_small\": {\n                const adj = issue.inclusive ? \">=\" : \">\";\n                const sizing = getSizing(issue.origin);\n                if (sizing) {\n                    return `Tro malgranda: atendiis ke ${issue.origin} havu ${adj}${issue.minimum.toString()} ${sizing.unit}`;\n                }\n                return `Tro malgranda: atendiis ke ${issue.origin} estu ${adj}${issue.minimum.toString()}`;\n            }\n            case \"invalid_format\": {\n                const _issue = issue;\n                if (_issue.format === \"starts_with\")\n                    return `Nevalida karaktraro: devas komencii per \"${_issue.prefix}\"`;\n                if (_issue.format === \"ends_with\")\n                    return `Nevalida karaktraro: devas finii per \"${_issue.suffix}\"`;\n                if (_issue.format === \"includes\")\n                    return `Nevalida karaktraro: devas inkluzivi \"${_issue.includes}\"`;\n                if (_issue.format === \"regex\")\n                    return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;\n                return `Nevalida ${Nouns[_issue.format] ?? issue.format}`;\n            }\n            case \"not_multiple_of\":\n                return `Nevalida nombro: devas esti oblo de ${issue.divisor}`;\n            case \"unrecognized_keys\":\n                return `Nekonata${issue.keys.length > 1 ? \"j\" : \"\"} losilo${issue.keys.length > 1 ? \"j\" : \"\"}: ${util.joinValues(issue.keys, \", \")}`;\n            case \"invalid_key\":\n                return `Nevalida losilo en ${issue.origin}`;\n            case \"invalid_union\":\n                return \"Nevalida enigo\";\n            case \"invalid_element\":\n                return `Nevalida valoro en ${issue.origin}`;\n            default:\n                return `Nevalida enigo`;\n        }\n    };\n};\nexport default function () {\n    return {\n        localeError: error(),\n    };\n}\n","import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        const { priority = 0, id, } = options ?? {};\n        const element = {\n            priority,\n            id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n","export function parseJsonMarkdown(s: string, parser = parsePartialJson) {\n  // eslint-disable-next-line no-param-reassign\n  s = s.trim();\n\n  const firstFenceIndex = s.indexOf(\"```\");\n  if (firstFenceIndex === -1) {\n    return parser(s);\n  }\n\n  let contentAfterFence = s.substring(firstFenceIndex + 3);\n\n  if (contentAfterFence.startsWith(\"json\\n\")) {\n    contentAfterFence = contentAfterFence.substring(5);\n  } else if (contentAfterFence.startsWith(\"json\")) {\n    contentAfterFence = contentAfterFence.substring(4);\n  } else if (contentAfterFence.startsWith(\"\\n\")) {\n    contentAfterFence = contentAfterFence.substring(1);\n  }\n\n  const closingFenceIndex = contentAfterFence.indexOf(\"```\");\n  let finalContent = contentAfterFence;\n  if (closingFenceIndex !== -1) {\n    finalContent = contentAfterFence.substring(0, closingFenceIndex);\n  }\n\n  return parser(finalContent.trim());\n}\n\n/**\n * Recursive descent partial JSON parser.\n * @param s - The string to parse.\n * @returns The parsed value.\n * @throws Error if the input is a malformed JSON string.\n */\nexport function strictParsePartialJson(s: string): unknown {\n  try {\n    return JSON.parse(s);\n  } catch {\n    // Continue to partial parsing\n  }\n\n  const buffer = s.trim();\n  if (buffer.length === 0) throw new Error(\"Unexpected end of JSON input\");\n\n  let pos = 0;\n\n  function skipWhitespace(): void {\n    while (pos < buffer.length && /\\s/.test(buffer[pos])) {\n      pos += 1;\n    }\n  }\n\n  function parseString(): string {\n    if (buffer[pos] !== '\"') {\n      throw new Error(`Expected '\"' at position ${pos}, got '${buffer[pos]}'`);\n    }\n\n    pos += 1;\n    let result = \"\";\n    let escaped = false;\n\n    while (pos < buffer.length) {\n      const char = buffer[pos];\n\n      if (escaped) {\n        if (char === \"n\") {\n          result += \"\\n\";\n        } else if (char === \"t\") {\n          result += \"\\t\";\n        } else if (char === \"r\") {\n          result += \"\\r\";\n        } else if (char === \"\\\\\") {\n          result += \"\\\\\";\n        } else if (char === '\"') {\n          result += '\"';\n        } else if (char === \"b\") {\n          result += \"\\b\";\n        } else if (char === \"f\") {\n          result += \"\\f\";\n        } else if (char === \"/\") {\n          result += \"/\";\n        } else if (char === \"u\") {\n          const hex = buffer.substring(pos + 1, pos + 5);\n          if (/^[0-9A-Fa-f]{0,4}$/.test(hex)) {\n            if (hex.length === 4) {\n              result += String.fromCharCode(Number.parseInt(hex, 16));\n            } else {\n              result += `u${hex}`;\n            }\n\n            pos += hex.length;\n          } else {\n            throw new Error(\n              `Invalid unicode escape sequence '\\\\u${hex}' at position ${pos}`\n            );\n          }\n        } else {\n          throw new Error(\n            `Invalid escape sequence '\\\\${char}' at position ${pos}`\n          );\n        }\n        escaped = false;\n      } else if (char === \"\\\\\") {\n        escaped = true;\n      } else if (char === '\"') {\n        pos += 1;\n        return result;\n      } else {\n        result += char;\n      }\n\n      pos += 1;\n    }\n\n    if (escaped) result += \"\\\\\";\n    return result;\n  }\n\n  function parseNumber(): number {\n    const start = pos;\n    let numStr = \"\";\n\n    if (buffer[pos] === \"-\") {\n      numStr += \"-\";\n      pos += 1;\n    }\n\n    if (pos < buffer.length && buffer[pos] === \"0\") {\n      numStr += \"0\";\n      pos += 1;\n\n      if (buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        throw new Error(`Invalid number at position ${start}`);\n      }\n    }\n\n    if (pos < buffer.length && buffer[pos] >= \"1\" && buffer[pos] <= \"9\") {\n      while (pos < buffer.length && buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n    }\n\n    if (pos < buffer.length && buffer[pos] === \".\") {\n      numStr += \".\";\n      pos += 1;\n      while (pos < buffer.length && buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n    }\n\n    if (pos < buffer.length && (buffer[pos] === \"e\" || buffer[pos] === \"E\")) {\n      numStr += buffer[pos];\n      pos += 1;\n      if (pos < buffer.length && (buffer[pos] === \"+\" || buffer[pos] === \"-\")) {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n      while (pos < buffer.length && buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n    }\n\n    if (numStr === \"-\") return -0;\n\n    const num = Number.parseFloat(numStr);\n\n    if (Number.isNaN(num)) {\n      pos = start;\n      throw new Error(`Invalid number '${numStr}' at position ${start}`);\n    }\n\n    return num;\n  }\n\n  function parseValue(): unknown {\n    skipWhitespace();\n\n    if (pos >= buffer.length) {\n      throw new Error(`Unexpected end of input at position ${pos}`);\n    }\n\n    const char = buffer[pos];\n\n    if (char === \"{\") return parseObject();\n    if (char === \"[\") return parseArray();\n    if (char === '\"') return parseString();\n\n    if (\"null\".startsWith(buffer.substring(pos, pos + 4))) {\n      pos += Math.min(4, buffer.length - pos);\n      return null;\n    }\n\n    if (\"true\".startsWith(buffer.substring(pos, pos + 4))) {\n      pos += Math.min(4, buffer.length - pos);\n      return true;\n    }\n\n    if (\"false\".startsWith(buffer.substring(pos, pos + 5))) {\n      pos += Math.min(5, buffer.length - pos);\n      return false;\n    }\n\n    if (char === \"-\" || (char >= \"0\" && char <= \"9\")) {\n      return parseNumber();\n    }\n\n    throw new Error(`Unexpected character '${char}' at position ${pos}`);\n  }\n\n  function parseArray(): unknown[] {\n    if (buffer[pos] !== \"[\") {\n      throw new Error(`Expected '[' at position ${pos}, got '${buffer[pos]}'`);\n    }\n\n    const arr: unknown[] = [];\n\n    pos += 1;\n    skipWhitespace();\n\n    if (pos >= buffer.length) return arr;\n    if (buffer[pos] === \"]\") {\n      pos += 1;\n      return arr;\n    }\n\n    while (pos < buffer.length) {\n      skipWhitespace();\n      if (pos >= buffer.length) return arr;\n\n      arr.push(parseValue());\n\n      skipWhitespace();\n      if (pos >= buffer.length) return arr;\n\n      if (buffer[pos] === \"]\") {\n        pos += 1;\n        return arr;\n      } else if (buffer[pos] === \",\") {\n        pos += 1;\n        continue;\n      }\n\n      throw new Error(\n        `Expected ',' or ']' at position ${pos}, got '${buffer[pos]}'`\n      );\n    }\n\n    return arr;\n  }\n\n  function parseObject(): Record<string, unknown> {\n    if (buffer[pos] !== \"{\") {\n      throw new Error(`Expected '{' at position ${pos}, got '${buffer[pos]}'`);\n    }\n\n    const obj: Record<string, unknown> = {};\n    pos += 1;\n    skipWhitespace();\n\n    if (pos >= buffer.length) return obj;\n    if (buffer[pos] === \"}\") {\n      pos += 1;\n      return obj;\n    }\n\n    while (pos < buffer.length) {\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      const key = parseString();\n\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      if (buffer[pos] !== \":\") {\n        throw new Error(\n          `Expected ':' at position ${pos}, got '${buffer[pos]}'`\n        );\n      }\n      pos += 1;\n\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      obj[key] = parseValue();\n\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      if (buffer[pos] === \"}\") {\n        pos += 1;\n        return obj;\n      } else if (buffer[pos] === \",\") {\n        pos += 1;\n        continue;\n      }\n\n      throw new Error(\n        `Expected ',' or '}' at position ${pos}, got '${buffer[pos]}'`\n      );\n    }\n\n    return obj;\n  }\n\n  const value = parseValue();\n  skipWhitespace();\n\n  if (pos < buffer.length) {\n    throw new Error(`Unexpected character '${buffer[pos]}' at position ${pos}`);\n  }\n\n  return value;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function parsePartialJson(s: string): any | null {\n  // Attempt to parse the modified string as JSON.\n  try {\n    if (typeof s === \"undefined\") return null;\n    return strictParsePartialJson(s);\n  } catch {\n    // If we still can't parse the string as JSON, return null to indicate failure.\n    return null;\n  }\n}\n","const handlePreserveConsecutiveUppercase = (decamelized, separator) => {\n\t// Lowercase all single uppercase characters. As we\n\t// want to preserve uppercase sequences, we cannot\n\t// simply lowercase the separated string at the end.\n\t// `data_For_USACounties`  `data_for_USACounties`\n\tdecamelized = decamelized.replace(\n\t\t/((?<![\\p{Uppercase_Letter}\\d])[\\p{Uppercase_Letter}\\d](?![\\p{Uppercase_Letter}\\d]))/gu,\n\t\t$0 => $0.toLowerCase(),\n\t);\n\n\t// Remaining uppercase sequences will be separated from lowercase sequences.\n\t// `data_For_USACounties`  `data_for_USA_counties`\n\t// We anchor at the start of an uppercase run to avoid excessive backtracking on\n\t// long all-uppercase substrings followed by a non-lowercase character.\n\treturn decamelized.replace(\n\t\t/(?<!\\p{Uppercase_Letter})(\\p{Uppercase_Letter}+)(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n\t\t(_, $1, $2) => $1 + separator + $2.toLowerCase(),\n\t);\n};\n\nexport default function decamelize(\n\ttext,\n\t{\n\t\tseparator = '_',\n\t\tpreserveConsecutiveUppercase = false,\n\t} = {},\n) {\n\tif (!(typeof text === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError(\n\t\t\t'The `text` and `separator` arguments should be of type `string`',\n\t\t);\n\t}\n\n\t// Checking the second character is done later on. Therefore process shorter strings here.\n\tif (text.length < 2) {\n\t\treturn preserveConsecutiveUppercase ? text : text.toLowerCase();\n\t}\n\n\tconst replacement = `$1${separator}$2`;\n\n\t// Split lowercase sequences followed by uppercase character.\n\t// `dataForUSACounties`  `data_For_USACounties`\n\t// `myURLstring  `my_URLstring`\n\tconst decamelized = text.replace(\n\t\t/([\\p{Lowercase_Letter}\\d])(\\p{Uppercase_Letter})/gu,\n\t\treplacement,\n\t);\n\n\tif (preserveConsecutiveUppercase) {\n\t\treturn handlePreserveConsecutiveUppercase(decamelized, separator);\n\t}\n\n\t// Split multiple uppercase characters followed by one or more lowercase characters.\n\t// `my_URLstring`  `my_ur_lstring`\n\treturn decamelized\n\t\t.replace(\n\t\t\t/(\\p{Uppercase_Letter})(\\p{Uppercase_Letter}\\p{Lowercase_Letter}+)/gu,\n\t\t\treplacement,\n\t\t)\n\t\t.toLowerCase();\n}\n","import { JsonSchema7TypeUnion } from \"./parseTypes.js\";\nimport { Refs } from \"./Refs.js\";\n\nexport type ErrorMessages<\n  T extends JsonSchema7TypeUnion | { format: string } | { pattern: string },\n  OmitProperties extends string = \"\",\n> = Partial<\n  Omit<{ [key in keyof T]: string }, OmitProperties | \"type\" | \"errorMessages\">\n>;\n\nexport function addErrorMessage<\n  T extends { errorMessage?: ErrorMessages<any> },\n>(res: T, key: keyof T, errorMessage: string | undefined, refs: Refs) {\n  if (!refs?.errorMessages) return;\n  if (errorMessage) {\n    res.errorMessage = {\n      ...res.errorMessage,\n      [key]: errorMessage,\n    };\n  }\n}\n\nexport function setResponseValueAndErrors<\n  Json7Type extends JsonSchema7TypeUnion & {\n    errorMessage?: ErrorMessages<Json7Type>;\n  },\n  Key extends keyof Omit<Json7Type, \"errorMessage\">,\n>(\n  res: Json7Type,\n  key: Key,\n  value: Json7Type[Key],\n  errorMessage: string | undefined,\n  refs: Refs,\n) {\n  res[key] = value;\n  addErrorMessage(res, key, errorMessage, refs);\n}\n","import { OrderResolutionStateType, DriverResultType } from '../state';\r\n\r\n// Simulated driver pool\r\nconst availableDrivers = [\r\n    { id: 'DRV-001', name: 'Ahmed Khan', vehicle: 'Motorcycle', available: true },\r\n    { id: 'DRV-002', name: 'Sara Ali', vehicle: 'Car', available: true },\r\n    { id: 'DRV-003', name: 'Hassan Malik', vehicle: 'Van', available: false },\r\n    { id: 'DRV-004', name: 'Fatima Noor', vehicle: 'Motorcycle', available: true },\r\n    { id: 'DRV-005', name: 'Usman Tariq', vehicle: 'Car', available: true },\r\n];\r\n\r\n/**\r\n * Find available drivers for order delivery\r\n */\r\nexport async function findAvailableDrivers(\r\n    state: OrderResolutionStateType\r\n): Promise<DriverResultType> {\r\n    // Simulate API delay\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    // Find available drivers\r\n    const drivers = availableDrivers.filter(d => d.available);\r\n\r\n    if (drivers.length === 0) {\r\n        throw new Error('No drivers available at the moment');\r\n    }\r\n\r\n    // Select best driver (in real app, would consider location, vehicle type, etc.)\r\n    const orderValue = state.orderDetails.total;\r\n    const selectedDriver = orderValue > 1000\r\n        ? drivers.find(d => d.vehicle === 'Car' || d.vehicle === 'Van') || drivers[0]\r\n        : drivers[0];\r\n\r\n    // Calculate estimated arrival (simulated)\r\n    const distance = Math.round(Math.random() * 10 + 2); // 2-12 km\r\n    const estimatedArrival = Math.round(distance * 3 + 10); // rough estimate\r\n\r\n    return {\r\n        driverId: selectedDriver.id,\r\n        driverName: selectedDriver.name,\r\n        vehicleType: selectedDriver.vehicle,\r\n        estimatedArrival,\r\n        distance,\r\n    };\r\n}\r\n\r\n/**\r\n * Assign driver to order\r\n */\r\nexport async function assignDriverToOrder(\r\n    orderId: string,\r\n    driverId: string\r\n): Promise<boolean> {\r\n    // Simulate assignment\r\n    await new Promise(resolve => setTimeout(resolve, 500));\r\n    console.log(`Assigned driver ${driverId} to order ${orderId}`);\r\n    return true;\r\n}\r\n","// Inlined from https://github.com/flexdinesh/browser-or-node\nimport { __version__ } from \"../index.js\";\nlet globalEnv;\nexport const isBrowser = () => typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\nexport const isWebWorker = () => typeof globalThis === \"object\" &&\n    globalThis.constructor &&\n    globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nexport const isJsDom = () => (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n    (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nexport const isDeno = () => typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nexport const isNode = () => typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\" &&\n    !isDeno();\nexport const getEnv = () => {\n    if (globalEnv) {\n        return globalEnv;\n    }\n    // @ts-expect-error Bun types are not imported due to conflicts with Node types\n    if (typeof Bun !== \"undefined\") {\n        globalEnv = \"bun\";\n    }\n    else if (isBrowser()) {\n        globalEnv = \"browser\";\n    }\n    else if (isNode()) {\n        globalEnv = \"node\";\n    }\n    else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    }\n    else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    }\n    else if (isDeno()) {\n        globalEnv = \"deno\";\n    }\n    else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nexport function getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: __version__,\n            ...releaseEnv,\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangSmith-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangSmith-specific metadata environment variables.\n */\nexport function getLangSmithEnvVarsMetadata() {\n    const allEnvVars = getLangSmithEnvironmentVariables();\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n        \"LANGSMITH_API_KEY\",\n        \"LANGSMITH_ENDPOINT\",\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGSMITH_PROJECT\",\n        \"LANGSMITH_SESSION\",\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)) {\n        if (typeof value === \"string\" &&\n            !excluded.includes(key) &&\n            !key.toLowerCase().includes(\"key\") &&\n            !key.toLowerCase().includes(\"secret\") &&\n            !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            }\n            else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves only the LangChain/LangSmith-prefixed environment variables from the current runtime environment.\n * This is more efficient than copying all environment variables.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain/LangSmith environment variables.\n */\nexport function getLangSmithEnvironmentVariables() {\n    const envVars = {};\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            for (const [key, value] of Object.entries(process.env)) {\n                if ((key.startsWith(\"LANGCHAIN_\") || key.startsWith(\"LANGSMITH_\")) &&\n                    value != null) {\n                    if ((key.toLowerCase().includes(\"key\") ||\n                        key.toLowerCase().includes(\"secret\") ||\n                        key.toLowerCase().includes(\"token\")) &&\n                        typeof value === \"string\") {\n                        envVars[key] =\n                            value.slice(0, 2) +\n                                \"*\".repeat(value.length - 4) +\n                                value.slice(-2);\n                    }\n                    else {\n                        envVars[key] = value;\n                    }\n                }\n            }\n        }\n    }\n    catch (e) {\n        // Catch any errors that might occur while trying to access environment variables\n    }\n    return envVars;\n}\nexport function getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\"\n            ? // eslint-disable-next-line no-process-env\n                process.env?.[name]\n            : undefined;\n    }\n    catch (e) {\n        return undefined;\n    }\n}\nexport function getLangSmithEnvironmentVariable(name) {\n    return (getEnvironmentVariable(`LANGSMITH_${name}`) ||\n        getEnvironmentVariable(`LANGCHAIN_${name}`));\n}\nexport function setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */\nexport function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\",\n    ];\n    const shas = {};\n    for (const env of common_release_envs) {\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\nexport function getOtelEnabled() {\n    return (getEnvironmentVariable(\"OTEL_ENABLED\") === \"true\" ||\n        getLangSmithEnvironmentVariable(\"OTEL_ENABLED\") === \"true\");\n}\n","// Should not import any OTEL packages to avoid pulling in optional deps.\nimport { getOtelEnabled } from \"../utils/env.js\";\nclass MockTracer {\n    constructor() {\n        Object.defineProperty(this, \"hasWarned\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    startActiveSpan(_name, ...args) {\n        if (!this.hasWarned && getOtelEnabled()) {\n            console.warn(\"You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. \" +\n                'Please add:\\n```\\nimport { initializeOTEL } from \"langsmith/experimental/otel/setup\";\\ninitializeOTEL();\\n```\\nat the beginning of your code.');\n            this.hasWarned = true;\n        }\n        // Handle different overloads:\n        // startActiveSpan(name, fn)\n        // startActiveSpan(name, options, fn)\n        // startActiveSpan(name, options, context, fn)\n        let fn;\n        if (args.length === 1 && typeof args[0] === \"function\") {\n            fn = args[0];\n        }\n        else if (args.length === 2 && typeof args[1] === \"function\") {\n            fn = args[1];\n        }\n        else if (args.length === 3 && typeof args[2] === \"function\") {\n            fn = args[2];\n        }\n        if (typeof fn === \"function\") {\n            return fn();\n        }\n        return undefined;\n    }\n}\nclass MockOTELTrace {\n    constructor() {\n        Object.defineProperty(this, \"mockTracer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new MockTracer()\n        });\n    }\n    getTracer(_name, _version) {\n        return this.mockTracer;\n    }\n    getActiveSpan() {\n        return undefined;\n    }\n    setSpan(context, _span) {\n        return context;\n    }\n    getSpan(_context) {\n        return undefined;\n    }\n    setSpanContext(context, _spanContext) {\n        return context;\n    }\n    getTracerProvider() {\n        return undefined;\n    }\n    setGlobalTracerProvider(_tracerProvider) {\n        return false;\n    }\n}\nclass MockOTELContext {\n    active() {\n        return {};\n    }\n    with(_context, fn) {\n        return fn();\n    }\n}\nconst OTEL_TRACE_KEY = Symbol.for(\"ls:otel_trace\");\nconst OTEL_CONTEXT_KEY = Symbol.for(\"ls:otel_context\");\nconst OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for(\"ls:otel_get_default_otlp_tracer_provider\");\nconst mockOTELTrace = new MockOTELTrace();\nconst mockOTELContext = new MockOTELContext();\nclass OTELProvider {\n    getTraceInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;\n    }\n    getContextInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;\n    }\n    initializeGlobalInstances(otel) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_TRACE_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_TRACE_KEY] = otel.trace;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_CONTEXT_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_CONTEXT_KEY] = otel.context;\n        }\n    }\n    setDefaultOTLPTracerComponents(components) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;\n    }\n    getDefaultOTLPTracerComponents() {\n        return (globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ??\n            undefined);\n    }\n}\nexport const OTELProviderSingleton = new OTELProvider();\n/**\n * Get the current OTEL trace instance.\n * Returns a mock implementation if OTEL is not available.\n */\nexport function getOTELTrace() {\n    return OTELProviderSingleton.getTraceInstance();\n}\n/**\n * Get the current OTEL context instance.\n * Returns a mock implementation if OTEL is not available.\n */\nexport function getOTELContext() {\n    return OTELProviderSingleton.getContextInstance();\n}\n/**\n * Initialize the global OTEL instances.\n * Should be called once when OTEL packages are available.\n */\nexport function setOTELInstances(otel) {\n    OTELProviderSingleton.initializeGlobalInstances(otel);\n}\n/**\n * Set a getter function for the default OTLP tracer provider.\n * This allows lazy initialization of the tracer provider.\n */\nexport function setDefaultOTLPTracerComponents(components) {\n    OTELProviderSingleton.setDefaultOTLPTracerComponents(components);\n}\n/**\n * Get the default OTLP tracer provider instance.\n * Returns undefined if not set.\n */\nexport function getDefaultOTLPTracerComponents() {\n    return OTELProviderSingleton.getDefaultOTLPTracerComponents();\n}\n","import * as constants from \"./constants.js\";\nimport { getOTELTrace } from \"../../singletons/otel.js\";\nconst WELL_KNOWN_OPERATION_NAMES = {\n    llm: \"chat\",\n    tool: \"execute_tool\",\n    retriever: \"embeddings\",\n    embedding: \"embeddings\",\n    prompt: \"chat\",\n};\nfunction getOperationName(runType) {\n    return WELL_KNOWN_OPERATION_NAMES[runType] || runType;\n}\nexport class LangSmithToOTELTranslator {\n    constructor() {\n        Object.defineProperty(this, \"spans\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    exportBatch(operations, otelContextMap) {\n        for (const op of operations) {\n            try {\n                if (!op.run) {\n                    continue;\n                }\n                if (op.operation === \"post\") {\n                    const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));\n                    if (span && !op.run.end_time) {\n                        this.spans.set(op.id, span);\n                    }\n                }\n                else {\n                    this.updateSpanForRun(op, op.run);\n                }\n            }\n            catch (e) {\n                console.error(`Error processing operation ${op.id}:`, e);\n            }\n        }\n    }\n    createSpanForRun(op, runInfo, otelContext) {\n        const activeSpan = otelContext && getOTELTrace().getSpan(otelContext);\n        if (!activeSpan) {\n            return;\n        }\n        try {\n            return this.finishSpanSetup(activeSpan, runInfo, op);\n        }\n        catch (e) {\n            console.error(`Failed to create span for run ${op.id}:`, e);\n            return undefined;\n        }\n    }\n    finishSpanSetup(span, runInfo, op) {\n        // Set all attributes\n        this.setSpanAttributes(span, runInfo, op);\n        // Set status based on error\n        if (runInfo.error) {\n            span.setStatus({ code: 2 }); // ERROR status\n            span.recordException(new Error(runInfo.error));\n        }\n        else {\n            span.setStatus({ code: 1 }); // OK status\n        }\n        // End the span if end_time is present\n        if (runInfo.end_time) {\n            span.end(new Date(runInfo.end_time));\n        }\n        return span;\n    }\n    updateSpanForRun(op, runInfo) {\n        try {\n            const span = this.spans.get(op.id);\n            if (!span) {\n                console.debug(`No span found for run ${op.id} during update`);\n                return;\n            }\n            // Update attributes\n            this.setSpanAttributes(span, runInfo, op);\n            // Update status based on error\n            if (runInfo.error) {\n                span.setStatus({ code: 2 }); // ERROR status\n                span.recordException(new Error(runInfo.error));\n            }\n            else {\n                span.setStatus({ code: 1 }); // OK status\n            }\n            // End the span if end_time is present\n            const endTime = runInfo.end_time;\n            if (endTime) {\n                span.end(new Date(endTime));\n                this.spans.delete(op.id);\n            }\n        }\n        catch (e) {\n            console.error(`Failed to update span for run ${op.id}:`, e);\n        }\n    }\n    extractModelName(runInfo) {\n        // Try to get model name from metadata\n        if (runInfo.extra?.metadata) {\n            const metadata = runInfo.extra.metadata;\n            // First check for ls_model_name in metadata\n            if (metadata.ls_model_name) {\n                return metadata.ls_model_name;\n            }\n            // Then check invocation_params for model info\n            if (metadata.invocation_params) {\n                const invocationParams = metadata.invocation_params;\n                if (invocationParams.model) {\n                    return invocationParams.model;\n                }\n                else if (invocationParams.model_name) {\n                    return invocationParams.model_name;\n                }\n            }\n        }\n        return;\n    }\n    setSpanAttributes(span, runInfo, op) {\n        if (\"run_type\" in runInfo && runInfo.run_type) {\n            span.setAttribute(constants.LANGSMITH_RUN_TYPE, runInfo.run_type);\n            // Set GenAI attributes according to OTEL semantic conventions\n            const operationName = getOperationName(runInfo.run_type || \"chain\");\n            span.setAttribute(constants.GEN_AI_OPERATION_NAME, operationName);\n        }\n        if (\"name\" in runInfo && runInfo.name) {\n            span.setAttribute(constants.LANGSMITH_NAME, runInfo.name);\n        }\n        if (\"session_id\" in runInfo && runInfo.session_id) {\n            span.setAttribute(constants.LANGSMITH_SESSION_ID, runInfo.session_id);\n        }\n        if (\"session_name\" in runInfo && runInfo.session_name) {\n            span.setAttribute(constants.LANGSMITH_SESSION_NAME, runInfo.session_name);\n        }\n        // Set gen_ai.system\n        this.setGenAiSystem(span, runInfo);\n        // Set model name if available\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            span.setAttribute(constants.GEN_AI_REQUEST_MODEL, modelName);\n        }\n        // Set token usage information\n        if (\"prompt_tokens\" in runInfo &&\n            typeof runInfo.prompt_tokens === \"number\") {\n            span.setAttribute(constants.GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);\n        }\n        if (\"completion_tokens\" in runInfo &&\n            typeof runInfo.completion_tokens === \"number\") {\n            span.setAttribute(constants.GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);\n        }\n        if (\"total_tokens\" in runInfo && typeof runInfo.total_tokens === \"number\") {\n            span.setAttribute(constants.GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);\n        }\n        // Set other parameters from invocation_params\n        this.setInvocationParameters(span, runInfo);\n        // Set metadata and tags if available\n        const metadata = runInfo.extra?.metadata || {};\n        for (const [key, value] of Object.entries(metadata)) {\n            if (value !== null && value !== undefined) {\n                span.setAttribute(`${constants.LANGSMITH_METADATA}.${key}`, String(value));\n            }\n        }\n        const tags = runInfo.tags;\n        if (tags && Array.isArray(tags)) {\n            span.setAttribute(constants.LANGSMITH_TAGS, tags.join(\", \"));\n        }\n        else if (tags) {\n            span.setAttribute(constants.LANGSMITH_TAGS, String(tags));\n        }\n        // Support additional serialized attributes, if present\n        if (\"serialized\" in runInfo && typeof runInfo.serialized === \"object\") {\n            const serialized = runInfo.serialized;\n            if (serialized.name) {\n                span.setAttribute(constants.GEN_AI_SERIALIZED_NAME, String(serialized.name));\n            }\n            if (serialized.signature) {\n                span.setAttribute(constants.GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));\n            }\n            if (serialized.doc) {\n                span.setAttribute(constants.GEN_AI_SERIALIZED_DOC, String(serialized.doc));\n            }\n        }\n        // Set inputs/outputs if available\n        this.setIOAttributes(span, op);\n    }\n    setGenAiSystem(span, runInfo) {\n        // Default to \"langchain\" if we can't determine the system\n        let system = \"langchain\";\n        // Extract model name to determine the system\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            const modelLower = modelName.toLowerCase();\n            if (modelLower.includes(\"anthropic\") || modelLower.startsWith(\"claude\")) {\n                system = \"anthropic\";\n            }\n            else if (modelLower.includes(\"bedrock\")) {\n                system = \"aws.bedrock\";\n            }\n            else if (modelLower.includes(\"azure\") &&\n                modelLower.includes(\"openai\")) {\n                system = \"az.ai.openai\";\n            }\n            else if (modelLower.includes(\"azure\") &&\n                modelLower.includes(\"inference\")) {\n                system = \"az.ai.inference\";\n            }\n            else if (modelLower.includes(\"cohere\")) {\n                system = \"cohere\";\n            }\n            else if (modelLower.includes(\"deepseek\")) {\n                system = \"deepseek\";\n            }\n            else if (modelLower.includes(\"gemini\")) {\n                system = \"gemini\";\n            }\n            else if (modelLower.includes(\"groq\")) {\n                system = \"groq\";\n            }\n            else if (modelLower.includes(\"watson\") || modelLower.includes(\"ibm\")) {\n                system = \"ibm.watsonx.ai\";\n            }\n            else if (modelLower.includes(\"mistral\")) {\n                system = \"mistral_ai\";\n            }\n            else if (modelLower.includes(\"gpt\") || modelLower.includes(\"openai\")) {\n                system = \"openai\";\n            }\n            else if (modelLower.includes(\"perplexity\") ||\n                modelLower.includes(\"sonar\")) {\n                system = \"perplexity\";\n            }\n            else if (modelLower.includes(\"vertex\")) {\n                system = \"vertex_ai\";\n            }\n            else if (modelLower.includes(\"xai\") || modelLower.includes(\"grok\")) {\n                system = \"xai\";\n            }\n        }\n        span.setAttribute(constants.GEN_AI_SYSTEM, system);\n    }\n    setInvocationParameters(span, runInfo) {\n        if (!runInfo.extra?.metadata?.invocation_params) {\n            return;\n        }\n        const invocationParams = runInfo.extra.metadata.invocation_params;\n        // Set relevant invocation parameters\n        if (invocationParams.max_tokens !== undefined) {\n            span.setAttribute(constants.GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);\n        }\n        if (invocationParams.temperature !== undefined) {\n            span.setAttribute(constants.GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);\n        }\n        if (invocationParams.top_p !== undefined) {\n            span.setAttribute(constants.GEN_AI_REQUEST_TOP_P, invocationParams.top_p);\n        }\n        if (invocationParams.frequency_penalty !== undefined) {\n            span.setAttribute(constants.GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);\n        }\n        if (invocationParams.presence_penalty !== undefined) {\n            span.setAttribute(constants.GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);\n        }\n    }\n    setIOAttributes(span, op) {\n        if (op.run.inputs) {\n            try {\n                const inputs = op.run.inputs;\n                if (typeof inputs === \"object\" && inputs !== null) {\n                    if (inputs.model && Array.isArray(inputs.messages)) {\n                        span.setAttribute(constants.GEN_AI_REQUEST_MODEL, inputs.model);\n                    }\n                    // Set additional request attributes if available\n                    if (inputs.stream !== undefined) {\n                        span.setAttribute(constants.LANGSMITH_REQUEST_STREAMING, inputs.stream);\n                    }\n                    if (inputs.extra_headers) {\n                        span.setAttribute(constants.LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));\n                    }\n                    if (inputs.extra_query) {\n                        span.setAttribute(constants.GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));\n                    }\n                    if (inputs.extra_body) {\n                        span.setAttribute(constants.GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));\n                    }\n                }\n                span.setAttribute(constants.GENAI_PROMPT, JSON.stringify(inputs));\n            }\n            catch (e) {\n                console.debug(`Failed to process inputs for run ${op.id}`, e);\n            }\n        }\n        if (op.run.outputs) {\n            try {\n                const outputs = op.run.outputs;\n                // Extract token usage from outputs (for LLM runs)\n                const tokenUsage = this.getUnifiedRunTokens(outputs);\n                if (tokenUsage) {\n                    span.setAttribute(constants.GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);\n                    span.setAttribute(constants.GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);\n                    span.setAttribute(constants.GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);\n                }\n                if (outputs && typeof outputs === \"object\") {\n                    if (outputs.model) {\n                        span.setAttribute(constants.GEN_AI_RESPONSE_MODEL, String(outputs.model));\n                    }\n                    // Extract additional response attributes\n                    if (outputs.id) {\n                        span.setAttribute(constants.GEN_AI_RESPONSE_ID, outputs.id);\n                    }\n                    if (outputs.choices && Array.isArray(outputs.choices)) {\n                        const finishReasons = outputs.choices\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            .map((choice) => choice.finish_reason)\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            .filter((reason) => reason)\n                            .map(String);\n                        if (finishReasons.length > 0) {\n                            span.setAttribute(constants.GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(\", \"));\n                        }\n                    }\n                    if (outputs.service_tier) {\n                        span.setAttribute(constants.GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);\n                    }\n                    if (outputs.system_fingerprint) {\n                        span.setAttribute(constants.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);\n                    }\n                    if (outputs.usage_metadata &&\n                        typeof outputs.usage_metadata === \"object\") {\n                        const usageMetadata = outputs.usage_metadata;\n                        if (usageMetadata.input_token_details) {\n                            span.setAttribute(constants.GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));\n                        }\n                        if (usageMetadata.output_token_details) {\n                            span.setAttribute(constants.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));\n                        }\n                    }\n                }\n                span.setAttribute(constants.GENAI_COMPLETION, JSON.stringify(outputs));\n            }\n            catch (e) {\n                console.debug(`Failed to process outputs for run ${op.id}`, e);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getUnifiedRunTokens(outputs) {\n        if (!outputs) {\n            return null;\n        }\n        // Search in non-generations lists\n        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);\n        if (tokenUsage) {\n            return tokenUsage;\n        }\n        // Find if direct kwarg in outputs\n        const keys = Object.keys(outputs);\n        for (const key of keys) {\n            const haystack = outputs[key];\n            if (!haystack || typeof haystack !== \"object\") {\n                continue;\n            }\n            tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);\n            if (tokenUsage) {\n                return tokenUsage;\n            }\n            if (haystack.lc === 1 &&\n                haystack.kwargs &&\n                typeof haystack.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        // Find in generations\n        const generations = outputs.generations || [];\n        if (!Array.isArray(generations)) {\n            return null;\n        }\n        const flatGenerations = Array.isArray(generations[0])\n            ? generations.flat()\n            : generations;\n        for (const generation of flatGenerations) {\n            if (typeof generation === \"object\" &&\n                generation.message &&\n                typeof generation.message === \"object\" &&\n                generation.message.kwargs &&\n                typeof generation.message.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        return null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extractUnifiedRunTokens(outputs) {\n        if (!outputs || typeof outputs !== \"object\") {\n            return null;\n        }\n        if (typeof outputs.input_tokens !== \"number\" ||\n            typeof outputs.output_tokens !== \"number\") {\n            return null;\n        }\n        return [outputs.input_tokens, outputs.output_tokens];\n    }\n}\n","import { $constructor } from \"./core.js\";\nimport * as util from \"./util.js\";\nconst initializer = (inst, def) => {\n    inst.name = \"$ZodError\";\n    Object.defineProperty(inst, \"_zod\", {\n        value: inst._zod,\n        enumerable: false,\n    });\n    Object.defineProperty(inst, \"issues\", {\n        value: def,\n        enumerable: false,\n    });\n    inst.message = JSON.stringify(def, util.jsonStringifyReplacer, 2);\n    Object.defineProperty(inst, \"toString\", {\n        value: () => inst.message,\n        enumerable: false,\n    });\n};\nexport const $ZodError = $constructor(\"$ZodError\", initializer);\nexport const $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nexport function flattenError(error, mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of error.issues) {\n        if (sub.path.length > 0) {\n            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n            fieldErrors[sub.path[0]].push(mapper(sub));\n        }\n        else {\n            formErrors.push(mapper(sub));\n        }\n    }\n    return { formErrors, fieldErrors };\n}\nexport function formatError(error, mapper = (issue) => issue.message) {\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                issue.errors.map((issues) => processError({ issues }));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues });\n            }\n            else if (issue.path.length === 0) {\n                fieldErrors._errors.push(mapper(issue));\n            }\n            else {\n                let curr = fieldErrors;\n                let i = 0;\n                while (i < issue.path.length) {\n                    const el = issue.path[i];\n                    const terminal = i === issue.path.length - 1;\n                    if (!terminal) {\n                        curr[el] = curr[el] || { _errors: [] };\n                    }\n                    else {\n                        curr[el] = curr[el] || { _errors: [] };\n                        curr[el]._errors.push(mapper(issue));\n                    }\n                    curr = curr[el];\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return fieldErrors;\n}\nexport function treeifyError(error, mapper = (issue) => issue.message) {\n    const result = { errors: [] };\n    const processError = (error, path = []) => {\n        var _a, _b;\n        for (const issue of error.issues) {\n            if (issue.code === \"invalid_union\" && issue.errors.length) {\n                // regular union error\n                issue.errors.map((issues) => processError({ issues }, issue.path));\n            }\n            else if (issue.code === \"invalid_key\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else if (issue.code === \"invalid_element\") {\n                processError({ issues: issue.issues }, issue.path);\n            }\n            else {\n                const fullpath = [...path, ...issue.path];\n                if (fullpath.length === 0) {\n                    result.errors.push(mapper(issue));\n                    continue;\n                }\n                let curr = result;\n                let i = 0;\n                while (i < fullpath.length) {\n                    const el = fullpath[i];\n                    const terminal = i === fullpath.length - 1;\n                    if (typeof el === \"string\") {\n                        curr.properties ?? (curr.properties = {});\n                        (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });\n                        curr = curr.properties[el];\n                    }\n                    else {\n                        curr.items ?? (curr.items = []);\n                        (_b = curr.items)[el] ?? (_b[el] = { errors: [] });\n                        curr = curr.items[el];\n                    }\n                    if (terminal) {\n                        curr.errors.push(mapper(issue));\n                    }\n                    i++;\n                }\n            }\n        }\n    };\n    processError(error);\n    return result;\n}\n/** Format a ZodError as a human-readable string in the following form.\n *\n * From\n *\n * ```ts\n * ZodError {\n *   issues: [\n *     {\n *       expected: 'string',\n *       code: 'invalid_type',\n *       path: [ 'username' ],\n *       message: 'Invalid input: expected string'\n *     },\n *     {\n *       expected: 'number',\n *       code: 'invalid_type',\n *       path: [ 'favoriteNumbers', 1 ],\n *       message: 'Invalid input: expected number'\n *     }\n *   ];\n * }\n * ```\n *\n * to\n *\n * ```\n * username\n *    Expected number, received string at \"username\n * favoriteNumbers[0]\n *    Invalid input: expected number\n * ```\n */\nexport function toDotPath(_path) {\n    const segs = [];\n    const path = _path.map((seg) => (typeof seg === \"object\" ? seg.key : seg));\n    for (const seg of path) {\n        if (typeof seg === \"number\")\n            segs.push(`[${seg}]`);\n        else if (typeof seg === \"symbol\")\n            segs.push(`[${JSON.stringify(String(seg))}]`);\n        else if (/[^\\w$]/.test(seg))\n            segs.push(`[${JSON.stringify(seg)}]`);\n        else {\n            if (segs.length)\n                segs.push(\".\");\n            segs.push(seg);\n        }\n    }\n    return segs.join(\"\");\n}\nexport function prettifyError(error) {\n    const lines = [];\n    // sort by path length\n    const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);\n    // Process each issue\n    for (const issue of issues) {\n        lines.push(` ${issue.message}`);\n        if (issue.path?.length)\n            lines.push(`   at ${toDotPath(issue.path)}`);\n    }\n    // Convert Map to formatted string\n    return lines.join(\"\\n\");\n}\n","import { ZodIssueCode } from \"../ZodError.js\";\nimport { util, ZodParsedType } from \"../helpers/util.js\";\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                }\n                else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"bigint\")\n                message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\")\n                message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\nexport default errorMap;\n","import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;","import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return unsafeStringify(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","import v35 from './v35.js';\nimport sha1 from './sha1.js';\nconst v5 = v35('v5', 0x50, sha1);\nexport default v5;","import { OrderResolutionStateType, WarehouseResultType } from '../state';\r\n\r\n// Simulated warehouse data\r\nconst warehouseLocations = [\r\n    { id: 'WH-001', name: 'Downtown Warehouse', stockLevel: 150 },\r\n    { id: 'WH-002', name: 'North District Hub', stockLevel: 89 },\r\n    { id: 'WH-003', name: 'Airport Logistics', stockLevel: 234 },\r\n];\r\n\r\n/**\r\n * Check warehouse inventory for order fulfillment\r\n */\r\nexport async function checkWarehouseInventory(\r\n    state: OrderResolutionStateType\r\n): Promise<WarehouseResultType> {\r\n    // Simulate API delay\r\n    await new Promise(resolve => setTimeout(resolve, 1500));\r\n\r\n    // Find a warehouse with sufficient stock\r\n    const requiredItems = state.orderDetails.items;\r\n    const availableWarehouse = warehouseLocations.find(\r\n        wh => wh.stockLevel >= requiredItems\r\n    );\r\n\r\n    if (!availableWarehouse) {\r\n        throw new Error('No warehouse has sufficient stock');\r\n    }\r\n\r\n    // Calculate prep time based on order size\r\n    const estimatedPrepTime = Math.ceil(requiredItems * 2.5);\r\n\r\n    return {\r\n        available: true,\r\n        stockLevel: availableWarehouse.stockLevel,\r\n        location: availableWarehouse.name,\r\n        estimatedPrepTime,\r\n    };\r\n}\r\n\r\n/**\r\n * Reserve items in warehouse\r\n */\r\nexport async function reserveWarehouseItems(\r\n    orderId: string,\r\n    items: number,\r\n    warehouseLocation: string\r\n): Promise<boolean> {\r\n    // Simulate reservation\r\n    await new Promise(resolve => setTimeout(resolve, 500));\r\n    console.log(`Reserved ${items} items at ${warehouseLocation} for order ${orderId}`);\r\n    return true;\r\n}\r\n","import { $ZodRegistry, globalRegistry } from \"./registries.js\";\nimport { getEnumValues } from \"./util.js\";\nexport class JSONSchemaGenerator {\n    constructor(params) {\n        this.counter = 0;\n        this.metadataRegistry = params?.metadata ?? globalRegistry;\n        this.target = params?.target ?? \"draft-2020-12\";\n        this.unrepresentable = params?.unrepresentable ?? \"throw\";\n        this.override = params?.override ?? (() => { });\n        this.io = params?.io ?? \"output\";\n        this.seen = new Map();\n    }\n    process(schema, _params = { path: [], schemaPath: [] }) {\n        var _a;\n        const def = schema._zod.def;\n        const formatMap = {\n            guid: \"uuid\",\n            url: \"uri\",\n            datetime: \"date-time\",\n            json_string: \"json-string\",\n            regex: \"\", // do not set\n        };\n        // check for schema in seens\n        const seen = this.seen.get(schema);\n        if (seen) {\n            seen.count++;\n            // check if cycle\n            const isCycle = _params.schemaPath.includes(schema);\n            if (isCycle) {\n                seen.cycle = _params.path;\n            }\n            return seen.schema;\n        }\n        // initialize\n        const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };\n        this.seen.set(schema, result);\n        // custom method overrides default behavior\n        const overrideSchema = schema._zod.toJSONSchema?.();\n        if (overrideSchema) {\n            result.schema = overrideSchema;\n        }\n        else {\n            const params = {\n                ..._params,\n                schemaPath: [..._params.schemaPath, schema],\n                path: _params.path,\n            };\n            const parent = schema._zod.parent;\n            if (parent) {\n                // schema was cloned from another schema\n                result.ref = parent;\n                this.process(parent, params);\n                this.seen.get(parent).isParent = true;\n            }\n            else {\n                const _json = result.schema;\n                switch (def.type) {\n                    case \"string\": {\n                        const json = _json;\n                        json.type = \"string\";\n                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod\n                            .bag;\n                        if (typeof minimum === \"number\")\n                            json.minLength = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxLength = maximum;\n                        // custom pattern overrides format\n                        if (format) {\n                            json.format = formatMap[format] ?? format;\n                            if (json.format === \"\")\n                                delete json.format; // empty format is not valid\n                        }\n                        if (contentEncoding)\n                            json.contentEncoding = contentEncoding;\n                        if (patterns && patterns.size > 0) {\n                            const regexes = [...patterns];\n                            if (regexes.length === 1)\n                                json.pattern = regexes[0].source;\n                            else if (regexes.length > 1) {\n                                result.schema.allOf = [\n                                    ...regexes.map((regex) => ({\n                                        ...(this.target === \"draft-7\" || this.target === \"draft-4\" || this.target === \"openapi-3.0\"\n                                            ? { type: \"string\" }\n                                            : {}),\n                                        pattern: regex.source,\n                                    })),\n                                ];\n                            }\n                        }\n                        break;\n                    }\n                    case \"number\": {\n                        const json = _json;\n                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;\n                        if (typeof format === \"string\" && format.includes(\"int\"))\n                            json.type = \"integer\";\n                        else\n                            json.type = \"number\";\n                        if (typeof exclusiveMinimum === \"number\") {\n                            if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                                json.minimum = exclusiveMinimum;\n                                json.exclusiveMinimum = true;\n                            }\n                            else {\n                                json.exclusiveMinimum = exclusiveMinimum;\n                            }\n                        }\n                        if (typeof minimum === \"number\") {\n                            json.minimum = minimum;\n                            if (typeof exclusiveMinimum === \"number\" && this.target !== \"draft-4\") {\n                                if (exclusiveMinimum >= minimum)\n                                    delete json.minimum;\n                                else\n                                    delete json.exclusiveMinimum;\n                            }\n                        }\n                        if (typeof exclusiveMaximum === \"number\") {\n                            if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                                json.maximum = exclusiveMaximum;\n                                json.exclusiveMaximum = true;\n                            }\n                            else {\n                                json.exclusiveMaximum = exclusiveMaximum;\n                            }\n                        }\n                        if (typeof maximum === \"number\") {\n                            json.maximum = maximum;\n                            if (typeof exclusiveMaximum === \"number\" && this.target !== \"draft-4\") {\n                                if (exclusiveMaximum <= maximum)\n                                    delete json.maximum;\n                                else\n                                    delete json.exclusiveMaximum;\n                            }\n                        }\n                        if (typeof multipleOf === \"number\")\n                            json.multipleOf = multipleOf;\n                        break;\n                    }\n                    case \"boolean\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"bigint\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"BigInt cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"symbol\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Symbols cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"null\": {\n                        if (this.target === \"openapi-3.0\") {\n                            _json.type = \"string\";\n                            _json.nullable = true;\n                            _json.enum = [null];\n                        }\n                        else\n                            _json.type = \"null\";\n                        break;\n                    }\n                    case \"any\": {\n                        break;\n                    }\n                    case \"unknown\": {\n                        break;\n                    }\n                    case \"undefined\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Undefined cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"void\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Void cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"never\": {\n                        _json.not = {};\n                        break;\n                    }\n                    case \"date\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Date cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"array\": {\n                        const json = _json;\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        json.type = \"array\";\n                        json.items = this.process(def.element, { ...params, path: [...params.path, \"items\"] });\n                        break;\n                    }\n                    case \"object\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        json.properties = {};\n                        const shape = def.shape; // params.shapeCache.get(schema)!;\n                        for (const key in shape) {\n                            json.properties[key] = this.process(shape[key], {\n                                ...params,\n                                path: [...params.path, \"properties\", key],\n                            });\n                        }\n                        // required keys\n                        const allKeys = new Set(Object.keys(shape));\n                        // const optionalKeys = new Set(def.optional);\n                        const requiredKeys = new Set([...allKeys].filter((key) => {\n                            const v = def.shape[key]._zod;\n                            if (this.io === \"input\") {\n                                return v.optin === undefined;\n                            }\n                            else {\n                                return v.optout === undefined;\n                            }\n                        }));\n                        if (requiredKeys.size > 0) {\n                            json.required = Array.from(requiredKeys);\n                        }\n                        // catchall\n                        if (def.catchall?._zod.def.type === \"never\") {\n                            // strict\n                            json.additionalProperties = false;\n                        }\n                        else if (!def.catchall) {\n                            // regular\n                            if (this.io === \"output\")\n                                json.additionalProperties = false;\n                        }\n                        else if (def.catchall) {\n                            json.additionalProperties = this.process(def.catchall, {\n                                ...params,\n                                path: [...params.path, \"additionalProperties\"],\n                            });\n                        }\n                        break;\n                    }\n                    case \"union\": {\n                        const json = _json;\n                        // Discriminated unions use oneOf (exactly one match) instead of anyOf (one or more matches)\n                        // because the discriminator field ensures mutual exclusivity between options in JSON Schema\n                        const isDiscriminated = def.discriminator !== undefined;\n                        const options = def.options.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, isDiscriminated ? \"oneOf\" : \"anyOf\", i],\n                        }));\n                        if (isDiscriminated) {\n                            json.oneOf = options;\n                        }\n                        else {\n                            json.anyOf = options;\n                        }\n                        break;\n                    }\n                    case \"intersection\": {\n                        const json = _json;\n                        const a = this.process(def.left, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 0],\n                        });\n                        const b = this.process(def.right, {\n                            ...params,\n                            path: [...params.path, \"allOf\", 1],\n                        });\n                        const isSimpleIntersection = (val) => \"allOf\" in val && Object.keys(val).length === 1;\n                        const allOf = [\n                            ...(isSimpleIntersection(a) ? a.allOf : [a]),\n                            ...(isSimpleIntersection(b) ? b.allOf : [b]),\n                        ];\n                        json.allOf = allOf;\n                        break;\n                    }\n                    case \"tuple\": {\n                        const json = _json;\n                        json.type = \"array\";\n                        const prefixPath = this.target === \"draft-2020-12\" ? \"prefixItems\" : \"items\";\n                        const restPath = this.target === \"draft-2020-12\" ? \"items\" : this.target === \"openapi-3.0\" ? \"items\" : \"additionalItems\";\n                        const prefixItems = def.items.map((x, i) => this.process(x, {\n                            ...params,\n                            path: [...params.path, prefixPath, i],\n                        }));\n                        const rest = def.rest\n                            ? this.process(def.rest, {\n                                ...params,\n                                path: [...params.path, restPath, ...(this.target === \"openapi-3.0\" ? [def.items.length] : [])],\n                            })\n                            : null;\n                        if (this.target === \"draft-2020-12\") {\n                            json.prefixItems = prefixItems;\n                            if (rest) {\n                                json.items = rest;\n                            }\n                        }\n                        else if (this.target === \"openapi-3.0\") {\n                            json.items = {\n                                anyOf: prefixItems,\n                            };\n                            if (rest) {\n                                json.items.anyOf.push(rest);\n                            }\n                            json.minItems = prefixItems.length;\n                            if (!rest) {\n                                json.maxItems = prefixItems.length;\n                            }\n                        }\n                        else {\n                            json.items = prefixItems;\n                            if (rest) {\n                                json.additionalItems = rest;\n                            }\n                        }\n                        // length\n                        const { minimum, maximum } = schema._zod.bag;\n                        if (typeof minimum === \"number\")\n                            json.minItems = minimum;\n                        if (typeof maximum === \"number\")\n                            json.maxItems = maximum;\n                        break;\n                    }\n                    case \"record\": {\n                        const json = _json;\n                        json.type = \"object\";\n                        if (this.target === \"draft-7\" || this.target === \"draft-2020-12\") {\n                            json.propertyNames = this.process(def.keyType, {\n                                ...params,\n                                path: [...params.path, \"propertyNames\"],\n                            });\n                        }\n                        json.additionalProperties = this.process(def.valueType, {\n                            ...params,\n                            path: [...params.path, \"additionalProperties\"],\n                        });\n                        break;\n                    }\n                    case \"map\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Map cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"set\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Set cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"enum\": {\n                        const json = _json;\n                        const values = getEnumValues(def.entries);\n                        // Number enums can have both string and number values\n                        if (values.every((v) => typeof v === \"number\"))\n                            json.type = \"number\";\n                        if (values.every((v) => typeof v === \"string\"))\n                            json.type = \"string\";\n                        json.enum = values;\n                        break;\n                    }\n                    case \"literal\": {\n                        const json = _json;\n                        const vals = [];\n                        for (const val of def.values) {\n                            if (val === undefined) {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"Literal `undefined` cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    // do not add to vals\n                                }\n                            }\n                            else if (typeof val === \"bigint\") {\n                                if (this.unrepresentable === \"throw\") {\n                                    throw new Error(\"BigInt literals cannot be represented in JSON Schema\");\n                                }\n                                else {\n                                    vals.push(Number(val));\n                                }\n                            }\n                            else {\n                                vals.push(val);\n                            }\n                        }\n                        if (vals.length === 0) {\n                            // do nothing (an undefined literal was stripped)\n                        }\n                        else if (vals.length === 1) {\n                            const val = vals[0];\n                            json.type = val === null ? \"null\" : typeof val;\n                            if (this.target === \"draft-4\" || this.target === \"openapi-3.0\") {\n                                json.enum = [val];\n                            }\n                            else {\n                                json.const = val;\n                            }\n                        }\n                        else {\n                            if (vals.every((v) => typeof v === \"number\"))\n                                json.type = \"number\";\n                            if (vals.every((v) => typeof v === \"string\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => typeof v === \"boolean\"))\n                                json.type = \"string\";\n                            if (vals.every((v) => v === null))\n                                json.type = \"null\";\n                            json.enum = vals;\n                        }\n                        break;\n                    }\n                    case \"file\": {\n                        const json = _json;\n                        const file = {\n                            type: \"string\",\n                            format: \"binary\",\n                            contentEncoding: \"binary\",\n                        };\n                        const { minimum, maximum, mime } = schema._zod.bag;\n                        if (minimum !== undefined)\n                            file.minLength = minimum;\n                        if (maximum !== undefined)\n                            file.maxLength = maximum;\n                        if (mime) {\n                            if (mime.length === 1) {\n                                file.contentMediaType = mime[0];\n                                Object.assign(json, file);\n                            }\n                            else {\n                                json.anyOf = mime.map((m) => {\n                                    const mFile = { ...file, contentMediaType: m };\n                                    return mFile;\n                                });\n                            }\n                        }\n                        else {\n                            Object.assign(json, file);\n                        }\n                        // if (this.unrepresentable === \"throw\") {\n                        //   throw new Error(\"File cannot be represented in JSON Schema\");\n                        // }\n                        break;\n                    }\n                    case \"transform\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Transforms cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"nullable\": {\n                        const inner = this.process(def.innerType, params);\n                        if (this.target === \"openapi-3.0\") {\n                            result.ref = def.innerType;\n                            _json.nullable = true;\n                        }\n                        else {\n                            _json.anyOf = [inner, { type: \"null\" }];\n                        }\n                        break;\n                    }\n                    case \"nonoptional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"success\": {\n                        const json = _json;\n                        json.type = \"boolean\";\n                        break;\n                    }\n                    case \"default\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"prefault\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        if (this.io === \"input\")\n                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));\n                        break;\n                    }\n                    case \"catch\": {\n                        // use conditionals\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        let catchValue;\n                        try {\n                            catchValue = def.catchValue(undefined);\n                        }\n                        catch {\n                            throw new Error(\"Dynamic catch values are not supported in JSON Schema\");\n                        }\n                        _json.default = catchValue;\n                        break;\n                    }\n                    case \"nan\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"NaN cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"template_literal\": {\n                        const json = _json;\n                        const pattern = schema._zod.pattern;\n                        if (!pattern)\n                            throw new Error(\"Pattern not found in template literal\");\n                        json.type = \"string\";\n                        json.pattern = pattern.source;\n                        break;\n                    }\n                    case \"pipe\": {\n                        const innerType = this.io === \"input\" ? (def.in._zod.def.type === \"transform\" ? def.out : def.in) : def.out;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"readonly\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        _json.readOnly = true;\n                        break;\n                    }\n                    // passthrough types\n                    case \"promise\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"optional\": {\n                        this.process(def.innerType, params);\n                        result.ref = def.innerType;\n                        break;\n                    }\n                    case \"lazy\": {\n                        const innerType = schema._zod.innerType;\n                        this.process(innerType, params);\n                        result.ref = innerType;\n                        break;\n                    }\n                    case \"custom\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Custom types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    case \"function\": {\n                        if (this.unrepresentable === \"throw\") {\n                            throw new Error(\"Function types cannot be represented in JSON Schema\");\n                        }\n                        break;\n                    }\n                    default: {\n                        def;\n                    }\n                }\n            }\n        }\n        // metadata\n        const meta = this.metadataRegistry.get(schema);\n        if (meta)\n            Object.assign(result.schema, meta);\n        if (this.io === \"input\" && isTransforming(schema)) {\n            // examples/defaults only apply to output type of pipe\n            delete result.schema.examples;\n            delete result.schema.default;\n        }\n        // set prefault as default\n        if (this.io === \"input\" && result.schema._prefault)\n            (_a = result.schema).default ?? (_a.default = result.schema._prefault);\n        delete result.schema._prefault;\n        // pulling fresh from this.seen in case it was overwritten\n        const _result = this.seen.get(schema);\n        return _result.schema;\n    }\n    emit(schema, _params) {\n        const params = {\n            cycles: _params?.cycles ?? \"ref\",\n            reused: _params?.reused ?? \"inline\",\n            // unrepresentable: _params?.unrepresentable ?? \"throw\",\n            // uri: _params?.uri ?? ((id) => `${id}`),\n            external: _params?.external ?? undefined,\n        };\n        // iterate over seen map;\n        const root = this.seen.get(schema);\n        if (!root)\n            throw new Error(\"Unprocessed schema. This is a bug in Zod.\");\n        // initialize result with root schema fields\n        // Object.assign(result, seen.cached);\n        // returns a ref to the schema\n        // defId will be empty if the ref points to an external schema (or #)\n        const makeURI = (entry) => {\n            // comparing the seen objects because sometimes\n            // multiple schemas map to the same seen object.\n            // e.g. lazy\n            // external is configured\n            const defsSegment = this.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            if (params.external) {\n                const externalId = params.external.registry.get(entry[0])?.id; // ?? \"__shared\";// `__schema${this.counter++}`;\n                // check if schema is in the external registry\n                const uriGenerator = params.external.uri ?? ((id) => id);\n                if (externalId) {\n                    return { ref: uriGenerator(externalId) };\n                }\n                // otherwise, add to __shared\n                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;\n                entry[1].defId = id; // set defId so it will be reused if needed\n                return { defId: id, ref: `${uriGenerator(\"__shared\")}#/${defsSegment}/${id}` };\n            }\n            if (entry[1] === root) {\n                return { ref: \"#\" };\n            }\n            // self-contained schema\n            const uriPrefix = `#`;\n            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;\n            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;\n            return { defId, ref: defUriPrefix + defId };\n        };\n        // stored cached version in `def` property\n        // remove all properties, set $ref\n        const extractToDef = (entry) => {\n            // if the schema is already a reference, do not extract it\n            if (entry[1].schema.$ref) {\n                return;\n            }\n            const seen = entry[1];\n            const { ref, defId } = makeURI(entry);\n            seen.def = { ...seen.schema };\n            // defId won't be set if the schema is a reference to an external schema\n            if (defId)\n                seen.defId = defId;\n            // wipe away all properties except $ref\n            const schema = seen.schema;\n            for (const key in schema) {\n                delete schema[key];\n            }\n            schema.$ref = ref;\n        };\n        // throw on cycles\n        // break cycles\n        if (params.cycles === \"throw\") {\n            for (const entry of this.seen.entries()) {\n                const seen = entry[1];\n                if (seen.cycle) {\n                    throw new Error(\"Cycle detected: \" +\n                        `#/${seen.cycle?.join(\"/\")}/<root>` +\n                        '\\n\\nSet the `cycles` parameter to `\"ref\"` to resolve cyclical schemas with defs.');\n                }\n            }\n        }\n        // extract schemas into $defs\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            // convert root schema to # $ref\n            if (schema === entry[0]) {\n                extractToDef(entry); // this has special handling for the root schema\n                continue;\n            }\n            // extract schemas that are in the external registry\n            if (params.external) {\n                const ext = params.external.registry.get(entry[0])?.id;\n                if (schema !== entry[0] && ext) {\n                    extractToDef(entry);\n                    continue;\n                }\n            }\n            // extract schemas with `id` meta\n            const id = this.metadataRegistry.get(entry[0])?.id;\n            if (id) {\n                extractToDef(entry);\n                continue;\n            }\n            // break cycles\n            if (seen.cycle) {\n                // any\n                extractToDef(entry);\n                continue;\n            }\n            // extract reused schemas\n            if (seen.count > 1) {\n                if (params.reused === \"ref\") {\n                    extractToDef(entry);\n                    // biome-ignore lint:\n                    continue;\n                }\n            }\n        }\n        // flatten _refs\n        const flattenRef = (zodSchema, params) => {\n            const seen = this.seen.get(zodSchema);\n            const schema = seen.def ?? seen.schema;\n            const _cached = { ...schema };\n            // already seen\n            if (seen.ref === null) {\n                return;\n            }\n            // flatten ref if defined\n            const ref = seen.ref;\n            seen.ref = null; // prevent recursion\n            if (ref) {\n                flattenRef(ref, params);\n                // merge referenced schema into current\n                const refSchema = this.seen.get(ref).schema;\n                if (refSchema.$ref &&\n                    (params.target === \"draft-7\" || params.target === \"draft-4\" || params.target === \"openapi-3.0\")) {\n                    schema.allOf = schema.allOf ?? [];\n                    schema.allOf.push(refSchema);\n                }\n                else {\n                    Object.assign(schema, refSchema);\n                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema\n                }\n            }\n            // execute overrides\n            if (!seen.isParent)\n                this.override({\n                    zodSchema: zodSchema,\n                    jsonSchema: schema,\n                    path: seen.path ?? [],\n                });\n        };\n        for (const entry of [...this.seen.entries()].reverse()) {\n            flattenRef(entry[0], { target: this.target });\n        }\n        const result = {};\n        if (this.target === \"draft-2020-12\") {\n            result.$schema = \"https://json-schema.org/draft/2020-12/schema\";\n        }\n        else if (this.target === \"draft-7\") {\n            result.$schema = \"http://json-schema.org/draft-07/schema#\";\n        }\n        else if (this.target === \"draft-4\") {\n            result.$schema = \"http://json-schema.org/draft-04/schema#\";\n        }\n        else if (this.target === \"openapi-3.0\") {\n            // OpenAPI 3.0 schema objects should not include a $schema property\n        }\n        else {\n            // @ts-ignore\n            console.warn(`Invalid target: ${this.target}`);\n        }\n        if (params.external?.uri) {\n            const id = params.external.registry.get(schema)?.id;\n            if (!id)\n                throw new Error(\"Schema is missing an `id` property\");\n            result.$id = params.external.uri(id);\n        }\n        Object.assign(result, root.def);\n        // build defs object\n        const defs = params.external?.defs ?? {};\n        for (const entry of this.seen.entries()) {\n            const seen = entry[1];\n            if (seen.def && seen.defId) {\n                defs[seen.defId] = seen.def;\n            }\n        }\n        // set definitions in result\n        if (params.external) {\n        }\n        else {\n            if (Object.keys(defs).length > 0) {\n                if (this.target === \"draft-2020-12\") {\n                    result.$defs = defs;\n                }\n                else {\n                    result.definitions = defs;\n                }\n            }\n        }\n        try {\n            // this \"finalizes\" this schema and ensures all cycles are removed\n            // each call to .emit() is functionally independent\n            // though the seen map is shared\n            return JSON.parse(JSON.stringify(result));\n        }\n        catch (_err) {\n            throw new Error(\"Error converting schema to JSON.\");\n        }\n    }\n}\nexport function toJSONSchema(input, _params) {\n    if (input instanceof $ZodRegistry) {\n        const gen = new JSONSchemaGenerator(_params);\n        const defs = {};\n        for (const entry of input._idmap.entries()) {\n            const [_, schema] = entry;\n            gen.process(schema);\n        }\n        const schemas = {};\n        const external = {\n            registry: input,\n            uri: _params?.uri,\n            defs,\n        };\n        for (const entry of input._idmap.entries()) {\n            const [key, schema] = entry;\n            schemas[key] = gen.emit(schema, {\n                ..._params,\n                external,\n            });\n        }\n        if (Object.keys(defs).length > 0) {\n            const defsSegment = gen.target === \"draft-2020-12\" ? \"$defs\" : \"definitions\";\n            schemas.__shared = {\n                [defsSegment]: defs,\n            };\n        }\n        return { schemas };\n    }\n    const gen = new JSONSchemaGenerator(_params);\n    gen.process(input);\n    return gen.emit(input, _params);\n}\nfunction isTransforming(_schema, _ctx) {\n    const ctx = _ctx ?? { seen: new Set() };\n    if (ctx.seen.has(_schema))\n        return false;\n    ctx.seen.add(_schema);\n    const def = _schema._zod.def;\n    if (def.type === \"transform\")\n        return true;\n    if (def.type === \"array\")\n        return isTransforming(def.element, ctx);\n    if (def.type === \"set\")\n        return isTransforming(def.valueType, ctx);\n    if (def.type === \"lazy\")\n        return isTransforming(def.getter(), ctx);\n    if (def.type === \"promise\" ||\n        def.type === \"optional\" ||\n        def.type === \"nonoptional\" ||\n        def.type === \"nullable\" ||\n        def.type === \"readonly\" ||\n        def.type === \"default\" ||\n        def.type === \"prefault\") {\n        return isTransforming(def.innerType, ctx);\n    }\n    if (def.type === \"intersection\") {\n        return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);\n    }\n    if (def.type === \"record\" || def.type === \"map\") {\n        return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);\n    }\n    if (def.type === \"pipe\") {\n        return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);\n    }\n    if (def.type === \"object\") {\n        for (const key in def.shape) {\n            if (isTransforming(def.shape[key], ctx))\n                return true;\n        }\n        return false;\n    }\n    if (def.type === \"union\") {\n        for (const option of def.options) {\n            if (isTransforming(option, ctx))\n                return true;\n        }\n        return false;\n    }\n    if (def.type === \"tuple\") {\n        for (const item of def.items) {\n            if (isTransforming(item, ctx))\n                return true;\n        }\n        if (def.rest && isTransforming(def.rest, ctx))\n            return true;\n        return false;\n    }\n    return false;\n}\n","import { dereference } from './dereference.js';\nimport { validate } from './validate.js';\nexport class Validator {\n    schema;\n    draft;\n    shortCircuit;\n    lookup;\n    constructor(schema, draft = '2019-09', shortCircuit = true) {\n        this.schema = schema;\n        this.draft = draft;\n        this.shortCircuit = shortCircuit;\n        this.lookup = dereference(schema);\n    }\n    validate(instance) {\n        return validate(instance, this.schema, this.draft, this.lookup, this.shortCircuit);\n    }\n    addSchema(schema, id) {\n        if (id) {\n            schema = { ...schema, $id: id };\n        }\n        dereference(schema, this.lookup);\n    }\n}\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport const ZodISODateTime = /*@__PURE__*/ core.$constructor(\"ZodISODateTime\", (inst, def) => {\n    core.$ZodISODateTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function datetime(params) {\n    return core._isoDateTime(ZodISODateTime, params);\n}\nexport const ZodISODate = /*@__PURE__*/ core.$constructor(\"ZodISODate\", (inst, def) => {\n    core.$ZodISODate.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function date(params) {\n    return core._isoDate(ZodISODate, params);\n}\nexport const ZodISOTime = /*@__PURE__*/ core.$constructor(\"ZodISOTime\", (inst, def) => {\n    core.$ZodISOTime.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function time(params) {\n    return core._isoTime(ZodISOTime, params);\n}\nexport const ZodISODuration = /*@__PURE__*/ core.$constructor(\"ZodISODuration\", (inst, def) => {\n    core.$ZodISODuration.init(inst, def);\n    schemas.ZodStringFormat.init(inst, def);\n});\nexport function duration(params) {\n    return core._isoDuration(ZodISODuration, params);\n}\n","import * as core from \"../core/index.js\";\nimport { ZodRealError } from \"./errors.js\";\nexport const parse = /* @__PURE__ */ core._parse(ZodRealError);\nexport const parseAsync = /* @__PURE__ */ core._parseAsync(ZodRealError);\nexport const safeParse = /* @__PURE__ */ core._safeParse(ZodRealError);\nexport const safeParseAsync = /* @__PURE__ */ core._safeParseAsync(ZodRealError);\n// Codec functions\nexport const encode = /* @__PURE__ */ core._encode(ZodRealError);\nexport const decode = /* @__PURE__ */ core._decode(ZodRealError);\nexport const encodeAsync = /* @__PURE__ */ core._encodeAsync(ZodRealError);\nexport const decodeAsync = /* @__PURE__ */ core._decodeAsync(ZodRealError);\nexport const safeEncode = /* @__PURE__ */ core._safeEncode(ZodRealError);\nexport const safeDecode = /* @__PURE__ */ core._safeDecode(ZodRealError);\nexport const safeEncodeAsync = /* @__PURE__ */ core._safeEncodeAsync(ZodRealError);\nexport const safeDecodeAsync = /* @__PURE__ */ core._safeDecodeAsync(ZodRealError);\n","import * as core from \"../core/index.js\";\nimport * as schemas from \"./schemas.js\";\nexport function string(params) {\n    return core._coercedString(schemas.ZodString, params);\n}\nexport function number(params) {\n    return core._coercedNumber(schemas.ZodNumber, params);\n}\nexport function boolean(params) {\n    return core._coercedBoolean(schemas.ZodBoolean, params);\n}\nexport function bigint(params) {\n    return core._coercedBigint(schemas.ZodBigInt, params);\n}\nexport function date(params) {\n    return core._coercedDate(schemas.ZodDate, params);\n}\n","import { getErrorMap } from \"../errors.js\";\nimport defaultErrorMap from \"../locales/en.js\";\nexport const makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    if (issueData.message !== undefined) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message,\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage,\n    };\n};\nexport const EMPTY_PATH = [];\nexport function addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap, // contextual error map is first priority\n            ctx.schemaErrorMap, // then schema-bound map if available\n            overrideMap, // then global override map\n            overrideMap === defaultErrorMap ? undefined : defaultErrorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nexport class ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nexport const INVALID = Object.freeze({\n    status: \"aborted\",\n});\nexport const DIRTY = (value) => ({ status: \"dirty\", value });\nexport const OK = (value) => ({ status: \"valid\", value });\nexport const isAborted = (x) => x.status === \"aborted\";\nexport const isDirty = (x) => x.status === \"dirty\";\nexport const isValid = (x) => x.status === \"valid\";\nexport const isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n","// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n","import km from \"./km.js\";\n/** @deprecated Use `km` instead. */\nexport default function () {\n    return km();\n}\n","import uk from \"./uk.js\";\n/** @deprecated Use `uk` instead. */\nexport default function () {\n    return uk();\n}\n","import z4 from \"./classic/index.js\";\nexport * from \"./classic/index.js\";\nexport default z4;\n","import type { ContentBlock } from \"../content/index.js\";\n\nexport function _isContentBlock<T extends string>(\n  block: unknown,\n  type: T\n): block is ContentBlock & { type: T } {\n  return _isObject(block) && block.type === type;\n}\n\nexport function _isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nexport function _isArray<T>(value: unknown): value is T[] {\n  return Array.isArray(value);\n}\n\nexport function _isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport function _isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nexport function _isBytesArray(value: unknown): value is Uint8Array {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  return value instanceof Uint8Array;\n}\n\nexport function safeParseJson<T = unknown>(value: string): T | undefined {\n  try {\n    return JSON.parse(value);\n  } catch {\n    return undefined;\n  }\n}\n\nexport const iife = <T>(fn: () => T): T => fn();\n","import {\n  RunnableSequence,\n  Runnable,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport type { PregelInterface } from \"../types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableSequence(\n  x: RunnableSequence | Runnable\n): x is RunnableSequence {\n  return \"steps\" in x && Array.isArray(x.steps);\n}\n\nexport function isPregelLike(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  x: PregelInterface<any, any> | RunnableLike<any, any, any>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): x is PregelInterface<any, any> {\n  return \"lg_is_pregel\" in x && x.lg_is_pregel === true;\n}\n\nexport function findSubgraphPregel(\n  candidate: Runnable\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): PregelInterface<any, any> | undefined {\n  const candidates = [candidate];\n  for (const candidate of candidates) {\n    if (isPregelLike(candidate)) {\n      return candidate;\n    } else if (isRunnableSequence(candidate)) {\n      candidates.push(...candidate.steps);\n    }\n  }\n  return undefined;\n}\n","import { StreamEvent } from \"../tracers/event_stream.js\";\nimport type { RunnableInterface } from \"./types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isRunnableInterface(thing: any): thing is RunnableInterface {\n  return thing ? thing.lc_runnable : false;\n}\n\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nexport class _RootEventFilter {\n  includeNames?: string[];\n\n  includeTypes?: string[];\n\n  includeTags?: string[];\n\n  excludeNames?: string[];\n\n  excludeTypes?: string[];\n\n  excludeTags?: string[];\n\n  constructor(fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }) {\n    this.includeNames = fields.includeNames;\n    this.includeTypes = fields.includeTypes;\n    this.includeTags = fields.includeTags;\n    this.excludeNames = fields.excludeNames;\n    this.excludeTypes = fields.excludeTypes;\n    this.excludeTags = fields.excludeTags;\n  }\n\n  includeEvent(event: StreamEvent, rootType: string): boolean {\n    let include =\n      this.includeNames === undefined &&\n      this.includeTypes === undefined &&\n      this.includeTags === undefined;\n    const eventTags = event.tags ?? [];\n\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(event.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(rootType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include || eventTags.some((tag) => this.includeTags?.includes(tag));\n    }\n\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(event.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(rootType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n\n    return include;\n  }\n}\n\nexport const toBase64Url = (str: string): string => {\n  // Use btoa for compatibility, assume ASCII\n  const encoded = btoa(str);\n  return encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n};\n","import { ZodLiteralDef } from \"zod/v3\";\nimport { Refs } from \"../Refs.js\";\n\nexport type JsonSchema7LiteralType =\n  | {\n      type: \"string\" | \"number\" | \"integer\" | \"boolean\";\n      const: string | number | boolean;\n    }\n  | {\n      type: \"object\" | \"array\";\n    };\n\nexport function parseLiteralDef(\n  def: ZodLiteralDef,\n  refs: Refs\n): JsonSchema7LiteralType {\n  const parsedType = typeof def.value;\n  if (\n    parsedType !== \"bigint\" &&\n    parsedType !== \"number\" &&\n    parsedType !== \"boolean\" &&\n    parsedType !== \"string\"\n  ) {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\",\n    };\n  }\n\n  if (refs.target === \"openApi3\") {\n    return {\n      type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n      enum: [def.value],\n    } as any;\n  }\n\n  return {\n    type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n    const: def.value,\n  };\n}\n","import { type BaseMessage } from \"./base.js\";\nimport { type AIMessage } from \"./ai.js\";\nimport { type ToolMessage } from \"./tool.js\";\n\nexport type MessageStringFormat = \"pretty\";\n\nexport function convertToFormattedString(\n  message: BaseMessage,\n  format: MessageStringFormat = \"pretty\"\n): string {\n  if (format === \"pretty\") return convertToPrettyString(message);\n  return JSON.stringify(message);\n}\n\nfunction convertToPrettyString(message: BaseMessage): string {\n  const lines: string[] = [];\n  const title = ` ${\n    message.type.charAt(0).toUpperCase() + message.type.slice(1)\n  } Message `;\n  const sepLen = Math.floor((80 - title.length) / 2);\n  const sep = \"=\".repeat(sepLen);\n  const secondSep = title.length % 2 === 0 ? sep : `${sep}=`;\n  lines.push(`${sep}${title}${secondSep}`);\n\n  // Add message type specific details\n  if (message.type === \"ai\") {\n    const aiMessage = message as AIMessage;\n    if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {\n      lines.push(\"Tool Calls:\");\n      for (const tc of aiMessage.tool_calls) {\n        lines.push(`  ${tc.name} (${tc.id})`);\n        lines.push(` Call ID: ${tc.id}`);\n        lines.push(\"  Args:\");\n        for (const [key, value] of Object.entries(tc.args)) {\n          lines.push(`    ${key}: ${value}`);\n        }\n      }\n    }\n  }\n  if (message.type === \"tool\") {\n    const toolMessage = message as ToolMessage;\n    if (toolMessage.name) {\n      lines.push(`Name: ${toolMessage.name}`);\n    }\n  }\n\n  // Add content if it's a string and not empty\n  if (typeof message.content === \"string\" && message.content.trim()) {\n    if (lines.length > 1) {\n      lines.push(\"\"); // blank line before content\n    }\n    lines.push(message.content);\n  }\n\n  return lines.join(\"\\n\");\n}\n","import { BaseMessage } from \"../messages/base.js\";\n\ntype Constructor<T> = new (...args: unknown[]) => T;\n\nexport const iife = <T>(fn: () => T): T => fn();\n\nfunction castStandardMessageContent<T extends BaseMessage>(message: T) {\n  const Cls = message.constructor as Constructor<T>;\n  return new Cls({\n    ...message,\n    content: message.contentBlocks,\n    response_metadata: {\n      ...message.response_metadata,\n      output_version: \"v1\",\n    },\n  });\n}\n\nexport { castStandardMessageContent };\n","const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n\t' A network error occurred.', // Bun (WebKit)\n\t'Network connection lost', // Cloudflare Workers (fetch)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\tconst {message, stack} = error;\n\n\t// Safari 17+ has generic message but no stack for network errors\n\tif (message === 'Load failed') {\n\t\treturn stack === undefined\n\t\t\t// Sentry adds its own stack trace to the fetch error, so also check for that\n\t\t\t|| '__sentry_captured__' in error;\n\t}\n\n\t// Deno network errors start with specific text\n\tif (message.startsWith('error sending request for url')) {\n\t\treturn true;\n\t}\n\n\t// Standard network error messages\n\treturn errorMessages.has(message);\n}\n","/* Converted from https://github.com/i404788/xxh3-ts\n\nBSD 2-Clause License\n\nCopyright (c) 2019, i404788\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nconst n = (n: number | string) => BigInt(n);\nconst view = (data: Uint8Array | DataView, offset: number = 0) =>\n  new DataView(data.buffer, data.byteOffset + offset, data.byteLength - offset);\n\nconst PRIME32_1 = n(\"0x9E3779B1\"); // 0b10011110001101110111100110110001\nconst PRIME32_2 = n(\"0x85EBCA77\"); // 0b10000101111010111100101001110111\nconst PRIME32_3 = n(\"0xC2B2AE3D\"); // 0b11000010101100101010111000111101\nconst PRIME64_1 = n(\"0x9E3779B185EBCA87\"); // 0b1001111000110111011110011011000110000101111010111100101010000111\nconst PRIME64_2 = n(\"0xC2B2AE3D27D4EB4F\"); // 0b1100001010110010101011100011110100100111110101001110101101001111\nconst PRIME64_3 = n(\"0x165667B19E3779F9\"); // 0b0001011001010110011001111011000110011110001101110111100111111001\nconst PRIME64_4 = n(\"0x85EBCA77C2B2AE63\"); // 0b1000010111101011110010100111011111000010101100101010111001100011\nconst PRIME64_5 = n(\"0x27D4EB2F165667C5\"); // 0b0010011111010100111010110010111100010110010101100110011111000101\nconst PRIME_MX1 = n(\"0x165667919E3779F9\"); // 0b0001011001010110011001111001000110011110001101110111100111111001\nconst PRIME_MX2 = n(\"0x9FB21C651E98DF25\"); // 0b1001111110110010000111000110010100011110100110001101111100100101\n\nconst hexToUint8Array = (hex: string) => {\n  const strLen = hex.length;\n  if (strLen % 2 !== 0) {\n    throw new Error(\"String should have an even number of characters\");\n  }\n\n  const maxLength = strLen / 2;\n  const bytes = new Uint8Array(maxLength);\n\n  let read = 0;\n  let write = 0;\n  while (write < maxLength) {\n    const slice = hex.slice(read, (read += 2));\n    bytes[write] = Number.parseInt(slice, 16);\n    write += 1;\n  }\n\n  return view(bytes);\n};\n\nconst kkey = hexToUint8Array(\n  \"b8fe6c3923a44bbe7c01812cf721ad1cded46de9839097db7240a4a4b7b3671fcb79e64eccc0e578825ad07dccff7221b8084674f743248ee03590e6813a264c3c2852bb91c300cb88d0658b1b532ea371644897a20df94e3819ef46a9deacd8a8fa763fe39c343ff9dcbbc7c70b4f1d8a51e04bcdb45931c89f7ec9d9787364eac5ac8334d3ebc3c581a0fffa1363eb170ddd51b7f0da49d316552629d4689e2b16be587d47a1fc8ff8b8d17ad031ce45cb3a8f95160428afd7fbcabb4b407e\"\n);\n\nconst mask128 = (n(1) << n(128)) - n(1);\nconst mask64 = (n(1) << n(64)) - n(1);\nconst mask32 = (n(1) << n(32)) - n(1);\nconst STRIPE_LEN = 64;\nconst ACC_NB = STRIPE_LEN / 8;\nconst _U64 = 8;\nconst _U32 = 4;\n\nfunction assert(a: boolean) {\n  if (!a) throw new Error(\"Assert failed\");\n}\n\nfunction bswap64(a: bigint) {\n  const scratchbuf = new DataView(new ArrayBuffer(8));\n  scratchbuf.setBigUint64(0, a, true);\n  return scratchbuf.getBigUint64(0, false);\n}\n\nfunction bswap32(input: bigint) {\n  let a = input;\n  a = ((a & n(0x0000ffff)) << n(16)) | ((a & n(0xffff0000)) >> n(16));\n  a = ((a & n(0x00ff00ff)) << n(8)) | ((a & n(0xff00ff00)) >> n(8));\n  return a; // 32-bit\n}\n\nfunction XXH_mult32to64(a: bigint, b: bigint) {\n  return ((a & mask32) * (b & mask32)) & mask64;\n}\n\nfunction rotl32(a: bigint, b: bigint) {\n  return ((a << b) | (a >> (n(32) - b))) & mask32;\n}\n\nfunction XXH3_accumulate_512(\n  acc: BigUint64Array,\n  dataView: DataView,\n  keyView: DataView\n) {\n  for (let i = 0; i < ACC_NB; i += 1) {\n    const data_val = dataView.getBigUint64(i * 8, true);\n    const data_key = data_val ^ keyView.getBigUint64(i * 8, true);\n    acc[i ^ 1] += data_val;\n    acc[i] += XXH_mult32to64(data_key, data_key >> n(32));\n  }\n  return acc;\n}\n\nfunction XXH3_accumulate(\n  acc: BigUint64Array,\n  dataView: DataView,\n  keyView: DataView,\n  nbStripes: number\n) {\n  for (let n = 0; n < nbStripes; n += 1) {\n    XXH3_accumulate_512(\n      acc,\n      view(dataView, n * STRIPE_LEN),\n      view(keyView, n * 8)\n    );\n  }\n  return acc;\n}\n\nfunction XXH3_scrambleAcc(acc: BigUint64Array, key: DataView) {\n  for (let i = 0; i < ACC_NB; i += 1) {\n    const key64 = key.getBigUint64(i * 8, true);\n    let acc64 = acc[i];\n    acc64 = xorshift64(acc64, n(47));\n    acc64 ^= key64;\n    acc64 *= PRIME32_1;\n    acc[i] = acc64 & mask64;\n  }\n  return acc;\n}\n\nfunction XXH3_mix2Accs(acc: BigUint64Array, key: DataView) {\n  return XXH3_mul128_fold64(\n    acc[0] ^ key.getBigUint64(0, true),\n    acc[1] ^ key.getBigUint64(_U64, true)\n  );\n}\n\nfunction XXH3_mergeAccs(acc: BigUint64Array, key: DataView, start: bigint) {\n  let result64 = start;\n\n  result64 += XXH3_mix2Accs(acc.slice(0), view(key, 0 * _U32));\n  result64 += XXH3_mix2Accs(acc.slice(2), view(key, 4 * _U32));\n  result64 += XXH3_mix2Accs(acc.slice(4), view(key, 8 * _U32));\n  result64 += XXH3_mix2Accs(acc.slice(6), view(key, 12 * _U32));\n\n  return XXH3_avalanche(result64 & mask64);\n}\n\nfunction XXH3_hashLong(\n  input: BigUint64Array,\n  data: DataView,\n  secret: DataView,\n  f_acc: (acc: BigUint64Array, data: DataView, key: DataView) => BigUint64Array,\n  f_scramble: (acc: BigUint64Array, key: DataView) => BigUint64Array\n) {\n  let acc = input;\n  const nbStripesPerBlock = Math.floor((secret.byteLength - STRIPE_LEN) / 8);\n  const block_len = STRIPE_LEN * nbStripesPerBlock;\n  const nb_blocks = Math.floor((data.byteLength - 1) / block_len);\n\n  for (let n = 0; n < nb_blocks; n += 1) {\n    acc = XXH3_accumulate(\n      acc,\n      view(data, n * block_len),\n      secret,\n      nbStripesPerBlock\n    );\n    acc = f_scramble(acc, view(secret, secret.byteLength - STRIPE_LEN));\n  }\n\n  {\n    // Partial block\n    const nbStripes = Math.floor(\n      (data.byteLength - 1 - block_len * nb_blocks) / STRIPE_LEN\n    );\n    acc = XXH3_accumulate(\n      acc,\n      view(data, nb_blocks * block_len),\n      secret,\n      nbStripes\n    );\n\n    // Last Stripe\n    acc = f_acc(\n      acc,\n      view(data, data.byteLength - STRIPE_LEN),\n      view(secret, secret.byteLength - STRIPE_LEN - 7)\n    );\n  }\n  return acc;\n}\n\nfunction XXH3_hashLong_128b(data: DataView, secret: DataView) {\n  let acc = new BigUint64Array([\n    PRIME32_3,\n    PRIME64_1,\n    PRIME64_2,\n    PRIME64_3,\n    PRIME64_4,\n    PRIME32_2,\n    PRIME64_5,\n    PRIME32_1,\n  ]);\n  assert(data.byteLength > 128);\n\n  acc = XXH3_hashLong(\n    acc,\n    data,\n    secret,\n    XXH3_accumulate_512,\n    XXH3_scrambleAcc\n  ) as BigUint64Array<ArrayBuffer>;\n\n  /* converge into final hash */\n  assert(acc.length * 8 === 64);\n  {\n    const low64 = XXH3_mergeAccs(\n      acc,\n      view(secret, 11),\n      (n(data.byteLength) * PRIME64_1) & mask64\n    );\n    const high64 = XXH3_mergeAccs(\n      acc,\n      view(secret, secret.byteLength - STRIPE_LEN - 11),\n      ~(n(data.byteLength) * PRIME64_2) & mask64\n    );\n    return (high64 << n(64)) | low64;\n  }\n}\n\nfunction XXH3_mul128_fold64(a: bigint, b: bigint) {\n  const lll = (a * b) & mask128;\n  return (lll & mask64) ^ (lll >> n(64));\n}\n\nfunction XXH3_mix16B(dataView: DataView, keyView: DataView, seed: bigint) {\n  return XXH3_mul128_fold64(\n    (dataView.getBigUint64(0, true) ^ (keyView.getBigUint64(0, true) + seed)) &\n      mask64,\n    (dataView.getBigUint64(8, true) ^ (keyView.getBigUint64(8, true) - seed)) &\n      mask64\n  );\n}\n\nfunction XXH3_mix32B(\n  acc: bigint,\n  data1: DataView,\n  data2: DataView,\n  key: DataView,\n  seed: bigint\n) {\n  let accl = acc & mask64;\n  let acch = (acc >> n(64)) & mask64;\n\n  accl += XXH3_mix16B(data1, key, seed);\n  accl ^= data2.getBigUint64(0, true) + data2.getBigUint64(8, true);\n  accl &= mask64;\n  acch += XXH3_mix16B(data2, view(key, 16), seed);\n  acch ^= data1.getBigUint64(0, true) + data1.getBigUint64(8, true);\n  acch &= mask64;\n\n  return (acch << n(64)) | accl;\n}\n\nfunction XXH3_avalanche(input: bigint) {\n  let h64 = input;\n  h64 ^= h64 >> n(37);\n  h64 *= PRIME_MX1;\n  h64 &= mask64;\n  h64 ^= h64 >> n(32);\n  return h64;\n}\n\nfunction XXH3_avalanche64(input: bigint) {\n  let h64 = input;\n  h64 ^= h64 >> n(33);\n  h64 *= PRIME64_2;\n  h64 &= mask64; // 64-bit\n  h64 ^= h64 >> n(29);\n  h64 *= PRIME64_3;\n  h64 &= mask64;\n  h64 ^= h64 >> n(32);\n  return h64;\n}\n\nfunction XXH3_len_1to3_128b(data: DataView, key32: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len > 0 && len <= 3);\n\n  const combined =\n    n(data.getUint8(len - 1)) |\n    n(len << 8) |\n    n(data.getUint8(0) << 16) |\n    n(data.getUint8(len >> 1) << 24);\n\n  const blow =\n    (n(key32.getUint32(0, true)) ^ n(key32.getUint32(4, true))) + seed;\n  const low = (combined ^ blow) & mask64;\n  const bhigh =\n    (n(key32.getUint32(8, true)) ^ n(key32.getUint32(12, true))) - seed;\n  const high = (rotl32(bswap32(combined), n(13)) ^ bhigh) & mask64;\n\n  return ((XXH3_avalanche64(high) & mask64) << n(64)) | XXH3_avalanche64(low);\n}\n\nfunction xorshift64(b: bigint, shift: bigint) {\n  return b ^ (b >> shift);\n}\n\nfunction XXH3_len_4to8_128b(data: DataView, key32: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len >= 4 && len <= 8);\n\n  {\n    const l1 = data.getUint32(0, true);\n    const l2 = data.getUint32(len - 4, true);\n    const l64 = n(l1) | (n(l2) << n(32));\n    const bitflip =\n      ((key32.getBigUint64(16, true) ^ key32.getBigUint64(24, true)) + seed) &\n      mask64;\n    const keyed = l64 ^ bitflip;\n    let m128 = (keyed * (PRIME64_1 + (n(len) << n(2)))) & mask128;\n    m128 += (m128 & mask64) << n(65);\n    m128 &= mask128;\n    m128 ^= m128 >> n(67);\n\n    return (\n      xorshift64(\n        (xorshift64(m128 & mask64, n(35)) * PRIME_MX2) & mask64,\n        n(28)\n      ) |\n      (XXH3_avalanche(m128 >> n(64)) << n(64))\n    );\n  }\n}\n\nfunction XXH3_len_9to16_128b(data: DataView, key64: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len >= 9 && len <= 16);\n\n  {\n    const bitflipl =\n      ((key64.getBigUint64(32, true) ^ key64.getBigUint64(40, true)) + seed) &\n      mask64;\n    const bitfliph =\n      ((key64.getBigUint64(48, true) ^ key64.getBigUint64(56, true)) - seed) &\n      mask64;\n    const ll1 = data.getBigUint64(0, true);\n    let ll2 = data.getBigUint64(len - 8, true);\n\n    let m128 = (ll1 ^ ll2 ^ bitflipl) * PRIME64_1;\n\n    const m128_l = (m128 & mask64) + (n(len - 1) << n(54));\n    m128 = (m128 & (mask128 ^ mask64)) | m128_l; // eqv. to adding only to lower 64b\n    ll2 ^= bitfliph;\n\n    m128 += (ll2 + (ll2 & mask32) * (PRIME32_2 - n(1))) << n(64);\n    m128 &= mask128;\n    m128 ^= bswap64(m128 >> n(64));\n    let h128 = (m128 & mask64) * PRIME64_2;\n    h128 += ((m128 >> n(64)) * PRIME64_2) << n(64);\n    h128 &= mask128;\n\n    return (\n      XXH3_avalanche(h128 & mask64) | (XXH3_avalanche(h128 >> n(64)) << n(64))\n    );\n  }\n}\n\nfunction XXH3_len_0to16_128b(data: DataView, seed: bigint) {\n  const len = data.byteLength;\n  assert(len <= 16);\n\n  if (len > 8) return XXH3_len_9to16_128b(data, kkey, seed);\n  if (len >= 4) return XXH3_len_4to8_128b(data, kkey, seed);\n  if (len > 0) return XXH3_len_1to3_128b(data, kkey, seed);\n\n  return (\n    XXH3_avalanche64(\n      seed ^ kkey.getBigUint64(64, true) ^ kkey.getBigUint64(72, true)\n    ) |\n    (XXH3_avalanche64(\n      seed ^ kkey.getBigUint64(80, true) ^ kkey.getBigUint64(88, true)\n    ) <<\n      n(64))\n  );\n}\n\nfunction inv64(x: bigint) {\n  // NOTE: `AND` fixes signedness (but because of 2's complement we need to re-add 1)\n  return (~x + n(1)) & mask64;\n}\n\nfunction XXH3_len_17to128_128b(data: DataView, secret: DataView, seed: bigint) {\n  let acc = (n(data.byteLength) * PRIME64_1) & mask64;\n  let i = n(data.byteLength - 1) / n(32);\n  while (i >= 0) {\n    const ni = Number(i);\n    acc = XXH3_mix32B(\n      acc,\n      view(data, 16 * ni),\n      view(data, data.byteLength - 16 * (ni + 1)),\n      view(secret, 32 * ni),\n      seed\n    );\n    i -= n(1);\n  }\n\n  let h128l = (acc + (acc >> n(64))) & mask64;\n  h128l = XXH3_avalanche(h128l);\n  let h128h =\n    (acc & mask64) * PRIME64_1 +\n    (acc >> n(64)) * PRIME64_4 +\n    ((n(data.byteLength) - seed) & mask64) * PRIME64_2;\n  h128h &= mask64;\n\n  h128h = inv64(XXH3_avalanche(h128h));\n  return h128l | (h128h << n(64));\n}\n\nfunction XXH3_len_129to240_128b(\n  data: DataView,\n  secret: DataView,\n  seed: bigint\n) {\n  let acc = (n(data.byteLength) * PRIME64_1) & mask64;\n  for (let i = 32; i < 160; i += 32) {\n    acc = XXH3_mix32B(\n      acc,\n      view(data, i - 32),\n      view(data, i - 16),\n      view(secret, i - 32),\n      seed\n    );\n  }\n  acc = XXH3_avalanche(acc & mask64) | (XXH3_avalanche(acc >> n(64)) << n(64));\n  for (let i = 160; i <= data.byteLength; i += 32) {\n    acc = XXH3_mix32B(\n      acc,\n      view(data, i - 32),\n      view(data, i - 16),\n      view(secret, 3 + i - 160),\n      seed\n    );\n  }\n  acc = XXH3_mix32B(\n    acc,\n    view(data, data.byteLength - 16),\n    view(data, data.byteLength - 32),\n    view(secret, 136 - 17 - 16),\n    inv64(seed)\n  );\n\n  let h128l = (acc + (acc >> n(64))) & mask64;\n  h128l = XXH3_avalanche(h128l);\n  let h128h =\n    (acc & mask64) * PRIME64_1 +\n    (acc >> n(64)) * PRIME64_4 +\n    ((n(data.byteLength) - seed) & mask64) * PRIME64_2;\n  h128h &= mask64;\n\n  h128h = inv64(XXH3_avalanche(h128h));\n  return h128l | (h128h << n(64));\n}\n\n// 16 byte min input\nexport function XXH3(input: Uint8Array | string, seed: bigint = n(0)) {\n  const encoder = new TextEncoder();\n  const data = view(typeof input === \"string\" ? encoder.encode(input) : input);\n  const len = data.byteLength;\n\n  const hexDigest = (data: bigint) => data.toString(16).padStart(32, \"0\");\n  if (len <= 16) return hexDigest(XXH3_len_0to16_128b(data, seed));\n  if (len <= 128) return hexDigest(XXH3_len_17to128_128b(data, kkey, seed));\n  if (len <= 240) return hexDigest(XXH3_len_129to240_128b(data, kkey, seed));\n  return hexDigest(XXH3_hashLong_128b(data, kkey));\n}\n\nexport function isXXH3(value: string): boolean {\n  // Check if the given string matches the format of XXH3 (128 bit hex digest).\n  return /^[0-9a-f]{32}$/.test(value);\n}\n","const ANSI_BACKGROUND_OFFSET = 10;\n\nconst wrapAnsi16 = (offset = 0) => code => `\\u001B[${code + offset}m`;\n\nconst wrapAnsi256 = (offset = 0) => code => `\\u001B[${38 + offset};5;${code}m`;\n\nconst wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\u001B[${38 + offset};2;${red};${green};${blue}m`;\n\nconst styles = {\n\tmodifier: {\n\t\treset: [0, 0],\n\t\t// 21 isn't widely supported and 22 does the same thing\n\t\tbold: [1, 22],\n\t\tdim: [2, 22],\n\t\titalic: [3, 23],\n\t\tunderline: [4, 24],\n\t\toverline: [53, 55],\n\t\tinverse: [7, 27],\n\t\thidden: [8, 28],\n\t\tstrikethrough: [9, 29],\n\t},\n\tcolor: {\n\t\tblack: [30, 39],\n\t\tred: [31, 39],\n\t\tgreen: [32, 39],\n\t\tyellow: [33, 39],\n\t\tblue: [34, 39],\n\t\tmagenta: [35, 39],\n\t\tcyan: [36, 39],\n\t\twhite: [37, 39],\n\n\t\t// Bright color\n\t\tblackBright: [90, 39],\n\t\tgray: [90, 39], // Alias of `blackBright`\n\t\tgrey: [90, 39], // Alias of `blackBright`\n\t\tredBright: [91, 39],\n\t\tgreenBright: [92, 39],\n\t\tyellowBright: [93, 39],\n\t\tblueBright: [94, 39],\n\t\tmagentaBright: [95, 39],\n\t\tcyanBright: [96, 39],\n\t\twhiteBright: [97, 39],\n\t},\n\tbgColor: {\n\t\tbgBlack: [40, 49],\n\t\tbgRed: [41, 49],\n\t\tbgGreen: [42, 49],\n\t\tbgYellow: [43, 49],\n\t\tbgBlue: [44, 49],\n\t\tbgMagenta: [45, 49],\n\t\tbgCyan: [46, 49],\n\t\tbgWhite: [47, 49],\n\n\t\t// Bright color\n\t\tbgBlackBright: [100, 49],\n\t\tbgGray: [100, 49], // Alias of `bgBlackBright`\n\t\tbgGrey: [100, 49], // Alias of `bgBlackBright`\n\t\tbgRedBright: [101, 49],\n\t\tbgGreenBright: [102, 49],\n\t\tbgYellowBright: [103, 49],\n\t\tbgBlueBright: [104, 49],\n\t\tbgMagentaBright: [105, 49],\n\t\tbgCyanBright: [106, 49],\n\t\tbgWhiteBright: [107, 49],\n\t},\n};\n\nexport const modifierNames = Object.keys(styles.modifier);\nexport const foregroundColorNames = Object.keys(styles.color);\nexport const backgroundColorNames = Object.keys(styles.bgColor);\nexport const colorNames = [...foregroundColorNames, ...backgroundColorNames];\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`,\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false,\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false,\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tstyles.color.ansi = wrapAnsi16();\n\tstyles.color.ansi256 = wrapAnsi256();\n\tstyles.color.ansi16m = wrapAnsi16m();\n\tstyles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);\n\tstyles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);\n\n\t// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js\n\tObject.defineProperties(styles, {\n\t\trgbToAnsi256: {\n\t\t\tvalue(red, green, blue) {\n\t\t\t\t// We use the extended greyscale palette here, with the exception of\n\t\t\t\t// black and white. normal palette only has 4 greyscale shades.\n\t\t\t\tif (red === green && green === blue) {\n\t\t\t\t\tif (red < 8) {\n\t\t\t\t\t\treturn 16;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (red > 248) {\n\t\t\t\t\t\treturn 231;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Math.round(((red - 8) / 247) * 24) + 232;\n\t\t\t\t}\n\n\t\t\t\treturn 16\n\t\t\t\t\t+ (36 * Math.round(red / 255 * 5))\n\t\t\t\t\t+ (6 * Math.round(green / 255 * 5))\n\t\t\t\t\t+ Math.round(blue / 255 * 5);\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t},\n\t\thexToRgb: {\n\t\t\tvalue(hex) {\n\t\t\t\tconst matches = /[a-f\\d]{6}|[a-f\\d]{3}/i.exec(hex.toString(16));\n\t\t\t\tif (!matches) {\n\t\t\t\t\treturn [0, 0, 0];\n\t\t\t\t}\n\n\t\t\t\tlet [colorString] = matches;\n\n\t\t\t\tif (colorString.length === 3) {\n\t\t\t\t\tcolorString = [...colorString].map(character => character + character).join('');\n\t\t\t\t}\n\n\t\t\t\tconst integer = Number.parseInt(colorString, 16);\n\n\t\t\t\treturn [\n\t\t\t\t\t/* eslint-disable no-bitwise */\n\t\t\t\t\t(integer >> 16) & 0xFF,\n\t\t\t\t\t(integer >> 8) & 0xFF,\n\t\t\t\t\tinteger & 0xFF,\n\t\t\t\t\t/* eslint-enable no-bitwise */\n\t\t\t\t];\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t},\n\t\thexToAnsi256: {\n\t\t\tvalue: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),\n\t\t\tenumerable: false,\n\t\t},\n\t\tansi256ToAnsi: {\n\t\t\tvalue(code) {\n\t\t\t\tif (code < 8) {\n\t\t\t\t\treturn 30 + code;\n\t\t\t\t}\n\n\t\t\t\tif (code < 16) {\n\t\t\t\t\treturn 90 + (code - 8);\n\t\t\t\t}\n\n\t\t\t\tlet red;\n\t\t\t\tlet green;\n\t\t\t\tlet blue;\n\n\t\t\t\tif (code >= 232) {\n\t\t\t\t\tred = (((code - 232) * 10) + 8) / 255;\n\t\t\t\t\tgreen = red;\n\t\t\t\t\tblue = red;\n\t\t\t\t} else {\n\t\t\t\t\tcode -= 16;\n\n\t\t\t\t\tconst remainder = code % 36;\n\n\t\t\t\t\tred = Math.floor(code / 36) / 5;\n\t\t\t\t\tgreen = Math.floor(remainder / 6) / 5;\n\t\t\t\t\tblue = (remainder % 6) / 5;\n\t\t\t\t}\n\n\t\t\t\tconst value = Math.max(red, green, blue) * 2;\n\n\t\t\t\tif (value === 0) {\n\t\t\t\t\treturn 30;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line no-bitwise\n\t\t\t\tlet result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));\n\n\t\t\t\tif (value === 2) {\n\t\t\t\t\tresult += 60;\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t},\n\t\t\tenumerable: false,\n\t\t},\n\t\trgbToAnsi: {\n\t\t\tvalue: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),\n\t\t\tenumerable: false,\n\t\t},\n\t\thexToAnsi: {\n\t\t\tvalue: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),\n\t\t\tenumerable: false,\n\t\t},\n\t});\n\n\treturn styles;\n}\n\nconst ansiStyles = assembleStyles();\n\nexport default ansiStyles;\n","import {\n  AppRouteRouteModule,\n  type AppRouteRouteHandlerContext,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\nimport type { IncomingMessage, ServerResponse } from 'node:http'\nimport { addRequestMeta, getRequestMeta } from '../../server/request-meta'\nimport { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\nimport { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\nimport { createServerModuleMap } from '../../server/app-render/action-utils'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\nimport {\n  NextRequestAdapter,\n  signalFromNodeResponse,\n} from '../../server/web/spec-extension/adapters/next-request'\nimport { BaseServerSpan } from '../../server/lib/trace/constants'\nimport { getRevalidateReason } from '../../server/instrumentation/utils'\nimport { sendResponse } from '../../server/send-response'\nimport {\n  fromNodeOutgoingHttpHeaders,\n  toNodeOutgoingHttpHeaders,\n} from '../../server/web/utils'\nimport { getCacheControlHeader } from '../../server/lib/cache-control'\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\nimport { NoFallbackError } from '../../shared/lib/no-fallback-error.external'\nimport {\n  CachedRouteKind,\n  type ResponseCacheEntry,\n  type ResponseGenerator,\n} from '../../server/response-cache'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n  relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n\nexport async function handler(\n  req: IncomingMessage,\n  res: ServerResponse,\n  ctx: {\n    waitUntil: (prom: Promise<void>) => void\n  }\n) {\n  if (routeModule.isDev) {\n    addRequestMeta(req, 'devRequestTimingInternalsEnd', process.hrtime.bigint())\n  }\n  let srcPage = 'VAR_DEFINITION_PAGE'\n\n  // turbopack doesn't normalize `/index` in the page name\n  // so we need to to process dynamic routes properly\n  // TODO: fix turbopack providing differing value from webpack\n  if (process.env.TURBOPACK) {\n    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n  } else if (srcPage === '/index') {\n    // we always normalize /index specifically\n    srcPage = '/'\n  }\n  const multiZoneDraftMode = process.env\n    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n\n  const prepareResult = await routeModule.prepare(req, res, {\n    srcPage,\n    multiZoneDraftMode,\n  })\n\n  if (!prepareResult) {\n    res.statusCode = 400\n    res.end('Bad Request')\n    ctx.waitUntil?.(Promise.resolve())\n    return null\n  }\n\n  const {\n    buildId,\n    params,\n    nextConfig,\n    parsedUrl,\n    isDraftMode,\n    prerenderManifest,\n    routerServerContext,\n    isOnDemandRevalidate,\n    revalidateOnlyGenerated,\n    resolvedPathname,\n    clientReferenceManifest,\n    serverActionsManifest,\n  } = prepareResult\n\n  const normalizedSrcPage = normalizeAppPath(srcPage)\n\n  let isIsr = Boolean(\n    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n      prerenderManifest.routes[resolvedPathname]\n  )\n\n  const render404 = async () => {\n    // TODO: should route-module itself handle rendering the 404\n    if (routerServerContext?.render404) {\n      await routerServerContext.render404(req, res, parsedUrl, false)\n    } else {\n      res.end('This page could not be found')\n    }\n    return null\n  }\n\n  if (isIsr && !isDraftMode) {\n    const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname])\n    const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage]\n\n    if (prerenderInfo) {\n      if (prerenderInfo.fallback === false && !isPrerendered) {\n        if (nextConfig.experimental.adapterPath) {\n          return await render404()\n        }\n        throw new NoFallbackError()\n      }\n    }\n  }\n\n  let cacheKey: string | null = null\n\n  if (isIsr && !routeModule.isDev && !isDraftMode) {\n    cacheKey = resolvedPathname\n    // ensure /index and / is normalized to one key\n    cacheKey = cacheKey === '/index' ? '/' : cacheKey\n  }\n\n  const supportsDynamicResponse: boolean =\n    // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true ||\n    // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr\n\n  // This is a revalidation request if the request is for a static\n  // page and it is not being resumed from a postponed render and\n  // it is not a dynamic RSC request then it is a revalidation\n  // request.\n  const isStaticGeneration = isIsr && !supportsDynamicResponse\n\n  // Before rendering (which initializes component tree modules), we have to\n  // set the reference manifests to our global store so Server Action's\n  // encryption util can access to them at the top level of the page module.\n  if (serverActionsManifest && clientReferenceManifest) {\n    setReferenceManifestsSingleton({\n      page: srcPage,\n      clientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap({\n        serverActionsManifest,\n      }),\n    })\n  }\n\n  const method = req.method || 'GET'\n  const tracer = getTracer()\n  const activeSpan = tracer.getActiveScopeSpan()\n\n  const context: AppRouteRouteHandlerContext = {\n    params,\n    prerenderManifest,\n    renderOpts: {\n      experimental: {\n        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n      },\n      cacheComponents: Boolean(nextConfig.cacheComponents),\n      supportsDynamicResponse,\n      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n      cacheLifeProfiles: nextConfig.cacheLife,\n      waitUntil: ctx.waitUntil,\n      onClose: (cb) => {\n        res.on('close', cb)\n      },\n      onAfterTaskError: undefined,\n      onInstrumentationRequestError: (error, _request, errorContext) =>\n        routeModule.onRequestError(\n          req,\n          error,\n          errorContext,\n          routerServerContext\n        ),\n    },\n    sharedContext: {\n      buildId,\n    },\n  }\n  const nodeNextReq = new NodeNextRequest(req)\n  const nodeNextRes = new NodeNextResponse(res)\n\n  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n    nodeNextReq,\n    signalFromNodeResponse(res)\n  )\n\n  try {\n    const invokeRouteModule = async (span?: Span) => {\n      return routeModule.handle(nextReq, context).finally(() => {\n        if (!span) return\n\n        span.setAttributes({\n          'http.status_code': res.statusCode,\n          'next.rsc': false,\n        })\n\n        const rootSpanAttributes = tracer.getRootSpanAttributes()\n        // We were unable to get attributes, probably OTEL is not enabled\n        if (!rootSpanAttributes) {\n          return\n        }\n\n        if (\n          rootSpanAttributes.get('next.span_type') !==\n          BaseServerSpan.handleRequest\n        ) {\n          console.warn(\n            `Unexpected root span type '${rootSpanAttributes.get(\n              'next.span_type'\n            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n          )\n          return\n        }\n\n        const route = rootSpanAttributes.get('next.route')\n        if (route) {\n          const name = `${method} ${route}`\n\n          span.setAttributes({\n            'next.route': route,\n            'http.route': route,\n            'next.span_name': name,\n          })\n          span.updateName(name)\n        } else {\n          span.updateName(`${method} ${srcPage}`)\n        }\n      })\n    }\n    const isMinimalMode = Boolean(\n      process.env.MINIMAL_MODE || getRequestMeta(req, 'minimalMode')\n    )\n\n    const handleResponse = async (currentSpan?: Span) => {\n      const responseGenerator: ResponseGenerator = async ({\n        previousCacheEntry,\n      }) => {\n        try {\n          if (\n            !isMinimalMode &&\n            isOnDemandRevalidate &&\n            revalidateOnlyGenerated &&\n            !previousCacheEntry\n          ) {\n            res.statusCode = 404\n            // on-demand revalidate always sets this header\n            res.setHeader('x-nextjs-cache', 'REVALIDATED')\n            res.end('This page could not be found')\n            return null\n          }\n\n          const response = await invokeRouteModule(currentSpan)\n\n          ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n          let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n\n          // Attempt using provided waitUntil if available\n          // if it's not we fallback to sendResponse's handling\n          if (pendingWaitUntil) {\n            if (ctx.waitUntil) {\n              ctx.waitUntil(pendingWaitUntil)\n              pendingWaitUntil = undefined\n            }\n          }\n          const cacheTags = context.renderOpts.collectedTags\n\n          // If the request is for a static response, we can cache it so long\n          // as it's not edge.\n          if (isIsr) {\n            const blob = await response.blob()\n\n            // Copy the headers from the response.\n            const headers = toNodeOutgoingHttpHeaders(response.headers)\n\n            if (cacheTags) {\n              headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n            }\n\n            if (!headers['content-type'] && blob.type) {\n              headers['content-type'] = blob.type\n            }\n\n            const revalidate =\n              typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n              context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n                ? false\n                : context.renderOpts.collectedRevalidate\n\n            const expire =\n              typeof context.renderOpts.collectedExpire === 'undefined' ||\n              context.renderOpts.collectedExpire >= INFINITE_CACHE\n                ? undefined\n                : context.renderOpts.collectedExpire\n\n            // Create the cache entry for the response.\n            const cacheEntry: ResponseCacheEntry = {\n              value: {\n                kind: CachedRouteKind.APP_ROUTE,\n                status: response.status,\n                body: Buffer.from(await blob.arrayBuffer()),\n                headers,\n              },\n              cacheControl: { revalidate, expire },\n            }\n\n            return cacheEntry\n          } else {\n            // send response without caching if not ISR\n            await sendResponse(\n              nodeNextReq,\n              nodeNextRes,\n              response,\n              context.renderOpts.pendingWaitUntil\n            )\n            return null\n          }\n        } catch (err) {\n          // if this is a background revalidate we need to report\n          // the request error here as it won't be bubbled\n          if (previousCacheEntry?.isStale) {\n            await routeModule.onRequestError(\n              req,\n              err,\n              {\n                routerKind: 'App Router',\n                routePath: srcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                  isStaticGeneration,\n                  isOnDemandRevalidate,\n                }),\n              },\n              routerServerContext\n            )\n          }\n          throw err\n        }\n      }\n\n      const cacheEntry = await routeModule.handleResponse({\n        req,\n        nextConfig,\n        cacheKey,\n        routeKind: RouteKind.APP_ROUTE,\n        isFallback: false,\n        prerenderManifest,\n        isRoutePPREnabled: false,\n        isOnDemandRevalidate,\n        revalidateOnlyGenerated,\n        responseGenerator,\n        waitUntil: ctx.waitUntil,\n        isMinimalMode,\n      })\n\n      // we don't create a cacheEntry for ISR\n      if (!isIsr) {\n        return null\n      }\n\n      if (cacheEntry?.value?.kind !== CachedRouteKind.APP_ROUTE) {\n        throw new Error(\n          `Invariant: app-route received invalid cache entry ${cacheEntry?.value?.kind}`\n        )\n      }\n\n      if (!isMinimalMode) {\n        res.setHeader(\n          'x-nextjs-cache',\n          isOnDemandRevalidate\n            ? 'REVALIDATED'\n            : cacheEntry.isMiss\n              ? 'MISS'\n              : cacheEntry.isStale\n                ? 'STALE'\n                : 'HIT'\n        )\n      }\n\n      // Draft mode should never be cached\n      if (isDraftMode) {\n        res.setHeader(\n          'Cache-Control',\n          'private, no-cache, no-store, max-age=0, must-revalidate'\n        )\n      }\n\n      const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers)\n\n      if (!(isMinimalMode && isIsr)) {\n        headers.delete(NEXT_CACHE_TAGS_HEADER)\n      }\n\n      // If cache control is already set on the response we don't\n      // override it to allow users to customize it via next.config\n      if (\n        cacheEntry.cacheControl &&\n        !res.getHeader('Cache-Control') &&\n        !headers.get('Cache-Control')\n      ) {\n        headers.set(\n          'Cache-Control',\n          getCacheControlHeader(cacheEntry.cacheControl)\n        )\n      }\n\n      await sendResponse(\n        nodeNextReq,\n        nodeNextRes,\n        // @ts-expect-error - Argument of type 'Buffer<ArrayBufferLike>' is not assignable to parameter of type 'BodyInit | null | undefined'.\n        new Response(cacheEntry.value.body, {\n          headers,\n          status: cacheEntry.value.status || 200,\n        })\n      )\n      return null\n    }\n\n    // TODO: activeSpan code path is for when wrapped by\n    // next-server can be removed when this is no longer used\n    if (activeSpan) {\n      await handleResponse(activeSpan)\n    } else {\n      await tracer.withPropagatedContext(req.headers, () =>\n        tracer.trace(\n          BaseServerSpan.handleRequest,\n          {\n            spanName: `${method} ${srcPage}`,\n            kind: SpanKind.SERVER,\n            attributes: {\n              'http.method': method,\n              'http.target': req.url,\n            },\n          },\n          handleResponse\n        )\n      )\n    }\n  } catch (err) {\n    if (!(err instanceof NoFallbackError)) {\n      await routeModule.onRequestError(req, err, {\n        routerKind: 'App Router',\n        routePath: normalizedSrcPage,\n        routeType: 'route',\n        revalidateReason: getRevalidateReason({\n          isStaticGeneration,\n          isOnDemandRevalidate,\n        }),\n      })\n    }\n\n    // rethrow so that we can handle serving error page\n\n    // If this is during static generation, throw the error again.\n    if (isIsr) throw err\n\n    // Otherwise, send a 500 response.\n    await sendResponse(\n      nodeNextReq,\n      nodeNextRes,\n      new Response(null, { status: 500 })\n    )\n    return null\n  }\n}\n","import { ToolCall } from \"../messages/tool.js\";\n\nexport function _isToolCall(toolCall?: unknown): toolCall is ToolCall {\n  return !!(\n    toolCall &&\n    typeof toolCall === \"object\" &&\n    \"type\" in toolCall &&\n    toolCall.type === \"tool_call\"\n  );\n}\n\nexport function _configHasToolCallId(\n  config?: unknown\n): config is { toolCall: { id?: string } } {\n  return !!(\n    config &&\n    typeof config === \"object\" &&\n    \"toolCall\" in config &&\n    config.toolCall != null &&\n    typeof config.toolCall === \"object\" &&\n    \"id\" in config.toolCall &&\n    typeof config.toolCall.id === \"string\"\n  );\n}\n/**\n * Custom error class used to handle exceptions related to tool input parsing.\n * It extends the built-in `Error` class and adds an optional `output`\n * property that can hold the output that caused the exception.\n */\nexport class ToolInputParsingException extends Error {\n  output?: string;\n\n  constructor(message: string, output?: string) {\n    super(message);\n    this.output = output;\n  }\n}\n","import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\n/**\n * UUID V7 - Unix Epoch time-based UUID\n *\n * The IETF has published RFC9562, introducing 3 new UUID versions (6,7,8). This\n * implementation of V7 is based on the accepted, though not yet approved,\n * revisions.\n *\n * RFC 9562:https://www.rfc-editor.org/rfc/rfc9562.html Universally Unique\n * IDentifiers (UUIDs)\n\n *\n * Sample V7 value:\n * https://www.rfc-editor.org/rfc/rfc9562.html#name-example-of-a-uuidv7-value\n *\n * Monotonic Bit Layout: RFC rfc9562.6.2 Method 1, Dedicated Counter Bits ref:\n *     https://www.rfc-editor.org/rfc/rfc9562.html#section-6.2-5.1\n *\n *   0                   1                   2                   3 0 1 2 3 4 5 6\n *   7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                          unix_ts_ms                           |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |          unix_ts_ms           |  ver  |        seq_hi         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |var|               seq_low               |        rand         |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *  |                             rand                              |\n *  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n *\n * seq is a 31 bit serialized counter; comprised of 12 bit seq_hi and 19 bit\n * seq_low, and randomly initialized upon timestamp change. 31 bit counter size\n * was selected as any bitwise operations in node are done as _signed_ 32 bit\n * ints. we exclude the sign bit.\n */\n\nlet _seqLow = null;\nlet _seqHigh = null;\nlet _msecs = 0;\nfunction v7(options, buf, offset) {\n  options = options || {};\n\n  // initialize buffer and pointer\n  let i = buf && offset || 0;\n  const b = buf || new Uint8Array(16);\n\n  // rnds is Uint8Array(16) filled with random bytes\n  const rnds = options.random || (options.rng || rng)();\n\n  // milliseconds since unix epoch, 1970-01-01 00:00\n  const msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // seq is user provided 31 bit counter\n  let seq = options.seq !== undefined ? options.seq : null;\n\n  // initialize local seq high/low parts\n  let seqHigh = _seqHigh;\n  let seqLow = _seqLow;\n\n  // check if clock has advanced and user has not provided msecs\n  if (msecs > _msecs && options.msecs === undefined) {\n    _msecs = msecs;\n\n    // unless user provided seq, reset seq parts\n    if (seq !== null) {\n      seqHigh = null;\n      seqLow = null;\n    }\n  }\n\n  // if we have a user provided seq\n  if (seq !== null) {\n    // trim provided seq to 31 bits of value, avoiding overflow\n    if (seq > 0x7fffffff) {\n      seq = 0x7fffffff;\n    }\n\n    // split provided seq into high/low parts\n    seqHigh = seq >>> 19 & 0xfff;\n    seqLow = seq & 0x7ffff;\n  }\n\n  // randomly initialize seq\n  if (seqHigh === null || seqLow === null) {\n    seqHigh = rnds[6] & 0x7f;\n    seqHigh = seqHigh << 8 | rnds[7];\n    seqLow = rnds[8] & 0x3f; // pad for var\n    seqLow = seqLow << 8 | rnds[9];\n    seqLow = seqLow << 5 | rnds[10] >>> 3;\n  }\n\n  // increment seq if within msecs window\n  if (msecs + 10000 > _msecs && seq === null) {\n    if (++seqLow > 0x7ffff) {\n      seqLow = 0;\n      if (++seqHigh > 0xfff) {\n        seqHigh = 0;\n\n        // increment internal _msecs. this allows us to continue incrementing\n        // while staying monotonic. Note, once we hit 10k milliseconds beyond system\n        // clock, we will reset breaking monotonicity (after (2^31)*10000 generations)\n        _msecs++;\n      }\n    }\n  } else {\n    // resetting; we have advanced more than\n    // 10k milliseconds beyond system clock\n    _msecs = msecs;\n  }\n  _seqHigh = seqHigh;\n  _seqLow = seqLow;\n\n  // [bytes 0-5] 48 bits of local timestamp\n  b[i++] = _msecs / 0x10000000000 & 0xff;\n  b[i++] = _msecs / 0x100000000 & 0xff;\n  b[i++] = _msecs / 0x1000000 & 0xff;\n  b[i++] = _msecs / 0x10000 & 0xff;\n  b[i++] = _msecs / 0x100 & 0xff;\n  b[i++] = _msecs & 0xff;\n\n  // [byte 6] - set 4 bits of version (7) with first 4 bits seq_hi\n  b[i++] = seqHigh >>> 4 & 0x0f | 0x70;\n\n  // [byte 7] remaining 8 bits of seq_hi\n  b[i++] = seqHigh & 0xff;\n\n  // [byte 8] - variant (2 bits), first 6 bits seq_low\n  b[i++] = seqLow >>> 13 & 0x3f | 0x80;\n\n  // [byte 9] 8 bits seq_low\n  b[i++] = seqLow >>> 5 & 0xff;\n\n  // [byte 10] remaining 5 bits seq_low, 3 bits random\n  b[i++] = seqLow << 3 & 0xff | rnds[10] & 0x07;\n\n  // [bytes 11-15] always random\n  b[i++] = rnds[11];\n  b[i++] = rnds[12];\n  b[i++] = rnds[13];\n  b[i++] = rnds[14];\n  b[i++] = rnds[15];\n  return buf || unsafeStringify(b);\n}\nexport default v7;","import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\nlet _clockseq;\n\n// Previous uuid creation time\nlet _lastMSecs = 0;\nlet _lastNSecs = 0;\n\n// See https://github.com/uuidjs/uuid for API details\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node;\n  let clockseq = options.clockseq;\n\n  // v1 only: Use cached `node` and `clockseq` values\n  if (!options._v6) {\n    if (!node) {\n      node = _nodeId;\n    }\n    if (clockseq == null) {\n      clockseq = _clockseq;\n    }\n  }\n\n  // Handle cases where we need entropy.  We do this lazily to minimize issues\n  // related to insufficient system entropy.  See #189\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || rng)();\n\n    // Randomize node\n    if (node == null) {\n      node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n\n      // v1 only: cache node value for reuse\n      if (!_nodeId && !options._v6) {\n        // per RFC4122 4.5: Set MAC multicast bit (v1 only)\n        node[0] |= 0x01; // Set multicast bit\n\n        _nodeId = node;\n      }\n    }\n\n    // Randomize clockseq\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n      if (_clockseq === undefined && !options._v6) {\n        _clockseq = clockseq;\n      }\n    }\n  }\n\n  // v1 & v6 timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so time is\n  // handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n  return buf || unsafeStringify(b);\n}\nexport default v1;","import * as core from \"../core/index.js\";\nimport { $ZodError } from \"../core/index.js\";\nimport * as util from \"../core/util.js\";\nconst initializer = (inst, issues) => {\n    $ZodError.init(inst, issues);\n    inst.name = \"ZodError\";\n    Object.defineProperties(inst, {\n        format: {\n            value: (mapper) => core.formatError(inst, mapper),\n            // enumerable: false,\n        },\n        flatten: {\n            value: (mapper) => core.flattenError(inst, mapper),\n            // enumerable: false,\n        },\n        addIssue: {\n            value: (issue) => {\n                inst.issues.push(issue);\n                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);\n            },\n            // enumerable: false,\n        },\n        addIssues: {\n            value: (issues) => {\n                inst.issues.push(...issues);\n                inst.message = JSON.stringify(inst.issues, util.jsonStringifyReplacer, 2);\n            },\n            // enumerable: false,\n        },\n        isEmpty: {\n            get() {\n                return inst.issues.length === 0;\n            },\n            // enumerable: false,\n        },\n    });\n    // Object.defineProperty(inst, \"isEmpty\", {\n    //   get() {\n    //     return inst.issues.length === 0;\n    //   },\n    // });\n};\nexport const ZodError = core.$constructor(\"ZodError\", initializer);\nexport const ZodRealError = core.$constructor(\"ZodError\", initializer, {\n    Parent: Error,\n});\n// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */\n// export type ErrorMapCtx = core.$ZodErrorMapCtx;\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;","/* eslint-disable */\n// @ts-nocheck\nimport { getLangSmithEnvironmentVariable } from \"../../utils/env.js\";\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = { result: \"[Circular]\" };\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER,\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        }\n        else if (val instanceof Set) {\n            return Array.from(val);\n        }\n        else if (val instanceof Date) {\n            return val.toISOString();\n        }\n        else if (val instanceof RegExp) {\n            return val.toString();\n        }\n        else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message,\n            };\n        }\n    }\n    else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function (key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nexport function serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    }\n    catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        getLangSmithEnvironmentVariable(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !==\n            \"true\" &&\n            console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            }\n            else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        }\n        catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        }\n        finally {\n            while (arr.length !== 0) {\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                }\n                else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, { value: replace });\n            arr.push([parent, k, val, propertyDescriptor]);\n        }\n        else {\n            replacerStack.push([val, k, replace]);\n        }\n    }\n    else {\n        parent[k] = replace;\n        arr.push([parent, k, val]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        }\n        else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    }\n    catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    }\n    finally {\n        // Ensure that we restore the object as it was.\n        while (arr.length !== 0) {\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            }\n            else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for (i = 0; i < stack.length; i++) {\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        }\n        catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" &&\n            depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" &&\n            edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for (i = 0; i < val.length; i++) {\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        }\n        else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for (i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([parent, k, val]);\n                parent[k] = tmp;\n            }\n            else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer =\n        typeof replacer !== \"undefined\"\n            ? replacer\n            : function (k, v) {\n                return v;\n            };\n    return function (key, val) {\n        if (replacerStack.length > 0) {\n            for (var i = 0; i < replacerStack.length; i++) {\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n","import * as core from \"./core.js\";\nimport * as errors from \"./errors.js\";\nimport * as util from \"./util.js\";\nexport const _parse = (_Err) => (schema, value, _ctx, _params) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n    const result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise) {\n        throw new core.$ZodAsyncError();\n    }\n    if (result.issues.length) {\n        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n        util.captureStackTrace(e, _params?.callee);\n        throw e;\n    }\n    return result.value;\n};\nexport const parse = /* @__PURE__*/ _parse(errors.$ZodRealError);\nexport const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n    let result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise)\n        result = await result;\n    if (result.issues.length) {\n        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())));\n        util.captureStackTrace(e, params?.callee);\n        throw e;\n    }\n    return result.value;\n};\nexport const parseAsync = /* @__PURE__*/ _parseAsync(errors.$ZodRealError);\nexport const _safeParse = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n    const result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise) {\n        throw new core.$ZodAsyncError();\n    }\n    return result.issues.length\n        ? {\n            success: false,\n            error: new (_Err ?? errors.$ZodError)(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        }\n        : { success: true, data: result.value };\n};\nexport const safeParse = /* @__PURE__*/ _safeParse(errors.$ZodRealError);\nexport const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n    let result = schema._zod.run({ value, issues: [] }, ctx);\n    if (result instanceof Promise)\n        result = await result;\n    return result.issues.length\n        ? {\n            success: false,\n            error: new _Err(result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n        }\n        : { success: true, data: result.value };\n};\nexport const safeParseAsync = /* @__PURE__*/ _safeParseAsync(errors.$ZodRealError);\nexport const _encode = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _parse(_Err)(schema, value, ctx);\n};\nexport const encode = /* @__PURE__*/ _encode(errors.$ZodRealError);\nexport const _decode = (_Err) => (schema, value, _ctx) => {\n    return _parse(_Err)(schema, value, _ctx);\n};\nexport const decode = /* @__PURE__*/ _decode(errors.$ZodRealError);\nexport const _encodeAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _parseAsync(_Err)(schema, value, ctx);\n};\nexport const encodeAsync = /* @__PURE__*/ _encodeAsync(errors.$ZodRealError);\nexport const _decodeAsync = (_Err) => async (schema, value, _ctx) => {\n    return _parseAsync(_Err)(schema, value, _ctx);\n};\nexport const decodeAsync = /* @__PURE__*/ _decodeAsync(errors.$ZodRealError);\nexport const _safeEncode = (_Err) => (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _safeParse(_Err)(schema, value, ctx);\n};\nexport const safeEncode = /* @__PURE__*/ _safeEncode(errors.$ZodRealError);\nexport const _safeDecode = (_Err) => (schema, value, _ctx) => {\n    return _safeParse(_Err)(schema, value, _ctx);\n};\nexport const safeDecode = /* @__PURE__*/ _safeDecode(errors.$ZodRealError);\nexport const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {\n    const ctx = _ctx ? Object.assign(_ctx, { direction: \"backward\" }) : { direction: \"backward\" };\n    return _safeParseAsync(_Err)(schema, value, ctx);\n};\nexport const safeEncodeAsync = /* @__PURE__*/ _safeEncodeAsync(errors.$ZodRealError);\nexport const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {\n    return _safeParseAsync(_Err)(schema, value, _ctx);\n};\nexport const safeDecodeAsync = /* @__PURE__*/ _safeDecodeAsync(errors.$ZodRealError);\n","import * as z from 'zod';\r\n\r\n// Step statuses for the workflow\r\nexport const WorkflowStep = z.enum([\r\n    'idle',\r\n    'resolving',\r\n    'checking_warehouse',\r\n    'assigning_driver',\r\n    'dispatching',\r\n    'completed',\r\n    'error'\r\n]);\r\n\r\nexport type WorkflowStepType = z.infer<typeof WorkflowStep>;\r\n\r\n// Warehouse check result\r\nexport const WarehouseResult = z.object({\r\n    available: z.boolean(),\r\n    stockLevel: z.number(),\r\n    location: z.string(),\r\n    estimatedPrepTime: z.number(), // minutes\r\n});\r\n\r\nexport type WarehouseResultType = z.infer<typeof WarehouseResult>;\r\n\r\n// Driver assignment result\r\nexport const DriverResult = z.object({\r\n    driverId: z.string(),\r\n    driverName: z.string(),\r\n    vehicleType: z.string(),\r\n    estimatedArrival: z.number(), // minutes\r\n    distance: z.number(), // km\r\n});\r\n\r\nexport type DriverResultType = z.infer<typeof DriverResult>;\r\n\r\n// Main workflow state\r\nexport const OrderResolutionState = z.object({\r\n    // Input\r\n    orderId: z.string(),\r\n    orderDetails: z.object({\r\n        customer: z.string(),\r\n        items: z.number(),\r\n        total: z.number(),\r\n        address: z.string(),\r\n    }),\r\n\r\n    // Progress tracking\r\n    currentStep: WorkflowStep,\r\n    stepMessages: z.array(z.object({\r\n        step: WorkflowStep,\r\n        message: z.string(),\r\n        timestamp: z.string(),\r\n    })),\r\n\r\n    // Results from each step\r\n    warehouseResult: WarehouseResult.optional(),\r\n    driverResult: DriverResult.optional(),\r\n\r\n    // Error handling\r\n    error: z.string().optional(),\r\n\r\n    // Final status\r\n    dispatchConfirmed: z.boolean(),\r\n    estimatedDeliveryTime: z.string().optional(),\r\n});\r\n\r\nexport type OrderResolutionStateType = z.infer<typeof OrderResolutionState>;\r\n\r\n// Initial state factory\r\nexport function createInitialState(\r\n    orderId: string,\r\n    orderDetails: OrderResolutionStateType['orderDetails']\r\n): OrderResolutionStateType {\r\n    return {\r\n        orderId,\r\n        orderDetails,\r\n        currentStep: 'idle',\r\n        stepMessages: [],\r\n        dispatchConfirmed: false,\r\n    };\r\n}\r\n","// Zod 3 compat layer\nimport * as core from \"../core/index.js\";\n/** @deprecated Use the raw string literal codes instead, e.g. \"invalid_type\". */\nexport const ZodIssueCode = {\n    invalid_type: \"invalid_type\",\n    too_big: \"too_big\",\n    too_small: \"too_small\",\n    invalid_format: \"invalid_format\",\n    not_multiple_of: \"not_multiple_of\",\n    unrecognized_keys: \"unrecognized_keys\",\n    invalid_union: \"invalid_union\",\n    invalid_key: \"invalid_key\",\n    invalid_element: \"invalid_element\",\n    invalid_value: \"invalid_value\",\n    custom: \"custom\",\n};\nexport { $brand, config } from \"../core/index.js\";\n/** @deprecated Use `z.config(params)` instead. */\nexport function setErrorMap(map) {\n    core.config({\n        customError: map,\n    });\n}\n/** @deprecated Use `z.config()` instead. */\nexport function getErrorMap() {\n    return core.config().customError;\n}\n/** @deprecated Do not use. Stub definition, only included for zod-to-json-schema compatibility. */\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n","import { ZodEnumDef } from \"zod/v3\";\n\nexport type JsonSchema7EnumType = {\n  type: \"string\";\n  enum: string[];\n};\n\nexport function parseEnumDef(def: ZodEnumDef): JsonSchema7EnumType {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values),\n  };\n}\n","export function squaredEuclidean(p: number[], q: number[]) {\n  let d = 0;\n  for (let i = 0; i < p.length; i++) {\n    d += (p[i] - q[i]) * (p[i] - q[i]);\n  }\n  return d;\n}\n\nexport function euclidean(p: number[], q: number[]) {\n  return Math.sqrt(squaredEuclidean(p, q));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nexport type LangChainErrorCodes =\n  | \"INVALID_PROMPT_INPUT\"\n  | \"INVALID_TOOL_RESULTS\"\n  | \"MESSAGE_COERCION_FAILURE\"\n  | \"MODEL_AUTHENTICATION\"\n  | \"MODEL_NOT_FOUND\"\n  | \"MODEL_RATE_LIMIT\"\n  | \"OUTPUT_PARSING_FAILURE\";\n\nexport function addLangChainErrorFields(\n  error: any,\n  lc_error_code: LangChainErrorCodes\n) {\n  (error as any).lc_error_code = lc_error_code;\n  error.message = `${error.message}\\n\\nTroubleshooting URL: https://docs.langchain.com/oss/javascript/langchain/errors/${lc_error_code}/\\n`;\n  return error;\n}\n","// import { $ZodType } from \"./schemas.js\";\nimport * as core from \"./core.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nexport const $ZodCheck = /*@__PURE__*/ core.$constructor(\"$ZodCheck\", (inst, def) => {\n    var _a;\n    inst._zod ?? (inst._zod = {});\n    inst._zod.def = def;\n    (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nconst numericOriginMap = {\n    number: \"number\",\n    bigint: \"bigint\",\n    object: \"date\",\n};\nexport const $ZodCheckLessThan = /*@__PURE__*/ core.$constructor(\"$ZodCheckLessThan\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const origin = numericOriginMap[typeof def.value];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n        if (def.value < curr) {\n            if (def.inclusive)\n                bag.maximum = def.value;\n            else\n                bag.exclusiveMaximum = def.value;\n        }\n    });\n    inst._zod.check = (payload) => {\n        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n            return;\n        }\n        payload.issues.push({\n            origin,\n            code: \"too_big\",\n            maximum: def.value,\n            input: payload.value,\n            inclusive: def.inclusive,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckGreaterThan = /*@__PURE__*/ core.$constructor(\"$ZodCheckGreaterThan\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const origin = numericOriginMap[typeof def.value];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n        if (def.value > curr) {\n            if (def.inclusive)\n                bag.minimum = def.value;\n            else\n                bag.exclusiveMinimum = def.value;\n        }\n    });\n    inst._zod.check = (payload) => {\n        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n            return;\n        }\n        payload.issues.push({\n            origin,\n            code: \"too_small\",\n            minimum: def.value,\n            input: payload.value,\n            inclusive: def.inclusive,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMultipleOf = \n/*@__PURE__*/ core.$constructor(\"$ZodCheckMultipleOf\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        var _a;\n        (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);\n    });\n    inst._zod.check = (payload) => {\n        if (typeof payload.value !== typeof def.value)\n            throw new Error(\"Cannot mix number and bigint in multiple_of check.\");\n        const isMultiple = typeof payload.value === \"bigint\"\n            ? payload.value % def.value === BigInt(0)\n            : util.floatSafeRemainder(payload.value, def.value) === 0;\n        if (isMultiple)\n            return;\n        payload.issues.push({\n            origin: typeof payload.value,\n            code: \"not_multiple_of\",\n            divisor: def.value,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckNumberFormat = /*@__PURE__*/ core.$constructor(\"$ZodCheckNumberFormat\", (inst, def) => {\n    $ZodCheck.init(inst, def); // no format checks\n    def.format = def.format || \"float64\";\n    const isInt = def.format?.includes(\"int\");\n    const origin = isInt ? \"int\" : \"number\";\n    const [minimum, maximum] = util.NUMBER_FORMAT_RANGES[def.format];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = def.format;\n        bag.minimum = minimum;\n        bag.maximum = maximum;\n        if (isInt)\n            bag.pattern = regexes.integer;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        if (isInt) {\n            if (!Number.isInteger(input)) {\n                // invalid_format issue\n                // payload.issues.push({\n                //   expected: def.format,\n                //   format: def.format,\n                //   code: \"invalid_format\",\n                //   input,\n                //   inst,\n                // });\n                // invalid_type issue\n                payload.issues.push({\n                    expected: origin,\n                    format: def.format,\n                    code: \"invalid_type\",\n                    continue: false,\n                    input,\n                    inst,\n                });\n                return;\n                // not_multiple_of issue\n                // payload.issues.push({\n                //   code: \"not_multiple_of\",\n                //   origin: \"number\",\n                //   input,\n                //   inst,\n                //   divisor: 1,\n                // });\n            }\n            if (!Number.isSafeInteger(input)) {\n                if (input > 0) {\n                    // too_big\n                    payload.issues.push({\n                        input,\n                        code: \"too_big\",\n                        maximum: Number.MAX_SAFE_INTEGER,\n                        note: \"Integers must be within the safe integer range.\",\n                        inst,\n                        origin,\n                        continue: !def.abort,\n                    });\n                }\n                else {\n                    // too_small\n                    payload.issues.push({\n                        input,\n                        code: \"too_small\",\n                        minimum: Number.MIN_SAFE_INTEGER,\n                        note: \"Integers must be within the safe integer range.\",\n                        inst,\n                        origin,\n                        continue: !def.abort,\n                    });\n                }\n                return;\n            }\n        }\n        if (input < minimum) {\n            payload.issues.push({\n                origin: \"number\",\n                input,\n                code: \"too_small\",\n                minimum,\n                inclusive: true,\n                inst,\n                continue: !def.abort,\n            });\n        }\n        if (input > maximum) {\n            payload.issues.push({\n                origin: \"number\",\n                input,\n                code: \"too_big\",\n                maximum,\n                inst,\n            });\n        }\n    };\n});\nexport const $ZodCheckBigIntFormat = /*@__PURE__*/ core.$constructor(\"$ZodCheckBigIntFormat\", (inst, def) => {\n    $ZodCheck.init(inst, def); // no format checks\n    const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = def.format;\n        bag.minimum = minimum;\n        bag.maximum = maximum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        if (input < minimum) {\n            payload.issues.push({\n                origin: \"bigint\",\n                input,\n                code: \"too_small\",\n                minimum: minimum,\n                inclusive: true,\n                inst,\n                continue: !def.abort,\n            });\n        }\n        if (input > maximum) {\n            payload.issues.push({\n                origin: \"bigint\",\n                input,\n                code: \"too_big\",\n                maximum,\n                inst,\n            });\n        }\n    };\n});\nexport const $ZodCheckMaxSize = /*@__PURE__*/ core.$constructor(\"$ZodCheckMaxSize\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.size !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);\n        if (def.maximum < curr)\n            inst._zod.bag.maximum = def.maximum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const size = input.size;\n        if (size <= def.maximum)\n            return;\n        payload.issues.push({\n            origin: util.getSizableOrigin(input),\n            code: \"too_big\",\n            maximum: def.maximum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMinSize = /*@__PURE__*/ core.$constructor(\"$ZodCheckMinSize\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.size !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);\n        if (def.minimum > curr)\n            inst._zod.bag.minimum = def.minimum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const size = input.size;\n        if (size >= def.minimum)\n            return;\n        payload.issues.push({\n            origin: util.getSizableOrigin(input),\n            code: \"too_small\",\n            minimum: def.minimum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckSizeEquals = /*@__PURE__*/ core.$constructor(\"$ZodCheckSizeEquals\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.size !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.minimum = def.size;\n        bag.maximum = def.size;\n        bag.size = def.size;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const size = input.size;\n        if (size === def.size)\n            return;\n        const tooBig = size > def.size;\n        payload.issues.push({\n            origin: util.getSizableOrigin(input),\n            ...(tooBig ? { code: \"too_big\", maximum: def.size } : { code: \"too_small\", minimum: def.size }),\n            inclusive: true,\n            exact: true,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMaxLength = /*@__PURE__*/ core.$constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.length !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);\n        if (def.maximum < curr)\n            inst._zod.bag.maximum = def.maximum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const length = input.length;\n        if (length <= def.maximum)\n            return;\n        const origin = util.getLengthableOrigin(input);\n        payload.issues.push({\n            origin,\n            code: \"too_big\",\n            maximum: def.maximum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckMinLength = /*@__PURE__*/ core.$constructor(\"$ZodCheckMinLength\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.length !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);\n        if (def.minimum > curr)\n            inst._zod.bag.minimum = def.minimum;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const length = input.length;\n        if (length >= def.minimum)\n            return;\n        const origin = util.getLengthableOrigin(input);\n        payload.issues.push({\n            origin,\n            code: \"too_small\",\n            minimum: def.minimum,\n            inclusive: true,\n            input,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckLengthEquals = /*@__PURE__*/ core.$constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n    var _a;\n    $ZodCheck.init(inst, def);\n    (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n        const val = payload.value;\n        return !util.nullish(val) && val.length !== undefined;\n    });\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.minimum = def.length;\n        bag.maximum = def.length;\n        bag.length = def.length;\n    });\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const length = input.length;\n        if (length === def.length)\n            return;\n        const origin = util.getLengthableOrigin(input);\n        const tooBig = length > def.length;\n        payload.issues.push({\n            origin,\n            ...(tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length }),\n            inclusive: true,\n            exact: true,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodCheckStringFormat\", (inst, def) => {\n    var _a, _b;\n    $ZodCheck.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = def.format;\n        if (def.pattern) {\n            bag.patterns ?? (bag.patterns = new Set());\n            bag.patterns.add(def.pattern);\n        }\n    });\n    if (def.pattern)\n        (_a = inst._zod).check ?? (_a.check = (payload) => {\n            def.pattern.lastIndex = 0;\n            if (def.pattern.test(payload.value))\n                return;\n            payload.issues.push({\n                origin: \"string\",\n                code: \"invalid_format\",\n                format: def.format,\n                input: payload.value,\n                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),\n                inst,\n                continue: !def.abort,\n            });\n        });\n    else\n        (_b = inst._zod).check ?? (_b.check = () => { });\n});\nexport const $ZodCheckRegex = /*@__PURE__*/ core.$constructor(\"$ZodCheckRegex\", (inst, def) => {\n    $ZodCheckStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        def.pattern.lastIndex = 0;\n        if (def.pattern.test(payload.value))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"regex\",\n            input: payload.value,\n            pattern: def.pattern.toString(),\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckLowerCase = /*@__PURE__*/ core.$constructor(\"$ZodCheckLowerCase\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.lowercase);\n    $ZodCheckStringFormat.init(inst, def);\n});\nexport const $ZodCheckUpperCase = /*@__PURE__*/ core.$constructor(\"$ZodCheckUpperCase\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.uppercase);\n    $ZodCheckStringFormat.init(inst, def);\n});\nexport const $ZodCheckIncludes = /*@__PURE__*/ core.$constructor(\"$ZodCheckIncludes\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const escapedRegex = util.escapeRegex(def.includes);\n    const pattern = new RegExp(typeof def.position === \"number\" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n    def.pattern = pattern;\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.patterns ?? (bag.patterns = new Set());\n        bag.patterns.add(pattern);\n    });\n    inst._zod.check = (payload) => {\n        if (payload.value.includes(def.includes, def.position))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"includes\",\n            includes: def.includes,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckStartsWith = /*@__PURE__*/ core.$constructor(\"$ZodCheckStartsWith\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const pattern = new RegExp(`^${util.escapeRegex(def.prefix)}.*`);\n    def.pattern ?? (def.pattern = pattern);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.patterns ?? (bag.patterns = new Set());\n        bag.patterns.add(pattern);\n    });\n    inst._zod.check = (payload) => {\n        if (payload.value.startsWith(def.prefix))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"starts_with\",\n            prefix: def.prefix,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckEndsWith = /*@__PURE__*/ core.$constructor(\"$ZodCheckEndsWith\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const pattern = new RegExp(`.*${util.escapeRegex(def.suffix)}$`);\n    def.pattern ?? (def.pattern = pattern);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.patterns ?? (bag.patterns = new Set());\n        bag.patterns.add(pattern);\n    });\n    inst._zod.check = (payload) => {\n        if (payload.value.endsWith(def.suffix))\n            return;\n        payload.issues.push({\n            origin: \"string\",\n            code: \"invalid_format\",\n            format: \"ends_with\",\n            suffix: def.suffix,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\n///////////////////////////////////\n/////    $ZodCheckProperty    /////\n///////////////////////////////////\nfunction handleCheckPropertyResult(result, payload, property) {\n    if (result.issues.length) {\n        payload.issues.push(...util.prefixIssues(property, result.issues));\n    }\n}\nexport const $ZodCheckProperty = /*@__PURE__*/ core.$constructor(\"$ZodCheckProperty\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    inst._zod.check = (payload) => {\n        const result = def.schema._zod.run({\n            value: payload.value[def.property],\n            issues: [],\n        }, {});\n        if (result instanceof Promise) {\n            return result.then((result) => handleCheckPropertyResult(result, payload, def.property));\n        }\n        handleCheckPropertyResult(result, payload, def.property);\n        return;\n    };\n});\nexport const $ZodCheckMimeType = /*@__PURE__*/ core.$constructor(\"$ZodCheckMimeType\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    const mimeSet = new Set(def.mime);\n    inst._zod.onattach.push((inst) => {\n        inst._zod.bag.mime = def.mime;\n    });\n    inst._zod.check = (payload) => {\n        if (mimeSet.has(payload.value.type))\n            return;\n        payload.issues.push({\n            code: \"invalid_value\",\n            values: def.mime,\n            input: payload.value.type,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCheckOverwrite = /*@__PURE__*/ core.$constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n    $ZodCheck.init(inst, def);\n    inst._zod.check = (payload) => {\n        payload.value = def.tx(payload.value);\n    };\n});\n","import * as checks from \"./checks.js\";\nimport * as registries from \"./registries.js\";\nimport * as schemas from \"./schemas.js\";\nimport * as util from \"./util.js\";\nexport function _string(Class, params) {\n    return new Class({\n        type: \"string\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _coercedString(Class, params) {\n    return new Class({\n        type: \"string\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _email(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"email\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _guid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"guid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uuid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uuidv4(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        version: \"v4\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uuidv6(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        version: \"v6\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uuidv7(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"uuid\",\n        check: \"string_format\",\n        abort: false,\n        version: \"v7\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _url(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"url\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _emoji(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"emoji\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _nanoid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"nanoid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _cuid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cuid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _cuid2(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cuid2\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _ulid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ulid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _xid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"xid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _ksuid(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ksuid\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _ipv4(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ipv4\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _ipv6(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"ipv6\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _mac(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"mac\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _cidrv4(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cidrv4\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _cidrv6(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"cidrv6\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _base64(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"base64\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _base64url(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"base64url\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _e164(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"e164\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _jwt(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"jwt\",\n        check: \"string_format\",\n        abort: false,\n        ...util.normalizeParams(params),\n    });\n}\nexport const TimePrecision = {\n    Any: null,\n    Minute: -1,\n    Second: 0,\n    Millisecond: 3,\n    Microsecond: 6,\n};\nexport function _isoDateTime(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"datetime\",\n        check: \"string_format\",\n        offset: false,\n        local: false,\n        precision: null,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _isoDate(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"date\",\n        check: \"string_format\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _isoTime(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"time\",\n        check: \"string_format\",\n        precision: null,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _isoDuration(Class, params) {\n    return new Class({\n        type: \"string\",\n        format: \"duration\",\n        check: \"string_format\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _number(Class, params) {\n    return new Class({\n        type: \"number\",\n        checks: [],\n        ...util.normalizeParams(params),\n    });\n}\nexport function _coercedNumber(Class, params) {\n    return new Class({\n        type: \"number\",\n        coerce: true,\n        checks: [],\n        ...util.normalizeParams(params),\n    });\n}\nexport function _int(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"safeint\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _float32(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"float32\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _float64(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"float64\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _int32(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"int32\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uint32(Class, params) {\n    return new Class({\n        type: \"number\",\n        check: \"number_format\",\n        abort: false,\n        format: \"uint32\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _boolean(Class, params) {\n    return new Class({\n        type: \"boolean\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _coercedBoolean(Class, params) {\n    return new Class({\n        type: \"boolean\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _bigint(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _coercedBigint(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _int64(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        check: \"bigint_format\",\n        abort: false,\n        format: \"int64\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uint64(Class, params) {\n    return new Class({\n        type: \"bigint\",\n        check: \"bigint_format\",\n        abort: false,\n        format: \"uint64\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _symbol(Class, params) {\n    return new Class({\n        type: \"symbol\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _undefined(Class, params) {\n    return new Class({\n        type: \"undefined\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _null(Class, params) {\n    return new Class({\n        type: \"null\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _any(Class) {\n    return new Class({\n        type: \"any\",\n    });\n}\nexport function _unknown(Class) {\n    return new Class({\n        type: \"unknown\",\n    });\n}\nexport function _never(Class, params) {\n    return new Class({\n        type: \"never\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _void(Class, params) {\n    return new Class({\n        type: \"void\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _date(Class, params) {\n    return new Class({\n        type: \"date\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _coercedDate(Class, params) {\n    return new Class({\n        type: \"date\",\n        coerce: true,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _nan(Class, params) {\n    return new Class({\n        type: \"nan\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _lt(value, params) {\n    return new checks.$ZodCheckLessThan({\n        check: \"less_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: false,\n    });\n}\nexport function _lte(value, params) {\n    return new checks.$ZodCheckLessThan({\n        check: \"less_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: true,\n    });\n}\nexport { \n/** @deprecated Use `z.lte()` instead. */\n_lte as _max, };\nexport function _gt(value, params) {\n    return new checks.$ZodCheckGreaterThan({\n        check: \"greater_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: false,\n    });\n}\nexport function _gte(value, params) {\n    return new checks.$ZodCheckGreaterThan({\n        check: \"greater_than\",\n        ...util.normalizeParams(params),\n        value,\n        inclusive: true,\n    });\n}\nexport { \n/** @deprecated Use `z.gte()` instead. */\n_gte as _min, };\nexport function _positive(params) {\n    return _gt(0, params);\n}\n// negative\nexport function _negative(params) {\n    return _lt(0, params);\n}\n// nonpositive\nexport function _nonpositive(params) {\n    return _lte(0, params);\n}\n// nonnegative\nexport function _nonnegative(params) {\n    return _gte(0, params);\n}\nexport function _multipleOf(value, params) {\n    return new checks.$ZodCheckMultipleOf({\n        check: \"multiple_of\",\n        ...util.normalizeParams(params),\n        value,\n    });\n}\nexport function _maxSize(maximum, params) {\n    return new checks.$ZodCheckMaxSize({\n        check: \"max_size\",\n        ...util.normalizeParams(params),\n        maximum,\n    });\n}\nexport function _minSize(minimum, params) {\n    return new checks.$ZodCheckMinSize({\n        check: \"min_size\",\n        ...util.normalizeParams(params),\n        minimum,\n    });\n}\nexport function _size(size, params) {\n    return new checks.$ZodCheckSizeEquals({\n        check: \"size_equals\",\n        ...util.normalizeParams(params),\n        size,\n    });\n}\nexport function _maxLength(maximum, params) {\n    const ch = new checks.$ZodCheckMaxLength({\n        check: \"max_length\",\n        ...util.normalizeParams(params),\n        maximum,\n    });\n    return ch;\n}\nexport function _minLength(minimum, params) {\n    return new checks.$ZodCheckMinLength({\n        check: \"min_length\",\n        ...util.normalizeParams(params),\n        minimum,\n    });\n}\nexport function _length(length, params) {\n    return new checks.$ZodCheckLengthEquals({\n        check: \"length_equals\",\n        ...util.normalizeParams(params),\n        length,\n    });\n}\nexport function _regex(pattern, params) {\n    return new checks.$ZodCheckRegex({\n        check: \"string_format\",\n        format: \"regex\",\n        ...util.normalizeParams(params),\n        pattern,\n    });\n}\nexport function _lowercase(params) {\n    return new checks.$ZodCheckLowerCase({\n        check: \"string_format\",\n        format: \"lowercase\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _uppercase(params) {\n    return new checks.$ZodCheckUpperCase({\n        check: \"string_format\",\n        format: \"uppercase\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _includes(includes, params) {\n    return new checks.$ZodCheckIncludes({\n        check: \"string_format\",\n        format: \"includes\",\n        ...util.normalizeParams(params),\n        includes,\n    });\n}\nexport function _startsWith(prefix, params) {\n    return new checks.$ZodCheckStartsWith({\n        check: \"string_format\",\n        format: \"starts_with\",\n        ...util.normalizeParams(params),\n        prefix,\n    });\n}\nexport function _endsWith(suffix, params) {\n    return new checks.$ZodCheckEndsWith({\n        check: \"string_format\",\n        format: \"ends_with\",\n        ...util.normalizeParams(params),\n        suffix,\n    });\n}\nexport function _property(property, schema, params) {\n    return new checks.$ZodCheckProperty({\n        check: \"property\",\n        property,\n        schema,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _mime(types, params) {\n    return new checks.$ZodCheckMimeType({\n        check: \"mime_type\",\n        mime: types,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _overwrite(tx) {\n    return new checks.$ZodCheckOverwrite({\n        check: \"overwrite\",\n        tx,\n    });\n}\n// normalize\nexport function _normalize(form) {\n    return _overwrite((input) => input.normalize(form));\n}\n// trim\nexport function _trim() {\n    return _overwrite((input) => input.trim());\n}\n// toLowerCase\nexport function _toLowerCase() {\n    return _overwrite((input) => input.toLowerCase());\n}\n// toUpperCase\nexport function _toUpperCase() {\n    return _overwrite((input) => input.toUpperCase());\n}\n// slugify\nexport function _slugify() {\n    return _overwrite((input) => util.slugify(input));\n}\nexport function _array(Class, element, params) {\n    return new Class({\n        type: \"array\",\n        element,\n        // get element() {\n        //   return element;\n        // },\n        ...util.normalizeParams(params),\n    });\n}\nexport function _union(Class, options, params) {\n    return new Class({\n        type: \"union\",\n        options,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _discriminatedUnion(Class, discriminator, options, params) {\n    return new Class({\n        type: \"union\",\n        options,\n        discriminator,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _intersection(Class, left, right) {\n    return new Class({\n        type: \"intersection\",\n        left,\n        right,\n    });\n}\n// export function _tuple(\n//   Class: util.SchemaClass<schemas.$ZodTuple>,\n//   items: [],\n//   params?: string | $ZodTupleParams\n// ): schemas.$ZodTuple<[], null>;\nexport function _tuple(Class, items, _paramsOrRest, _params) {\n    const hasRest = _paramsOrRest instanceof schemas.$ZodType;\n    const params = hasRest ? _params : _paramsOrRest;\n    const rest = hasRest ? _paramsOrRest : null;\n    return new Class({\n        type: \"tuple\",\n        items,\n        rest,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _record(Class, keyType, valueType, params) {\n    return new Class({\n        type: \"record\",\n        keyType,\n        valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _map(Class, keyType, valueType, params) {\n    return new Class({\n        type: \"map\",\n        keyType,\n        valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _set(Class, valueType, params) {\n    return new Class({\n        type: \"set\",\n        valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _enum(Class, values, params) {\n    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n    // if (Array.isArray(values)) {\n    //   for (const value of values) {\n    //     entries[value] = value;\n    //   }\n    // } else {\n    //   Object.assign(entries, values);\n    // }\n    // const entries: util.EnumLike = {};\n    // for (const val of values) {\n    //   entries[val] = val;\n    // }\n    return new Class({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function _nativeEnum(Class, entries, params) {\n    return new Class({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _literal(Class, value, params) {\n    return new Class({\n        type: \"literal\",\n        values: Array.isArray(value) ? value : [value],\n        ...util.normalizeParams(params),\n    });\n}\nexport function _file(Class, params) {\n    return new Class({\n        type: \"file\",\n        ...util.normalizeParams(params),\n    });\n}\nexport function _transform(Class, fn) {\n    return new Class({\n        type: \"transform\",\n        transform: fn,\n    });\n}\nexport function _optional(Class, innerType) {\n    return new Class({\n        type: \"optional\",\n        innerType,\n    });\n}\nexport function _nullable(Class, innerType) {\n    return new Class({\n        type: \"nullable\",\n        innerType,\n    });\n}\nexport function _default(Class, innerType, defaultValue) {\n    return new Class({\n        type: \"default\",\n        innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport function _nonoptional(Class, innerType, params) {\n    return new Class({\n        type: \"nonoptional\",\n        innerType,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _success(Class, innerType) {\n    return new Class({\n        type: \"success\",\n        innerType,\n    });\n}\nexport function _catch(Class, innerType, catchValue) {\n    return new Class({\n        type: \"catch\",\n        innerType,\n        catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue),\n    });\n}\nexport function _pipe(Class, in_, out) {\n    return new Class({\n        type: \"pipe\",\n        in: in_,\n        out,\n    });\n}\nexport function _readonly(Class, innerType) {\n    return new Class({\n        type: \"readonly\",\n        innerType,\n    });\n}\nexport function _templateLiteral(Class, parts, params) {\n    return new Class({\n        type: \"template_literal\",\n        parts,\n        ...util.normalizeParams(params),\n    });\n}\nexport function _lazy(Class, getter) {\n    return new Class({\n        type: \"lazy\",\n        getter,\n    });\n}\nexport function _promise(Class, innerType) {\n    return new Class({\n        type: \"promise\",\n        innerType,\n    });\n}\nexport function _custom(Class, fn, _params) {\n    const norm = util.normalizeParams(_params);\n    norm.abort ?? (norm.abort = true); // default to abort:false\n    const schema = new Class({\n        type: \"custom\",\n        check: \"custom\",\n        fn: fn,\n        ...norm,\n    });\n    return schema;\n}\n// same as _custom but defaults to abort:false\nexport function _refine(Class, fn, _params) {\n    const schema = new Class({\n        type: \"custom\",\n        check: \"custom\",\n        fn: fn,\n        ...util.normalizeParams(_params),\n    });\n    return schema;\n}\nexport function _superRefine(fn) {\n    const ch = _check((payload) => {\n        payload.addIssue = (issue) => {\n            if (typeof issue === \"string\") {\n                payload.issues.push(util.issue(issue, payload.value, ch._zod.def));\n            }\n            else {\n                // for Zod 3 backwards compatibility\n                const _issue = issue;\n                if (_issue.fatal)\n                    _issue.continue = false;\n                _issue.code ?? (_issue.code = \"custom\");\n                _issue.input ?? (_issue.input = payload.value);\n                _issue.inst ?? (_issue.inst = ch);\n                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...\n                payload.issues.push(util.issue(_issue));\n            }\n        };\n        return fn(payload.value, payload);\n    });\n    return ch;\n}\nexport function _check(fn, params) {\n    const ch = new checks.$ZodCheck({\n        check: \"custom\",\n        ...util.normalizeParams(params),\n    });\n    ch._zod.check = fn;\n    return ch;\n}\nexport function describe(description) {\n    const ch = new checks.$ZodCheck({ check: \"describe\" });\n    ch._zod.onattach = [\n        (inst) => {\n            const existing = registries.globalRegistry.get(inst) ?? {};\n            registries.globalRegistry.add(inst, { ...existing, description });\n        },\n    ];\n    ch._zod.check = () => { }; // no-op check\n    return ch;\n}\nexport function meta(metadata) {\n    const ch = new checks.$ZodCheck({ check: \"meta\" });\n    ch._zod.onattach = [\n        (inst) => {\n            const existing = registries.globalRegistry.get(inst) ?? {};\n            registries.globalRegistry.add(inst, { ...existing, ...metadata });\n        },\n    ];\n    ch._zod.check = () => { }; // no-op check\n    return ch;\n}\nexport function _stringbool(Classes, _params) {\n    const params = util.normalizeParams(_params);\n    let truthyArray = params.truthy ?? [\"true\", \"1\", \"yes\", \"on\", \"y\", \"enabled\"];\n    let falsyArray = params.falsy ?? [\"false\", \"0\", \"no\", \"off\", \"n\", \"disabled\"];\n    if (params.case !== \"sensitive\") {\n        truthyArray = truthyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n        falsyArray = falsyArray.map((v) => (typeof v === \"string\" ? v.toLowerCase() : v));\n    }\n    const truthySet = new Set(truthyArray);\n    const falsySet = new Set(falsyArray);\n    const _Codec = Classes.Codec ?? schemas.$ZodCodec;\n    const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;\n    const _String = Classes.String ?? schemas.$ZodString;\n    const stringSchema = new _String({ type: \"string\", error: params.error });\n    const booleanSchema = new _Boolean({ type: \"boolean\", error: params.error });\n    const codec = new _Codec({\n        type: \"pipe\",\n        in: stringSchema,\n        out: booleanSchema,\n        transform: ((input, payload) => {\n            let data = input;\n            if (params.case !== \"sensitive\")\n                data = data.toLowerCase();\n            if (truthySet.has(data)) {\n                return true;\n            }\n            else if (falsySet.has(data)) {\n                return false;\n            }\n            else {\n                payload.issues.push({\n                    code: \"invalid_value\",\n                    expected: \"stringbool\",\n                    values: [...truthySet, ...falsySet],\n                    input: payload.value,\n                    inst: codec,\n                    continue: false,\n                });\n                return {};\n            }\n        }),\n        reverseTransform: ((input, _payload) => {\n            if (input === true) {\n                return truthyArray[0] || \"true\";\n            }\n            else {\n                return falsyArray[0] || \"false\";\n            }\n        }),\n        error: params.error,\n    });\n    return codec;\n}\nexport function _stringFormat(Class, format, fnOrRegex, _params = {}) {\n    const params = util.normalizeParams(_params);\n    const def = {\n        ...util.normalizeParams(_params),\n        check: \"string_format\",\n        type: \"string\",\n        format,\n        fn: typeof fnOrRegex === \"function\" ? fnOrRegex : (val) => fnOrRegex.test(val),\n        ...params,\n    };\n    if (fnOrRegex instanceof RegExp) {\n        def.pattern = fnOrRegex;\n    }\n    const inst = new Class(def);\n    return inst;\n}\n","import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isContentBlock, _isObject, _isString } from \"./utils.js\";\n\nfunction convertToV1FromChatGoogleMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `libs/providers/langchain-google-genai/src/utils/common.ts:mapGenerateContentResultToChatResult\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (\n        _isContentBlock(block, \"inlineData\") &&\n        _isObject(block.inlineData) &&\n        _isString(block.inlineData.mimeType) &&\n        _isString(block.inlineData.data)\n      ) {\n        yield {\n          type: \"file\",\n          mimeType: block.inlineData.mimeType,\n          data: block.inlineData.data,\n        };\n        continue;\n      } else if (\n        _isContentBlock(block, \"functionCall\") &&\n        _isObject(block.functionCall) &&\n        _isString(block.functionCall.name) &&\n        _isObject(block.functionCall.args)\n      ) {\n        yield {\n          type: \"tool_call\",\n          id: message.id,\n          name: block.functionCall.name,\n          args: block.functionCall.args,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"functionResponse\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (\n        _isContentBlock(block, \"fileData\") &&\n        _isObject(block.fileData) &&\n        _isString(block.fileData.mimeType) &&\n        _isString(block.fileData.fileUri)\n      ) {\n        yield {\n          type: \"file\",\n          mimeType: block.fileData.mimeType,\n          fileId: block.fileData.fileUri,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"executableCode\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (_isContentBlock(block, \"codeExecutionResult\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatGoogleGenAITranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatGoogleMessage,\n  translateContentChunk: convertToV1FromChatGoogleMessage,\n};\n","import { Refs } from \"../Refs.js\";\nimport { JsonSchema7AnyType, parseAnyDef } from \"./any.js\";\n\nexport type JsonSchema7NeverType = {\n  not: JsonSchema7AnyType;\n};\n\nexport function parseNeverDef(refs: Refs): JsonSchema7NeverType | undefined {\n  return refs.target === \"openAi\"\n    ? undefined\n    : {\n        not: parseAnyDef({\n          ...refs,\n          currentPath: [...refs.currentPath, \"not\"],\n        }),\n      };\n}\n","import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointListOptions,\n  CheckpointTuple,\n  copyCheckpoint,\n  getCheckpointId,\n  maxChannelVersion,\n  WRITES_IDX_MAP,\n} from \"./base.js\";\nimport { SerializerProtocol } from \"./serde/base.js\";\nimport {\n  CheckpointMetadata,\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"./types.js\";\nimport { TASKS } from \"./serde/types.js\";\n\nfunction _generateKey(\n  threadId: string,\n  checkpointNamespace: string,\n  checkpointId: string\n) {\n  return JSON.stringify([threadId, checkpointNamespace, checkpointId]);\n}\n\nfunction _parseKey(key: string) {\n  const [threadId, checkpointNamespace, checkpointId] = JSON.parse(key);\n  return { threadId, checkpointNamespace, checkpointId };\n}\n\nexport class MemorySaver extends BaseCheckpointSaver {\n  // thread ID ->  checkpoint namespace -> checkpoint ID -> checkpoint mapping\n  storage: Record<\n    string,\n    Record<string, Record<string, [Uint8Array, Uint8Array, string | undefined]>>\n  > = {};\n\n  writes: Record<string, Record<string, [string, string, Uint8Array]>> = {};\n\n  constructor(serde?: SerializerProtocol) {\n    super(serde);\n  }\n\n  /** @internal */\n  async _migratePendingSends(\n    mutableCheckpoint: Checkpoint,\n    threadId: string,\n    checkpointNs: string,\n    parentCheckpointId: string\n  ) {\n    const deseriablizableCheckpoint = mutableCheckpoint;\n    const parentKey = _generateKey(threadId, checkpointNs, parentCheckpointId);\n\n    const pendingSends = await Promise.all(\n      Object.values(this.writes[parentKey] ?? {})\n        .filter(([_taskId, channel]) => channel === TASKS)\n        .map(\n          async ([_taskId, _channel, writes]) =>\n            await this.serde.loadsTyped(\"json\", writes)\n        )\n    );\n\n    deseriablizableCheckpoint.channel_values ??= {};\n    deseriablizableCheckpoint.channel_values[TASKS] = pendingSends;\n\n    deseriablizableCheckpoint.channel_versions ??= {};\n    deseriablizableCheckpoint.channel_versions[TASKS] =\n      Object.keys(deseriablizableCheckpoint.channel_versions).length > 0\n        ? maxChannelVersion(\n            ...Object.values(deseriablizableCheckpoint.channel_versions)\n          )\n        : this.getNextVersion(undefined);\n  }\n\n  async getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined> {\n    const thread_id = config.configurable?.thread_id;\n    const checkpoint_ns = config.configurable?.checkpoint_ns ?? \"\";\n    let checkpoint_id = getCheckpointId(config);\n\n    if (checkpoint_id) {\n      const saved = this.storage[thread_id]?.[checkpoint_ns]?.[checkpoint_id];\n      if (saved !== undefined) {\n        const [checkpoint, metadata, parentCheckpointId] = saved;\n        const key = _generateKey(thread_id, checkpoint_ns, checkpoint_id);\n        const deserializedCheckpoint: Checkpoint = await this.serde.loadsTyped(\n          \"json\",\n          checkpoint\n        );\n\n        if (deserializedCheckpoint.v < 4 && parentCheckpointId !== undefined) {\n          await this._migratePendingSends(\n            deserializedCheckpoint,\n            thread_id,\n            checkpoint_ns,\n            parentCheckpointId\n          );\n        }\n\n        const pendingWrites: CheckpointPendingWrite[] = await Promise.all(\n          Object.values(this.writes[key] || {}).map(\n            async ([taskId, channel, value]) => {\n              return [\n                taskId,\n                channel,\n                await this.serde.loadsTyped(\"json\", value),\n              ];\n            }\n          )\n        );\n        const checkpointTuple: CheckpointTuple = {\n          config,\n          checkpoint: deserializedCheckpoint,\n          metadata: (await this.serde.loadsTyped(\n            \"json\",\n            metadata\n          )) as CheckpointMetadata,\n          pendingWrites,\n        };\n        if (parentCheckpointId !== undefined) {\n          checkpointTuple.parentConfig = {\n            configurable: {\n              thread_id,\n              checkpoint_ns,\n              checkpoint_id: parentCheckpointId,\n            },\n          };\n        }\n        return checkpointTuple;\n      }\n    } else {\n      const checkpoints = this.storage[thread_id]?.[checkpoint_ns];\n      if (checkpoints !== undefined) {\n        // eslint-disable-next-line prefer-destructuring\n        checkpoint_id = Object.keys(checkpoints).sort((a, b) =>\n          b.localeCompare(a)\n        )[0];\n        const saved = checkpoints[checkpoint_id];\n        const [checkpoint, metadata, parentCheckpointId] = saved;\n        const key = _generateKey(thread_id, checkpoint_ns, checkpoint_id);\n        const deserializedCheckpoint: Checkpoint = await this.serde.loadsTyped(\n          \"json\",\n          checkpoint\n        );\n\n        if (deserializedCheckpoint.v < 4 && parentCheckpointId !== undefined) {\n          await this._migratePendingSends(\n            deserializedCheckpoint,\n            thread_id,\n            checkpoint_ns,\n            parentCheckpointId\n          );\n        }\n\n        const pendingWrites: CheckpointPendingWrite[] = await Promise.all(\n          Object.values(this.writes[key] || {}).map(\n            async ([taskId, channel, value]) => {\n              return [\n                taskId,\n                channel,\n                await this.serde.loadsTyped(\"json\", value),\n              ];\n            }\n          )\n        );\n        const checkpointTuple: CheckpointTuple = {\n          config: {\n            configurable: {\n              thread_id,\n              checkpoint_id,\n              checkpoint_ns,\n            },\n          },\n          checkpoint: deserializedCheckpoint,\n          metadata: (await this.serde.loadsTyped(\n            \"json\",\n            metadata\n          )) as CheckpointMetadata,\n          pendingWrites,\n        };\n        if (parentCheckpointId !== undefined) {\n          checkpointTuple.parentConfig = {\n            configurable: {\n              thread_id,\n              checkpoint_ns,\n              checkpoint_id: parentCheckpointId,\n            },\n          };\n        }\n        return checkpointTuple;\n      }\n    }\n\n    return undefined;\n  }\n\n  async *list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple> {\n    // eslint-disable-next-line prefer-const\n    let { before, limit, filter } = options ?? {};\n    const threadIds = config.configurable?.thread_id\n      ? [config.configurable?.thread_id]\n      : Object.keys(this.storage);\n    const configCheckpointNamespace = config.configurable?.checkpoint_ns;\n    const configCheckpointId = config.configurable?.checkpoint_id;\n\n    for (const threadId of threadIds) {\n      for (const checkpointNamespace of Object.keys(\n        this.storage[threadId] ?? {}\n      )) {\n        if (\n          configCheckpointNamespace !== undefined &&\n          checkpointNamespace !== configCheckpointNamespace\n        ) {\n          continue;\n        }\n        const checkpoints = this.storage[threadId]?.[checkpointNamespace] ?? {};\n        const sortedCheckpoints = Object.entries(checkpoints).sort((a, b) =>\n          b[0].localeCompare(a[0])\n        );\n\n        for (const [\n          checkpointId,\n          [checkpoint, metadataStr, parentCheckpointId],\n        ] of sortedCheckpoints) {\n          // Filter by checkpoint ID from config\n          if (configCheckpointId && checkpointId !== configCheckpointId) {\n            continue;\n          }\n\n          // Filter by checkpoint ID from before config\n          if (\n            before &&\n            before.configurable?.checkpoint_id &&\n            checkpointId >= before.configurable.checkpoint_id\n          ) {\n            continue;\n          }\n\n          // Parse metadata\n          const metadata = (await this.serde.loadsTyped(\n            \"json\",\n            metadataStr\n          )) as CheckpointMetadata;\n\n          if (\n            filter &&\n            !Object.entries(filter).every(\n              ([key, value]) =>\n                (metadata as unknown as Record<string, unknown>)[key] === value\n            )\n          ) {\n            continue;\n          }\n\n          // Limit search results\n          if (limit !== undefined) {\n            if (limit <= 0) break;\n            limit -= 1;\n          }\n\n          const key = _generateKey(threadId, checkpointNamespace, checkpointId);\n          const writes = Object.values(this.writes[key] || {});\n\n          const pendingWrites: CheckpointPendingWrite[] = await Promise.all(\n            writes.map(async ([taskId, channel, value]) => {\n              return [\n                taskId,\n                channel,\n                await this.serde.loadsTyped(\"json\", value),\n              ];\n            })\n          );\n\n          const deserializedCheckpoint = await this.serde.loadsTyped(\n            \"json\",\n            checkpoint\n          );\n\n          if (\n            deserializedCheckpoint.v < 4 &&\n            parentCheckpointId !== undefined\n          ) {\n            await this._migratePendingSends(\n              deserializedCheckpoint,\n              threadId,\n              checkpointNamespace,\n              parentCheckpointId\n            );\n          }\n\n          const checkpointTuple: CheckpointTuple = {\n            config: {\n              configurable: {\n                thread_id: threadId,\n                checkpoint_ns: checkpointNamespace,\n                checkpoint_id: checkpointId,\n              },\n            },\n            checkpoint: deserializedCheckpoint,\n            metadata,\n            pendingWrites,\n          };\n          if (parentCheckpointId !== undefined) {\n            checkpointTuple.parentConfig = {\n              configurable: {\n                thread_id: threadId,\n                checkpoint_ns: checkpointNamespace,\n                checkpoint_id: parentCheckpointId,\n              },\n            };\n          }\n          yield checkpointTuple;\n        }\n      }\n    }\n  }\n\n  async put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata\n  ): Promise<RunnableConfig> {\n    const preparedCheckpoint: Partial<Checkpoint> = copyCheckpoint(checkpoint);\n    const threadId = config.configurable?.thread_id;\n    const checkpointNamespace = config.configurable?.checkpoint_ns ?? \"\";\n    if (threadId === undefined) {\n      throw new Error(\n        `Failed to put checkpoint. The passed RunnableConfig is missing a required \"thread_id\" field in its \"configurable\" property.`\n      );\n    }\n\n    if (!this.storage[threadId]) {\n      this.storage[threadId] = {};\n    }\n    if (!this.storage[threadId][checkpointNamespace]) {\n      this.storage[threadId][checkpointNamespace] = {};\n    }\n\n    const [[, serializedCheckpoint], [, serializedMetadata]] =\n      await Promise.all([\n        this.serde.dumpsTyped(preparedCheckpoint),\n        this.serde.dumpsTyped(metadata),\n      ]);\n\n    this.storage[threadId][checkpointNamespace][checkpoint.id] = [\n      serializedCheckpoint,\n      serializedMetadata,\n      config.configurable?.checkpoint_id, // parent\n    ];\n\n    return {\n      configurable: {\n        thread_id: threadId,\n        checkpoint_ns: checkpointNamespace,\n        checkpoint_id: checkpoint.id,\n      },\n    };\n  }\n\n  async putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void> {\n    const threadId = config.configurable?.thread_id;\n    const checkpointNamespace = config.configurable?.checkpoint_ns;\n    const checkpointId = config.configurable?.checkpoint_id;\n    if (threadId === undefined) {\n      throw new Error(\n        `Failed to put writes. The passed RunnableConfig is missing a required \"thread_id\" field in its \"configurable\" property`\n      );\n    }\n    if (checkpointId === undefined) {\n      throw new Error(\n        `Failed to put writes. The passed RunnableConfig is missing a required \"checkpoint_id\" field in its \"configurable\" property.`\n      );\n    }\n    const outerKey = _generateKey(threadId, checkpointNamespace, checkpointId);\n    const outerWrites_ = this.writes[outerKey];\n    if (this.writes[outerKey] === undefined) {\n      this.writes[outerKey] = {};\n    }\n\n    await Promise.all(\n      writes.map(async ([channel, value], idx) => {\n        const [, serializedValue] = await this.serde.dumpsTyped(value);\n        const innerKey: [string, number] = [\n          taskId,\n          WRITES_IDX_MAP[channel] || idx,\n        ];\n        const innerKeyStr = `${innerKey[0]},${innerKey[1]}`;\n        if (innerKey[1] >= 0 && outerWrites_ && innerKeyStr in outerWrites_) {\n          return;\n        }\n        this.writes[outerKey][innerKeyStr] = [taskId, channel, serializedValue];\n      })\n    );\n  }\n\n  async deleteThread(threadId: string): Promise<void> {\n    delete this.storage[threadId];\n    for (const key of Object.keys(this.writes)) {\n      if (_parseKey(key).threadId === threadId) delete this.writes[key];\n    }\n  }\n}\n","import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\nexport const areSetsEqual = <T>(a: Set<T>, b: Set<T>) =>\n  a.size === b.size && [...a].every((value) => b.has(value));\n\n/**\n * A channel that waits until all named values are received before making the value available.\n *\n * This ensures that if node N and node M both write to channel C, the value of C will not be updated\n * until N and M have completed updating.\n */\nexport class NamedBarrierValue<Value> extends BaseChannel<\n  void,\n  Value,\n  Value[]\n> {\n  lc_graph_name = \"NamedBarrierValue\";\n\n  names: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  constructor(names: Set<Value>) {\n    super();\n    this.names = names;\n    this.seen = new Set<Value>();\n  }\n\n  fromCheckpoint(checkpoint?: Value[]) {\n    const empty = new NamedBarrierValue<Value>(this.names);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.seen = new Set(checkpoint);\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    let updated = false;\n    for (const nodeName of values) {\n      if (this.names.has(nodeName)) {\n        if (!this.seen.has(nodeName)) {\n          this.seen.add(nodeName);\n          updated = true;\n        }\n      } else {\n        throw new InvalidUpdateError(\n          `Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(\n            this.names\n          )}`\n        );\n      }\n    }\n    return updated;\n  }\n\n  // If we have not yet seen all the node names we want to wait for,\n  // throw an error to prevent continuing.\n  get(): void {\n    if (!areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): Value[] {\n    return [...this.seen];\n  }\n\n  consume(): boolean {\n    if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {\n      this.seen = new Set<Value>();\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n\n/**\n * A channel that waits until all named values are received before making the value ready to be made available.\n * It is only made available after finish() is called.\n * @internal\n */\nexport class NamedBarrierValueAfterFinish<Value> extends BaseChannel<\n  void,\n  Value,\n  [Value[], boolean]\n> {\n  lc_graph_name = \"NamedBarrierValueAfterFinish\";\n\n  names: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  finished: boolean;\n\n  constructor(names: Set<Value>) {\n    super();\n    this.names = names;\n    this.seen = new Set<Value>();\n    this.finished = false;\n  }\n\n  fromCheckpoint(checkpoint?: [Value[], boolean]) {\n    const empty = new NamedBarrierValueAfterFinish<Value>(this.names);\n    if (typeof checkpoint !== \"undefined\") {\n      const [seen, finished] = checkpoint;\n      empty.seen = new Set(seen);\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    let updated = false;\n    for (const nodeName of values) {\n      if (this.names.has(nodeName) && !this.seen.has(nodeName)) {\n        this.seen.add(nodeName);\n        updated = true;\n      } else if (!this.names.has(nodeName)) {\n        throw new InvalidUpdateError(\n          `Value ${JSON.stringify(nodeName)} not in names ${JSON.stringify(\n            this.names\n          )}`\n        );\n      }\n    }\n    return updated;\n  }\n\n  get(): void {\n    if (!this.finished || !areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): [Value[], boolean] {\n    return [[...this.seen], this.finished];\n  }\n\n  consume(): boolean {\n    if (\n      this.finished &&\n      this.seen &&\n      this.names &&\n      areSetsEqual(this.seen, this.names)\n    ) {\n      this.seen = new Set<Value>();\n      this.finished = false;\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && !!this.names && areSetsEqual(this.names, this.seen)) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return this.finished && !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n","import type { StandardContentBlockTranslator } from \"./index.js\";\nimport type { ContentBlock } from \"../content/index.js\";\nimport type { AIMessageChunk, AIMessage } from \"../ai.js\";\nimport type { BaseMessage, BaseMessageChunk } from \"../base.js\";\nimport {\n  _isArray,\n  _isContentBlock,\n  _isNumber,\n  _isObject,\n  _isString,\n  safeParseJson,\n  iife,\n} from \"./utils.js\";\n\nfunction convertAnthropicAnnotation(\n  citation: ContentBlock\n): ContentBlock.Citation | undefined {\n  if (\n    citation.type === \"char_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_char_index) &&\n    _isNumber(citation.end_char_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_char_index,\n      end_char_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"char\",\n      title: document_title ?? undefined,\n      startIndex: start_char_index,\n      endIndex: end_char_index,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"page_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_page_number) &&\n    _isNumber(citation.end_page_number) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_page_number,\n      end_page_number,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"page\",\n      title: document_title ?? undefined,\n      startIndex: start_page_number,\n      endIndex: end_page_number,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"content_block_location\" &&\n    _isString(citation.document_title) &&\n    _isNumber(citation.start_block_index) &&\n    _isNumber(citation.end_block_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      document_title,\n      start_block_index,\n      end_block_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"block\",\n      title: document_title ?? undefined,\n      startIndex: start_block_index,\n      endIndex: end_block_index,\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"web_search_result_location\" &&\n    _isString(citation.url) &&\n    _isString(citation.title) &&\n    _isString(citation.encrypted_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const { url, title, encrypted_index, cited_text, ...rest } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"url\",\n      url,\n      title,\n      startIndex: Number(encrypted_index),\n      endIndex: Number(encrypted_index),\n      citedText: cited_text,\n    };\n  }\n  if (\n    citation.type === \"search_result_location\" &&\n    _isString(citation.source) &&\n    _isString(citation.title) &&\n    _isNumber(citation.start_block_index) &&\n    _isNumber(citation.end_block_index) &&\n    _isString(citation.cited_text)\n  ) {\n    const {\n      source,\n      title,\n      start_block_index,\n      end_block_index,\n      cited_text,\n      ...rest\n    } = citation;\n    return {\n      ...rest,\n      type: \"citation\",\n      source: \"search\",\n      url: source,\n      title: title ?? undefined,\n      startIndex: start_block_index,\n      endIndex: end_block_index,\n      citedText: cited_text,\n    };\n  }\n  return undefined;\n}\n\n/**\n * Converts an Anthropic content block to a standard V1 content block.\n *\n * This function handles the conversion of Anthropic-specific content blocks\n * (document and image blocks) to the standardized V1 format. It supports\n * various source types including base64 data, URLs, file IDs, and text data.\n *\n * @param block - The Anthropic content block to convert\n * @returns A standard V1 content block if conversion is successful, undefined otherwise\n *\n * @example\n * ```typescript\n * const anthropicBlock = {\n *   type: \"image\",\n *   source: {\n *     type: \"base64\",\n *     media_type: \"image/png\",\n *     data: \"iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==\"\n *   }\n * };\n *\n * const standardBlock = convertToV1FromAnthropicContentBlock(anthropicBlock);\n * // Returns: { type: \"image\", mimeType: \"image/png\", data: \"...\" }\n * ```\n */\nexport function convertToV1FromAnthropicContentBlock(\n  block: ContentBlock\n): ContentBlock.Standard | undefined {\n  if (\n    _isContentBlock(block, \"document\") &&\n    _isObject(block.source) &&\n    \"type\" in block.source\n  ) {\n    if (\n      block.source.type === \"base64\" &&\n      _isString(block.source.media_type) &&\n      _isString(block.source.data)\n    ) {\n      return {\n        type: \"file\",\n        mimeType: block.source.media_type,\n        data: block.source.data,\n      };\n    } else if (block.source.type === \"url\" && _isString(block.source.url)) {\n      return {\n        type: \"file\",\n        url: block.source.url,\n      };\n    } else if (\n      block.source.type === \"file\" &&\n      _isString(block.source.file_id)\n    ) {\n      return {\n        type: \"file\",\n        fileId: block.source.file_id,\n      };\n    } else if (block.source.type === \"text\" && _isString(block.source.data)) {\n      return {\n        type: \"file\",\n        mimeType: String(block.source.media_type ?? \"text/plain\"),\n        data: block.source.data,\n      };\n    }\n  } else if (\n    _isContentBlock(block, \"image\") &&\n    _isObject(block.source) &&\n    \"type\" in block.source\n  ) {\n    if (\n      block.source.type === \"base64\" &&\n      _isString(block.source.media_type) &&\n      _isString(block.source.data)\n    ) {\n      return {\n        type: \"image\",\n        mimeType: block.source.media_type,\n        data: block.source.data,\n      };\n    } else if (block.source.type === \"url\" && _isString(block.source.url)) {\n      return {\n        type: \"image\",\n        url: block.source.url,\n      };\n    } else if (\n      block.source.type === \"file\" &&\n      _isString(block.source.file_id)\n    ) {\n      return {\n        type: \"image\",\n        fileId: block.source.file_id,\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Converts an array of content blocks from Anthropic format to v1 standard format.\n *\n * This function processes each content block in the input array, attempting to convert\n * Anthropic-specific block formats (like image blocks with source objects, document blocks, etc.)\n * to the standardized v1 content block format. If a block cannot be converted, it is\n * passed through as-is with a type assertion to ContentBlock.Standard.\n *\n * @param content - Array of content blocks in Anthropic format to be converted\n * @returns Array of content blocks in v1 standard format\n */\nexport function convertToV1FromAnthropicInput(\n  content: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    for (const block of content) {\n      const stdBlock = convertToV1FromAnthropicContentBlock(block);\n      if (stdBlock) {\n        yield stdBlock;\n      } else {\n        yield block as ContentBlock.Standard;\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\n/**\n * Converts an Anthropic AI message to an array of v1 standard content blocks.\n *\n * This function processes an AI message containing Anthropic-specific content blocks\n * and converts them to the standardized v1 content block format.\n *\n * @param message - The AI message containing Anthropic-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage([\n *   { type: \"text\", text: \"Hello world\" },\n *   { type: \"thinking\", text: \"Let me think about this...\" },\n *   { type: \"tool_use\", id: \"123\", name: \"calculator\", input: { a: 1, b: 2 } }\n * ]);\n *\n * const standardBlocks = convertToV1FromAnthropicMessage(message);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello world\" },\n * //   { type: \"reasoning\", reasoning: \"Let me think about this...\" },\n * //   { type: \"tool_call\", id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * // ]\n * ```\n */\nexport function convertToV1FromAnthropicMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      // TextBlock\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        const { text, citations, ...rest } = block;\n        if (_isArray(citations) && citations.length) {\n          const _citations = citations.reduce<ContentBlock.Citation[]>(\n            (acc, item) => {\n              const citation = convertAnthropicAnnotation(item as ContentBlock);\n              if (citation) {\n                return [...acc, citation];\n              }\n              return acc;\n            },\n            []\n          );\n          yield {\n            ...rest,\n            type: \"text\",\n            text,\n            annotations: _citations,\n          };\n          continue;\n        } else {\n          yield {\n            ...rest,\n            type: \"text\",\n            text,\n          };\n          continue;\n        }\n      }\n      // ThinkingBlock\n      else if (\n        _isContentBlock(block, \"thinking\") &&\n        _isString(block.thinking)\n      ) {\n        const { thinking, signature, ...rest } = block;\n        yield {\n          ...rest,\n          type: \"reasoning\",\n          reasoning: thinking,\n          signature,\n        };\n        continue;\n      }\n      // RedactedThinkingBlock\n      else if (_isContentBlock(block, \"redacted_thinking\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      }\n      // ToolUseBlock\n      else if (\n        _isContentBlock(block, \"tool_use\") &&\n        _isString(block.name) &&\n        _isString(block.id)\n      ) {\n        yield {\n          type: \"tool_call\",\n          id: block.id,\n          name: block.name,\n          args: block.input,\n        };\n        continue;\n      }\n      // message chunks can have input_json_delta contents\n      else if (_isContentBlock(block, \"input_json_delta\")) {\n        if (_isAIMessageChunk(message) && message.tool_call_chunks?.length) {\n          const tool_call_chunk = message.tool_call_chunks[0];\n          yield {\n            type: \"tool_call_chunk\",\n            id: tool_call_chunk.id,\n            name: tool_call_chunk.name,\n            args: tool_call_chunk.args,\n            index: tool_call_chunk.index,\n          };\n          continue;\n        }\n      }\n      // ServerToolUseBlock\n      else if (\n        _isContentBlock(block, \"server_tool_use\") &&\n        _isString(block.name) &&\n        _isString(block.id)\n      ) {\n        const { name, id } = block;\n        if (name === \"web_search\") {\n          const query = iife(() => {\n            if (typeof block.input === \"string\") {\n              return block.input;\n            } else if (_isObject(block.input) && _isString(block.input.query)) {\n              return block.input.query;\n            } else if (_isString(block.partial_json)) {\n              const json = safeParseJson<{ query?: string }>(\n                block.partial_json\n              );\n              if (json?.query) {\n                return json.query;\n              }\n            }\n            return \"\";\n          });\n          yield {\n            id,\n            type: \"server_tool_call\",\n            name: \"web_search\",\n            args: { query },\n          };\n          continue;\n        } else if (block.name === \"code_execution\") {\n          const code = iife(() => {\n            if (typeof block.input === \"string\") {\n              return block.input;\n            } else if (_isObject(block.input) && _isString(block.input.code)) {\n              return block.input.code;\n            } else if (_isString(block.partial_json)) {\n              const json = safeParseJson<{ code?: string }>(block.partial_json);\n              if (json?.code) {\n                return json.code;\n              }\n            }\n            return \"\";\n          });\n          yield {\n            id,\n            type: \"server_tool_call\",\n            name: \"code_execution\",\n            args: { code },\n          };\n          continue;\n        }\n      }\n      // WebSearchToolResultBlock\n      else if (\n        _isContentBlock(block, \"web_search_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isArray(block.content)\n      ) {\n        const { content, tool_use_id } = block;\n        const urls = content.reduce<string[]>((acc, content) => {\n          if (_isContentBlock(content, \"web_search_result\")) {\n            return [...acc, content.url as string];\n          }\n          return acc;\n        }, []);\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"web_search\",\n          toolCallId: tool_use_id,\n          status: \"success\",\n          output: {\n            urls,\n          },\n        };\n        continue;\n      }\n      // CodeExecutionToolResultBlock\n      else if (\n        _isContentBlock(block, \"code_execution_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isObject(block.content)\n      ) {\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"code_execution\",\n          toolCallId: block.tool_use_id,\n          status: \"success\",\n          output: block.content,\n        };\n        continue;\n      }\n      // MCPToolUseBlock\n      else if (_isContentBlock(block, \"mcp_tool_use\")) {\n        yield {\n          id: block.id,\n          type: \"server_tool_call\",\n          name: \"mcp_tool_use\",\n          args: block.input,\n        };\n        continue;\n      }\n      // MCPToolResultBlock\n      else if (\n        _isContentBlock(block, \"mcp_tool_result\") &&\n        _isString(block.tool_use_id) &&\n        _isObject(block.content)\n      ) {\n        yield {\n          type: \"server_tool_call_result\",\n          name: \"mcp_tool_use\",\n          toolCallId: block.tool_use_id,\n          status: \"success\",\n          output: block.content,\n        };\n        continue;\n      }\n      // ContainerUploadBlock\n      else if (_isContentBlock(block, \"container_upload\")) {\n        yield {\n          type: \"server_tool_call\",\n          name: \"container_upload\",\n          args: block.input,\n        };\n        continue;\n      }\n      // SearchResultBlockParam\n      else if (_isContentBlock(block, \"search_result\")) {\n        yield { id: block.id, type: \"non_standard\", value: block };\n        continue;\n      }\n      // ToolResultBlockParam\n      else if (_isContentBlock(block, \"tool_result\")) {\n        yield { id: block.id, type: \"non_standard\", value: block };\n        continue;\n      } else {\n        // For all other blocks, we try to convert them to a standard block\n        const stdBlock = convertToV1FromAnthropicContentBlock(block);\n        if (stdBlock) {\n          yield stdBlock;\n          continue;\n        }\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatAnthropicTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromAnthropicMessage,\n  translateContentChunk: convertToV1FromAnthropicMessage,\n};\n\nfunction _isAIMessageChunk(message: unknown): message is AIMessageChunk {\n  return (\n    typeof (message as BaseMessage)?._getType === \"function\" &&\n    typeof (message as BaseMessageChunk).concat === \"function\" &&\n    (message as BaseMessageChunk)._getType() === \"ai\"\n  );\n}\n","/* eslint-disable */\n// @ts-nocheck\n// p-retry code vendored to avoid import issues\n// Source: https://github.com/sindresorhus/p-retry\nimport isNetworkError from \"../is-network-error/index.js\";\nfunction validateRetries(retries) {\n    if (typeof retries === \"number\") {\n        if (retries < 0) {\n            throw new TypeError(\"Expected `retries` to be a non-negative number.\");\n        }\n        if (Number.isNaN(retries)) {\n            throw new TypeError(\"Expected `retries` to be a valid number or Infinity, got NaN.\");\n        }\n    }\n    else if (retries !== undefined) {\n        throw new TypeError(\"Expected `retries` to be a number or Infinity.\");\n    }\n}\nfunction validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {\n    if (value === undefined) {\n        return;\n    }\n    if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? \" or Infinity\" : \"\"}.`);\n    }\n    if (!allowInfinity && !Number.isFinite(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n    }\n    if (value < min) {\n        throw new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n    }\n}\nexport class AbortError extends Error {\n    constructor(message) {\n        super();\n        if (message instanceof Error) {\n            this.originalError = message;\n            ({ message } = message);\n        }\n        else {\n            this.originalError = new Error(message);\n            this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n    }\n}\nfunction calculateDelay(retriesConsumed, options) {\n    const attempt = Math.max(1, retriesConsumed + 1);\n    const random = options.randomize ? Math.random() + 1 : 1;\n    let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));\n    timeout = Math.min(timeout, options.maxTimeout);\n    return timeout;\n}\nfunction calculateRemainingTime(start, max) {\n    if (!Number.isFinite(max)) {\n        return max;\n    }\n    return max - (performance.now() - start);\n}\nasync function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options, }) {\n    const normalizedError = error instanceof Error\n        ? error\n        : new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n    if (normalizedError instanceof AbortError) {\n        throw normalizedError.originalError;\n    }\n    const retriesLeft = Number.isFinite(options.retries)\n        ? Math.max(0, options.retries - retriesConsumed)\n        : options.retries;\n    const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n    const context = Object.freeze({\n        error: normalizedError,\n        attemptNumber,\n        retriesLeft,\n        retriesConsumed,\n    });\n    await options.onFailedAttempt(context);\n    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n        throw normalizedError;\n    }\n    const consumeRetry = await options.shouldConsumeRetry(context);\n    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n    if (remainingTime <= 0 || retriesLeft <= 0) {\n        throw normalizedError;\n    }\n    if (normalizedError instanceof TypeError &&\n        !isNetworkError(normalizedError)) {\n        if (consumeRetry) {\n            throw normalizedError;\n        }\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    if (!(await options.shouldRetry(context))) {\n        throw normalizedError;\n    }\n    if (!consumeRetry) {\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    const delayTime = calculateDelay(retriesConsumed, options);\n    const finalDelay = Math.min(delayTime, remainingTime);\n    if (finalDelay > 0) {\n        await new Promise((resolve, reject) => {\n            const onAbort = () => {\n                clearTimeout(timeoutToken);\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                reject(options.signal.reason);\n            };\n            const timeoutToken = setTimeout(() => {\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                resolve();\n            }, finalDelay);\n            if (options.unref) {\n                timeoutToken.unref?.();\n            }\n            options.signal?.addEventListener(\"abort\", onAbort, { once: true });\n        });\n    }\n    options.signal?.throwIfAborted();\n    return true;\n}\nexport default async function pRetry(input, options = {}) {\n    options = { ...options };\n    validateRetries(options.retries);\n    if (Object.hasOwn(options, \"forever\")) {\n        throw new Error(\"The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.\");\n    }\n    options.retries ??= 10;\n    options.factor ??= 2;\n    options.minTimeout ??= 1000;\n    options.maxTimeout ??= Number.POSITIVE_INFINITY;\n    options.maxRetryTime ??= Number.POSITIVE_INFINITY;\n    options.randomize ??= false;\n    options.onFailedAttempt ??= () => { };\n    options.shouldRetry ??= () => true;\n    options.shouldConsumeRetry ??= () => true;\n    // Validate numeric options and normalize edge cases\n    validateNumberOption(\"factor\", options.factor, {\n        min: 0,\n        allowInfinity: false,\n    });\n    validateNumberOption(\"minTimeout\", options.minTimeout, {\n        min: 0,\n        allowInfinity: false,\n    });\n    validateNumberOption(\"maxTimeout\", options.maxTimeout, {\n        min: 0,\n        allowInfinity: true,\n    });\n    validateNumberOption(\"maxRetryTime\", options.maxRetryTime, {\n        min: 0,\n        allowInfinity: true,\n    });\n    // Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n    if (!(options.factor > 0)) {\n        options.factor = 1;\n    }\n    options.signal?.throwIfAborted();\n    let attemptNumber = 0;\n    let retriesConsumed = 0;\n    const startTime = performance.now();\n    while (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {\n        attemptNumber++;\n        try {\n            options.signal?.throwIfAborted();\n            const result = await input(attemptNumber);\n            options.signal?.throwIfAborted();\n            return result;\n        }\n        catch (error) {\n            if (await onAttemptFailure({\n                error,\n                attemptNumber,\n                retriesConsumed,\n                startTime,\n                options,\n            })) {\n                retriesConsumed++;\n            }\n        }\n    }\n    // Should not reach here, but in case it does, throw an error\n    throw new Error(\"Retry attempts exhausted without throwing an error.\");\n}\nexport function makeRetriable(function_, options) {\n    return function (...arguments_) {\n        return pRetry(() => function_.apply(this, arguments_), options);\n    };\n}\n","import { ZodError, ZodIssueCode, } from \"./ZodError.js\";\nimport { defaultErrorMap, getErrorMap } from \"./errors.js\";\nimport { errorUtil } from \"./helpers/errorUtil.js\";\nimport { DIRTY, INVALID, OK, ParseStatus, addIssueToContext, isAborted, isAsync, isDirty, isValid, makeIssue, } from \"./helpers/parseUtil.js\";\nimport { util, ZodParsedType, getParsedType } from \"./helpers/util.js\";\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (Array.isArray(this._key)) {\n                this._cachedPath.push(...this._path, ...this._key);\n            }\n            else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error() {\n                if (this._error)\n                    return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            },\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return { message: message ?? ctx.defaultError };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return { message: message ?? required_error ?? ctx.defaultError };\n        }\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        return { message: message ?? invalid_type_error ?? ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nexport class ZodType {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: params?.async ?? false,\n                contextualErrorMap: params?.errorMap,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    \"~validate\"(data) {\n        const ctx = {\n            common: {\n                issues: [],\n                async: !!this[\"~standard\"].async,\n            },\n            path: [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        if (!this[\"~standard\"].async) {\n            try {\n                const result = this._parseSync({ data, path: [], parent: ctx });\n                return isValid(result)\n                    ? {\n                        value: result.value,\n                    }\n                    : {\n                        issues: ctx.common.issues,\n                    };\n            }\n            catch (err) {\n                if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n                    this[\"~standard\"].async = true;\n                }\n                ctx.common = {\n                    issues: [],\n                    async: true,\n                };\n            }\n        }\n        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result)\n            ? {\n                value: result.value,\n            }\n            : {\n                issues: ctx.common.issues,\n            });\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params?.errorMap,\n                async: true,\n            },\n            path: params?.path || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n        this[\"~standard\"] = {\n            version: 1,\n            vendor: \"zod\",\n            validate: (data) => this[\"~validate\"](data),\n        };\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([this, option], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def),\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst cuid2Regex = /^[0-9a-z]+$/;\nconst ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\n// const uuidRegex =\n//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\nconst uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nconst nanoidRegex = /^[a-z0-9_-]{21}$/i;\nconst jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nconst durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n//old email regex\n// const emailRegex = /^(([^<>()[\\].,;:\\s@\"]+(\\.[^<>()[\\].,;:\\s@\"]+)*)|(\".+\"))@((?!-)([^<>()[\\].,;:\\s@\"]+\\.)+[^<>()[\\].,;:\\s@\"]{1,})[^-<>()[\\].,;:\\s@\"]$/i;\n// eslint-disable-next-line\n// const emailRegex =\n//   /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$/;\n// const emailRegex =\n//   /^[a-zA-Z0-9\\.\\!\\#\\$\\%\\&\\'\\*\\+\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~\\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n// const emailRegex =\n//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])$/i;\nconst emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\n// const emailRegex =\n//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\\.[a-z0-9\\-]+)*$/i;\n// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression\nconst _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nlet emojiRegex;\n// faster, simpler, safer\nconst ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nconst ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\n// const ipv6Regex =\n// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nconst ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nconst ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\n// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript\nconst base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n// https://base64.guru/standards/base64url\nconst base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\n// simple\n// const dateRegexSource = `\\\\d{4}-\\\\d{2}-\\\\d{2}`;\n// no leap year validation\n// const dateRegexSource = `\\\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\\\d|2\\\\d))`;\n// with leap year validation\nconst dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nconst dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let secondsRegexSource = `[0-5]\\\\d`;\n    if (args.precision) {\n        secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n    }\n    else if (args.precision == null) {\n        secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n    }\n    const secondsQuantifier = args.precision ? \"+\" : \"?\"; // require seconds if precision is nonzero\n    return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\n// Adapted from https://stackoverflow.com/a/3143231\nexport function datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset)\n        opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nfunction isValidJWT(jwt, alg) {\n    if (!jwtRegex.test(jwt))\n        return false;\n    try {\n        const [header] = jwt.split(\".\");\n        if (!header)\n            return false;\n        // Convert base64url to base64\n        const base64 = header\n            .replace(/-/g, \"+\")\n            .replace(/_/g, \"/\")\n            .padEnd(header.length + ((4 - (header.length % 4)) % 4), \"=\");\n        // @ts-ignore\n        const decoded = JSON.parse(atob(base64));\n        if (typeof decoded !== \"object\" || decoded === null)\n            return false;\n        if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n            return false;\n        if (!decoded.alg)\n            return false;\n        if (alg && decoded.alg !== alg)\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nfunction isValidCidr(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nexport class ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    // @ts-ignore\n                    new URL(input.data);\n                }\n                catch {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { includes: check.value, position: check.position },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            }\n            else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"jwt\") {\n                if (!isValidJWT(input.data, check.alg)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"jwt\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cidr\") {\n                if (!isValidCidr(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cidr\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"base64url\") {\n                if (!base64urlRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    emoji(message) {\n        return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    nanoid(message) {\n        return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid2(message) {\n        return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n    }\n    ulid(message) {\n        return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n    }\n    base64(message) {\n        return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n    }\n    base64url(message) {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return this._addCheck({\n            kind: \"base64url\",\n            ...errorUtil.errToObj(message),\n        });\n    }\n    jwt(options) {\n        return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n    }\n    ip(options) {\n        return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n    }\n    cidr(options) {\n        return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n    }\n    datetime(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            offset: options?.offset ?? false,\n            local: options?.local ?? false,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    date(message) {\n        return this._addCheck({ kind: \"date\", message });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    duration(message) {\n        return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value: value,\n            position: options?.position,\n            ...errorUtil.errToObj(options?.message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    /**\n     * Equivalent to `.min(1)`\n     */\n    nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    toLowerCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toLowerCase\" }],\n        });\n    }\n    toUpperCase() {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"toUpperCase\" }],\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch) => ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n    }\n    get isCIDR() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n    }\n    get isBase64url() {\n        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames\n        return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / 10 ** decCount;\n}\nexport class ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\" || (ch.kind === \"multipleOf\" && util.isInteger(ch.value)));\n    }\n    get isFinite() {\n        let max = null;\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            }\n            else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n            else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBigInt extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            try {\n                input.data = BigInt(input.data);\n            }\n            catch {\n                return this._getInvalidInput(input);\n            }\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            return this._getInvalidInput(input);\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _getInvalidInput(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.bigint,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodBigInt({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodBigInt.create = (params) => {\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: params?.coerce ?? false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: params?.coerce || false,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (Number.isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: params?.coerce || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([...ctx.data].map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = [...ctx.data].map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element),\n        });\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nexport class ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        // extend<\n        //   Augmentation extends ZodRawShape,\n        //   NewOutput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_output\"]\n        //       : k extends keyof Output\n        //       ? Output[k]\n        //       : never;\n        //   }>,\n        //   NewInput extends util.flatten<{\n        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n        //       ? Augmentation[k][\"_input\"]\n        //       : k extends keyof Input\n        //       ? Input[k]\n        //       : never;\n        //   }>\n        // >(\n        //   augmentation: Augmentation\n        // ): ZodObject<\n        //   extendShape<T, Augmentation>,\n        //   UnknownKeys,\n        //   Catchall,\n        //   NewOutput,\n        //   NewInput\n        // > {\n        //   return new ZodObject({\n        //     ...this._def,\n        //     shape: () => ({\n        //       ...this._def.shape(),\n        //       ...augmentation,\n        //     }),\n        //   }) as any;\n        // }\n        /**\n         * @deprecated Use `.extend` instead\n         *  */\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        this._cached = { shape, keys };\n        return this._cached;\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") {\n            }\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: errorUtil.errToObj(message).message ?? defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new ZodObject({\n            ...this._def,\n            shape: () => ({\n                ...this._def.shape(),\n                ...augmentation,\n            }),\n        });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => ({\n                ...this._def.shape(),\n                ...merging._def.shape(),\n            }),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(mask)) {\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    /**\n     * @deprecated\n     */\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            }\n            else {\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        for (const key of util.objectKeys(this.shape)) {\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            }\n            else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return util.objectValues(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else if (type instanceof ZodOptional) {\n        return [undefined, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodNullable) {\n        return [null, ...getDiscriminator(type.unwrap())];\n    }\n    else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    }\n    else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else {\n        return [];\n    }\n};\nexport class ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nexport class ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\n// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport class ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = [...ctx.data]\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nexport class ZodMap extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), defaultErrorMap].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(async function (...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            // Would love a way to avoid disabling this rule, but we need\n            // an alias (using an arrow function was what caused 2651).\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const me = this;\n            return OK(function (...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args ? args : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nexport class ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nexport class ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(this._def.values);\n        }\n        if (!this._cache.has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return ZodEnum.create(values, {\n            ...this._def,\n            ...newDef,\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n            ...this._def,\n            ...newDef,\n        });\n    }\n}\nZodEnum.create = createZodEnum;\nexport class ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (!this._cache) {\n            this._cache = new Set(util.getValidEnumValues(this._def.values));\n        }\n        if (!this._cache.has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodPromise extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed) => {\n                    if (status.value === \"aborted\")\n                        return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                    if (result.status === \"aborted\")\n                        return INVALID;\n                    if (result.status === \"dirty\")\n                        return DIRTY(result.value);\n                    if (status.value === \"dirty\")\n                        return DIRTY(result.value);\n                    return result;\n                });\n            }\n            else {\n                if (status.value === \"aborted\")\n                    return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (result.status === \"aborted\")\n                    return INVALID;\n                if (result.status === \"dirty\")\n                    return DIRTY(result.value);\n                if (status.value === \"dirty\")\n                    return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (!isValid(base))\n                    return INVALID;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n                    if (!isValid(base))\n                        return INVALID;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n                        status: status.value,\n                        value: result,\n                    }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nexport { ZodEffects as ZodTransformer };\nexport class ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        // newCtx is used to not collect issues from inner types in ctx\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: [],\n            },\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx,\n            },\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\"\n                        ? result.value\n                        : this._def.catchValue({\n                            get error() {\n                                return new ZodError(newCtx.common.issues);\n                            },\n                            input: newCtx.data,\n                        }),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\"\n                    ? result.value\n                    : this._def.catchValue({\n                        get error() {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data,\n                    }),\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n        ...processCreateParams(params),\n    });\n};\nexport class ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nexport const BRAND = Symbol(\"zod_brand\");\nexport class ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nexport class ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nexport class ZodReadonly extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data) => {\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodReadonly.create = (type, params) => {\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params),\n    });\n};\n////////////////////////////////////////\n////////////////////////////////////////\n//////////                    //////////\n//////////      z.custom      //////////\n//////////                    //////////\n////////////////////////////////////////\n////////////////////////////////////////\nfunction cleanParams(params, data) {\n    const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n    const p2 = typeof p === \"string\" ? { message: p } : p;\n    return p2;\n}\nexport function custom(check, _params = {}, \n/**\n * @deprecated\n *\n * Pass `fatal` into the params object instead:\n *\n * ```ts\n * z.string().custom((val) => val.length > 5, { fatal: false })\n * ```\n *\n */\nfatal) {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            const r = check(data);\n            if (r instanceof Promise) {\n                return r.then((r) => {\n                    if (!r) {\n                        const params = cleanParams(_params, data);\n                        const _fatal = params.fatal ?? fatal ?? true;\n                        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n                    }\n                });\n            }\n            if (!r) {\n                const params = cleanParams(_params, data);\n                const _fatal = params.fatal ?? fatal ?? true;\n                ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n            }\n            return;\n        });\n    return ZodAny.create();\n}\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport const late = {\n    object: ZodObject.lazycreate,\n};\nexport var ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n// requires TS 4.4+\nclass Class {\n    constructor(..._) { }\n}\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nexport const coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({\n        ...arg,\n        coerce: true,\n    })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport const NEVER = INVALID;\n","import { v7 as uuidv7 } from \"uuid\";\nexport { uuid7FromTime } from \"./utils/_uuid.js\";\n/**\n * Generate a random UUID v7 string.\n */\nexport function uuid7() {\n    return uuidv7();\n}\n","import { _LC_CONTEXT_VARIABLES_KEY } from \"../singletons/constants.js\";\n/**\n * Get a context variable from a run tree instance\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getContextVar(runTree, key) {\n    if (_LC_CONTEXT_VARIABLES_KEY in runTree) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const contextVars = runTree[_LC_CONTEXT_VARIABLES_KEY];\n        return contextVars[key];\n    }\n    return undefined;\n}\n/**\n * Set a context variable on a run tree instance\n */\nexport function setContextVar(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrunTree, key, value) {\n    const contextVars = _LC_CONTEXT_VARIABLES_KEY in runTree\n        ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            runTree[_LC_CONTEXT_VARIABLES_KEY]\n        : {};\n    contextVars[key] = value;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    runTree[_LC_CONTEXT_VARIABLES_KEY] = contextVars;\n}\n","import * as core from \"../core/index.js\";\nimport { util } from \"../core/index.js\";\nimport * as checks from \"./checks.js\";\nimport * as iso from \"./iso.js\";\nimport * as parse from \"./parse.js\";\nexport const ZodType = /*@__PURE__*/ core.$constructor(\"ZodType\", (inst, def) => {\n    core.$ZodType.init(inst, def);\n    inst.def = def;\n    inst.type = def.type;\n    Object.defineProperty(inst, \"_def\", { value: def });\n    // base methods\n    inst.check = (...checks) => {\n        return inst.clone(util.mergeDefs(def, {\n            checks: [\n                ...(def.checks ?? []),\n                ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch),\n            ],\n        }));\n    };\n    inst.clone = (def, params) => core.clone(inst, def, params);\n    inst.brand = () => inst;\n    inst.register = ((reg, meta) => {\n        reg.add(inst, meta);\n        return inst;\n    });\n    // parsing\n    inst.parse = (data, params) => parse.parse(inst, data, params, { callee: inst.parse });\n    inst.safeParse = (data, params) => parse.safeParse(inst, data, params);\n    inst.parseAsync = async (data, params) => parse.parseAsync(inst, data, params, { callee: inst.parseAsync });\n    inst.safeParseAsync = async (data, params) => parse.safeParseAsync(inst, data, params);\n    inst.spa = inst.safeParseAsync;\n    // encoding/decoding\n    inst.encode = (data, params) => parse.encode(inst, data, params);\n    inst.decode = (data, params) => parse.decode(inst, data, params);\n    inst.encodeAsync = async (data, params) => parse.encodeAsync(inst, data, params);\n    inst.decodeAsync = async (data, params) => parse.decodeAsync(inst, data, params);\n    inst.safeEncode = (data, params) => parse.safeEncode(inst, data, params);\n    inst.safeDecode = (data, params) => parse.safeDecode(inst, data, params);\n    inst.safeEncodeAsync = async (data, params) => parse.safeEncodeAsync(inst, data, params);\n    inst.safeDecodeAsync = async (data, params) => parse.safeDecodeAsync(inst, data, params);\n    // refinements\n    inst.refine = (check, params) => inst.check(refine(check, params));\n    inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n    inst.overwrite = (fn) => inst.check(checks.overwrite(fn));\n    // wrappers\n    inst.optional = () => optional(inst);\n    inst.nullable = () => nullable(inst);\n    inst.nullish = () => optional(nullable(inst));\n    inst.nonoptional = (params) => nonoptional(inst, params);\n    inst.array = () => array(inst);\n    inst.or = (arg) => union([inst, arg]);\n    inst.and = (arg) => intersection(inst, arg);\n    inst.transform = (tx) => pipe(inst, transform(tx));\n    inst.default = (def) => _default(inst, def);\n    inst.prefault = (def) => prefault(inst, def);\n    // inst.coalesce = (def, params) => coalesce(inst, def, params);\n    inst.catch = (params) => _catch(inst, params);\n    inst.pipe = (target) => pipe(inst, target);\n    inst.readonly = () => readonly(inst);\n    // meta\n    inst.describe = (description) => {\n        const cl = inst.clone();\n        core.globalRegistry.add(cl, { description });\n        return cl;\n    };\n    Object.defineProperty(inst, \"description\", {\n        get() {\n            return core.globalRegistry.get(inst)?.description;\n        },\n        configurable: true,\n    });\n    inst.meta = (...args) => {\n        if (args.length === 0) {\n            return core.globalRegistry.get(inst);\n        }\n        const cl = inst.clone();\n        core.globalRegistry.add(cl, args[0]);\n        return cl;\n    };\n    // helpers\n    inst.isOptional = () => inst.safeParse(undefined).success;\n    inst.isNullable = () => inst.safeParse(null).success;\n    return inst;\n});\n/** @internal */\nexport const _ZodString = /*@__PURE__*/ core.$constructor(\"_ZodString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    ZodType.init(inst, def);\n    const bag = inst._zod.bag;\n    inst.format = bag.format ?? null;\n    inst.minLength = bag.minimum ?? null;\n    inst.maxLength = bag.maximum ?? null;\n    // validations\n    inst.regex = (...args) => inst.check(checks.regex(...args));\n    inst.includes = (...args) => inst.check(checks.includes(...args));\n    inst.startsWith = (...args) => inst.check(checks.startsWith(...args));\n    inst.endsWith = (...args) => inst.check(checks.endsWith(...args));\n    inst.min = (...args) => inst.check(checks.minLength(...args));\n    inst.max = (...args) => inst.check(checks.maxLength(...args));\n    inst.length = (...args) => inst.check(checks.length(...args));\n    inst.nonempty = (...args) => inst.check(checks.minLength(1, ...args));\n    inst.lowercase = (params) => inst.check(checks.lowercase(params));\n    inst.uppercase = (params) => inst.check(checks.uppercase(params));\n    // transforms\n    inst.trim = () => inst.check(checks.trim());\n    inst.normalize = (...args) => inst.check(checks.normalize(...args));\n    inst.toLowerCase = () => inst.check(checks.toLowerCase());\n    inst.toUpperCase = () => inst.check(checks.toUpperCase());\n    inst.slugify = () => inst.check(checks.slugify());\n});\nexport const ZodString = /*@__PURE__*/ core.$constructor(\"ZodString\", (inst, def) => {\n    core.$ZodString.init(inst, def);\n    _ZodString.init(inst, def);\n    inst.email = (params) => inst.check(core._email(ZodEmail, params));\n    inst.url = (params) => inst.check(core._url(ZodURL, params));\n    inst.jwt = (params) => inst.check(core._jwt(ZodJWT, params));\n    inst.emoji = (params) => inst.check(core._emoji(ZodEmoji, params));\n    inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n    inst.uuid = (params) => inst.check(core._uuid(ZodUUID, params));\n    inst.uuidv4 = (params) => inst.check(core._uuidv4(ZodUUID, params));\n    inst.uuidv6 = (params) => inst.check(core._uuidv6(ZodUUID, params));\n    inst.uuidv7 = (params) => inst.check(core._uuidv7(ZodUUID, params));\n    inst.nanoid = (params) => inst.check(core._nanoid(ZodNanoID, params));\n    inst.guid = (params) => inst.check(core._guid(ZodGUID, params));\n    inst.cuid = (params) => inst.check(core._cuid(ZodCUID, params));\n    inst.cuid2 = (params) => inst.check(core._cuid2(ZodCUID2, params));\n    inst.ulid = (params) => inst.check(core._ulid(ZodULID, params));\n    inst.base64 = (params) => inst.check(core._base64(ZodBase64, params));\n    inst.base64url = (params) => inst.check(core._base64url(ZodBase64URL, params));\n    inst.xid = (params) => inst.check(core._xid(ZodXID, params));\n    inst.ksuid = (params) => inst.check(core._ksuid(ZodKSUID, params));\n    inst.ipv4 = (params) => inst.check(core._ipv4(ZodIPv4, params));\n    inst.ipv6 = (params) => inst.check(core._ipv6(ZodIPv6, params));\n    inst.cidrv4 = (params) => inst.check(core._cidrv4(ZodCIDRv4, params));\n    inst.cidrv6 = (params) => inst.check(core._cidrv6(ZodCIDRv6, params));\n    inst.e164 = (params) => inst.check(core._e164(ZodE164, params));\n    // iso\n    inst.datetime = (params) => inst.check(iso.datetime(params));\n    inst.date = (params) => inst.check(iso.date(params));\n    inst.time = (params) => inst.check(iso.time(params));\n    inst.duration = (params) => inst.check(iso.duration(params));\n});\nexport function string(params) {\n    return core._string(ZodString, params);\n}\nexport const ZodStringFormat = /*@__PURE__*/ core.$constructor(\"ZodStringFormat\", (inst, def) => {\n    core.$ZodStringFormat.init(inst, def);\n    _ZodString.init(inst, def);\n});\nexport const ZodEmail = /*@__PURE__*/ core.$constructor(\"ZodEmail\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodEmail.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function email(params) {\n    return core._email(ZodEmail, params);\n}\nexport const ZodGUID = /*@__PURE__*/ core.$constructor(\"ZodGUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodGUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function guid(params) {\n    return core._guid(ZodGUID, params);\n}\nexport const ZodUUID = /*@__PURE__*/ core.$constructor(\"ZodUUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodUUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function uuid(params) {\n    return core._uuid(ZodUUID, params);\n}\nexport function uuidv4(params) {\n    return core._uuidv4(ZodUUID, params);\n}\n// ZodUUIDv6\nexport function uuidv6(params) {\n    return core._uuidv6(ZodUUID, params);\n}\n// ZodUUIDv7\nexport function uuidv7(params) {\n    return core._uuidv7(ZodUUID, params);\n}\nexport const ZodURL = /*@__PURE__*/ core.$constructor(\"ZodURL\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodURL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function url(params) {\n    return core._url(ZodURL, params);\n}\nexport function httpUrl(params) {\n    return core._url(ZodURL, {\n        protocol: /^https?$/,\n        hostname: core.regexes.domain,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodEmoji = /*@__PURE__*/ core.$constructor(\"ZodEmoji\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodEmoji.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function emoji(params) {\n    return core._emoji(ZodEmoji, params);\n}\nexport const ZodNanoID = /*@__PURE__*/ core.$constructor(\"ZodNanoID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodNanoID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function nanoid(params) {\n    return core._nanoid(ZodNanoID, params);\n}\nexport const ZodCUID = /*@__PURE__*/ core.$constructor(\"ZodCUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cuid(params) {\n    return core._cuid(ZodCUID, params);\n}\nexport const ZodCUID2 = /*@__PURE__*/ core.$constructor(\"ZodCUID2\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCUID2.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cuid2(params) {\n    return core._cuid2(ZodCUID2, params);\n}\nexport const ZodULID = /*@__PURE__*/ core.$constructor(\"ZodULID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodULID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ulid(params) {\n    return core._ulid(ZodULID, params);\n}\nexport const ZodXID = /*@__PURE__*/ core.$constructor(\"ZodXID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodXID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function xid(params) {\n    return core._xid(ZodXID, params);\n}\nexport const ZodKSUID = /*@__PURE__*/ core.$constructor(\"ZodKSUID\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodKSUID.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ksuid(params) {\n    return core._ksuid(ZodKSUID, params);\n}\nexport const ZodIPv4 = /*@__PURE__*/ core.$constructor(\"ZodIPv4\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodIPv4.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ipv4(params) {\n    return core._ipv4(ZodIPv4, params);\n}\nexport const ZodMAC = /*@__PURE__*/ core.$constructor(\"ZodMAC\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodMAC.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function mac(params) {\n    return core._mac(ZodMAC, params);\n}\nexport const ZodIPv6 = /*@__PURE__*/ core.$constructor(\"ZodIPv6\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodIPv6.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function ipv6(params) {\n    return core._ipv6(ZodIPv6, params);\n}\nexport const ZodCIDRv4 = /*@__PURE__*/ core.$constructor(\"ZodCIDRv4\", (inst, def) => {\n    core.$ZodCIDRv4.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cidrv4(params) {\n    return core._cidrv4(ZodCIDRv4, params);\n}\nexport const ZodCIDRv6 = /*@__PURE__*/ core.$constructor(\"ZodCIDRv6\", (inst, def) => {\n    core.$ZodCIDRv6.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function cidrv6(params) {\n    return core._cidrv6(ZodCIDRv6, params);\n}\nexport const ZodBase64 = /*@__PURE__*/ core.$constructor(\"ZodBase64\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function base64(params) {\n    return core._base64(ZodBase64, params);\n}\nexport const ZodBase64URL = /*@__PURE__*/ core.$constructor(\"ZodBase64URL\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodBase64URL.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function base64url(params) {\n    return core._base64url(ZodBase64URL, params);\n}\nexport const ZodE164 = /*@__PURE__*/ core.$constructor(\"ZodE164\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodE164.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function e164(params) {\n    return core._e164(ZodE164, params);\n}\nexport const ZodJWT = /*@__PURE__*/ core.$constructor(\"ZodJWT\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodJWT.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function jwt(params) {\n    return core._jwt(ZodJWT, params);\n}\nexport const ZodCustomStringFormat = /*@__PURE__*/ core.$constructor(\"ZodCustomStringFormat\", (inst, def) => {\n    // ZodStringFormat.init(inst, def);\n    core.$ZodCustomStringFormat.init(inst, def);\n    ZodStringFormat.init(inst, def);\n});\nexport function stringFormat(format, fnOrRegex, _params = {}) {\n    return core._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);\n}\nexport function hostname(_params) {\n    return core._stringFormat(ZodCustomStringFormat, \"hostname\", core.regexes.hostname, _params);\n}\nexport function hex(_params) {\n    return core._stringFormat(ZodCustomStringFormat, \"hex\", core.regexes.hex, _params);\n}\nexport function hash(alg, params) {\n    const enc = params?.enc ?? \"hex\";\n    const format = `${alg}_${enc}`;\n    const regex = core.regexes[format];\n    if (!regex)\n        throw new Error(`Unrecognized hash format: ${format}`);\n    return core._stringFormat(ZodCustomStringFormat, format, regex, params);\n}\nexport const ZodNumber = /*@__PURE__*/ core.$constructor(\"ZodNumber\", (inst, def) => {\n    core.$ZodNumber.init(inst, def);\n    ZodType.init(inst, def);\n    inst.gt = (value, params) => inst.check(checks.gt(value, params));\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.lt = (value, params) => inst.check(checks.lt(value, params));\n    inst.lte = (value, params) => inst.check(checks.lte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    inst.int = (params) => inst.check(int(params));\n    inst.safe = (params) => inst.check(int(params));\n    inst.positive = (params) => inst.check(checks.gt(0, params));\n    inst.nonnegative = (params) => inst.check(checks.gte(0, params));\n    inst.negative = (params) => inst.check(checks.lt(0, params));\n    inst.nonpositive = (params) => inst.check(checks.lte(0, params));\n    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n    inst.step = (value, params) => inst.check(checks.multipleOf(value, params));\n    // inst.finite = (params) => inst.check(core.finite(params));\n    inst.finite = () => inst;\n    const bag = inst._zod.bag;\n    inst.minValue =\n        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n    inst.maxValue =\n        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n    inst.isInt = (bag.format ?? \"\").includes(\"int\") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n    inst.isFinite = true;\n    inst.format = bag.format ?? null;\n});\nexport function number(params) {\n    return core._number(ZodNumber, params);\n}\nexport const ZodNumberFormat = /*@__PURE__*/ core.$constructor(\"ZodNumberFormat\", (inst, def) => {\n    core.$ZodNumberFormat.init(inst, def);\n    ZodNumber.init(inst, def);\n});\nexport function int(params) {\n    return core._int(ZodNumberFormat, params);\n}\nexport function float32(params) {\n    return core._float32(ZodNumberFormat, params);\n}\nexport function float64(params) {\n    return core._float64(ZodNumberFormat, params);\n}\nexport function int32(params) {\n    return core._int32(ZodNumberFormat, params);\n}\nexport function uint32(params) {\n    return core._uint32(ZodNumberFormat, params);\n}\nexport const ZodBoolean = /*@__PURE__*/ core.$constructor(\"ZodBoolean\", (inst, def) => {\n    core.$ZodBoolean.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function boolean(params) {\n    return core._boolean(ZodBoolean, params);\n}\nexport const ZodBigInt = /*@__PURE__*/ core.$constructor(\"ZodBigInt\", (inst, def) => {\n    core.$ZodBigInt.init(inst, def);\n    ZodType.init(inst, def);\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.gt = (value, params) => inst.check(checks.gt(value, params));\n    inst.gte = (value, params) => inst.check(checks.gte(value, params));\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.lt = (value, params) => inst.check(checks.lt(value, params));\n    inst.lte = (value, params) => inst.check(checks.lte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    inst.positive = (params) => inst.check(checks.gt(BigInt(0), params));\n    inst.negative = (params) => inst.check(checks.lt(BigInt(0), params));\n    inst.nonpositive = (params) => inst.check(checks.lte(BigInt(0), params));\n    inst.nonnegative = (params) => inst.check(checks.gte(BigInt(0), params));\n    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));\n    const bag = inst._zod.bag;\n    inst.minValue = bag.minimum ?? null;\n    inst.maxValue = bag.maximum ?? null;\n    inst.format = bag.format ?? null;\n});\nexport function bigint(params) {\n    return core._bigint(ZodBigInt, params);\n}\nexport const ZodBigIntFormat = /*@__PURE__*/ core.$constructor(\"ZodBigIntFormat\", (inst, def) => {\n    core.$ZodBigIntFormat.init(inst, def);\n    ZodBigInt.init(inst, def);\n});\n// int64\nexport function int64(params) {\n    return core._int64(ZodBigIntFormat, params);\n}\n// uint64\nexport function uint64(params) {\n    return core._uint64(ZodBigIntFormat, params);\n}\nexport const ZodSymbol = /*@__PURE__*/ core.$constructor(\"ZodSymbol\", (inst, def) => {\n    core.$ZodSymbol.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function symbol(params) {\n    return core._symbol(ZodSymbol, params);\n}\nexport const ZodUndefined = /*@__PURE__*/ core.$constructor(\"ZodUndefined\", (inst, def) => {\n    core.$ZodUndefined.init(inst, def);\n    ZodType.init(inst, def);\n});\nfunction _undefined(params) {\n    return core._undefined(ZodUndefined, params);\n}\nexport { _undefined as undefined };\nexport const ZodNull = /*@__PURE__*/ core.$constructor(\"ZodNull\", (inst, def) => {\n    core.$ZodNull.init(inst, def);\n    ZodType.init(inst, def);\n});\nfunction _null(params) {\n    return core._null(ZodNull, params);\n}\nexport { _null as null };\nexport const ZodAny = /*@__PURE__*/ core.$constructor(\"ZodAny\", (inst, def) => {\n    core.$ZodAny.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function any() {\n    return core._any(ZodAny);\n}\nexport const ZodUnknown = /*@__PURE__*/ core.$constructor(\"ZodUnknown\", (inst, def) => {\n    core.$ZodUnknown.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function unknown() {\n    return core._unknown(ZodUnknown);\n}\nexport const ZodNever = /*@__PURE__*/ core.$constructor(\"ZodNever\", (inst, def) => {\n    core.$ZodNever.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function never(params) {\n    return core._never(ZodNever, params);\n}\nexport const ZodVoid = /*@__PURE__*/ core.$constructor(\"ZodVoid\", (inst, def) => {\n    core.$ZodVoid.init(inst, def);\n    ZodType.init(inst, def);\n});\nfunction _void(params) {\n    return core._void(ZodVoid, params);\n}\nexport { _void as void };\nexport const ZodDate = /*@__PURE__*/ core.$constructor(\"ZodDate\", (inst, def) => {\n    core.$ZodDate.init(inst, def);\n    ZodType.init(inst, def);\n    inst.min = (value, params) => inst.check(checks.gte(value, params));\n    inst.max = (value, params) => inst.check(checks.lte(value, params));\n    const c = inst._zod.bag;\n    inst.minDate = c.minimum ? new Date(c.minimum) : null;\n    inst.maxDate = c.maximum ? new Date(c.maximum) : null;\n});\nexport function date(params) {\n    return core._date(ZodDate, params);\n}\nexport const ZodArray = /*@__PURE__*/ core.$constructor(\"ZodArray\", (inst, def) => {\n    core.$ZodArray.init(inst, def);\n    ZodType.init(inst, def);\n    inst.element = def.element;\n    inst.min = (minLength, params) => inst.check(checks.minLength(minLength, params));\n    inst.nonempty = (params) => inst.check(checks.minLength(1, params));\n    inst.max = (maxLength, params) => inst.check(checks.maxLength(maxLength, params));\n    inst.length = (len, params) => inst.check(checks.length(len, params));\n    inst.unwrap = () => inst.element;\n});\nexport function array(element, params) {\n    return core._array(ZodArray, element, params);\n}\n// .keyof\nexport function keyof(schema) {\n    const shape = schema._zod.def.shape;\n    return _enum(Object.keys(shape));\n}\nexport const ZodObject = /*@__PURE__*/ core.$constructor(\"ZodObject\", (inst, def) => {\n    core.$ZodObjectJIT.init(inst, def);\n    ZodType.init(inst, def);\n    util.defineLazy(inst, \"shape\", () => {\n        return def.shape;\n    });\n    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });\n    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });\n    inst.extend = (incoming) => {\n        return util.extend(inst, incoming);\n    };\n    inst.safeExtend = (incoming) => {\n        return util.safeExtend(inst, incoming);\n    };\n    inst.merge = (other) => util.merge(inst, other);\n    inst.pick = (mask) => util.pick(inst, mask);\n    inst.omit = (mask) => util.omit(inst, mask);\n    inst.partial = (...args) => util.partial(ZodOptional, inst, args[0]);\n    inst.required = (...args) => util.required(ZodNonOptional, inst, args[0]);\n});\nexport function object(shape, params) {\n    const def = {\n        type: \"object\",\n        shape: shape ?? {},\n        ...util.normalizeParams(params),\n    };\n    return new ZodObject(def);\n}\n// strictObject\nexport function strictObject(shape, params) {\n    return new ZodObject({\n        type: \"object\",\n        shape,\n        catchall: never(),\n        ...util.normalizeParams(params),\n    });\n}\n// looseObject\nexport function looseObject(shape, params) {\n    return new ZodObject({\n        type: \"object\",\n        shape,\n        catchall: unknown(),\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodUnion = /*@__PURE__*/ core.$constructor(\"ZodUnion\", (inst, def) => {\n    core.$ZodUnion.init(inst, def);\n    ZodType.init(inst, def);\n    inst.options = def.options;\n});\nexport function union(options, params) {\n    return new ZodUnion({\n        type: \"union\",\n        options: options,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodDiscriminatedUnion = /*@__PURE__*/ core.$constructor(\"ZodDiscriminatedUnion\", (inst, def) => {\n    ZodUnion.init(inst, def);\n    core.$ZodDiscriminatedUnion.init(inst, def);\n});\nexport function discriminatedUnion(discriminator, options, params) {\n    // const [options, params] = args;\n    return new ZodDiscriminatedUnion({\n        type: \"union\",\n        options,\n        discriminator,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodIntersection = /*@__PURE__*/ core.$constructor(\"ZodIntersection\", (inst, def) => {\n    core.$ZodIntersection.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function intersection(left, right) {\n    return new ZodIntersection({\n        type: \"intersection\",\n        left: left,\n        right: right,\n    });\n}\nexport const ZodTuple = /*@__PURE__*/ core.$constructor(\"ZodTuple\", (inst, def) => {\n    core.$ZodTuple.init(inst, def);\n    ZodType.init(inst, def);\n    inst.rest = (rest) => inst.clone({\n        ...inst._zod.def,\n        rest: rest,\n    });\n});\nexport function tuple(items, _paramsOrRest, _params) {\n    const hasRest = _paramsOrRest instanceof core.$ZodType;\n    const params = hasRest ? _params : _paramsOrRest;\n    const rest = hasRest ? _paramsOrRest : null;\n    return new ZodTuple({\n        type: \"tuple\",\n        items: items,\n        rest,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodRecord = /*@__PURE__*/ core.$constructor(\"ZodRecord\", (inst, def) => {\n    core.$ZodRecord.init(inst, def);\n    ZodType.init(inst, def);\n    inst.keyType = def.keyType;\n    inst.valueType = def.valueType;\n});\nexport function record(keyType, valueType, params) {\n    return new ZodRecord({\n        type: \"record\",\n        keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\n// type alksjf = core.output<core.$ZodRecordKey>;\nexport function partialRecord(keyType, valueType, params) {\n    const k = core.clone(keyType);\n    k._zod.values = undefined;\n    return new ZodRecord({\n        type: \"record\",\n        keyType: k,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodMap = /*@__PURE__*/ core.$constructor(\"ZodMap\", (inst, def) => {\n    core.$ZodMap.init(inst, def);\n    ZodType.init(inst, def);\n    inst.keyType = def.keyType;\n    inst.valueType = def.valueType;\n});\nexport function map(keyType, valueType, params) {\n    return new ZodMap({\n        type: \"map\",\n        keyType: keyType,\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodSet = /*@__PURE__*/ core.$constructor(\"ZodSet\", (inst, def) => {\n    core.$ZodSet.init(inst, def);\n    ZodType.init(inst, def);\n    inst.min = (...args) => inst.check(core._minSize(...args));\n    inst.nonempty = (params) => inst.check(core._minSize(1, params));\n    inst.max = (...args) => inst.check(core._maxSize(...args));\n    inst.size = (...args) => inst.check(core._size(...args));\n});\nexport function set(valueType, params) {\n    return new ZodSet({\n        type: \"set\",\n        valueType: valueType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodEnum = /*@__PURE__*/ core.$constructor(\"ZodEnum\", (inst, def) => {\n    core.$ZodEnum.init(inst, def);\n    ZodType.init(inst, def);\n    inst.enum = def.entries;\n    inst.options = Object.values(def.entries);\n    const keys = new Set(Object.keys(def.entries));\n    inst.extract = (values, params) => {\n        const newEntries = {};\n        for (const value of values) {\n            if (keys.has(value)) {\n                newEntries[value] = def.entries[value];\n            }\n            else\n                throw new Error(`Key ${value} not found in enum`);\n        }\n        return new ZodEnum({\n            ...def,\n            checks: [],\n            ...util.normalizeParams(params),\n            entries: newEntries,\n        });\n    };\n    inst.exclude = (values, params) => {\n        const newEntries = { ...def.entries };\n        for (const value of values) {\n            if (keys.has(value)) {\n                delete newEntries[value];\n            }\n            else\n                throw new Error(`Key ${value} not found in enum`);\n        }\n        return new ZodEnum({\n            ...def,\n            checks: [],\n            ...util.normalizeParams(params),\n            entries: newEntries,\n        });\n    };\n});\nfunction _enum(values, params) {\n    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n    return new ZodEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport { _enum as enum };\n/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.\n *\n * ```ts\n * enum Colors { red, green, blue }\n * z.enum(Colors);\n * ```\n */\nexport function nativeEnum(entries, params) {\n    return new ZodEnum({\n        type: \"enum\",\n        entries,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodLiteral = /*@__PURE__*/ core.$constructor(\"ZodLiteral\", (inst, def) => {\n    core.$ZodLiteral.init(inst, def);\n    ZodType.init(inst, def);\n    inst.values = new Set(def.values);\n    Object.defineProperty(inst, \"value\", {\n        get() {\n            if (def.values.length > 1) {\n                throw new Error(\"This schema contains multiple valid literal values. Use `.values` instead.\");\n            }\n            return def.values[0];\n        },\n    });\n});\nexport function literal(value, params) {\n    return new ZodLiteral({\n        type: \"literal\",\n        values: Array.isArray(value) ? value : [value],\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodFile = /*@__PURE__*/ core.$constructor(\"ZodFile\", (inst, def) => {\n    core.$ZodFile.init(inst, def);\n    ZodType.init(inst, def);\n    inst.min = (size, params) => inst.check(core._minSize(size, params));\n    inst.max = (size, params) => inst.check(core._maxSize(size, params));\n    inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));\n});\nexport function file(params) {\n    return core._file(ZodFile, params);\n}\nexport const ZodTransform = /*@__PURE__*/ core.$constructor(\"ZodTransform\", (inst, def) => {\n    core.$ZodTransform.init(inst, def);\n    ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (_ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(inst.constructor.name);\n        }\n        payload.addIssue = (issue) => {\n            if (typeof issue === \"string\") {\n                payload.issues.push(util.issue(issue, payload.value, def));\n            }\n            else {\n                // for Zod 3 backwards compatibility\n                const _issue = issue;\n                if (_issue.fatal)\n                    _issue.continue = false;\n                _issue.code ?? (_issue.code = \"custom\");\n                _issue.input ?? (_issue.input = payload.value);\n                _issue.inst ?? (_issue.inst = inst);\n                // _issue.continue ??= true;\n                payload.issues.push(util.issue(_issue));\n            }\n        };\n        const output = def.transform(payload.value, payload);\n        if (output instanceof Promise) {\n            return output.then((output) => {\n                payload.value = output;\n                return payload;\n            });\n        }\n        payload.value = output;\n        return payload;\n    };\n});\nexport function transform(fn) {\n    return new ZodTransform({\n        type: \"transform\",\n        transform: fn,\n    });\n}\nexport const ZodOptional = /*@__PURE__*/ core.$constructor(\"ZodOptional\", (inst, def) => {\n    core.$ZodOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function optional(innerType) {\n    return new ZodOptional({\n        type: \"optional\",\n        innerType: innerType,\n    });\n}\nexport const ZodNullable = /*@__PURE__*/ core.$constructor(\"ZodNullable\", (inst, def) => {\n    core.$ZodNullable.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function nullable(innerType) {\n    return new ZodNullable({\n        type: \"nullable\",\n        innerType: innerType,\n    });\n}\n// nullish\nexport function nullish(innerType) {\n    return optional(nullable(innerType));\n}\nexport const ZodDefault = /*@__PURE__*/ core.$constructor(\"ZodDefault\", (inst, def) => {\n    core.$ZodDefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n    inst.removeDefault = inst.unwrap;\n});\nexport function _default(innerType, defaultValue) {\n    return new ZodDefault({\n        type: \"default\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodPrefault = /*@__PURE__*/ core.$constructor(\"ZodPrefault\", (inst, def) => {\n    core.$ZodPrefault.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function prefault(innerType, defaultValue) {\n    return new ZodPrefault({\n        type: \"prefault\",\n        innerType: innerType,\n        get defaultValue() {\n            return typeof defaultValue === \"function\" ? defaultValue() : util.shallowClone(defaultValue);\n        },\n    });\n}\nexport const ZodNonOptional = /*@__PURE__*/ core.$constructor(\"ZodNonOptional\", (inst, def) => {\n    core.$ZodNonOptional.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function nonoptional(innerType, params) {\n    return new ZodNonOptional({\n        type: \"nonoptional\",\n        innerType: innerType,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodSuccess = /*@__PURE__*/ core.$constructor(\"ZodSuccess\", (inst, def) => {\n    core.$ZodSuccess.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function success(innerType) {\n    return new ZodSuccess({\n        type: \"success\",\n        innerType: innerType,\n    });\n}\nexport const ZodCatch = /*@__PURE__*/ core.$constructor(\"ZodCatch\", (inst, def) => {\n    core.$ZodCatch.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n    inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n    return new ZodCatch({\n        type: \"catch\",\n        innerType: innerType,\n        catchValue: (typeof catchValue === \"function\" ? catchValue : () => catchValue),\n    });\n}\nexport { _catch as catch };\nexport const ZodNaN = /*@__PURE__*/ core.$constructor(\"ZodNaN\", (inst, def) => {\n    core.$ZodNaN.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function nan(params) {\n    return core._nan(ZodNaN, params);\n}\nexport const ZodPipe = /*@__PURE__*/ core.$constructor(\"ZodPipe\", (inst, def) => {\n    core.$ZodPipe.init(inst, def);\n    ZodType.init(inst, def);\n    inst.in = def.in;\n    inst.out = def.out;\n});\nexport function pipe(in_, out) {\n    return new ZodPipe({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        // ...util.normalizeParams(params),\n    });\n}\nexport const ZodCodec = /*@__PURE__*/ core.$constructor(\"ZodCodec\", (inst, def) => {\n    ZodPipe.init(inst, def);\n    core.$ZodCodec.init(inst, def);\n});\nexport function codec(in_, out, params) {\n    return new ZodCodec({\n        type: \"pipe\",\n        in: in_,\n        out: out,\n        transform: params.decode,\n        reverseTransform: params.encode,\n    });\n}\nexport const ZodReadonly = /*@__PURE__*/ core.$constructor(\"ZodReadonly\", (inst, def) => {\n    core.$ZodReadonly.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function readonly(innerType) {\n    return new ZodReadonly({\n        type: \"readonly\",\n        innerType: innerType,\n    });\n}\nexport const ZodTemplateLiteral = /*@__PURE__*/ core.$constructor(\"ZodTemplateLiteral\", (inst, def) => {\n    core.$ZodTemplateLiteral.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function templateLiteral(parts, params) {\n    return new ZodTemplateLiteral({\n        type: \"template_literal\",\n        parts,\n        ...util.normalizeParams(params),\n    });\n}\nexport const ZodLazy = /*@__PURE__*/ core.$constructor(\"ZodLazy\", (inst, def) => {\n    core.$ZodLazy.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.getter();\n});\nexport function lazy(getter) {\n    return new ZodLazy({\n        type: \"lazy\",\n        getter: getter,\n    });\n}\nexport const ZodPromise = /*@__PURE__*/ core.$constructor(\"ZodPromise\", (inst, def) => {\n    core.$ZodPromise.init(inst, def);\n    ZodType.init(inst, def);\n    inst.unwrap = () => inst._zod.def.innerType;\n});\nexport function promise(innerType) {\n    return new ZodPromise({\n        type: \"promise\",\n        innerType: innerType,\n    });\n}\nexport const ZodFunction = /*@__PURE__*/ core.$constructor(\"ZodFunction\", (inst, def) => {\n    core.$ZodFunction.init(inst, def);\n    ZodType.init(inst, def);\n});\nexport function _function(params) {\n    return new ZodFunction({\n        type: \"function\",\n        input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),\n        output: params?.output ?? unknown(),\n    });\n}\nexport { _function as function };\nexport const ZodCustom = /*@__PURE__*/ core.$constructor(\"ZodCustom\", (inst, def) => {\n    core.$ZodCustom.init(inst, def);\n    ZodType.init(inst, def);\n});\n// custom checks\nexport function check(fn) {\n    const ch = new core.$ZodCheck({\n        check: \"custom\",\n        // ...util.normalizeParams(params),\n    });\n    ch._zod.check = fn;\n    return ch;\n}\nexport function custom(fn, _params) {\n    return core._custom(ZodCustom, fn ?? (() => true), _params);\n}\nexport function refine(fn, _params = {}) {\n    return core._refine(ZodCustom, fn, _params);\n}\n// superRefine\nexport function superRefine(fn) {\n    return core._superRefine(fn);\n}\n// Re-export describe and meta from core\nexport const describe = core.describe;\nexport const meta = core.meta;\nfunction _instanceof(cls, params = {\n    error: `Input not instance of ${cls.name}`,\n}) {\n    const inst = new ZodCustom({\n        type: \"custom\",\n        check: \"custom\",\n        fn: (data) => data instanceof cls,\n        abort: true,\n        ...util.normalizeParams(params),\n    });\n    inst._zod.bag.Class = cls;\n    return inst;\n}\nexport { _instanceof as instanceof };\n// stringbool\nexport const stringbool = (...args) => core._stringbool({\n    Codec: ZodCodec,\n    Boolean: ZodBoolean,\n    String: ZodString,\n}, ...args);\nexport function json(params) {\n    const jsonSchema = lazy(() => {\n        return union([string(params), number(), boolean(), _null(), array(jsonSchema), record(string(), jsonSchema)]);\n    });\n    return jsonSchema;\n}\n// preprocess\n// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */\nexport function preprocess(fn, schema) {\n    return pipe(transform(fn), schema);\n}\n","import { deepCompareStrict } from './deep-compare-strict.js';\nimport { dereference } from './dereference.js';\nimport { format } from './format.js';\nimport { encodePointer } from './pointer.js';\nimport { ucs2length } from './ucs2-length.js';\nexport function validate(instance, schema, draft = '2019-09', lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = '#', schemaLocation = '#', evaluated = Object.create(null)) {\n    if (schema === true) {\n        return { valid: true, errors: [] };\n    }\n    if (schema === false) {\n        return {\n            valid: false,\n            errors: [\n                {\n                    instanceLocation,\n                    keyword: 'false',\n                    keywordLocation: instanceLocation,\n                    error: 'False boolean schema.'\n                }\n            ]\n        };\n    }\n    const rawInstanceType = typeof instance;\n    let instanceType;\n    switch (rawInstanceType) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n            instanceType = rawInstanceType;\n            break;\n        case 'object':\n            if (instance === null) {\n                instanceType = 'null';\n            }\n            else if (Array.isArray(instance)) {\n                instanceType = 'array';\n            }\n            else {\n                instanceType = 'object';\n            }\n            break;\n        default:\n            throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n    }\n    const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;\n    const errors = [];\n    if ($recursiveAnchor === true && recursiveAnchor === null) {\n        recursiveAnchor = schema;\n    }\n    if ($recursiveRef === '#') {\n        const refSchema = recursiveAnchor === null\n            ? lookup[__absolute_recursive_ref__]\n            : recursiveAnchor;\n        const keywordLocation = `${schemaLocation}/$recursiveRef`;\n        const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: '$recursiveRef',\n                keywordLocation,\n                error: 'A subschema had errors.'\n            }, ...result.errors);\n        }\n    }\n    if ($ref !== undefined) {\n        const uri = __absolute_ref__ || $ref;\n        const refSchema = lookup[uri];\n        if (refSchema === undefined) {\n            let message = `Unresolved $ref \"${$ref}\".`;\n            if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                message += `  Absolute URI \"${__absolute_ref__}\".`;\n            }\n            message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join('\\n- ')}`;\n            throw new Error(message);\n        }\n        const keywordLocation = `${schemaLocation}/$ref`;\n        const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: '$ref',\n                keywordLocation,\n                error: 'A subschema had errors.'\n            }, ...result.errors);\n        }\n        if (draft === '4' || draft === '7') {\n            return { valid: errors.length === 0, errors };\n        }\n    }\n    if (Array.isArray($type)) {\n        let length = $type.length;\n        let valid = false;\n        for (let i = 0; i < length; i++) {\n            if (instanceType === $type[i] ||\n                ($type[i] === 'integer' &&\n                    instanceType === 'number' &&\n                    instance % 1 === 0 &&\n                    instance === instance)) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            errors.push({\n                instanceLocation,\n                keyword: 'type',\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`\n            });\n        }\n    }\n    else if ($type === 'integer') {\n        if (instanceType !== 'number' || instance % 1 || instance !== instance) {\n            errors.push({\n                instanceLocation,\n                keyword: 'type',\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n            });\n        }\n    }\n    else if ($type !== undefined && instanceType !== $type) {\n        errors.push({\n            instanceLocation,\n            keyword: 'type',\n            keywordLocation: `${schemaLocation}/type`,\n            error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n        });\n    }\n    if ($const !== undefined) {\n        if (instanceType === 'object' || instanceType === 'array') {\n            if (!deepCompareStrict(instance, $const)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'const',\n                    keywordLocation: `${schemaLocation}/const`,\n                    error: `Instance does not match ${JSON.stringify($const)}.`\n                });\n            }\n        }\n        else if (instance !== $const) {\n            errors.push({\n                instanceLocation,\n                keyword: 'const',\n                keywordLocation: `${schemaLocation}/const`,\n                error: `Instance does not match ${JSON.stringify($const)}.`\n            });\n        }\n    }\n    if ($enum !== undefined) {\n        if (instanceType === 'object' || instanceType === 'array') {\n            if (!$enum.some(value => deepCompareStrict(instance, value))) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'enum',\n                    keywordLocation: `${schemaLocation}/enum`,\n                    error: `Instance does not match any of ${JSON.stringify($enum)}.`\n                });\n            }\n        }\n        else if (!$enum.some(value => instance === value)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'enum',\n                keywordLocation: `${schemaLocation}/enum`,\n                error: `Instance does not match any of ${JSON.stringify($enum)}.`\n            });\n        }\n    }\n    if ($not !== undefined) {\n        const keywordLocation = `${schemaLocation}/not`;\n        const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);\n        if (result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: 'not',\n                keywordLocation,\n                error: 'Instance matched \"not\" schema.'\n            });\n        }\n    }\n    let subEvaluateds = [];\n    if ($anyOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/anyOf`;\n        const errorsLength = errors.length;\n        let anyValid = false;\n        for (let i = 0; i < $anyOf.length; i++) {\n            const subSchema = $anyOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            anyValid = anyValid || result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (anyValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'anyOf',\n                keywordLocation,\n                error: 'Instance does not match any subschemas.'\n            });\n        }\n    }\n    if ($allOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/allOf`;\n        const errorsLength = errors.length;\n        let allValid = true;\n        for (let i = 0; i < $allOf.length; i++) {\n            const subSchema = $allOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            allValid = allValid && result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (allValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'allOf',\n                keywordLocation,\n                error: `Instance does not match every subschema.`\n            });\n        }\n    }\n    if ($oneOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/oneOf`;\n        const errorsLength = errors.length;\n        const matches = $oneOf.filter((subSchema, i) => {\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n            return result.valid;\n        }).length;\n        if (matches === 1) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'oneOf',\n                keywordLocation,\n                error: `Instance does not match exactly one subschema (${matches} matches).`\n            });\n        }\n    }\n    if (instanceType === 'object' || instanceType === 'array') {\n        Object.assign(evaluated, ...subEvaluateds);\n    }\n    if ($if !== undefined) {\n        const keywordLocation = `${schemaLocation}/if`;\n        const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n        if (conditionResult) {\n            if ($then !== undefined) {\n                const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                if (!thenResult.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'if',\n                        keywordLocation,\n                        error: `Instance does not match \"then\" schema.`\n                    }, ...thenResult.errors);\n                }\n            }\n        }\n        else if ($else !== undefined) {\n            const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n            if (!elseResult.valid) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'if',\n                    keywordLocation,\n                    error: `Instance does not match \"else\" schema.`\n                }, ...elseResult.errors);\n            }\n        }\n    }\n    if (instanceType === 'object') {\n        if ($required !== undefined) {\n            for (const key of $required) {\n                if (!(key in instance)) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'required',\n                        keywordLocation: `${schemaLocation}/required`,\n                        error: `Instance does not have required property \"${key}\".`\n                    });\n                }\n            }\n        }\n        const keys = Object.keys(instance);\n        if ($minProperties !== undefined && keys.length < $minProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minProperties',\n                keywordLocation: `${schemaLocation}/minProperties`,\n                error: `Instance does not have at least ${$minProperties} properties.`\n            });\n        }\n        if ($maxProperties !== undefined && keys.length > $maxProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxProperties',\n                keywordLocation: `${schemaLocation}/maxProperties`,\n                error: `Instance does not have at least ${$maxProperties} properties.`\n            });\n        }\n        if ($propertyNames !== undefined) {\n            const keywordLocation = `${schemaLocation}/propertyNames`;\n            for (const key in instance) {\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'propertyNames',\n                        keywordLocation,\n                        error: `Property name \"${key}\" does not match schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($dependentRequired !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependantRequired`;\n            for (const key in $dependentRequired) {\n                if (key in instance) {\n                    const required = $dependentRequired[key];\n                    for (const dependantKey of required) {\n                        if (!(dependantKey in instance)) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: 'dependentRequired',\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if ($dependentSchemas !== undefined) {\n            for (const key in $dependentSchemas) {\n                const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                if (key in instance) {\n                    const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n                    if (!result.valid) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'dependentSchemas',\n                            keywordLocation,\n                            error: `Instance has \"${key}\" but does not match dependant schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($dependencies !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependencies`;\n            for (const key in $dependencies) {\n                if (key in instance) {\n                    const propsOrSchema = $dependencies[key];\n                    if (Array.isArray(propsOrSchema)) {\n                        for (const dependantKey of propsOrSchema) {\n                            if (!(dependantKey in instance)) {\n                                errors.push({\n                                    instanceLocation,\n                                    keyword: 'dependencies',\n                                    keywordLocation,\n                                    error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                                });\n                            }\n                        }\n                    }\n                    else {\n                        const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n                        if (!result.valid) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: 'dependencies',\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not match dependant schema.`\n                            }, ...result.errors);\n                        }\n                    }\n                }\n            }\n        }\n        const thisEvaluated = Object.create(null);\n        let stop = false;\n        if ($properties !== undefined) {\n            const keywordLocation = `${schemaLocation}/properties`;\n            for (const key in $properties) {\n                if (!(key in instance)) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n                if (result.valid) {\n                    evaluated[key] = thisEvaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'properties',\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match schema.`\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if (!stop && $patternProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/patternProperties`;\n            for (const pattern in $patternProperties) {\n                const regex = new RegExp(pattern, 'u');\n                const subSchema = $patternProperties[pattern];\n                for (const key in instance) {\n                    if (!regex.test(key)) {\n                        continue;\n                    }\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n                    if (result.valid) {\n                        evaluated[key] = thisEvaluated[key] = true;\n                    }\n                    else {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'patternProperties',\n                            keywordLocation,\n                            error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if (!stop && $additionalProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/additionalProperties`;\n            for (const key in instance) {\n                if (thisEvaluated[key]) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (result.valid) {\n                    evaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'additionalProperties',\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match additional properties schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        else if (!stop && $unevaluatedProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n            for (const key in instance) {\n                if (!evaluated[key]) {\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                    if (result.valid) {\n                        evaluated[key] = true;\n                    }\n                    else {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'unevaluatedProperties',\n                            keywordLocation,\n                            error: `Property \"${key}\" does not match unevaluated properties schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === 'array') {\n        if ($maxItems !== undefined && instance.length > $maxItems) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxItems',\n                keywordLocation: `${schemaLocation}/maxItems`,\n                error: `Array has too many items (${instance.length} > ${$maxItems}).`\n            });\n        }\n        if ($minItems !== undefined && instance.length < $minItems) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minItems',\n                keywordLocation: `${schemaLocation}/minItems`,\n                error: `Array has too few items (${instance.length} < ${$minItems}).`\n            });\n        }\n        const length = instance.length;\n        let i = 0;\n        let stop = false;\n        if ($prefixItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/prefixItems`;\n            const length2 = Math.min($prefixItems.length, length);\n            for (; i < length2; i++) {\n                const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'prefixItems',\n                        keywordLocation,\n                        error: `Items did not match schema.`\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if ($items !== undefined) {\n            const keywordLocation = `${schemaLocation}/items`;\n            if (Array.isArray($items)) {\n                const length2 = Math.min($items.length, length);\n                for (; i < length2; i++) {\n                    const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'items',\n                            keywordLocation,\n                            error: `Items did not match schema.`\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            else {\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'items',\n                            keywordLocation,\n                            error: `Items did not match schema.`\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            if (!stop && $additionalItems !== undefined) {\n                const keywordLocation = `${schemaLocation}/additionalItems`;\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'additionalItems',\n                            keywordLocation,\n                            error: `Items did not match additional items schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($contains !== undefined) {\n            if (length === 0 && $minContains === undefined) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'contains',\n                    keywordLocation: `${schemaLocation}/contains`,\n                    error: `Array is empty. It must contain at least one item matching the schema.`\n                });\n            }\n            else if ($minContains !== undefined && length < $minContains) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minContains',\n                    keywordLocation: `${schemaLocation}/minContains`,\n                    error: `Array has less items (${length}) than minContains (${$minContains}).`\n                });\n            }\n            else {\n                const keywordLocation = `${schemaLocation}/contains`;\n                const errorsLength = errors.length;\n                let contained = 0;\n                for (let j = 0; j < length; j++) {\n                    const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                    if (result.valid) {\n                        evaluated[j] = true;\n                        contained++;\n                    }\n                    else {\n                        errors.push(...result.errors);\n                    }\n                }\n                if (contained >= ($minContains || 0)) {\n                    errors.length = errorsLength;\n                }\n                if ($minContains === undefined &&\n                    $maxContains === undefined &&\n                    contained === 0) {\n                    errors.splice(errorsLength, 0, {\n                        instanceLocation,\n                        keyword: 'contains',\n                        keywordLocation,\n                        error: `Array does not contain item matching schema.`\n                    });\n                }\n                else if ($minContains !== undefined && contained < $minContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'minContains',\n                        keywordLocation: `${schemaLocation}/minContains`,\n                        error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`\n                    });\n                }\n                else if ($maxContains !== undefined && contained > $maxContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'maxContains',\n                        keywordLocation: `${schemaLocation}/maxContains`,\n                        error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`\n                    });\n                }\n            }\n        }\n        if (!stop && $unevaluatedItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n            for (i; i < length; i++) {\n                if (evaluated[i]) {\n                    continue;\n                }\n                const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'unevaluatedItems',\n                        keywordLocation,\n                        error: `Items did not match unevaluated items schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($uniqueItems) {\n            for (let j = 0; j < length; j++) {\n                const a = instance[j];\n                const ao = typeof a === 'object' && a !== null;\n                for (let k = 0; k < length; k++) {\n                    if (j === k) {\n                        continue;\n                    }\n                    const b = instance[k];\n                    const bo = typeof b === 'object' && b !== null;\n                    if (a === b || (ao && bo && deepCompareStrict(a, b))) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'uniqueItems',\n                            keywordLocation: `${schemaLocation}/uniqueItems`,\n                            error: `Duplicate items at indexes ${j} and ${k}.`\n                        });\n                        j = Number.MAX_SAFE_INTEGER;\n                        k = Number.MAX_SAFE_INTEGER;\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === 'number') {\n        if (draft === '4') {\n            if ($minimum !== undefined &&\n                (($exclusiveMinimum === true && instance <= $minimum) ||\n                    instance < $minimum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minimum',\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum ? 'or equal to ' : ''} ${$minimum}.`\n                });\n            }\n            if ($maximum !== undefined &&\n                (($exclusiveMaximum === true && instance >= $maximum) ||\n                    instance > $maximum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'maximum',\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$exclusiveMaximum ? 'or equal to ' : ''} ${$maximum}.`\n                });\n            }\n        }\n        else {\n            if ($minimum !== undefined && instance < $minimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minimum',\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$minimum}.`\n                });\n            }\n            if ($maximum !== undefined && instance > $maximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'maximum',\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$maximum}.`\n                });\n            }\n            if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'exclusiveMinimum',\n                    keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum}.`\n                });\n            }\n            if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'exclusiveMaximum',\n                    keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                    error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`\n                });\n            }\n        }\n        if ($multipleOf !== undefined) {\n            const remainder = instance % $multipleOf;\n            if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'multipleOf',\n                    keywordLocation: `${schemaLocation}/multipleOf`,\n                    error: `${instance} is not a multiple of ${$multipleOf}.`\n                });\n            }\n        }\n    }\n    else if (instanceType === 'string') {\n        const length = $minLength === undefined && $maxLength === undefined\n            ? 0\n            : ucs2length(instance);\n        if ($minLength !== undefined && length < $minLength) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minLength',\n                keywordLocation: `${schemaLocation}/minLength`,\n                error: `String is too short (${length} < ${$minLength}).`\n            });\n        }\n        if ($maxLength !== undefined && length > $maxLength) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxLength',\n                keywordLocation: `${schemaLocation}/maxLength`,\n                error: `String is too long (${length} > ${$maxLength}).`\n            });\n        }\n        if ($pattern !== undefined && !new RegExp($pattern, 'u').test(instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'pattern',\n                keywordLocation: `${schemaLocation}/pattern`,\n                error: `String does not match pattern.`\n            });\n        }\n        if ($format !== undefined &&\n            format[$format] &&\n            !format[$format](instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'format',\n                keywordLocation: `${schemaLocation}/format`,\n                error: `String does not match format \"${$format}\".`\n            });\n        }\n    }\n    return { valid: errors.length === 0, errors };\n}\n","import { OrderResolutionStateType } from '../state';\r\n\r\n/**\r\n * Initial node - Start resolving the order\r\n */\r\nexport async function resolveOrderNode(\r\n    state: OrderResolutionStateType\r\n): Promise<Partial<OrderResolutionStateType>> {\r\n    // Simulate processing\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    const message = `Starting resolution for order ${state.orderId} - ${state.orderDetails.customer}`;\r\n\r\n    return {\r\n        currentStep: 'resolving',\r\n        stepMessages: [\r\n            ...state.stepMessages,\r\n            {\r\n                step: 'resolving',\r\n                message,\r\n                timestamp: new Date().toISOString(),\r\n            },\r\n        ],\r\n    };\r\n}\r\n","import { OrderResolutionStateType } from '../state';\r\n\r\n/**\r\n * Final node - Confirm dispatch and calculate delivery time\r\n */\r\nexport async function confirmDispatchNode(\r\n    state: OrderResolutionStateType\r\n): Promise<Partial<OrderResolutionStateType>> {\r\n    // Simulate final processing\r\n    await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n    // Calculate estimated delivery time\r\n    const warehousePrepTime = state.warehouseResult?.estimatedPrepTime || 15;\r\n    const driverArrivalTime = state.driverResult?.estimatedArrival || 30;\r\n    const totalMinutes = warehousePrepTime + driverArrivalTime;\r\n\r\n    const deliveryDate = new Date();\r\n    deliveryDate.setMinutes(deliveryDate.getMinutes() + totalMinutes);\r\n\r\n    const message = ` Order dispatched! Estimated delivery: ${deliveryDate.toLocaleTimeString()} (${totalMinutes} min from now)`;\r\n\r\n    return {\r\n        currentStep: 'completed',\r\n        dispatchConfirmed: true,\r\n        estimatedDeliveryTime: deliveryDate.toISOString(),\r\n        stepMessages: [\r\n            ...state.stepMessages,\r\n            {\r\n                step: 'completed',\r\n                message,\r\n                timestamp: new Date().toISOString(),\r\n            },\r\n        ],\r\n    };\r\n}\r\n","import { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\nexport function initializeAsyncLocalStorageSingleton() {\n  AsyncLocalStorageProviderSingleton.initializeGlobalInstance(\n    new AsyncLocalStorage()\n  );\n}\n","import { ZodPipelineDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7AllOfType } from \"./intersection.js\";\n\nexport const parsePipelineDef = (\n  def: ZodPipelineDef<any, any>,\n  refs: Refs\n): JsonSchema7AllOfType | JsonSchema7Type | undefined => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"],\n  });\n\n  return {\n    allOf: [a, b].filter((x): x is JsonSchema7Type => x !== undefined),\n  };\n};\n","import { ZodOptionalDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { parseAnyDef } from \"./any.js\";\n\nexport const parseOptionalDef = (\n  def: ZodOptionalDef,\n  refs: Refs\n): JsonSchema7Type | undefined => {\n  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n    return parseDef(def.innerType._def, refs);\n  }\n\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"],\n  });\n\n  return innerSchema\n    ? {\n        anyOf: [\n          {\n            not: parseAnyDef(refs),\n          },\n          innerSchema,\n        ],\n      }\n    : parseAnyDef(refs);\n};\n","import { ChatPromptValueInterface } from \"../prompt_values.js\";\nimport { RunnableLike, Runnable, RunnableBinding } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { InputValues } from \"../utils/types/index.js\";\nimport {\n  BaseMessagePromptTemplateLike,\n  ChatPromptTemplate,\n  ChatPromptTemplateInput,\n} from \"./chat.js\";\n\nfunction isWithStructuredOutput(x: unknown): x is {\n  withStructuredOutput: (...arg: unknown[]) => Runnable;\n} {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    \"withStructuredOutput\" in x &&\n    typeof x.withStructuredOutput === \"function\"\n  );\n}\n\nfunction isRunnableBinding(x: unknown): x is RunnableBinding<unknown, unknown> {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    \"lc_id\" in x &&\n    Array.isArray(x.lc_id) &&\n    x.lc_id.join(\"/\") === \"langchain_core/runnables/RunnableBinding\"\n  );\n}\n\n/**\n * Interface for the input of a ChatPromptTemplate.\n */\nexport interface StructuredPromptInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends ChatPromptTemplateInput<RunInput, PartialVariableName> {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: Record<string, any>;\n  method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\";\n}\n\nexport class StructuredPrompt<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends ChatPromptTemplate<RunInput, PartialVariableName>\n  implements StructuredPromptInput<RunInput, PartialVariableName>\n{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: Record<string, any>;\n\n  method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\";\n\n  lc_namespace = [\"langchain_core\", \"prompts\", \"structured\"];\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      ...super.lc_aliases,\n      schema: \"schema_\",\n    };\n  }\n\n  constructor(input: StructuredPromptInput<RunInput, PartialVariableName>) {\n    super(input);\n    this.schema = input.schema;\n    this.method = input.method;\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<ChatPromptValueInterface, NewRunOutput>\n  ): Runnable<RunInput, Exclude<NewRunOutput, Error>, RunnableConfig> {\n    if (isWithStructuredOutput(coerceable)) {\n      return super.pipe(coerceable.withStructuredOutput(this.schema));\n    }\n\n    if (\n      isRunnableBinding(coerceable) &&\n      isWithStructuredOutput(coerceable.bound)\n    ) {\n      return super.pipe(\n        new RunnableBinding({\n          bound: coerceable.bound.withStructuredOutput(\n            this.schema,\n            ...(this.method ? [{ method: this.method }] : [])\n          ),\n          kwargs: coerceable.kwargs ?? {},\n          config: coerceable.config,\n          configFactories: coerceable.configFactories,\n        })\n      );\n    }\n\n    throw new Error(\n      `Structured prompts need to be piped to a language model that supports the \"withStructuredOutput()\" method.`\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static fromMessagesAndSchema<RunInput extends InputValues = any>(\n    promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[],\n    schema: StructuredPromptInput[\"schema\"],\n    method?: \"jsonMode\" | \"jsonSchema\" | \"functionMode\"\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): ChatPromptTemplate<RunInput, any> {\n    return StructuredPrompt.fromMessages<\n      RunInput,\n      StructuredPromptInput<RunInput>\n    >(promptMessages, { schema, method });\n  }\n}\n","import { BaseContentBlock } from \"./base.js\";\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type ImageDetail = \"auto\" | \"low\" | \"high\";\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type MessageContentText = {\n  type: \"text\";\n  text: string;\n};\n\n/**\n * @deprecated\n * Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type MessageContentImageUrl = {\n  type: \"image_url\";\n  image_url: string | { url: string; detail?: ImageDetail };\n};\n\n/**\n * @deprecated\n * Use {@link ContentBlock} instead.\n */\nexport type MessageContentComplex =\n  | MessageContentText\n  | MessageContentImageUrl\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | (Record<string, any> & { type?: \"text\" | \"image_url\" | string })\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | (Record<string, any> & { type?: never });\n\nexport type Data = never;\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace Data {\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface BaseDataContentBlock extends BaseContentBlock {\n    mime_type?: string;\n    metadata?: Record<string, unknown>;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface URLContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"url\";\n    url: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface Base64ContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"base64\";\n    data: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface PlainTextContentBlock extends BaseDataContentBlock {\n    type: \"file\" | \"text\";\n    source_type: \"text\";\n    text: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export interface IDContentBlock extends BaseDataContentBlock {\n    type: \"image\" | \"audio\" | \"file\";\n    source_type: \"id\";\n    id: string;\n  }\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type DataContentBlock =\n    | URLContentBlock\n    | Base64ContentBlock\n    | PlainTextContentBlock\n    | IDContentBlock;\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardImageBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n  ) & {\n    type: \"image\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardAudioBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n  ) & {\n    type: \"audio\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardFileBlock = (\n    | URLContentBlock\n    | Base64ContentBlock\n    | IDContentBlock\n    | PlainTextContentBlock\n  ) & {\n    type: \"file\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Standard} instead\n   */\n  export type StandardTextBlock = PlainTextContentBlock & {\n    type: \"text\";\n  };\n\n  /**\n   * @deprecated\n   * Use {@link ContentBlock.Multimodal.Data} instead\n   */\n  export type DataContentBlockType = DataContentBlock[\"type\"];\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isDataContentBlock(\n  content_block: object\n): content_block is Data.DataContentBlock {\n  return (\n    typeof content_block === \"object\" &&\n    content_block !== null &&\n    \"type\" in content_block &&\n    typeof content_block.type === \"string\" &&\n    \"source_type\" in content_block &&\n    (content_block.source_type === \"url\" ||\n      content_block.source_type === \"base64\" ||\n      content_block.source_type === \"text\" ||\n      content_block.source_type === \"id\")\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isURLContentBlock(\n  content_block: object\n): content_block is Data.URLContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"url\" &&\n    \"url\" in content_block &&\n    typeof content_block.url === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isBase64ContentBlock(\n  content_block: object\n): content_block is Data.Base64ContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"base64\" &&\n    \"data\" in content_block &&\n    typeof content_block.data === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isPlainTextContentBlock(\n  content_block: object\n): content_block is Data.PlainTextContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"text\" &&\n    \"text\" in content_block &&\n    typeof content_block.text === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function isIDContentBlock(\n  content_block: object\n): content_block is Data.IDContentBlock {\n  return (\n    isDataContentBlock(content_block) &&\n    content_block.source_type === \"id\" &&\n    \"id\" in content_block &&\n    typeof content_block.id === \"string\"\n  );\n}\n\n/**\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function convertToOpenAIImageBlock(\n  content_block: Data.URLContentBlock | Data.Base64ContentBlock\n) {\n  if (isDataContentBlock(content_block)) {\n    if (content_block.source_type === \"url\") {\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: content_block.url,\n        },\n      };\n    }\n    if (content_block.source_type === \"base64\") {\n      if (!content_block.mime_type) {\n        throw new Error(\"mime_type key is required for base64 data.\");\n      }\n      const mime_type = content_block.mime_type;\n      return {\n        type: \"image_url\",\n        image_url: {\n          url: `data:${mime_type};base64,${content_block.data}`,\n        },\n      };\n    }\n  }\n  throw new Error(\n    \"Unsupported source type. Only 'url' and 'base64' are supported.\"\n  );\n}\n\n/**\n * Utility function for ChatModelProviders. Parses a mime type into a type, subtype, and parameters.\n *\n * @param mime_type - The mime type to parse.\n * @returns An object containing the type, subtype, and parameters.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseMimeType(mime_type: string): {\n  type: string;\n  subtype: string;\n  parameters: Record<string, string>;\n} {\n  const parts = mime_type.split(\";\")[0].split(\"/\");\n  if (parts.length !== 2) {\n    throw new Error(\n      `Invalid mime type: \"${mime_type}\" - does not match type/subtype format.`\n    );\n  }\n\n  const type = parts[0].trim();\n  const subtype = parts[1].trim();\n\n  if (type === \"\" || subtype === \"\") {\n    throw new Error(\n      `Invalid mime type: \"${mime_type}\" - type or subtype is empty.`\n    );\n  }\n\n  const parameters: Record<string, string> = {};\n\n  for (const parameterKvp of mime_type.split(\";\").slice(1)) {\n    const parameterParts = parameterKvp.split(\"=\");\n    if (parameterParts.length !== 2) {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n    const key = parameterParts[0].trim();\n    const value = parameterParts[1].trim();\n    if (key === \"\") {\n      throw new Error(`Invalid parameter syntax in mime type: \"${mime_type}\".`);\n    }\n\n    parameters[key] = value;\n  }\n\n  return {\n    type,\n    subtype,\n    parameters,\n  };\n}\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns An object containing the parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl,\n  asTypedArray,\n}: {\n  dataUrl: string;\n  asTypedArray: true;\n}): { data: Uint8Array; mime_type: string } | undefined;\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl,\n  asTypedArray,\n}: {\n  dataUrl: string;\n  asTypedArray?: false;\n}): { data: string; mime_type: string } | undefined;\n\n/**\n * Utility function for ChatModelProviders. Parses a base64 data URL into a typed array or string.\n *\n * @param dataUrl - The base64 data URL to parse.\n * @param asTypedArray - Whether to return the data as a typed array.\n * @returns The parsed data and mime type, or undefined if the data URL is invalid.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function parseBase64DataUrl({\n  dataUrl: data_url,\n  asTypedArray = false,\n}: {\n  dataUrl: string;\n  asTypedArray?: boolean;\n}): { data: string | Uint8Array; mime_type: string } | undefined {\n  const formatMatch = data_url.match(\n    /^data:(\\w+\\/\\w+);base64,([A-Za-z0-9+/]+=*)$/\n  );\n  let mime_type: string | undefined;\n\n  if (formatMatch) {\n    mime_type = formatMatch[1].toLowerCase();\n    const data = asTypedArray\n      ? Uint8Array.from(atob(formatMatch[2]), (c) => c.charCodeAt(0))\n      : formatMatch[2];\n    return {\n      mime_type,\n      data,\n    };\n  }\n\n  return undefined;\n}\n\n/**\n * A bag of provider-specific content block types.\n *\n * Allows implementations of {@link StandardContentBlockConverter} and related to be defined only in\n * terms of the types they support. Also allows for forward compatibility as the set of known\n * standard types grows, as the set of types can be extended without breaking existing\n * implementations of the aforementioned interfaces.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport type ProviderFormatTypes<\n  TextFormat = unknown,\n  ImageFormat = unknown,\n  AudioFormat = unknown,\n  FileFormat = unknown,\n  VideoFormat = unknown\n> = {\n  text: TextFormat;\n  image: ImageFormat;\n  audio: AudioFormat;\n  file: FileFormat;\n  video: VideoFormat;\n};\n\n/**\n * Utility interface for converting between standard and provider-specific data content blocks, to be\n * used when implementing chat model providers.\n *\n * Meant to be used with {@link convertToProviderContentBlock} and\n * {@link convertToStandardContentBlock} rather than being consumed directly.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport interface StandardContentBlockConverter<\n  Formats extends Partial<ProviderFormatTypes>\n> {\n  /**\n   * The name of the provider type that corresponds to the provider-specific content block types\n   * that this converter supports.\n   */\n  providerName: string;\n\n  /**\n   * Convert from a standard image block to a provider's proprietary image block format.\n   * @param block - The standard image block to convert.\n   * @returns The provider image block.\n   */\n  fromStandardImageBlock?(block: Data.StandardImageBlock): Formats[\"image\"];\n\n  /**\n   * Convert from a standard audio block to a provider's proprietary audio block format.\n   * @param block - The standard audio block to convert.\n   * @returns The provider audio block.\n   */\n  fromStandardAudioBlock?(block: Data.StandardAudioBlock): Formats[\"audio\"];\n\n  /**\n   * Convert from a standard file block to a provider's proprietary file block format.\n   * @param block - The standard file block to convert.\n   * @returns The provider file block.\n   */\n  fromStandardFileBlock?(block: Data.StandardFileBlock): Formats[\"file\"];\n\n  /**\n   * Convert from a standard text block to a provider's proprietary text block format.\n   * @param block - The standard text block to convert.\n   * @returns The provider text block.\n   */\n  fromStandardTextBlock?(block: Data.StandardTextBlock): Formats[\"text\"];\n}\n\n/**\n * Convert from a standard data content block to a provider's proprietary data content block format.\n *\n * Don't override this method. Instead, override the more specific conversion methods and use this\n * method unmodified.\n *\n * @param block - The standard data content block to convert.\n * @returns The provider data content block.\n * @throws An error if the standard data content block type is not supported.\n *\n * @deprecated Don't use data content blocks. Use {@link ContentBlock.Multimodal.Data} instead.\n */\nexport function convertToProviderContentBlock<\n  Formats extends Partial<ProviderFormatTypes>\n>(\n  block: Data.DataContentBlock,\n  converter: StandardContentBlockConverter<Formats>\n): Formats[keyof Formats] {\n  if (block.type === \"text\") {\n    if (!converter.fromStandardTextBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardTextBlock\\` method.`\n      );\n    }\n    return converter.fromStandardTextBlock(block as Data.StandardTextBlock);\n  }\n  if (block.type === \"image\") {\n    if (!converter.fromStandardImageBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardImageBlock\\` method.`\n      );\n    }\n    return converter.fromStandardImageBlock(block as Data.StandardImageBlock);\n  }\n  if (block.type === \"audio\") {\n    if (!converter.fromStandardAudioBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardAudioBlock\\` method.`\n      );\n    }\n    return converter.fromStandardAudioBlock(block as Data.StandardAudioBlock);\n  }\n  if (block.type === \"file\") {\n    if (!converter.fromStandardFileBlock) {\n      throw new Error(\n        `Converter for ${converter.providerName} does not implement \\`fromStandardFileBlock\\` method.`\n      );\n    }\n    return converter.fromStandardFileBlock(block as Data.StandardFileBlock);\n  }\n  throw new Error(\n    `Unable to convert content block type '${block.type}' to provider-specific format: not recognized.`\n  );\n}\n","import { ZodEffectsDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { parseAnyDef } from \"./any.js\";\n\nexport function parseEffectsDef(\n  _def: ZodEffectsDef,\n  refs: Refs\n): JsonSchema7Type | undefined {\n  return refs.effectStrategy === \"input\"\n    ? parseDef(_def.schema._def, refs)\n    : parseAnyDef(refs);\n}\n","import { ZodDateDef } from \"zod/v3\";\nimport { Refs } from \"../Refs.js\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { JsonSchema7NumberType } from \"./number.js\";\nimport { DateStrategy } from \"../Options.js\";\n\nexport type JsonSchema7DateType =\n  | {\n      type: \"integer\" | \"string\";\n      format: \"unix-time\" | \"date-time\" | \"date\";\n      minimum?: number;\n      maximum?: number;\n      errorMessage?: ErrorMessages<JsonSchema7NumberType>;\n    }\n  | {\n      anyOf: JsonSchema7DateType[];\n    };\n\nexport function parseDateDef(\n  def: ZodDateDef,\n  refs: Refs,\n  overrideDateStrategy?: DateStrategy\n): JsonSchema7DateType {\n  const strategy = overrideDateStrategy ?? refs.dateStrategy;\n\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item) => parseDateDef(def, refs, item)),\n    };\n  }\n\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\",\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\",\n      };\n    case \"integer\":\n      return integerDateParser(def, refs);\n  }\n}\n\nconst integerDateParser = (def: ZodDateDef, refs: Refs) => {\n  const res: JsonSchema7DateType = {\n    type: \"integer\",\n    format: \"unix-time\",\n  };\n\n  if (refs.target === \"openApi3\") {\n    return res;\n  }\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        setResponseValueAndErrors(\n          res,\n          \"minimum\",\n          check.value, // This is in milliseconds\n          check.message,\n          refs\n        );\n        break;\n      case \"max\":\n        setResponseValueAndErrors(\n          res,\n          \"maximum\",\n          check.value, // This is in milliseconds\n          check.message,\n          refs\n        );\n        break;\n    }\n  }\n\n  return res;\n};\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\nimport { load } from \"@langchain/core/load\";\nimport { SerializerProtocol } from \"./base.js\";\nimport { stringify } from \"./utils/fast-safe-stringify/index.js\";\n\nfunction isLangChainSerializedObject(value: Record<string, unknown>) {\n  return (\n    value !== null &&\n    value.lc === 1 &&\n    value.type === \"constructor\" &&\n    Array.isArray(value.id)\n  );\n}\n\n/**\n * The replacer in stringify does not allow delegation to built-in LangChain\n * serialization methods, and instead immediately calls `.toJSON()` and\n * continues to stringify subfields.\n *\n * We therefore must start from the most nested elements in the input and\n * deserialize upwards rather than top-down.\n */\nasync function _reviver(value: any): Promise<any> {\n  if (value && typeof value === \"object\") {\n    if (Array.isArray(value)) {\n      const revivedArray = await Promise.all(\n        value.map((item) => _reviver(item))\n      );\n      return revivedArray;\n    } else {\n      const revivedObj: any = {};\n      for (const [k, v] of Object.entries(value)) {\n        revivedObj[k] = await _reviver(v);\n      }\n\n      if (revivedObj.lc === 2 && revivedObj.type === \"undefined\") {\n        return undefined;\n      } else if (\n        revivedObj.lc === 2 &&\n        revivedObj.type === \"constructor\" &&\n        Array.isArray(revivedObj.id)\n      ) {\n        try {\n          const constructorName = revivedObj.id[revivedObj.id.length - 1];\n          let constructor: any;\n\n          switch (constructorName) {\n            case \"Set\":\n              constructor = Set;\n              break;\n            case \"Map\":\n              constructor = Map;\n              break;\n            case \"RegExp\":\n              constructor = RegExp;\n              break;\n            case \"Error\":\n              constructor = Error;\n              break;\n            default:\n              return revivedObj;\n          }\n          if (revivedObj.method) {\n            return (constructor as any)[revivedObj.method](\n              ...(revivedObj.args || [])\n            );\n          } else {\n            return new (constructor as any)(...(revivedObj.args || []));\n          }\n        } catch (error) {\n          return revivedObj;\n        }\n      } else if (isLangChainSerializedObject(revivedObj)) {\n        return load(JSON.stringify(revivedObj));\n      }\n\n      return revivedObj;\n    }\n  }\n  return value;\n}\n\nfunction _encodeConstructorArgs(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  constructor: Function,\n  method?: string,\n  args?: any[],\n  kwargs?: Record<string, any>\n): object {\n  return {\n    lc: 2,\n    type: \"constructor\",\n    id: [constructor.name],\n    method: method ?? null,\n    args: args ?? [],\n    kwargs: kwargs ?? {},\n  };\n}\n\nfunction _default(obj: any): any {\n  if (obj === undefined) {\n    return {\n      lc: 2,\n      type: \"undefined\",\n    };\n  } else if (obj instanceof Set || obj instanceof Map) {\n    return _encodeConstructorArgs(obj.constructor, undefined, [\n      Array.from(obj),\n    ]);\n  } else if (obj instanceof RegExp) {\n    return _encodeConstructorArgs(RegExp, undefined, [obj.source, obj.flags]);\n  } else if (obj instanceof Error) {\n    return _encodeConstructorArgs(obj.constructor, undefined, [obj.message]);\n    // TODO: Remove special case\n  } else if (obj?.lg_name === \"Send\") {\n    return {\n      node: obj.node,\n      args: obj.args,\n    };\n  } else {\n    return obj;\n  }\n}\n\nexport class JsonPlusSerializer implements SerializerProtocol {\n  protected _dumps(obj: any): Uint8Array {\n    const encoder = new TextEncoder();\n    return encoder.encode(\n      stringify(obj, (_: string, value: any) => {\n        return _default(value);\n      })\n    );\n  }\n\n  async dumpsTyped(obj: any): Promise<[string, Uint8Array]> {\n    if (obj instanceof Uint8Array) {\n      return [\"bytes\", obj];\n    } else {\n      return [\"json\", this._dumps(obj)];\n    }\n  }\n\n  protected async _loads(data: string): Promise<any> {\n    const parsed = JSON.parse(data);\n    return _reviver(parsed);\n  }\n\n  async loadsTyped(type: string, data: Uint8Array | string): Promise<any> {\n    if (type === \"bytes\") {\n      return typeof data === \"string\" ? new TextEncoder().encode(data) : data;\n    } else if (type === \"json\") {\n      return this._loads(\n        typeof data === \"string\" ? data : new TextDecoder().decode(data)\n      );\n    } else {\n      throw new Error(`Unknown serialization type: ${type}`);\n    }\n  }\n}\n","import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isArray, _isContentBlock, _isString, iife } from \"./utils.js\";\n\nfunction convertToV1FromChatVertexMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `/libs/providers/langchain-google-common/src/utils/gemini.ts:partsToMessageContent`\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"reasoning\") && _isString(block.reasoning)) {\n        const signature = iife(() => {\n          const reasoningIndex = content.indexOf(block);\n          if (\n            _isArray(message.additional_kwargs?.signatures) &&\n            reasoningIndex >= 0\n          ) {\n            return message.additional_kwargs.signatures.at(reasoningIndex);\n          }\n          return undefined;\n        });\n        if (_isString(signature)) {\n          yield {\n            type: \"reasoning\",\n            reasoning: block.reasoning,\n            signature,\n          };\n        } else {\n          yield {\n            type: \"reasoning\",\n            reasoning: block.reasoning,\n          };\n        }\n        continue;\n      } else if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (_isContentBlock(block, \"image_url\")) {\n        if (_isString(block.image_url)) {\n          if (block.image_url.startsWith(\"data:\")) {\n            const dataUrlRegex = /^data:([^;]+);base64,(.+)$/;\n            const match = block.image_url.match(dataUrlRegex);\n            if (match) {\n              yield { type: \"image\", data: match[2], mimeType: match[1] };\n            } else {\n              yield { type: \"image\", url: block.image_url };\n            }\n          } else {\n            yield { type: \"image\", url: block.image_url };\n          }\n        }\n        continue;\n      } else if (\n        _isContentBlock(block, \"media\") &&\n        _isString(block.mimeType) &&\n        _isString(block.data)\n      ) {\n        yield { type: \"file\", mimeType: block.mimeType, data: block.data };\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatVertexTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatVertexMessage,\n  translateContentChunk: convertToV1FromChatVertexMessage,\n};\n","export { Client, } from \"./client.js\";\nexport { RunTree } from \"./run_trees.js\";\nexport { overrideFetchImplementation } from \"./singletons/fetch.js\";\nexport { getDefaultProjectName } from \"./utils/project.js\";\nexport { uuid7, uuid7FromTime } from \"./uuid.js\";\n// Update using yarn bump-version\nexport const __version__ = \"0.3.82\";\n","import { OrderResolutionStateType } from '../state';\r\nimport { checkWarehouseInventory } from '../tools/warehouse';\r\n\r\n/**\r\n * Check warehouse inventory and reserve items\r\n */\r\nexport async function checkWarehouseNode(\r\n    state: OrderResolutionStateType\r\n): Promise<Partial<OrderResolutionStateType>> {\r\n    try {\r\n        const warehouseResult = await checkWarehouseInventory(state);\r\n\r\n        const message = ` Items available at ${warehouseResult.location}. Stock: ${warehouseResult.stockLevel} units. Prep time: ~${warehouseResult.estimatedPrepTime} min`;\r\n\r\n        return {\r\n            currentStep: 'checking_warehouse',\r\n            warehouseResult,\r\n            stepMessages: [\r\n                ...state.stepMessages,\r\n                {\r\n                    step: 'checking_warehouse',\r\n                    message,\r\n                    timestamp: new Date().toISOString(),\r\n                },\r\n            ],\r\n        };\r\n    } catch (error) {\r\n        return {\r\n            currentStep: 'error',\r\n            error: error instanceof Error ? error.message : 'Warehouse check failed',\r\n            stepMessages: [\r\n                ...state.stepMessages,\r\n                {\r\n                    step: 'error',\r\n                    message: `Warehouse check failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n                    timestamp: new Date().toISOString(),\r\n                },\r\n            ],\r\n        };\r\n    }\r\n}\r\n","import { OrderResolutionStateType } from '../state';\r\nimport { findAvailableDrivers, assignDriverToOrder } from '../tools/driver';\r\n\r\n/**\r\n * Find and assign an available driver\r\n */\r\nexport async function assignDriverNode(\r\n    state: OrderResolutionStateType\r\n): Promise<Partial<OrderResolutionStateType>> {\r\n    try {\r\n        const driverResult = await findAvailableDrivers(state);\r\n\r\n        // Assign the driver to the order\r\n        await assignDriverToOrder(state.orderId, driverResult.driverId);\r\n\r\n        const message = ` Driver assigned: ${driverResult.driverName} (${driverResult.vehicleType}). ETA: ~${driverResult.estimatedArrival} min, Distance: ${driverResult.distance} km`;\r\n\r\n        return {\r\n            currentStep: 'assigning_driver',\r\n            driverResult,\r\n            stepMessages: [\r\n                ...state.stepMessages,\r\n                {\r\n                    step: 'assigning_driver',\r\n                    message,\r\n                    timestamp: new Date().toISOString(),\r\n                },\r\n            ],\r\n        };\r\n    } catch (error) {\r\n        return {\r\n            currentStep: 'error',\r\n            error: error instanceof Error ? error.message : 'Driver assignment failed',\r\n            stepMessages: [\r\n                ...state.stepMessages,\r\n                {\r\n                    step: 'error',\r\n                    message: `Driver assignment failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\r\n                    timestamp: new Date().toISOString(),\r\n                },\r\n            ],\r\n        };\r\n    }\r\n}\r\n","import { EventEmitter } from 'eventemitter3';\nimport pTimeout from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverIntervalCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #rateLimitedInInterval = false;\n    #rateLimitFlushScheduled = false;\n    #interval;\n    #intervalEnd = 0;\n    #lastExecutionTime = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    // Track currently running tasks for debugging\n    #runningTasks = new Map();\n    /**\n    Get or set the default timeout for all tasks. Can be changed at runtime.\n\n    Operations will throw a `TimeoutError` if they don't complete within the specified time.\n\n    The timeout begins when the operation is dequeued and starts execution, not while it's waiting in the queue.\n\n    @example\n    ```\n    const queue = new PQueue({timeout: 5000});\n\n    // Change timeout for all future tasks\n    queue.timeout = 10000;\n    ```\n    */\n    timeout;\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverIntervalCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        // TODO: Remove this fallback in the next major version\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        this.#carryoverIntervalCount = options.carryoverIntervalCount ?? options.carryoverConcurrencyCount ?? false;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        if (options.timeout !== undefined && !(Number.isFinite(options.timeout) && options.timeout > 0)) {\n            throw new TypeError(`Expected \\`timeout\\` to be a positive finite number, got \\`${options.timeout}\\` (${typeof options.timeout})`);\n        }\n        this.timeout = options.timeout;\n        this.#isPaused = options.autoStart === false;\n        this.#setupRateLimitTracking();\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        if (this.#pending === 0) {\n            this.emit('pendingZero');\n        }\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval(); // Already schedules update\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // If the interval has expired while idle, check if we should enforce the interval\n                // from the last task execution. This ensures proper spacing between tasks even\n                // when the queue becomes empty and then new tasks are added.\n                if (this.#lastExecutionTime > 0) {\n                    const timeSinceLastExecution = now - this.#lastExecutionTime;\n                    if (timeSinceLastExecution < this.#interval) {\n                        // Not enough time has passed since the last task execution\n                        this.#createIntervalTimeout(this.#interval - timeSinceLastExecution);\n                        return true;\n                    }\n                }\n                // Enough time has passed or no previous execution, allow execution\n                this.#intervalCount = (this.#carryoverIntervalCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                this.#createIntervalTimeout(delay);\n                return true;\n            }\n        }\n        return false;\n    }\n    #createIntervalTimeout(delay) {\n        if (this.#timeoutId !== undefined) {\n            return;\n        }\n        this.#timeoutId = setTimeout(() => {\n            this.#onResumeInterval();\n        }, delay);\n    }\n    #clearIntervalTimer() {\n        if (this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n    }\n    #clearTimeoutTimer() {\n        if (this.#timeoutId) {\n            clearTimeout(this.#timeoutId);\n            this.#timeoutId = undefined;\n        }\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            this.#clearIntervalTimer();\n            this.emit('empty');\n            if (this.#pending === 0) {\n                // Clear timeout as well when completely idle\n                this.#clearTimeoutTimer();\n                this.emit('idle');\n            }\n            return false;\n        }\n        let taskStarted = false;\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                // Increment interval count immediately to prevent race conditions\n                if (!this.#isIntervalIgnored) {\n                    this.#intervalCount++;\n                    this.#scheduleRateLimitUpdate();\n                }\n                this.emit('active');\n                this.#lastExecutionTime = Date.now();\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                taskStarted = true;\n            }\n        }\n        return taskStarted;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            this.#clearIntervalTimer();\n        }\n        this.#intervalCount = this.#carryoverIntervalCount ? this.#pending : 0;\n        this.#processQueue();\n        this.#scheduleRateLimitUpdate();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '', {priority: 1});\n    queue.add(async () => '', {priority: 0, id: ''});\n    queue.add(async () => '', {priority: 1});\n    queue.add(async () => '', {priority: 1});\n\n    queue.setPriority('', 2);\n    ```\n\n    In this case, the promise function with `id: ''` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '', {priority: 1});\n    queue.add(async () => '', {priority: 1, id: ''});\n    queue.add(async () => '');\n    queue.add(async () => '', {priority: 0});\n\n    queue.setPriority('', -1);\n    ```\n    Here, the promise function with `id: ''` executes last.\n    */\n    setPriority(id, priority) {\n        if (typeof priority !== 'number' || !Number.isFinite(priority)) {\n            throw new TypeError(`Expected \\`priority\\` to be a finite number, got \\`${priority}\\` (${typeof priority})`);\n        }\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            // Create a unique symbol for tracking this task\n            const taskSymbol = Symbol(`task-${options.id}`);\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                // Track this running task\n                this.#runningTasks.set(taskSymbol, {\n                    id: options.id,\n                    priority: options.priority ?? 0, // Match priority-queue default\n                    startTime: Date.now(),\n                    timeout: options.timeout,\n                });\n                let eventListener;\n                try {\n                    // Check abort signal - if aborted, need to decrement the counter\n                    // that was incremented in tryToStartAnother\n                    try {\n                        options.signal?.throwIfAborted();\n                    }\n                    catch (error) {\n                        // Decrement the counter that was already incremented\n                        if (!this.#isIntervalIgnored) {\n                            this.#intervalCount--;\n                        }\n                        // Clean up tracking before throwing\n                        this.#runningTasks.delete(taskSymbol);\n                        throw error;\n                    }\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), {\n                            milliseconds: options.timeout,\n                            message: `Task timed out after ${options.timeout}ms (queue has ${this.#pending} running, ${this.#queue.size} waiting)`,\n                        });\n                    }\n                    if (options.signal) {\n                        const { signal } = options;\n                        operation = Promise.race([operation, new Promise((_resolve, reject) => {\n                                eventListener = () => {\n                                    reject(signal.reason);\n                                };\n                                signal.addEventListener('abort', eventListener, { once: true });\n                            })]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    // Clean up abort event listener\n                    if (eventListener) {\n                        options.signal?.removeEventListener('abort', eventListener);\n                    }\n                    // Remove from running tasks\n                    this.#runningTasks.delete(taskSymbol);\n                    // Use queueMicrotask to prevent deep recursion while maintaining timing\n                    queueMicrotask(() => {\n                        this.#next();\n                    });\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n        // Note: We don't clear #runningTasks as those tasks are still running\n        // They will be removed when they complete in the finally block\n        // Force synchronous update since clear() should have immediate effect\n        this.#updateRateLimitState();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    /**\n    The difference with `.onIdle` is that `.onPendingZero` only waits for currently running tasks to finish, ignoring queued tasks.\n\n    @returns A promise that settles when all currently running tasks have completed; `queue.pending === 0`.\n    */\n    async onPendingZero() {\n        if (this.#pending === 0) {\n            return;\n        }\n        await this.#onEvent('pendingZero');\n    }\n    /**\n    @returns A promise that settles when the queue becomes rate-limited due to intervalCap.\n    */\n    async onRateLimit() {\n        if (this.isRateLimited) {\n            return;\n        }\n        await this.#onEvent('rateLimit');\n    }\n    /**\n    @returns A promise that settles when the queue is no longer rate-limited.\n    */\n    async onRateLimitCleared() {\n        if (!this.isRateLimited) {\n            return;\n        }\n        await this.#onEvent('rateLimitCleared');\n    }\n    /**\n    @returns A promise that rejects when any task in the queue errors.\n\n    Use with `Promise.race([queue.onError(), queue.onIdle()])` to fail fast on the first error while still resolving normally when the queue goes idle.\n\n    Important: The promise returned by `add()` still rejects. You must handle each `add()` promise (for example, `.catch(() => {})`) to avoid unhandled rejections.\n\n    @example\n    ```\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    queue.add(() => fetchData(1)).catch(() => {});\n    queue.add(() => fetchData(2)).catch(() => {});\n    queue.add(() => fetchData(3)).catch(() => {});\n\n    // Stop processing on first error\n    try {\n        await Promise.race([\n            queue.onError(),\n            queue.onIdle()\n        ]);\n    } catch (error) {\n        queue.pause(); // Stop processing remaining tasks\n        console.error('Queue failed:', error);\n    }\n    ```\n    */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\n    async onError() {\n        return new Promise((_resolve, reject) => {\n            const handleError = (error) => {\n                this.off('error', handleError);\n                reject(error);\n            };\n            this.on('error', handleError);\n        });\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n    #setupRateLimitTracking() {\n        // Only schedule updates when rate limiting is enabled\n        if (this.#isIntervalIgnored) {\n            return;\n        }\n        // Wire up to lifecycle events that affect rate limit state\n        // Only 'add' and 'next' can actually change rate limit state\n        this.on('add', () => {\n            if (this.#queue.size > 0) {\n                this.#scheduleRateLimitUpdate();\n            }\n        });\n        this.on('next', () => {\n            this.#scheduleRateLimitUpdate();\n        });\n    }\n    #scheduleRateLimitUpdate() {\n        // Skip if rate limiting is not enabled or already scheduled\n        if (this.#isIntervalIgnored || this.#rateLimitFlushScheduled) {\n            return;\n        }\n        this.#rateLimitFlushScheduled = true;\n        queueMicrotask(() => {\n            this.#rateLimitFlushScheduled = false;\n            this.#updateRateLimitState();\n        });\n    }\n    #updateRateLimitState() {\n        const previous = this.#rateLimitedInInterval;\n        const shouldBeRateLimited = !this.#isIntervalIgnored\n            && this.#intervalCount >= this.#intervalCap\n            && this.#queue.size > 0;\n        if (shouldBeRateLimited !== previous) {\n            this.#rateLimitedInInterval = shouldBeRateLimited;\n            this.emit(shouldBeRateLimited ? 'rateLimit' : 'rateLimitCleared');\n        }\n    }\n    /**\n    Whether the queue is currently rate-limited due to intervalCap.\n    */\n    get isRateLimited() {\n        return this.#rateLimitedInInterval;\n    }\n    /**\n    Whether the queue is saturated. Returns `true` when:\n    - All concurrency slots are occupied and tasks are waiting, OR\n    - The queue is rate-limited and tasks are waiting\n\n    Useful for detecting backpressure and potential hanging tasks.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    // Backpressure handling\n    if (queue.isSaturated) {\n        console.log('Queue is saturated, waiting for capacity...');\n        await queue.onSizeLessThan(queue.concurrency);\n    }\n\n    // Monitoring for stuck tasks\n    setInterval(() => {\n        if (queue.isSaturated) {\n            console.warn(`Queue saturated: ${queue.pending} running, ${queue.size} waiting`);\n        }\n    }, 60000);\n    ```\n    */\n    get isSaturated() {\n        return (this.#pending === this.#concurrency && this.#queue.size > 0)\n            || (this.isRateLimited && this.#queue.size > 0);\n    }\n    /**\n    The tasks currently being executed. Each task includes its `id`, `priority`, `startTime`, and `timeout` (if set).\n\n    Returns an array of task info objects.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 2});\n\n    // Add tasks with IDs for better debugging\n    queue.add(() => fetchUser(123), {id: 'user-123'});\n    queue.add(() => fetchPosts(456), {id: 'posts-456', priority: 1});\n\n    // Check what's running\n    console.log(queue.runningTasks);\n    // => [{\n    //   id: 'user-123',\n    //   priority: 0,\n    //   startTime: 1759253001716,\n    //   timeout: undefined\n    // }, {\n    //   id: 'posts-456',\n    //   priority: 1,\n    //   startTime: 1759253001916,\n    //   timeout: undefined\n    // }]\n    ```\n    */\n    get runningTasks() {\n        // Return fresh array with fresh objects to prevent mutations\n        return [...this.#runningTasks.values()].map(task => ({ ...task }));\n    }\n}\n/**\nError thrown when a task times out.\n\n@example\n```\nimport PQueue, {TimeoutError} from 'p-queue';\n\nconst queue = new PQueue({timeout: 1000});\n\ntry {\n    await queue.add(() => someTask());\n} catch (error) {\n    if (error instanceof TimeoutError) {\n        console.log('Task timed out');\n    }\n}\n```\n*/\nexport { TimeoutError } from 'p-timeout';\n","import {\n  Runnable,\n  RunnableConfig,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { _isSend, CONFIG_KEY_SEND, Send, TASKS } from \"../constants.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport { InvalidUpdateError } from \"../errors.js\";\n\ntype TYPE_SEND = (values: Array<[string, unknown]>) => void;\n\nexport const SKIP_WRITE = {\n  [Symbol.for(\"LG_SKIP_WRITE\")]: true,\n};\n\nfunction _isSkipWrite(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_SKIP_WRITE\")] !== undefined\n  );\n}\n\nexport const PASSTHROUGH = {\n  [Symbol.for(\"LG_PASSTHROUGH\")]: true,\n};\n\nfunction _isPassthrough(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_PASSTHROUGH\")] !== undefined\n  );\n}\n\nconst IS_WRITER = Symbol(\"IS_WRITER\");\n\n/**\n * Mapping of write channels to Runnables that return the value to be written,\n * or None to skip writing.\n */\nexport class ChannelWrite<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable<RunInput, RunInput> {\n  writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>;\n\n  constructor(\n    writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>,\n    tags?: string[]\n  ) {\n    const name = `ChannelWrite<${writes\n      .map((packet) => {\n        if (_isSend(packet)) {\n          return packet.node;\n        } else if (\"channel\" in packet) {\n          return packet.channel;\n        }\n        return \"...\";\n      })\n      .join(\",\")}>`;\n    super({\n      ...{ writes, name, tags },\n      func: async (input: RunInput, config?: RunnableConfig) => {\n        return this._write(input, config ?? {});\n      },\n    });\n\n    this.writes = writes;\n  }\n\n  async _write(input: unknown, config: RunnableConfig): Promise<unknown> {\n    const writes = this.writes.map((write) => {\n      if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) {\n        return {\n          mapper: write.mapper,\n          value: input,\n        };\n      } else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) {\n        return {\n          channel: write.channel,\n          value: input,\n          skipNone: write.skipNone,\n          mapper: write.mapper,\n        };\n      } else {\n        return write;\n      }\n    });\n    await ChannelWrite.doWrite(config, writes);\n    return input;\n  }\n\n  // TODO: Support requireAtLeastOneOf\n  static async doWrite(\n    config: RunnableConfig,\n    writes: (ChannelWriteEntry | ChannelWriteTupleEntry | Send)[]\n  ): Promise<void> {\n    // validate\n    for (const w of writes) {\n      if (_isChannelWriteEntry(w)) {\n        if (w.channel === TASKS) {\n          throw new InvalidUpdateError(\n            \"Cannot write to the reserved channel TASKS\"\n          );\n        }\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n      if (_isChannelWriteTupleEntry(w)) {\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const writeEntries: [string, any][] = [];\n    for (const w of writes) {\n      if (_isSend(w)) {\n        writeEntries.push([TASKS, w]);\n      } else if (_isChannelWriteTupleEntry(w)) {\n        const mappedResult = await w.mapper.invoke(w.value, config);\n        if (mappedResult != null && mappedResult.length > 0) {\n          writeEntries.push(...mappedResult);\n        }\n      } else if (_isChannelWriteEntry(w)) {\n        const mappedValue =\n          w.mapper !== undefined\n            ? await w.mapper.invoke(w.value, config)\n            : w.value;\n        if (_isSkipWrite(mappedValue)) {\n          continue;\n        }\n        if (w.skipNone && mappedValue === undefined) {\n          continue;\n        }\n        writeEntries.push([w.channel, mappedValue]);\n      } else {\n        throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);\n      }\n    }\n    const write: TYPE_SEND = config.configurable?.[CONFIG_KEY_SEND];\n    write(writeEntries);\n  }\n\n  static isWriter(runnable: RunnableLike): runnable is ChannelWrite {\n    return (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      runnable instanceof ChannelWrite ||\n      (IS_WRITER in runnable && !!runnable[IS_WRITER])\n    );\n  }\n\n  static registerWriter<T extends Runnable>(runnable: T): T {\n    return Object.defineProperty(runnable, IS_WRITER, { value: true });\n  }\n}\n\nexport interface ChannelWriteEntry {\n  channel: string;\n  value: unknown;\n  skipNone?: boolean;\n  mapper?: Runnable;\n}\n\nfunction _isChannelWriteEntry(x: unknown): x is ChannelWriteEntry {\n  return (\n    x !== undefined && typeof (x as ChannelWriteEntry).channel === \"string\"\n  );\n}\n\nexport interface ChannelWriteTupleEntry {\n  value: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper: Runnable<any, [string, any][]>;\n}\n\nfunction _isChannelWriteTupleEntry(x: unknown): x is ChannelWriteTupleEntry {\n  return (\n    x !== undefined &&\n    !_isChannelWriteEntry(x) &&\n    Runnable.isRunnable((x as ChannelWriteTupleEntry).mapper)\n  );\n}\n","import { Document } from \"../../documents/document.js\";\nimport { BaseRetriever } from \"../../retrievers/index.js\";\n\nexport class FakeRetriever extends BaseRetriever {\n  lc_namespace = [\"test\", \"fake\"];\n\n  output = [\n    new Document({ pageContent: \"foo\" }),\n    new Document({ pageContent: \"bar\" }),\n  ];\n\n  constructor(fields?: { output: Document[] }) {\n    super();\n    this.output = fields?.output ?? this.output;\n  }\n\n  async _getRelevantDocuments(\n    _query: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<Document<Record<string, any>>[]> {\n    return this.output;\n  }\n}\n","import type { RunnableConfig } from \"../runnables/types.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { pickRunnableConfigKeys } from \"./config.js\";\n\nexport function isIterableIterator(\n  thing: unknown\n): thing is IterableIterator<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as Generator)[Symbol.iterator] === \"function\" &&\n    // avoid detecting array/set as iterator\n    typeof (thing as Generator).next === \"function\"\n  );\n}\n\nexport const isIterator = (x: unknown): x is Iterator<unknown> =>\n  x != null &&\n  typeof x === \"object\" &&\n  \"next\" in x &&\n  typeof x.next === \"function\";\n\nexport function isAsyncIterable(\n  thing: unknown\n): thing is AsyncIterable<unknown> {\n  return (\n    typeof thing === \"object\" &&\n    thing !== null &&\n    typeof (thing as AsyncIterable<unknown>)[Symbol.asyncIterator] ===\n      \"function\"\n  );\n}\n\nexport function* consumeIteratorInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: IterableIterator<T>\n): IterableIterator<T> {\n  while (true) {\n    const { value, done } = AsyncLocalStorageProviderSingleton.runWithConfig(\n      pickRunnableConfigKeys(context),\n      iter.next.bind(iter),\n      true\n    );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n\nexport async function* consumeAsyncIterableInContext<T>(\n  context: Partial<RunnableConfig> | undefined,\n  iter: AsyncIterable<T>\n): AsyncIterableIterator<T> {\n  const iterator = iter[Symbol.asyncIterator]();\n  while (true) {\n    const { value, done } =\n      await AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(context),\n        iterator.next.bind(iter),\n        true\n      );\n    if (done) {\n      break;\n    } else {\n      yield value;\n    }\n  }\n}\n","const UPPERCASE = /[\\p{Lu}]/u;\nconst LOWERCASE = /[\\p{Ll}]/u;\nconst LEADING_CAPITAL = /^[\\p{Lu}](?![\\p{Lu}])/u;\nconst SEPARATORS = /[_.\\- ]+/;\n\n// The |$ alternative allows matching at end-of-string, capturing empty string\n// This enables NUMBERS_AND_IDENTIFIER to match digits at string end (e.g., \"test123\")\nconst IDENTIFIER = /([\\p{Alpha}\\p{N}_]|$)/u;\n\nconst LEADING_SEPARATORS = new RegExp('^' + SEPARATORS.source);\nconst SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, 'gu');\nconst NUMBERS_AND_IDENTIFIER = new RegExp(String.raw`\\d+` + IDENTIFIER.source, 'gu');\n\nconst preserveCamelCase = (string, toLowerCase, toUpperCase, preserveConsecutiveUppercase) => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\tlet isLastLastCharPreserved = false;\n\n\tfor (let index = 0; index < string.length; index++) {\n\t\tconst character = string[index];\n\n\t\t// Was the character 3 positions back inserted as a separator?\n\t\t// Prevents excessive separators by checking if we recently inserted one\n\t\t// index - 3 accounts for: current character, inserted separator, previous character\n\t\t// Default true for early positions activates the preserveConsecutiveUppercase guard\n\t\tisLastLastCharPreserved = index > 2 ? string[index - 3] === '-' : true;\n\n\t\tif (isLastCharLower && UPPERCASE.test(character)) {\n\t\t\t// FooBar  Foo-Bar (insert separator before uppercase)\n\t\t\tstring = string.slice(0, index) + '-' + string.slice(index);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\tindex++;\n\t\t} else if (\n\t\t\tisLastCharUpper\n\t\t\t&& isLastLastCharUpper\n\t\t\t&& LOWERCASE.test(character)\n\t\t\t&& (!isLastLastCharPreserved || preserveConsecutiveUppercase)\n\t\t) {\n\t\t\t// FOOBar  FOO-Bar\n\t\t\tstring = string.slice(0, index - 1) + '-' + string.slice(index - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower\n\t\t\t\t= toLowerCase(character) === character\n\t\t\t\t\t&& toUpperCase(character) !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper\n\t\t\t\t= toUpperCase(character) === character\n\t\t\t\t\t&& toLowerCase(character) !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst preserveConsecutiveUppercase = (input, toLowerCase) => input.replace(LEADING_CAPITAL, match => toLowerCase(match));\n\nconst processWithCasePreservation = (input, toLowerCase, preserveConsecutiveUppercase) => {\n\tlet result = '';\n\tlet previousWasNumber = false;\n\tlet previousWasUppercase = false;\n\n\t// Convert input to array for lookahead capability\n\tconst characters = [...input];\n\n\tfor (let index = 0; index < characters.length; index++) {\n\t\tconst character = characters[index];\n\t\tconst isUpperCase = UPPERCASE.test(character);\n\t\tconst nextCharIsUpperCase = index + 1 < characters.length && UPPERCASE.test(characters[index + 1]);\n\n\t\tif (previousWasNumber && /[\\p{Alpha}]/u.test(character)) {\n\t\t\t// Letter after number - preserve original case\n\t\t\tresult += character;\n\t\t\tpreviousWasNumber = false;\n\t\t\tpreviousWasUppercase = isUpperCase;\n\t\t} else if (preserveConsecutiveUppercase && isUpperCase && (previousWasUppercase || nextCharIsUpperCase)) {\n\t\t\t// Part of consecutive uppercase sequence when preserveConsecutiveUppercase is true - keep it\n\t\t\tresult += character;\n\t\t\tpreviousWasUppercase = true;\n\t\t} else if (/\\d/.test(character)) {\n\t\t\t// Number - keep as-is and track it\n\t\t\tresult += character;\n\t\t\tpreviousWasNumber = true;\n\t\t\tpreviousWasUppercase = false;\n\t\t} else if (SEPARATORS.test(character)) {\n\t\t\t// Separator - keep as-is and maintain previousWasNumber state\n\t\t\tresult += character;\n\t\t\tpreviousWasUppercase = false;\n\t\t} else {\n\t\t\t// Regular character - lowercase it\n\t\t\tresult += toLowerCase(character);\n\t\t\tpreviousWasNumber = false;\n\t\t\tpreviousWasUppercase = false;\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\nCore post-processing:\n- Collapses separators and uppercases the following identifier character.\n- Optionally uppercases the identifier following a numeric sequence.\n\nTwo-pass strategy prevents conflicts:\n1. NUMBERS_AND_IDENTIFIER: handles digit-to-letter transitions\n2. SEPARATORS_AND_IDENTIFIER: handles separator-to-identifier transitions\n\nExample: \"b2b_registration\" with capitalizeAfterNumber: true\n- Pass 1: \"2b\" matches, next char is \"_\" (separator), so don't capitalize  \"b2b_registration\"\n- Pass 2: \"_r\" matches, replace with \"R\"  \"b2bRegistration\"\n*/\nconst postProcess = (input, toUpperCase, {capitalizeAfterNumber}) => {\n\tconst transformNumericIdentifier = capitalizeAfterNumber\n\t\t? (match, identifier, offset, string) => {\n\t\t\tconst nextCharacter = string.charAt(offset + match.length);\n\n\t\t\t// If the numeric+identifier run is immediately followed by a separator,\n\t\t\t// treat it as a continued token and do not force a new word.\n\t\t\tif (SEPARATORS.test(nextCharacter)) {\n\t\t\t\treturn match;\n\t\t\t}\n\n\t\t\t// Only uppercase the identifier part (not the digits) for efficiency\n\t\t\treturn identifier ? match.slice(0, -identifier.length) + toUpperCase(identifier) : match;\n\t\t}\n\t\t// When false: numbers do not create a word boundary.\n\t\t: match => match;\n\n\treturn input\n\t\t.replaceAll(NUMBERS_AND_IDENTIFIER, transformNumericIdentifier)\n\t\t.replaceAll(\n\t\t\tSEPARATORS_AND_IDENTIFIER,\n\t\t\t(_, identifier) => toUpperCase(identifier),\n\t\t);\n};\n\nexport default function camelCase(input, options) {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = {\n\t\tpascalCase: false,\n\t\tpreserveConsecutiveUppercase: false,\n\t\tcapitalizeAfterNumber: true,\n\t\t...options,\n\t};\n\n\tif (Array.isArray(input)) {\n\t\tinput = input\n\t\t\t.map(element => element.trim())\n\t\t\t.filter(element => element.length > 0)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\t// Preserve leading _ and $ as they have semantic meaning\n\tconst leadingPrefix = input.match(/^[_$]*/)[0];\n\tinput = input.slice(leadingPrefix.length);\n\n\tif (input.length === 0) {\n\t\treturn leadingPrefix;\n\t}\n\n\tconst toLowerCase = options.locale === false\n\t\t? string => string.toLowerCase()\n\t\t: string => string.toLocaleLowerCase(options.locale);\n\n\tconst toUpperCase = options.locale === false\n\t\t? string => string.toUpperCase()\n\t\t: string => string.toLocaleUpperCase(options.locale);\n\n\tif (input.length === 1) {\n\t\tif (SEPARATORS.test(input)) {\n\t\t\treturn leadingPrefix;\n\t\t}\n\n\t\treturn leadingPrefix + (options.pascalCase\n\t\t\t? toUpperCase(input)\n\t\t\t: toLowerCase(input));\n\t}\n\n\tconst hasUpperCase = input !== toLowerCase(input);\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(\n\t\t\tinput,\n\t\t\ttoLowerCase,\n\t\t\ttoUpperCase,\n\t\t\toptions.preserveConsecutiveUppercase,\n\t\t);\n\t}\n\n\t// Strip leading separators eagerly so they do not affect word detection\n\tinput = input.replace(LEADING_SEPARATORS, '');\n\n\t// Normalize base casing while preserving intended consecutive uppers\n\tif (options.capitalizeAfterNumber) {\n\t\t// Standard behavior - lowercase everything (or preserve consecutive uppercase)\n\t\tinput = options.preserveConsecutiveUppercase\n\t\t\t? preserveConsecutiveUppercase(input, toLowerCase)\n\t\t\t: toLowerCase(input);\n\t} else {\n\t\t// Preserve case after numbers (processWithCasePreservation handles preserveConsecutiveUppercase internally)\n\t\tinput = processWithCasePreservation(input, toLowerCase, options.preserveConsecutiveUppercase);\n\t}\n\n\tif (options.pascalCase && input.length > 0) {\n\t\tinput = toUpperCase(input[0]) + input.slice(1);\n\t}\n\n\treturn leadingPrefix + postProcess(input, toUpperCase, options);\n}\n","import { IterableReadableStream } from \"../utils/stream.js\";\n\nexport function convertToHttpEventStream(stream: AsyncGenerator) {\n  const encoder = new TextEncoder();\n  const finalStream = new ReadableStream<Uint8Array>({\n    async start(controller) {\n      for await (const chunk of stream) {\n        controller.enqueue(\n          encoder.encode(`event: data\\ndata: ${JSON.stringify(chunk)}\\n\\n`)\n        );\n      }\n      controller.enqueue(encoder.encode(\"event: end\\n\\n\"));\n      controller.close();\n    },\n  });\n  return IterableReadableStream.fromReadableStream(finalStream);\n}\n","import { Command, Interrupt } from \"./constants.js\";\n\n// When editing, make sure to update the index found here:\n// https://langchain-ai.github.io/langgraphjs/troubleshooting/errors/\nexport type BaseLangGraphErrorFields = {\n  lc_error_code?:\n    | \"GRAPH_RECURSION_LIMIT\"\n    | \"INVALID_CONCURRENT_GRAPH_UPDATE\"\n    | \"INVALID_GRAPH_NODE_RETURN_VALUE\"\n    | \"MISSING_CHECKPOINTER\"\n    | \"MULTIPLE_SUBGRAPHS\"\n    | \"UNREACHABLE_NODE\";\n};\n\n// TODO: Merge with base LangChain error class when we drop support for core@0.2.0\n/** @category Errors */\nexport class BaseLangGraphError extends Error {\n  lc_error_code?: string;\n\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    let finalMessage = message ?? \"\";\n    if (fields?.lc_error_code) {\n      finalMessage = `${finalMessage}\\n\\nTroubleshooting URL: https://docs.langchain.com/oss/javascript/langgraph/${fields.lc_error_code}/\\n`;\n    }\n    super(finalMessage);\n    this.lc_error_code = fields?.lc_error_code;\n  }\n}\n\nexport class GraphBubbleUp extends BaseLangGraphError {\n  get is_bubble_up() {\n    return true;\n  }\n}\n\nexport class GraphRecursionError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"GraphRecursionError\";\n  }\n\n  static get unminifiable_name() {\n    return \"GraphRecursionError\";\n  }\n}\n\nexport class GraphValueError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"GraphValueError\";\n  }\n\n  static get unminifiable_name() {\n    return \"GraphValueError\";\n  }\n}\n\nexport class GraphInterrupt extends GraphBubbleUp {\n  interrupts: Interrupt[];\n\n  constructor(interrupts?: Interrupt[], fields?: BaseLangGraphErrorFields) {\n    super(JSON.stringify(interrupts, null, 2), fields);\n    this.name = \"GraphInterrupt\";\n    this.interrupts = interrupts ?? [];\n  }\n\n  static get unminifiable_name() {\n    return \"GraphInterrupt\";\n  }\n}\n\n/** Raised by a node to interrupt execution. */\nexport class NodeInterrupt extends GraphInterrupt {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(message: any, fields?: BaseLangGraphErrorFields) {\n    super([{ value: message }], fields);\n    this.name = \"NodeInterrupt\";\n  }\n\n  static get unminifiable_name() {\n    return \"NodeInterrupt\";\n  }\n}\n\nexport class ParentCommand extends GraphBubbleUp {\n  command: Command;\n\n  constructor(command: Command) {\n    super();\n    this.name = \"ParentCommand\";\n    this.command = command;\n  }\n\n  static get unminifiable_name() {\n    return \"ParentCommand\";\n  }\n}\n\nexport function isParentCommand(e?: unknown): e is ParentCommand {\n  return (\n    e !== undefined &&\n    (e as ParentCommand).name === ParentCommand.unminifiable_name\n  );\n}\n\nexport function isGraphBubbleUp(e?: unknown): e is GraphBubbleUp {\n  return e !== undefined && (e as GraphBubbleUp).is_bubble_up === true;\n}\n\nexport function isGraphInterrupt(e?: unknown): e is GraphInterrupt {\n  return (\n    e !== undefined &&\n    [\n      GraphInterrupt.unminifiable_name,\n      NodeInterrupt.unminifiable_name,\n    ].includes((e as Error).name)\n  );\n}\n\nexport class EmptyInputError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"EmptyInputError\";\n  }\n\n  static get unminifiable_name() {\n    return \"EmptyInputError\";\n  }\n}\n\nexport class EmptyChannelError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"EmptyChannelError\";\n  }\n\n  static get unminifiable_name() {\n    return \"EmptyChannelError\";\n  }\n}\n\nexport class InvalidUpdateError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"InvalidUpdateError\";\n  }\n\n  static get unminifiable_name() {\n    return \"InvalidUpdateError\";\n  }\n}\n\n/**\n * @deprecated This exception type is no longer thrown.\n */\nexport class MultipleSubgraphsError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"MultipleSubgraphError\";\n  }\n\n  static get unminifiable_name() {\n    return \"MultipleSubgraphError\";\n  }\n}\n\nexport class UnreachableNodeError extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"UnreachableNodeError\";\n  }\n\n  static get unminifiable_name() {\n    return \"UnreachableNodeError\";\n  }\n}\n\n/**\n * Exception raised when an error occurs in the remote graph.\n */\nexport class RemoteException extends BaseLangGraphError {\n  constructor(message?: string, fields?: BaseLangGraphErrorFields) {\n    super(message, fields);\n    this.name = \"RemoteException\";\n  }\n\n  static get unminifiable_name() {\n    return \"RemoteException\";\n  }\n}\n\n/**\n * Used for subgraph detection.\n */\nexport const getSubgraphsSeenSet = () => {\n  if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (globalThis as any)[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] === undefined\n  ) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (globalThis as any)[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")] = new Set();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (globalThis as any)[Symbol.for(\"LG_CHECKPOINT_SEEN_NS_SET\")];\n};\n","import { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { LangGraphRunnableConfig } from \"./pregel/runnable_types.js\";\n\nexport function writer<T>(chunk: T): void {\n  const config: LangGraphRunnableConfig | undefined =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  if (!config) {\n    throw new Error(\"Called interrupt() outside the context of a graph.\");\n  }\n\n  const conf = config.configurable;\n  if (!conf) {\n    throw new Error(\"No configurable found in config\");\n  }\n\n  return conf.writer?.(chunk);\n}\n\nexport type InferWriterType<T> = T extends typeof writer<infer C> ? C : any; // eslint-disable-line @typescript-eslint/no-explicit-any\n","import * as checks from \"./checks.js\";\nimport * as core from \"./core.js\";\nimport { Doc } from \"./doc.js\";\nimport { parse, parseAsync, safeParse, safeParseAsync } from \"./parse.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nimport { version } from \"./versions.js\";\nexport const $ZodType = /*@__PURE__*/ core.$constructor(\"$ZodType\", (inst, def) => {\n    var _a;\n    inst ?? (inst = {});\n    inst._zod.def = def; // set _def property\n    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object\n    inst._zod.version = version;\n    const checks = [...(inst._zod.def.checks ?? [])];\n    // if inst is itself a checks.$ZodCheck, run it as a check\n    if (inst._zod.traits.has(\"$ZodCheck\")) {\n        checks.unshift(inst);\n    }\n    for (const ch of checks) {\n        for (const fn of ch._zod.onattach) {\n            fn(inst);\n        }\n    }\n    if (checks.length === 0) {\n        // deferred initializer\n        // inst._zod.parse is not yet defined\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        inst._zod.deferred?.push(() => {\n            inst._zod.run = inst._zod.parse;\n        });\n    }\n    else {\n        const runChecks = (payload, checks, ctx) => {\n            let isAborted = util.aborted(payload);\n            let asyncResult;\n            for (const ch of checks) {\n                if (ch._zod.def.when) {\n                    const shouldRun = ch._zod.def.when(payload);\n                    if (!shouldRun)\n                        continue;\n                }\n                else if (isAborted) {\n                    continue;\n                }\n                const currLen = payload.issues.length;\n                const _ = ch._zod.check(payload);\n                if (_ instanceof Promise && ctx?.async === false) {\n                    throw new core.$ZodAsyncError();\n                }\n                if (asyncResult || _ instanceof Promise) {\n                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n                        await _;\n                        const nextLen = payload.issues.length;\n                        if (nextLen === currLen)\n                            return;\n                        if (!isAborted)\n                            isAborted = util.aborted(payload, currLen);\n                    });\n                }\n                else {\n                    const nextLen = payload.issues.length;\n                    if (nextLen === currLen)\n                        continue;\n                    if (!isAborted)\n                        isAborted = util.aborted(payload, currLen);\n                }\n            }\n            if (asyncResult) {\n                return asyncResult.then(() => {\n                    return payload;\n                });\n            }\n            return payload;\n        };\n        // const handleChecksResult = (\n        //   checkResult: ParsePayload,\n        //   originalResult: ParsePayload,\n        //   ctx: ParseContextInternal\n        // ): util.MaybeAsync<ParsePayload> => {\n        //   // if the checks mutated the value && there are no issues, re-parse the result\n        //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)\n        //     return inst._zod.parse(checkResult, ctx);\n        //   return originalResult;\n        // };\n        const handleCanaryResult = (canary, payload, ctx) => {\n            // abort if the canary is aborted\n            if (util.aborted(canary)) {\n                canary.aborted = true;\n                return canary;\n            }\n            // run checks first, then\n            const checkResult = runChecks(payload, checks, ctx);\n            if (checkResult instanceof Promise) {\n                if (ctx.async === false)\n                    throw new core.$ZodAsyncError();\n                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));\n            }\n            return inst._zod.parse(checkResult, ctx);\n        };\n        inst._zod.run = (payload, ctx) => {\n            if (ctx.skipChecks) {\n                return inst._zod.parse(payload, ctx);\n            }\n            if (ctx.direction === \"backward\") {\n                // run canary\n                // initial pass (no checks)\n                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });\n                if (canary instanceof Promise) {\n                    return canary.then((canary) => {\n                        return handleCanaryResult(canary, payload, ctx);\n                    });\n                }\n                return handleCanaryResult(canary, payload, ctx);\n            }\n            // forward\n            const result = inst._zod.parse(payload, ctx);\n            if (result instanceof Promise) {\n                if (ctx.async === false)\n                    throw new core.$ZodAsyncError();\n                return result.then((result) => runChecks(result, checks, ctx));\n            }\n            return runChecks(result, checks, ctx);\n        };\n    }\n    inst[\"~standard\"] = {\n        validate: (value) => {\n            try {\n                const r = safeParse(inst, value);\n                return r.success ? { value: r.data } : { issues: r.error?.issues };\n            }\n            catch (_) {\n                return safeParseAsync(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));\n            }\n        },\n        vendor: \"zod\",\n        version: 1,\n    };\n});\nexport { clone } from \"./util.js\";\nexport const $ZodString = /*@__PURE__*/ core.$constructor(\"$ZodString\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);\n    inst._zod.parse = (payload, _) => {\n        if (def.coerce)\n            try {\n                payload.value = String(payload.value);\n            }\n            catch (_) { }\n        if (typeof payload.value === \"string\")\n            return payload;\n        payload.issues.push({\n            expected: \"string\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodStringFormat\", (inst, def) => {\n    // check initialization must come first\n    checks.$ZodCheckStringFormat.init(inst, def);\n    $ZodString.init(inst, def);\n});\nexport const $ZodGUID = /*@__PURE__*/ core.$constructor(\"$ZodGUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.guid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodUUID = /*@__PURE__*/ core.$constructor(\"$ZodUUID\", (inst, def) => {\n    if (def.version) {\n        const versionMap = {\n            v1: 1,\n            v2: 2,\n            v3: 3,\n            v4: 4,\n            v5: 5,\n            v6: 6,\n            v7: 7,\n            v8: 8,\n        };\n        const v = versionMap[def.version];\n        if (v === undefined)\n            throw new Error(`Invalid UUID version: \"${def.version}\"`);\n        def.pattern ?? (def.pattern = regexes.uuid(v));\n    }\n    else\n        def.pattern ?? (def.pattern = regexes.uuid());\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodEmail = /*@__PURE__*/ core.$constructor(\"$ZodEmail\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.email);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodURL = /*@__PURE__*/ core.$constructor(\"$ZodURL\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        try {\n            // Trim whitespace from input\n            const trimmed = payload.value.trim();\n            // @ts-ignore\n            const url = new URL(trimmed);\n            if (def.hostname) {\n                def.hostname.lastIndex = 0;\n                if (!def.hostname.test(url.hostname)) {\n                    payload.issues.push({\n                        code: \"invalid_format\",\n                        format: \"url\",\n                        note: \"Invalid hostname\",\n                        pattern: def.hostname.source,\n                        input: payload.value,\n                        inst,\n                        continue: !def.abort,\n                    });\n                }\n            }\n            if (def.protocol) {\n                def.protocol.lastIndex = 0;\n                if (!def.protocol.test(url.protocol.endsWith(\":\") ? url.protocol.slice(0, -1) : url.protocol)) {\n                    payload.issues.push({\n                        code: \"invalid_format\",\n                        format: \"url\",\n                        note: \"Invalid protocol\",\n                        pattern: def.protocol.source,\n                        input: payload.value,\n                        inst,\n                        continue: !def.abort,\n                    });\n                }\n            }\n            // Set the output value based on normalize flag\n            if (def.normalize) {\n                // Use normalized URL\n                payload.value = url.href;\n            }\n            else {\n                // Preserve the original input (trimmed)\n                payload.value = trimmed;\n            }\n            return;\n        }\n        catch (_) {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"url\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodEmoji = /*@__PURE__*/ core.$constructor(\"$ZodEmoji\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.emoji());\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodNanoID = /*@__PURE__*/ core.$constructor(\"$ZodNanoID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.nanoid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID = /*@__PURE__*/ core.$constructor(\"$ZodCUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cuid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID2 = /*@__PURE__*/ core.$constructor(\"$ZodCUID2\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cuid2);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodULID = /*@__PURE__*/ core.$constructor(\"$ZodULID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ulid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodXID = /*@__PURE__*/ core.$constructor(\"$ZodXID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.xid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodKSUID = /*@__PURE__*/ core.$constructor(\"$ZodKSUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ksuid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODateTime = /*@__PURE__*/ core.$constructor(\"$ZodISODateTime\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.datetime(def));\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODate = /*@__PURE__*/ core.$constructor(\"$ZodISODate\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.date);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISOTime = /*@__PURE__*/ core.$constructor(\"$ZodISOTime\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.time(def));\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODuration = /*@__PURE__*/ core.$constructor(\"$ZodISODuration\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.duration);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodIPv4 = /*@__PURE__*/ core.$constructor(\"$ZodIPv4\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ipv4);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.format = `ipv4`;\n});\nexport const $ZodIPv6 = /*@__PURE__*/ core.$constructor(\"$ZodIPv6\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ipv6);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.format = `ipv6`;\n    inst._zod.check = (payload) => {\n        try {\n            // @ts-ignore\n            new URL(`http://[${payload.value}]`);\n            // return;\n        }\n        catch {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"ipv6\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodMAC = /*@__PURE__*/ core.$constructor(\"$ZodMAC\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.mac(def.delimiter));\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.format = `mac`;\n});\nexport const $ZodCIDRv4 = /*@__PURE__*/ core.$constructor(\"$ZodCIDRv4\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cidrv4);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCIDRv6 = /*@__PURE__*/ core.$constructor(\"$ZodCIDRv6\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cidrv6); // not used for validation\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        const parts = payload.value.split(\"/\");\n        try {\n            if (parts.length !== 2)\n                throw new Error();\n            const [address, prefix] = parts;\n            if (!prefix)\n                throw new Error();\n            const prefixNum = Number(prefix);\n            if (`${prefixNum}` !== prefix)\n                throw new Error();\n            if (prefixNum < 0 || prefixNum > 128)\n                throw new Error();\n            // @ts-ignore\n            new URL(`http://[${address}]`);\n        }\n        catch {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"cidrv6\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64(data) {\n    if (data === \"\")\n        return true;\n    if (data.length % 4 !== 0)\n        return false;\n    try {\n        // @ts-ignore\n        atob(data);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport const $ZodBase64 = /*@__PURE__*/ core.$constructor(\"$ZodBase64\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.base64);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.contentEncoding = \"base64\";\n    inst._zod.check = (payload) => {\n        if (isValidBase64(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"base64\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64URL(data) {\n    if (!regexes.base64url.test(data))\n        return false;\n    const base64 = data.replace(/[-_]/g, (c) => (c === \"-\" ? \"+\" : \"/\"));\n    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n    return isValidBase64(padded);\n}\nexport const $ZodBase64URL = /*@__PURE__*/ core.$constructor(\"$ZodBase64URL\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.base64url);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.bag.contentEncoding = \"base64url\";\n    inst._zod.check = (payload) => {\n        if (isValidBase64URL(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"base64url\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodE164 = /*@__PURE__*/ core.$constructor(\"$ZodE164\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.e164);\n    $ZodStringFormat.init(inst, def);\n});\n//////////////////////////////   ZodJWT   //////////////////////////////\nexport function isValidJWT(token, algorithm = null) {\n    try {\n        const tokensParts = token.split(\".\");\n        if (tokensParts.length !== 3)\n            return false;\n        const [header] = tokensParts;\n        if (!header)\n            return false;\n        // @ts-ignore\n        const parsedHeader = JSON.parse(atob(header));\n        if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\")\n            return false;\n        if (!parsedHeader.alg)\n            return false;\n        if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm))\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport const $ZodJWT = /*@__PURE__*/ core.$constructor(\"$ZodJWT\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        if (isValidJWT(payload.value, def.alg))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"jwt\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCustomStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodCustomStringFormat\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        if (def.fn(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: def.format,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodNumber = /*@__PURE__*/ core.$constructor(\"$ZodNumber\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = Number(payload.value);\n            }\n            catch (_) { }\n        const input = payload.value;\n        if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n            return payload;\n        }\n        const received = typeof input === \"number\"\n            ? Number.isNaN(input)\n                ? \"NaN\"\n                : !Number.isFinite(input)\n                    ? \"Infinity\"\n                    : undefined\n            : undefined;\n        payload.issues.push({\n            expected: \"number\",\n            code: \"invalid_type\",\n            input,\n            inst,\n            ...(received ? { received } : {}),\n        });\n        return payload;\n    };\n});\nexport const $ZodNumberFormat = /*@__PURE__*/ core.$constructor(\"$ZodNumberFormat\", (inst, def) => {\n    checks.$ZodCheckNumberFormat.init(inst, def);\n    $ZodNumber.init(inst, def); // no format checks\n});\nexport const $ZodBoolean = /*@__PURE__*/ core.$constructor(\"$ZodBoolean\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.boolean;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = Boolean(payload.value);\n            }\n            catch (_) { }\n        const input = payload.value;\n        if (typeof input === \"boolean\")\n            return payload;\n        payload.issues.push({\n            expected: \"boolean\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodBigInt = /*@__PURE__*/ core.$constructor(\"$ZodBigInt\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.bigint;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = BigInt(payload.value);\n            }\n            catch (_) { }\n        if (typeof payload.value === \"bigint\")\n            return payload;\n        payload.issues.push({\n            expected: \"bigint\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodBigIntFormat = /*@__PURE__*/ core.$constructor(\"$ZodBigIntFormat\", (inst, def) => {\n    checks.$ZodCheckBigIntFormat.init(inst, def);\n    $ZodBigInt.init(inst, def); // no format checks\n});\nexport const $ZodSymbol = /*@__PURE__*/ core.$constructor(\"$ZodSymbol\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"symbol\")\n            return payload;\n        payload.issues.push({\n            expected: \"symbol\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodUndefined = /*@__PURE__*/ core.$constructor(\"$ZodUndefined\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.undefined;\n    inst._zod.values = new Set([undefined]);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"undefined\")\n            return payload;\n        payload.issues.push({\n            expected: \"undefined\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodNull = /*@__PURE__*/ core.$constructor(\"$ZodNull\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.null;\n    inst._zod.values = new Set([null]);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (input === null)\n            return payload;\n        payload.issues.push({\n            expected: \"null\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodAny = /*@__PURE__*/ core.$constructor(\"$ZodAny\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload) => payload;\n});\nexport const $ZodUnknown = /*@__PURE__*/ core.$constructor(\"$ZodUnknown\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload) => payload;\n});\nexport const $ZodNever = /*@__PURE__*/ core.$constructor(\"$ZodNever\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        payload.issues.push({\n            expected: \"never\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodVoid = /*@__PURE__*/ core.$constructor(\"$ZodVoid\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"undefined\")\n            return payload;\n        payload.issues.push({\n            expected: \"void\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodDate = /*@__PURE__*/ core.$constructor(\"$ZodDate\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce) {\n            try {\n                payload.value = new Date(payload.value);\n            }\n            catch (_err) { }\n        }\n        const input = payload.value;\n        const isDate = input instanceof Date;\n        const isValidDate = isDate && !Number.isNaN(input.getTime());\n        if (isValidDate)\n            return payload;\n        payload.issues.push({\n            expected: \"date\",\n            code: \"invalid_type\",\n            input,\n            ...(isDate ? { received: \"Invalid Date\" } : {}),\n            inst,\n        });\n        return payload;\n    };\n});\nfunction handleArrayResult(result, final, index) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(index, result.issues));\n    }\n    final.value[index] = result.value;\n}\nexport const $ZodArray = /*@__PURE__*/ core.$constructor(\"$ZodArray\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!Array.isArray(input)) {\n            payload.issues.push({\n                expected: \"array\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        payload.value = Array(input.length);\n        const proms = [];\n        for (let i = 0; i < input.length; i++) {\n            const item = input[i];\n            const result = def.element._zod.run({\n                value: item,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleArrayResult(result, payload, i)));\n            }\n            else {\n                handleArrayResult(result, payload, i);\n            }\n        }\n        if (proms.length) {\n            return Promise.all(proms).then(() => payload);\n        }\n        return payload; //handleArrayResultsAsync(parseResults, final);\n    };\n});\nfunction handlePropertyResult(result, final, key, input) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(key, result.issues));\n    }\n    if (result.value === undefined) {\n        if (key in input) {\n            final.value[key] = undefined;\n        }\n    }\n    else {\n        final.value[key] = result.value;\n    }\n}\nfunction normalizeDef(def) {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n        if (!def.shape?.[k]?._zod?.traits?.has(\"$ZodType\")) {\n            throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n        }\n    }\n    const okeys = util.optionalKeys(def.shape);\n    return {\n        ...def,\n        keys,\n        keySet: new Set(keys),\n        numKeys: keys.length,\n        optionalKeys: new Set(okeys),\n    };\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n    const unrecognized = [];\n    // iterate over input keys\n    const keySet = def.keySet;\n    const _catchall = def.catchall._zod;\n    const t = _catchall.def.type;\n    for (const key in input) {\n        if (keySet.has(key))\n            continue;\n        if (t === \"never\") {\n            unrecognized.push(key);\n            continue;\n        }\n        const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n        if (r instanceof Promise) {\n            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));\n        }\n        else {\n            handlePropertyResult(r, payload, key, input);\n        }\n    }\n    if (unrecognized.length) {\n        payload.issues.push({\n            code: \"unrecognized_keys\",\n            keys: unrecognized,\n            input,\n            inst,\n        });\n    }\n    if (!proms.length)\n        return payload;\n    return Promise.all(proms).then(() => {\n        return payload;\n    });\n}\nexport const $ZodObject = /*@__PURE__*/ core.$constructor(\"$ZodObject\", (inst, def) => {\n    // requires cast because technically $ZodObject doesn't extend\n    $ZodType.init(inst, def);\n    // const sh = def.shape;\n    const desc = Object.getOwnPropertyDescriptor(def, \"shape\");\n    if (!desc?.get) {\n        const sh = def.shape;\n        Object.defineProperty(def, \"shape\", {\n            get: () => {\n                const newSh = { ...sh };\n                Object.defineProperty(def, \"shape\", {\n                    value: newSh,\n                });\n                return newSh;\n            },\n        });\n    }\n    const _normalized = util.cached(() => normalizeDef(def));\n    util.defineLazy(inst._zod, \"propValues\", () => {\n        const shape = def.shape;\n        const propValues = {};\n        for (const key in shape) {\n            const field = shape[key]._zod;\n            if (field.values) {\n                propValues[key] ?? (propValues[key] = new Set());\n                for (const v of field.values)\n                    propValues[key].add(v);\n            }\n        }\n        return propValues;\n    });\n    const isObject = util.isObject;\n    const catchall = def.catchall;\n    let value;\n    inst._zod.parse = (payload, ctx) => {\n        value ?? (value = _normalized.value);\n        const input = payload.value;\n        if (!isObject(input)) {\n            payload.issues.push({\n                expected: \"object\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        payload.value = {};\n        const proms = [];\n        const shape = value.shape;\n        for (const key of value.keys) {\n            const el = shape[key];\n            const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n            if (r instanceof Promise) {\n                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));\n            }\n            else {\n                handlePropertyResult(r, payload, key, input);\n            }\n        }\n        if (!catchall) {\n            return proms.length ? Promise.all(proms).then(() => payload) : payload;\n        }\n        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n    };\n});\nexport const $ZodObjectJIT = /*@__PURE__*/ core.$constructor(\"$ZodObjectJIT\", (inst, def) => {\n    // requires cast because technically $ZodObject doesn't extend\n    $ZodObject.init(inst, def);\n    const superParse = inst._zod.parse;\n    const _normalized = util.cached(() => normalizeDef(def));\n    const generateFastpass = (shape) => {\n        const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n        const normalized = _normalized.value;\n        const parseStr = (key) => {\n            const k = util.esc(key);\n            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n        };\n        doc.write(`const input = payload.value;`);\n        const ids = Object.create(null);\n        let counter = 0;\n        for (const key of normalized.keys) {\n            ids[key] = `key_${counter++}`;\n        }\n        // A: preserve key order {\n        doc.write(`const newResult = {};`);\n        for (const key of normalized.keys) {\n            const id = ids[key];\n            const k = util.esc(key);\n            doc.write(`const ${id} = ${parseStr(key)};`);\n            doc.write(`\n        if (${id}.issues.length) {\n          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${k}, ...iss.path] : [${k}]\n          })));\n        }\n        \n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        \n      `);\n        }\n        doc.write(`payload.value = newResult;`);\n        doc.write(`return payload;`);\n        const fn = doc.compile();\n        return (payload, ctx) => fn(shape, payload, ctx);\n    };\n    let fastpass;\n    const isObject = util.isObject;\n    const jit = !core.globalConfig.jitless;\n    const allowsEval = util.allowsEval;\n    const fastEnabled = jit && allowsEval.value; // && !def.catchall;\n    const catchall = def.catchall;\n    let value;\n    inst._zod.parse = (payload, ctx) => {\n        value ?? (value = _normalized.value);\n        const input = payload.value;\n        if (!isObject(input)) {\n            payload.issues.push({\n                expected: \"object\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n            // always synchronous\n            if (!fastpass)\n                fastpass = generateFastpass(def.shape);\n            payload = fastpass(payload, ctx);\n            if (!catchall)\n                return payload;\n            return handleCatchall([], input, payload, ctx, value, inst);\n        }\n        return superParse(payload, ctx);\n    };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n    for (const result of results) {\n        if (result.issues.length === 0) {\n            final.value = result.value;\n            return final;\n        }\n    }\n    const nonaborted = results.filter((r) => !util.aborted(r));\n    if (nonaborted.length === 1) {\n        final.value = nonaborted[0].value;\n        return nonaborted[0];\n    }\n    final.issues.push({\n        code: \"invalid_union\",\n        input: final.value,\n        inst,\n        errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n    });\n    return final;\n}\nexport const $ZodUnion = /*@__PURE__*/ core.$constructor(\"$ZodUnion\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : undefined);\n    util.defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : undefined);\n    util.defineLazy(inst._zod, \"values\", () => {\n        if (def.options.every((o) => o._zod.values)) {\n            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n        }\n        return undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        if (def.options.every((o) => o._zod.pattern)) {\n            const patterns = def.options.map((o) => o._zod.pattern);\n            return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p.source)).join(\"|\")})$`);\n        }\n        return undefined;\n    });\n    const single = def.options.length === 1;\n    const first = def.options[0]._zod.run;\n    inst._zod.parse = (payload, ctx) => {\n        if (single) {\n            return first(payload, ctx);\n        }\n        let async = false;\n        const results = [];\n        for (const option of def.options) {\n            const result = option._zod.run({\n                value: payload.value,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                results.push(result);\n                async = true;\n            }\n            else {\n                if (result.issues.length === 0)\n                    return result;\n                results.push(result);\n            }\n        }\n        if (!async)\n            return handleUnionResults(results, payload, inst, ctx);\n        return Promise.all(results).then((results) => {\n            return handleUnionResults(results, payload, inst, ctx);\n        });\n    };\n});\nexport const $ZodDiscriminatedUnion = \n/*@__PURE__*/\ncore.$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n    $ZodUnion.init(inst, def);\n    const _super = inst._zod.parse;\n    util.defineLazy(inst._zod, \"propValues\", () => {\n        const propValues = {};\n        for (const option of def.options) {\n            const pv = option._zod.propValues;\n            if (!pv || Object.keys(pv).length === 0)\n                throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n            for (const [k, v] of Object.entries(pv)) {\n                if (!propValues[k])\n                    propValues[k] = new Set();\n                for (const val of v) {\n                    propValues[k].add(val);\n                }\n            }\n        }\n        return propValues;\n    });\n    const disc = util.cached(() => {\n        const opts = def.options;\n        const map = new Map();\n        for (const o of opts) {\n            const values = o._zod.propValues?.[def.discriminator];\n            if (!values || values.size === 0)\n                throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n            for (const v of values) {\n                if (map.has(v)) {\n                    throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n                }\n                map.set(v, o);\n            }\n        }\n        return map;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!util.isObject(input)) {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: \"object\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const opt = disc.value.get(input?.[def.discriminator]);\n        if (opt) {\n            return opt._zod.run(payload, ctx);\n        }\n        if (def.unionFallback) {\n            return _super(payload, ctx);\n        }\n        // no matching discriminator\n        payload.issues.push({\n            code: \"invalid_union\",\n            errors: [],\n            note: \"No matching discriminator\",\n            discriminator: def.discriminator,\n            input,\n            path: [def.discriminator],\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodIntersection = /*@__PURE__*/ core.$constructor(\"$ZodIntersection\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n        const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n        const async = left instanceof Promise || right instanceof Promise;\n        if (async) {\n            return Promise.all([left, right]).then(([left, right]) => {\n                return handleIntersectionResults(payload, left, right);\n            });\n        }\n        return handleIntersectionResults(payload, left, right);\n    };\n});\nfunction mergeValues(a, b) {\n    // const aType = parse.t(a);\n    // const bType = parse.t(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    if (a instanceof Date && b instanceof Date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    if (util.isPlainObject(a) && util.isPlainObject(b)) {\n        const bKeys = Object.keys(b);\n        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false,\n                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return { valid: false, mergeErrorPath: [] };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false,\n                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n    if (left.issues.length) {\n        result.issues.push(...left.issues);\n    }\n    if (right.issues.length) {\n        result.issues.push(...right.issues);\n    }\n    if (util.aborted(result))\n        return result;\n    const merged = mergeValues(left.value, right.value);\n    if (!merged.valid) {\n        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n    }\n    result.value = merged.data;\n    return result;\n}\nexport const $ZodTuple = /*@__PURE__*/ core.$constructor(\"$ZodTuple\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const items = def.items;\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!Array.isArray(input)) {\n            payload.issues.push({\n                input,\n                inst,\n                expected: \"tuple\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        payload.value = [];\n        const proms = [];\n        const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== \"optional\");\n        const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;\n        if (!def.rest) {\n            const tooBig = input.length > items.length;\n            const tooSmall = input.length < optStart - 1;\n            if (tooBig || tooSmall) {\n                payload.issues.push({\n                    ...(tooBig ? { code: \"too_big\", maximum: items.length } : { code: \"too_small\", minimum: items.length }),\n                    input,\n                    inst,\n                    origin: \"array\",\n                });\n                return payload;\n            }\n        }\n        let i = -1;\n        for (const item of items) {\n            i++;\n            if (i >= input.length)\n                if (i >= optStart)\n                    continue;\n            const result = item._zod.run({\n                value: input[i],\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n            }\n            else {\n                handleTupleResult(result, payload, i);\n            }\n        }\n        if (def.rest) {\n            const rest = input.slice(items.length);\n            for (const el of rest) {\n                i++;\n                const result = def.rest._zod.run({\n                    value: el,\n                    issues: [],\n                }, ctx);\n                if (result instanceof Promise) {\n                    proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n                }\n                else {\n                    handleTupleResult(result, payload, i);\n                }\n            }\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleTupleResult(result, final, index) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(index, result.issues));\n    }\n    final.value[index] = result.value;\n}\nexport const $ZodRecord = /*@__PURE__*/ core.$constructor(\"$ZodRecord\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!util.isPlainObject(input)) {\n            payload.issues.push({\n                expected: \"record\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const proms = [];\n        const values = def.keyType._zod.values;\n        if (values) {\n            payload.value = {};\n            const recordKeys = new Set();\n            for (const key of values) {\n                if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n                    recordKeys.add(typeof key === \"number\" ? key.toString() : key);\n                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n                    if (result instanceof Promise) {\n                        proms.push(result.then((result) => {\n                            if (result.issues.length) {\n                                payload.issues.push(...util.prefixIssues(key, result.issues));\n                            }\n                            payload.value[key] = result.value;\n                        }));\n                    }\n                    else {\n                        if (result.issues.length) {\n                            payload.issues.push(...util.prefixIssues(key, result.issues));\n                        }\n                        payload.value[key] = result.value;\n                    }\n                }\n            }\n            let unrecognized;\n            for (const key in input) {\n                if (!recordKeys.has(key)) {\n                    unrecognized = unrecognized ?? [];\n                    unrecognized.push(key);\n                }\n            }\n            if (unrecognized && unrecognized.length > 0) {\n                payload.issues.push({\n                    code: \"unrecognized_keys\",\n                    input,\n                    inst,\n                    keys: unrecognized,\n                });\n            }\n        }\n        else {\n            payload.value = {};\n            for (const key of Reflect.ownKeys(input)) {\n                if (key === \"__proto__\")\n                    continue;\n                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n                if (keyResult instanceof Promise) {\n                    throw new Error(\"Async schemas not supported in object keys currently\");\n                }\n                if (keyResult.issues.length) {\n                    payload.issues.push({\n                        code: \"invalid_key\",\n                        origin: \"record\",\n                        issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                        input: key,\n                        path: [key],\n                        inst,\n                    });\n                    payload.value[keyResult.value] = keyResult.value;\n                    continue;\n                }\n                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n                if (result instanceof Promise) {\n                    proms.push(result.then((result) => {\n                        if (result.issues.length) {\n                            payload.issues.push(...util.prefixIssues(key, result.issues));\n                        }\n                        payload.value[keyResult.value] = result.value;\n                    }));\n                }\n                else {\n                    if (result.issues.length) {\n                        payload.issues.push(...util.prefixIssues(key, result.issues));\n                    }\n                    payload.value[keyResult.value] = result.value;\n                }\n            }\n        }\n        if (proms.length) {\n            return Promise.all(proms).then(() => payload);\n        }\n        return payload;\n    };\n});\nexport const $ZodMap = /*@__PURE__*/ core.$constructor(\"$ZodMap\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!(input instanceof Map)) {\n            payload.issues.push({\n                expected: \"map\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const proms = [];\n        payload.value = new Map();\n        for (const [key, value] of input) {\n            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n            const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);\n            if (keyResult instanceof Promise || valueResult instanceof Promise) {\n                proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {\n                    handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n                }));\n            }\n            else {\n                handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n            }\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n    if (keyResult.issues.length) {\n        if (util.propertyKeyTypes.has(typeof key)) {\n            final.issues.push(...util.prefixIssues(key, keyResult.issues));\n        }\n        else {\n            final.issues.push({\n                code: \"invalid_key\",\n                origin: \"map\",\n                input,\n                inst,\n                issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            });\n        }\n    }\n    if (valueResult.issues.length) {\n        if (util.propertyKeyTypes.has(typeof key)) {\n            final.issues.push(...util.prefixIssues(key, valueResult.issues));\n        }\n        else {\n            final.issues.push({\n                origin: \"map\",\n                code: \"invalid_element\",\n                input,\n                inst,\n                key: key,\n                issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            });\n        }\n    }\n    final.value.set(keyResult.value, valueResult.value);\n}\nexport const $ZodSet = /*@__PURE__*/ core.$constructor(\"$ZodSet\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!(input instanceof Set)) {\n            payload.issues.push({\n                input,\n                inst,\n                expected: \"set\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        const proms = [];\n        payload.value = new Set();\n        for (const item of input) {\n            const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleSetResult(result, payload)));\n            }\n            else\n                handleSetResult(result, payload);\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleSetResult(result, final) {\n    if (result.issues.length) {\n        final.issues.push(...result.issues);\n    }\n    final.value.add(result.value);\n}\nexport const $ZodEnum = /*@__PURE__*/ core.$constructor(\"$ZodEnum\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const values = util.getEnumValues(def.entries);\n    const valuesSet = new Set(values);\n    inst._zod.values = valuesSet;\n    inst._zod.pattern = new RegExp(`^(${values\n        .filter((k) => util.propertyKeyTypes.has(typeof k))\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o.toString()))\n        .join(\"|\")})$`);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (valuesSet.has(input)) {\n            return payload;\n        }\n        payload.issues.push({\n            code: \"invalid_value\",\n            values,\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodLiteral = /*@__PURE__*/ core.$constructor(\"$ZodLiteral\", (inst, def) => {\n    $ZodType.init(inst, def);\n    if (def.values.length === 0) {\n        throw new Error(\"Cannot create literal schema with no valid values\");\n    }\n    const values = new Set(def.values);\n    inst._zod.values = values;\n    inst._zod.pattern = new RegExp(`^(${def.values\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o ? util.escapeRegex(o.toString()) : String(o)))\n        .join(\"|\")})$`);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (values.has(input)) {\n            return payload;\n        }\n        payload.issues.push({\n            code: \"invalid_value\",\n            values: def.values,\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodFile = /*@__PURE__*/ core.$constructor(\"$ZodFile\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        // @ts-ignore\n        if (input instanceof File)\n            return payload;\n        payload.issues.push({\n            expected: \"file\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodTransform = /*@__PURE__*/ core.$constructor(\"$ZodTransform\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(inst.constructor.name);\n        }\n        const _out = def.transform(payload.value, payload);\n        if (ctx.async) {\n            const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n            return output.then((output) => {\n                payload.value = output;\n                return payload;\n            });\n        }\n        if (_out instanceof Promise) {\n            throw new core.$ZodAsyncError();\n        }\n        payload.value = _out;\n        return payload;\n    };\n});\nfunction handleOptionalResult(result, input) {\n    if (result.issues.length && input === undefined) {\n        return { issues: [], value: undefined };\n    }\n    return result;\n}\nexport const $ZodOptional = /*@__PURE__*/ core.$constructor(\"$ZodOptional\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => {\n        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        const pattern = def.innerType._zod.pattern;\n        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        if (def.innerType._zod.optin === \"optional\") {\n            const result = def.innerType._zod.run(payload, ctx);\n            if (result instanceof Promise)\n                return result.then((r) => handleOptionalResult(r, payload.value));\n            return handleOptionalResult(result, payload.value);\n        }\n        if (payload.value === undefined) {\n            return payload;\n        }\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodNullable = /*@__PURE__*/ core.$constructor(\"$ZodNullable\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        const pattern = def.innerType._zod.pattern;\n        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;\n    });\n    util.defineLazy(inst._zod, \"values\", () => {\n        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        // Forward direction (decode): allow null to pass through\n        if (payload.value === null)\n            return payload;\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodDefault = /*@__PURE__*/ core.$constructor(\"$ZodDefault\", (inst, def) => {\n    $ZodType.init(inst, def);\n    // inst._zod.qin = \"true\";\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply defaults for undefined input\n        if (payload.value === undefined) {\n            payload.value = def.defaultValue;\n            /**\n             * $ZodDefault returns the default value immediately in forward direction.\n             * It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n            return payload;\n        }\n        // Forward direction: continue with default handling\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => handleDefaultResult(result, def));\n        }\n        return handleDefaultResult(result, def);\n    };\n});\nfunction handleDefaultResult(payload, def) {\n    if (payload.value === undefined) {\n        payload.value = def.defaultValue;\n    }\n    return payload;\n}\nexport const $ZodPrefault = /*@__PURE__*/ core.$constructor(\"$ZodPrefault\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply prefault for undefined input\n        if (payload.value === undefined) {\n            payload.value = def.defaultValue;\n        }\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodNonOptional = /*@__PURE__*/ core.$constructor(\"$ZodNonOptional\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => {\n        const v = def.innerType._zod.values;\n        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => handleNonOptionalResult(result, inst));\n        }\n        return handleNonOptionalResult(result, inst);\n    };\n});\nfunction handleNonOptionalResult(payload, inst) {\n    if (!payload.issues.length && payload.value === undefined) {\n        payload.issues.push({\n            code: \"invalid_type\",\n            expected: \"nonoptional\",\n            input: payload.value,\n            inst,\n        });\n    }\n    return payload;\n}\nexport const $ZodSuccess = /*@__PURE__*/ core.$constructor(\"$ZodSuccess\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(\"ZodSuccess\");\n        }\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => {\n                payload.value = result.issues.length === 0;\n                return payload;\n            });\n        }\n        payload.value = result.issues.length === 0;\n        return payload;\n    };\n});\nexport const $ZodCatch = /*@__PURE__*/ core.$constructor(\"$ZodCatch\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply catch logic\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => {\n                payload.value = result.value;\n                if (result.issues.length) {\n                    payload.value = def.catchValue({\n                        ...payload,\n                        error: {\n                            issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                        },\n                        input: payload.value,\n                    });\n                    payload.issues = [];\n                }\n                return payload;\n            });\n        }\n        payload.value = result.value;\n        if (result.issues.length) {\n            payload.value = def.catchValue({\n                ...payload,\n                error: {\n                    issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                },\n                input: payload.value,\n            });\n            payload.issues = [];\n        }\n        return payload;\n    };\n});\nexport const $ZodNaN = /*@__PURE__*/ core.$constructor(\"$ZodNaN\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                expected: \"nan\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        return payload;\n    };\n});\nexport const $ZodPipe = /*@__PURE__*/ core.$constructor(\"$ZodPipe\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n    util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            const right = def.out._zod.run(payload, ctx);\n            if (right instanceof Promise) {\n                return right.then((right) => handlePipeResult(right, def.in, ctx));\n            }\n            return handlePipeResult(right, def.in, ctx);\n        }\n        const left = def.in._zod.run(payload, ctx);\n        if (left instanceof Promise) {\n            return left.then((left) => handlePipeResult(left, def.out, ctx));\n        }\n        return handlePipeResult(left, def.out, ctx);\n    };\n});\nfunction handlePipeResult(left, next, ctx) {\n    if (left.issues.length) {\n        // prevent further checks\n        left.aborted = true;\n        return left;\n    }\n    return next._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nexport const $ZodCodec = /*@__PURE__*/ core.$constructor(\"$ZodCodec\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n    util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n    inst._zod.parse = (payload, ctx) => {\n        const direction = ctx.direction || \"forward\";\n        if (direction === \"forward\") {\n            const left = def.in._zod.run(payload, ctx);\n            if (left instanceof Promise) {\n                return left.then((left) => handleCodecAResult(left, def, ctx));\n            }\n            return handleCodecAResult(left, def, ctx);\n        }\n        else {\n            const right = def.out._zod.run(payload, ctx);\n            if (right instanceof Promise) {\n                return right.then((right) => handleCodecAResult(right, def, ctx));\n            }\n            return handleCodecAResult(right, def, ctx);\n        }\n    };\n});\nfunction handleCodecAResult(result, def, ctx) {\n    if (result.issues.length) {\n        // prevent further checks\n        result.aborted = true;\n        return result;\n    }\n    const direction = ctx.direction || \"forward\";\n    if (direction === \"forward\") {\n        const transformed = def.transform(result.value, result);\n        if (transformed instanceof Promise) {\n            return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));\n        }\n        return handleCodecTxResult(result, transformed, def.out, ctx);\n    }\n    else {\n        const transformed = def.reverseTransform(result.value, result);\n        if (transformed instanceof Promise) {\n            return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));\n        }\n        return handleCodecTxResult(result, transformed, def.in, ctx);\n    }\n}\nfunction handleCodecTxResult(left, value, nextSchema, ctx) {\n    // Check if transform added any issues\n    if (left.issues.length) {\n        left.aborted = true;\n        return left;\n    }\n    return nextSchema._zod.run({ value, issues: left.issues }, ctx);\n}\nexport const $ZodReadonly = /*@__PURE__*/ core.$constructor(\"$ZodReadonly\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType?._zod?.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType?._zod?.optout);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then(handleReadonlyResult);\n        }\n        return handleReadonlyResult(result);\n    };\n});\nfunction handleReadonlyResult(payload) {\n    payload.value = Object.freeze(payload.value);\n    return payload;\n}\nexport const $ZodTemplateLiteral = /*@__PURE__*/ core.$constructor(\"$ZodTemplateLiteral\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const regexParts = [];\n    for (const part of def.parts) {\n        if (typeof part === \"object\" && part !== null) {\n            // is Zod schema\n            if (!part._zod.pattern) {\n                // if (!source)\n                throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n            }\n            const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n            if (!source)\n                throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n            const start = source.startsWith(\"^\") ? 1 : 0;\n            const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n            regexParts.push(source.slice(start, end));\n        }\n        else if (part === null || util.primitiveTypes.has(typeof part)) {\n            regexParts.push(util.escapeRegex(`${part}`));\n        }\n        else {\n            throw new Error(`Invalid template literal part: ${part}`);\n        }\n    }\n    inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"string\") {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                expected: \"template_literal\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        inst._zod.pattern.lastIndex = 0;\n        if (!inst._zod.pattern.test(payload.value)) {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                code: \"invalid_format\",\n                format: def.format ?? \"template_literal\",\n                pattern: inst._zod.pattern.source,\n            });\n            return payload;\n        }\n        return payload;\n    };\n});\nexport const $ZodFunction = /*@__PURE__*/ core.$constructor(\"$ZodFunction\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._def = def;\n    inst._zod.def = def;\n    inst.implement = (func) => {\n        if (typeof func !== \"function\") {\n            throw new Error(\"implement() must be called with a function\");\n        }\n        return function (...args) {\n            const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;\n            const result = Reflect.apply(func, this, parsedArgs);\n            if (inst._def.output) {\n                return parse(inst._def.output, result);\n            }\n            return result;\n        };\n    };\n    inst.implementAsync = (func) => {\n        if (typeof func !== \"function\") {\n            throw new Error(\"implementAsync() must be called with a function\");\n        }\n        return async function (...args) {\n            const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;\n            const result = await Reflect.apply(func, this, parsedArgs);\n            if (inst._def.output) {\n                return await parseAsync(inst._def.output, result);\n            }\n            return result;\n        };\n    };\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"function\") {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: \"function\",\n                input: payload.value,\n                inst,\n            });\n            return payload;\n        }\n        // Check if output is a promise type to determine if we should use async implementation\n        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === \"promise\";\n        if (hasPromiseOutput) {\n            payload.value = inst.implementAsync(payload.value);\n        }\n        else {\n            payload.value = inst.implement(payload.value);\n        }\n        return payload;\n    };\n    inst.input = (...args) => {\n        const F = inst.constructor;\n        if (Array.isArray(args[0])) {\n            return new F({\n                type: \"function\",\n                input: new $ZodTuple({\n                    type: \"tuple\",\n                    items: args[0],\n                    rest: args[1],\n                }),\n                output: inst._def.output,\n            });\n        }\n        return new F({\n            type: \"function\",\n            input: args[0],\n            output: inst._def.output,\n        });\n    };\n    inst.output = (output) => {\n        const F = inst.constructor;\n        return new F({\n            type: \"function\",\n            input: inst._def.input,\n            output,\n        });\n    };\n    return inst;\n});\nexport const $ZodPromise = /*@__PURE__*/ core.$constructor(\"$ZodPromise\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));\n    };\n});\nexport const $ZodLazy = /*@__PURE__*/ core.$constructor(\"$ZodLazy\", (inst, def) => {\n    $ZodType.init(inst, def);\n    // let _innerType!: any;\n    // util.defineLazy(def, \"getter\", () => {\n    //   if (!_innerType) {\n    //     _innerType = def.getter();\n    //   }\n    //   return () => _innerType;\n    // });\n    util.defineLazy(inst._zod, \"innerType\", () => def.getter());\n    util.defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType?._zod?.pattern);\n    util.defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType?._zod?.propValues);\n    util.defineLazy(inst._zod, \"optin\", () => inst._zod.innerType?._zod?.optin ?? undefined);\n    util.defineLazy(inst._zod, \"optout\", () => inst._zod.innerType?._zod?.optout ?? undefined);\n    inst._zod.parse = (payload, ctx) => {\n        const inner = inst._zod.innerType;\n        return inner._zod.run(payload, ctx);\n    };\n});\nexport const $ZodCustom = /*@__PURE__*/ core.$constructor(\"$ZodCustom\", (inst, def) => {\n    checks.$ZodCheck.init(inst, def);\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _) => {\n        return payload;\n    };\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const r = def.fn(input);\n        if (r instanceof Promise) {\n            return r.then((r) => handleRefineResult(r, payload, input, inst));\n        }\n        handleRefineResult(r, payload, input, inst);\n        return;\n    };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n    if (!result) {\n        const _iss = {\n            code: \"custom\",\n            input,\n            inst, // incorporates params.error into issue reporting\n            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting\n            continue: !inst._zod.def.abort,\n            // params: inst._zod.def.params,\n        };\n        if (inst._zod.def.params)\n            _iss.params = inst._zod.def.params;\n        payload.issues.push(util.issue(_iss));\n    }\n}\n","import { ZodTupleDef, ZodTupleItems, ZodTypeAny } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\n\nexport type JsonSchema7TupleType = {\n  type: \"array\";\n  minItems: number;\n  items: JsonSchema7Type[];\n} & (\n  | {\n      maxItems: number;\n    }\n  | {\n      additionalItems?: JsonSchema7Type;\n    }\n);\n\nexport function parseTupleDef(\n  def: ZodTupleDef<ZodTupleItems | [], ZodTypeAny | null>,\n  refs: Refs\n): JsonSchema7TupleType {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\", `${i}`],\n          })\n        )\n        .reduce(\n          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),\n          []\n        ),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"],\n      }),\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items\n        .map((x, i) =>\n          parseDef(x._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"items\", `${i}`],\n          })\n        )\n        .reduce(\n          (acc: JsonSchema7Type[], x) => (x === undefined ? acc : [...acc, x]),\n          []\n        ),\n    };\n  }\n}\n","import { ZodSchema } from \"zod/v3\";\nimport { Options, Targets } from \"./Options.js\";\nimport { parseDef } from \"./parseDef.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\nimport { getRefs } from \"./Refs.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\n\nconst zodToJsonSchema = <Target extends Targets = \"jsonSchema7\">(\n  schema: ZodSchema<any>,\n  options?: Partial<Options<Target>> | string\n): (Target extends \"jsonSchema7\" ? JsonSchema7Type : object) & {\n  $schema?: string;\n  definitions?: {\n    [key: string]: Target extends \"jsonSchema7\"\n      ? JsonSchema7Type\n      : Target extends \"jsonSchema2019-09\"\n      ? JsonSchema7Type\n      : object;\n  };\n} => {\n  const refs = getRefs(options);\n\n  let definitions =\n    typeof options === \"object\" && options.definitions\n      ? Object.entries(options.definitions).reduce(\n          (acc: { [key: string]: JsonSchema7Type }, [name, schema]) => ({\n            ...acc,\n            [name]:\n              parseDef(\n                schema._def,\n                {\n                  ...refs,\n                  currentPath: [...refs.basePath, refs.definitionPath, name],\n                },\n                true\n              ) ?? parseAnyDef(refs),\n          }),\n          {}\n        )\n      : undefined;\n\n  const name =\n    typeof options === \"string\"\n      ? options\n      : options?.nameStrategy === \"title\"\n      ? undefined\n      : options?.name;\n\n  const main =\n    parseDef(\n      schema._def,\n      name === undefined\n        ? refs\n        : {\n            ...refs,\n            currentPath: [...refs.basePath, refs.definitionPath, name],\n          },\n      false\n    ) ?? (parseAnyDef(refs) as JsonSchema7Type);\n\n  const title =\n    typeof options === \"object\" &&\n    options.name !== undefined &&\n    options.nameStrategy === \"title\"\n      ? options.name\n      : undefined;\n\n  if (title !== undefined) {\n    main.title = title;\n  }\n\n  if (refs.flags.hasReferencedOpenAiAnyType) {\n    if (!definitions) {\n      definitions = {};\n    }\n\n    if (!definitions[refs.openAiAnyTypeName]) {\n      definitions[refs.openAiAnyTypeName] = {\n        // Skipping \"object\" as no properties can be defined and additionalProperties must be \"false\"\n        type: [\"string\", \"number\", \"integer\", \"boolean\", \"array\", \"null\"],\n        items: {\n          $ref:\n            refs.$refStrategy === \"relative\"\n              ? \"1\"\n              : [\n                  ...refs.basePath,\n                  refs.definitionPath,\n                  refs.openAiAnyTypeName,\n                ].join(\"/\"),\n        },\n      } as JsonSchema7Type;\n    }\n  }\n\n  const combined: ReturnType<typeof zodToJsonSchema<Target>> =\n    name === undefined\n      ? definitions\n        ? {\n            ...main,\n            [refs.definitionPath]: definitions,\n          }\n        : main\n      : {\n          $ref: [\n            ...(refs.$refStrategy === \"relative\" ? [] : refs.basePath),\n            refs.definitionPath,\n            name,\n          ].join(\"/\"),\n          [refs.definitionPath]: {\n            ...definitions,\n            [name]: main,\n          },\n        };\n\n  if (refs.target === \"jsonSchema7\") {\n    combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  } else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n    combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n  }\n\n  if (\n    refs.target === \"openAi\" &&\n    (\"anyOf\" in combined ||\n      \"oneOf\" in combined ||\n      \"allOf\" in combined ||\n      (\"type\" in combined && Array.isArray(combined.type)))\n  ) {\n    console.warn(\n      \"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\"\n    );\n  }\n\n  return combined;\n};\n\nexport { zodToJsonSchema };\n","import { ZodNativeEnumDef } from \"zod/v3\";\n\nexport type JsonSchema7NativeEnumType = {\n  type: \"string\" | \"number\" | [\"string\", \"number\"];\n  enum: (string | number)[];\n};\n\nexport function parseNativeEnumDef(\n  def: ZodNativeEnumDef\n): JsonSchema7NativeEnumType {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key: string) => {\n    return typeof object[object[key]] !== \"number\";\n  });\n\n  const actualValues = actualKeys.map((key: string) => object[key]);\n\n  const parsedTypes = Array.from(\n    new Set(actualValues.map((values: string | number) => typeof values))\n  );\n\n  return {\n    type:\n      parsedTypes.length === 1\n        ? parsedTypes[0] === \"string\"\n          ? \"string\"\n          : \"number\"\n        : [\"string\", \"number\"],\n    enum: actualValues,\n  };\n}\n","import { BaseOutputParser } from \"../../output_parsers/base.js\";\n\n/**\n * Parser for comma-separated values. It splits the input text by commas\n * and trims the resulting values.\n */\nexport class FakeSplitIntoListParser extends BaseOutputParser<string[]> {\n  lc_namespace = [\"tests\", \"fake\"];\n\n  getFormatInstructions() {\n    return \"\";\n  }\n\n  async parse(text: string): Promise<string[]> {\n    return text.split(\",\").map((value) => value.trim());\n  }\n}\n","import { v5, v6 } from \"uuid\";\n\nexport function uuid6(clockseq: number): string {\n  return v6({ clockseq });\n}\n\n// Skip UUID validation check, since UUID6s\n// generated with negative clockseq are not\n// technically compliant, but still work.\n// See: https://github.com/uuidjs/uuid/issues/511\nexport function uuid5(name: string, namespace: string): string {\n  const namespaceBytes = namespace\n    .replace(/-/g, \"\")\n    .match(/.{2}/g)!\n    .map((byte) => parseInt(byte, 16));\n  return v5(name, new Uint8Array(namespaceBytes));\n}\n","import { ZodArrayDef, ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\n\nexport type JsonSchema7ArrayType = {\n  type: \"array\";\n  items?: JsonSchema7Type;\n  minItems?: number;\n  maxItems?: number;\n  errorMessages?: ErrorMessages<JsonSchema7ArrayType, \"items\">;\n};\n\nexport function parseArrayDef(def: ZodArrayDef, refs: Refs) {\n  const res: JsonSchema7ArrayType = {\n    type: \"array\",\n  };\n  if (\n    def.type?._def &&\n    def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny\n  ) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"],\n    });\n  }\n\n  if (def.minLength) {\n    setResponseValueAndErrors(\n      res,\n      \"minItems\",\n      def.minLength.value,\n      def.minLength.message,\n      refs\n    );\n  }\n  if (def.maxLength) {\n    setResponseValueAndErrors(\n      res,\n      \"maxItems\",\n      def.maxLength.value,\n      def.maxLength.message,\n      refs\n    );\n  }\n  if (def.exactLength) {\n    setResponseValueAndErrors(\n      res,\n      \"minItems\",\n      def.exactLength.value,\n      def.exactLength.message,\n      refs\n    );\n    setResponseValueAndErrors(\n      res,\n      \"maxItems\",\n      def.exactLength.value,\n      def.exactLength.message,\n      refs\n    );\n  }\n  return res;\n}\n","import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { RunnableConfig } from \"./types.js\";\n\nexport const DEFAULT_RECURSION_LIMIT = 25;\n\nexport { type RunnableConfig };\n\nexport async function getCallbackManagerForConfig(config?: RunnableConfig) {\n  return CallbackManager._configureSync(\n    config?.callbacks,\n    undefined,\n    config?.tags,\n    undefined,\n    config?.metadata\n  );\n}\n\nexport function mergeConfigs<CallOptions extends RunnableConfig>(\n  ...configs: (CallOptions | RunnableConfig | undefined | null)[]\n): Partial<CallOptions> {\n  // We do not want to call ensureConfig on the empty state here as this may cause\n  // double loading of callbacks if async local storage is being used.\n  const copy: Partial<CallOptions> = {};\n  for (const options of configs.filter((c): c is CallOptions => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"tags\") {\n        const baseKeys: string[] = copy[key] ?? [];\n        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = { ...copy[key], ...options[key] };\n      } else if (key === \"timeout\") {\n        if (copy.timeout === undefined) {\n          copy.timeout = options.timeout;\n        } else if (options.timeout !== undefined) {\n          copy.timeout = Math.min(copy.timeout, options.timeout);\n        }\n      } else if (key === \"signal\") {\n        if (copy.signal === undefined) {\n          copy.signal = options.signal;\n        } else if (options.signal !== undefined) {\n          if (\"any\" in AbortSignal) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            copy.signal = (AbortSignal as any).any([\n              copy.signal,\n              options.signal,\n            ]);\n          } else {\n            copy.signal = options.signal;\n          }\n        }\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(\n              providedCallbacks._parentRunId,\n              {\n                handlers: baseCallbacks.handlers.concat(\n                  providedCallbacks.handlers\n                ),\n                inheritableHandlers: baseCallbacks.inheritableHandlers.concat(\n                  providedCallbacks.inheritableHandlers\n                ),\n                tags: Array.from(\n                  new Set(baseCallbacks.tags.concat(providedCallbacks.tags))\n                ),\n                inheritableTags: Array.from(\n                  new Set(\n                    baseCallbacks.inheritableTags.concat(\n                      providedCallbacks.inheritableTags\n                    )\n                  )\n                ),\n                metadata: {\n                  ...baseCallbacks.metadata,\n                  ...providedCallbacks.metadata,\n                },\n              }\n            );\n          }\n        }\n      } else {\n        const typedKey = key as keyof CallOptions;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy as Partial<CallOptions>;\n}\n\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig<CallOptions extends RunnableConfig>(\n  config?: CallOptions\n): CallOptions {\n  const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  let empty: RunnableConfig = {\n    tags: [],\n    metadata: {},\n    recursionLimit: 25,\n    runId: undefined,\n  };\n  if (implicitConfig) {\n    // Don't allow runId and runName to be loaded implicitly, as this can cause\n    // child runs to improperly inherit their parents' run ids.\n    const { runId, runName, ...rest } = implicitConfig;\n    empty = Object.entries(rest).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (config) {\n    empty = Object.entries(config).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (currentConfig: Record<string, any>, [key, value]) => {\n        if (value !== undefined) {\n          currentConfig[key] = value;\n        }\n        return currentConfig;\n      },\n      empty\n    );\n  }\n  if (empty?.configurable) {\n    for (const key of Object.keys(empty.configurable)) {\n      if (\n        PRIMITIVES.has(typeof empty.configurable[key]) &&\n        !empty.metadata?.[key]\n      ) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = empty.configurable[key];\n      }\n    }\n  }\n  if (empty.timeout !== undefined) {\n    if (empty.timeout <= 0) {\n      throw new Error(\"Timeout must be a positive number\");\n    }\n    const timeoutSignal = AbortSignal.timeout(empty.timeout);\n    if (empty.signal !== undefined) {\n      if (\"any\" in AbortSignal) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        empty.signal = (AbortSignal as any).any([empty.signal, timeoutSignal]);\n      }\n    } else {\n      empty.signal = timeoutSignal;\n    }\n    delete empty.timeout;\n  }\n  return empty as CallOptions;\n}\n\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig<CallOptions extends RunnableConfig>(\n  config: Partial<CallOptions> = {},\n  {\n    callbacks,\n    maxConcurrency,\n    recursionLimit,\n    runName,\n    configurable,\n    runId,\n  }: RunnableConfig = {}\n): Partial<CallOptions> {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = { ...newConfig.configurable, ...configurable };\n  }\n  if (runId !== undefined) {\n    delete newConfig.runId;\n  }\n  return newConfig;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function pickRunnableConfigKeys<CallOptions extends Record<string, any>>(\n  config?: CallOptions\n): Partial<RunnableConfig> | undefined {\n  if (!config) return undefined;\n\n  return {\n    configurable: config.configurable,\n    recursionLimit: config.recursionLimit,\n    callbacks: config.callbacks,\n    tags: config.tags,\n    metadata: config.metadata,\n    maxConcurrency: config.maxConcurrency,\n    timeout: config.timeout,\n    signal: config.signal,\n    // @ts-expect-error - Store is a LangGraph-specific property\n    // which wewant to pass through to all runnables.\n    // (eg. tools should have access to writing to the store)\n    store: config.store,\n  };\n}\n","import { Client } from \"langsmith\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\nlet client: Client;\n\nexport const getDefaultLangChainClientSingleton = () => {\n  if (client === undefined) {\n    const clientParams =\n      getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\"\n        ? {\n            // LangSmith has its own backgrounding system\n            blockOnRootRunFinalization: true,\n          }\n        : {};\n    client = new Client(clientParams);\n  }\n  return client;\n};\n\nexport const setDefaultLangChainClientSingleton = (newClient: Client) => {\n  client = newClient;\n};\n","import mustache from \"mustache\";\nimport { MessageContent } from \"../messages/index.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\nfunction configureMustache() {\n  // Use unescaped HTML\n  // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n  mustache.escape = (text) => text;\n}\n\n/**\n * Type that specifies the format of a template.\n */\nexport type TemplateFormat = \"f-string\" | \"mustache\";\n\n/**\n * Type that represents a node in a parsed format string. It can be either\n * a literal text or a variable name.\n */\nexport type ParsedTemplateNode =\n  | { type: \"literal\"; text: string }\n  | { type: \"variable\"; name: string };\n\n/**\n * Alias for `ParsedTemplateNode` since it is the same for\n * both f-string and mustache templates.\n */\nexport type ParsedFStringNode = ParsedTemplateNode;\n\nexport const parseFString = (template: string): ParsedTemplateNode[] => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes: ParsedTemplateNode[] = [];\n\n  const nextBracket = (bracket: \"}\" | \"{\" | \"{}\", start: number) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({ type: \"literal\", text: \"{\" });\n      i += 2;\n    } else if (\n      chars[i] === \"}\" &&\n      i + 1 < chars.length &&\n      chars[i + 1] === \"}\"\n    ) {\n      nodes.push({ type: \"literal\", text: \"}\" });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\"),\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({ type: \"literal\", text });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\n\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @param {string[]} context Array of section variable names for nested context\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (\n  template: mustache.TemplateSpans,\n  context: string[] = []\n): ParsedTemplateNode[] => {\n  const nodes: ParsedTemplateNode[] = [];\n\n  for (const temp of template) {\n    if (temp[0] === \"name\") {\n      const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n      nodes.push({ type: \"variable\", name });\n    } else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n      // # represents a section, \"&\" represents an unescaped variable.\n      // These should both be considered variables.\n      nodes.push({ type: \"variable\", name: temp[1] });\n\n      // If this is a section with nested content, recursively process it\n      if (temp[0] === \"#\" && temp.length > 4 && Array.isArray(temp[4])) {\n        const newContext = [...context, temp[1]];\n        const nestedNodes = mustacheTemplateToNodes(temp[4], newContext);\n        nodes.push(...nestedNodes);\n      }\n    } else {\n      nodes.push({ type: \"literal\", text: temp[1] });\n    }\n  }\n\n  return nodes;\n};\n\nexport const parseMustache = (template: string) => {\n  configureMustache();\n  const parsed = mustache.parse(template);\n  return mustacheTemplateToNodes(parsed);\n};\n\nexport const interpolateFString = (template: string, values: InputValues) => {\n  return parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n      if (node.name in values) {\n        const stringValue =\n          typeof values[node.name] === \"string\"\n            ? values[node.name]\n            : JSON.stringify(values[node.name]);\n        return res + stringValue;\n      }\n      throw new Error(`(f-string) Missing value for input ${node.name}`);\n    }\n\n    return res + node.text;\n  }, \"\");\n};\n\nexport const interpolateMustache = (template: string, values: InputValues) => {\n  configureMustache();\n  return mustache.render(template, values);\n};\n\n/**\n * Type that represents a function that takes a template string and a set\n * of input values, and returns a string where all variables in the\n * template have been replaced with their corresponding values.\n */\ntype Interpolator = (template: string, values: InputValues) => string;\n\n/**\n * Type that represents a function that takes a template string and\n * returns an array of `ParsedTemplateNode`.\n */\ntype Parser = (template: string) => ParsedTemplateNode[];\n\nexport const DEFAULT_FORMATTER_MAPPING: Record<TemplateFormat, Interpolator> = {\n  \"f-string\": interpolateFString,\n  mustache: interpolateMustache,\n};\n\nexport const DEFAULT_PARSER_MAPPING: Record<TemplateFormat, Parser> = {\n  \"f-string\": parseFString,\n  mustache: parseMustache,\n};\n\nexport const renderTemplate = (\n  template: string,\n  templateFormat: TemplateFormat,\n  inputValues: InputValues\n) => {\n  try {\n    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n  } catch (e) {\n    const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n    throw error;\n  }\n};\n\nexport const parseTemplate = (\n  template: string,\n  templateFormat: TemplateFormat\n) => DEFAULT_PARSER_MAPPING[templateFormat](template);\n\nexport const checkValidTemplate = (\n  template: MessageContent,\n  templateFormat: TemplateFormat,\n  inputVariables: string[]\n) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    const dummyInputs: InputValues = inputVariables.reduce((acc, v) => {\n      acc[v] = \"foo\";\n      return acc;\n    }, {} as Record<string, string>);\n    if (Array.isArray(template)) {\n      template.forEach((message) => {\n        if (\n          message.type === \"text\" &&\n          \"text\" in message &&\n          typeof message.text === \"string\"\n        ) {\n          renderTemplate(message.text, templateFormat, dummyInputs);\n        } else if (message.type === \"image_url\") {\n          if (typeof message.image_url === \"string\") {\n            renderTemplate(message.image_url, templateFormat, dummyInputs);\n          } else if (\n            typeof message.image_url === \"object\" &&\n            message.image_url !== null &&\n            \"url\" in message.image_url &&\n            typeof message.image_url.url === \"string\"\n          ) {\n            const imageUrl = message.image_url.url;\n            renderTemplate(imageUrl, templateFormat, dummyInputs);\n          }\n        } else {\n          throw new Error(\n            `Invalid message template received. ${JSON.stringify(\n              message,\n              null,\n              2\n            )}`\n          );\n        }\n      });\n    } else {\n      renderTemplate(template, templateFormat, dummyInputs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};\n","import { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  ChannelVersions,\n  CheckpointMetadata,\n} from \"@langchain/langgraph-checkpoint\";\nimport { CONFIG_KEY_CHECKPOINT_MAP, START } from \"../../constants.js\";\n\nexport function getNullChannelVersion(currentVersions: ChannelVersions) {\n  // Short circuit for commonly used channels such as __start__\n  // (used by StateGraph)\n  const startVersion = typeof currentVersions[START];\n  if (startVersion === \"number\") return 0;\n  if (startVersion === \"string\") return \"\";\n\n  // Defer back to obtaining a first key from channel versions\n  for (const key in currentVersions) {\n    if (!Object.prototype.hasOwnProperty.call(currentVersions, key)) continue;\n    const versionType = typeof currentVersions[key];\n    if (versionType === \"number\") return 0;\n    if (versionType === \"string\") return \"\";\n    break;\n  }\n\n  return undefined;\n}\n\nexport function getNewChannelVersions(\n  previousVersions: ChannelVersions,\n  currentVersions: ChannelVersions\n): ChannelVersions {\n  // Get new channel versions\n  if (Object.keys(previousVersions).length > 0) {\n    const nullVersion = getNullChannelVersion(currentVersions);\n    return Object.fromEntries(\n      Object.entries(currentVersions).filter(\n        ([k, v]) => v > (previousVersions[k] ?? nullVersion)\n      )\n    );\n  } else {\n    return currentVersions;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport type RetryPolicy = {\n  /**\n   * Amount of time that must elapse before the first retry occurs in milliseconds.\n   * @default 500\n   */\n  initialInterval?: number;\n\n  /**\n   * Multiplier by which the interval increases after each retry.\n   * @default 2\n   */\n  backoffFactor?: number;\n\n  /**\n   * Maximum amount of time that may elapse between retries in milliseconds.\n   * @default 128000\n   */\n  maxInterval?: number;\n\n  /**\n   * Maximum amount of time that may elapse between retries.\n   * @default 3\n   */\n  maxAttempts?: number;\n\n  /** Whether to add random jitter to the interval between retries. */\n  jitter?: boolean;\n\n  /** A function that returns True for exceptions that should trigger a retry. */\n  retryOn?: (e: any) => boolean; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  /** Whether to log a warning when a retry is attempted. Defaults to true. */\n  logWarning?: boolean;\n};\n\n/**\n * Configuration for caching nodes.\n */\nexport type CachePolicy = {\n  /**\n   * A function used to generate a cache key from node's input.\n   * @returns A key for the cache.\n   */\n  keyFunc?: (args: unknown[]) => string;\n\n  /**\n   * The time to live for the cache in seconds.\n   * If not defined, the entry will never expire.\n   */\n  ttl?: number;\n};\n\nexport function patchConfigurable(\n  config: RunnableConfig | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  patch: Record<string, any>\n): RunnableConfig {\n  if (config === null) {\n    return { configurable: patch };\n  } else if (config?.configurable === undefined) {\n    return { ...config, configurable: patch };\n  } else {\n    return {\n      ...config,\n      configurable: { ...config.configurable, ...patch },\n    };\n  }\n}\n\nexport function patchCheckpointMap(\n  config: RunnableConfig,\n  metadata?: CheckpointMetadata\n): RunnableConfig {\n  const parents = metadata?.parents ?? {};\n\n  if (Object.keys(parents).length > 0) {\n    return patchConfigurable(config, {\n      [CONFIG_KEY_CHECKPOINT_MAP]: {\n        ...parents,\n        [config.configurable?.checkpoint_ns ?? \"\"]:\n          config.configurable?.checkpoint_id,\n      },\n    });\n  } else {\n    return config;\n  }\n}\n\n/**\n * Combine multiple abort signals into a single abort signal.\n * @param signals - The abort signals to combine.\n * @returns A combined abort signal and a dispose function to remove the abort listener if unused.\n */\nexport function combineAbortSignals(...x: (AbortSignal | undefined)[]): {\n  signal: AbortSignal | undefined;\n  dispose?: () => void;\n} {\n  const signals = [...new Set(x.filter(Boolean))] as AbortSignal[];\n\n  if (signals.length === 0) {\n    return { signal: undefined, dispose: undefined };\n  }\n\n  if (signals.length === 1) {\n    return { signal: signals[0], dispose: undefined };\n  }\n\n  const combinedController = new AbortController();\n  const listener = () => {\n    const reason = signals.find((s) => s.aborted)?.reason;\n    combinedController.abort(reason);\n    signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n  };\n\n  signals.forEach((s) => s.addEventListener(\"abort\", listener, { once: true }));\n\n  const hasAlreadyAbortedSignal = signals.find((s) => s.aborted);\n  if (hasAlreadyAbortedSignal) {\n    combinedController.abort(hasAlreadyAbortedSignal.reason);\n  }\n\n  return {\n    signal: combinedController.signal,\n    dispose: () => {\n      signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n    },\n  };\n}\n\n/**\n * Combine multiple callbacks into a single callback.\n * @param callback1 - The first callback to combine.\n * @param callback2 - The second callback to combine.\n * @returns A single callback that is a combination of the input callbacks.\n */\nexport const combineCallbacks = (\n  callback1?: Callbacks,\n  callback2?: Callbacks\n): Callbacks | undefined => {\n  if (!callback1 && !callback2) {\n    return undefined;\n  }\n\n  if (!callback1) {\n    return callback2;\n  }\n\n  if (!callback2) {\n    return callback1;\n  }\n  if (Array.isArray(callback1) && Array.isArray(callback2)) {\n    return [...callback1, ...callback2];\n  }\n  if (Array.isArray(callback1)) {\n    return [...callback1, callback2] as Callbacks;\n  }\n  if (Array.isArray(callback2)) {\n    return [callback1, ...callback2];\n  }\n  return [callback1, callback2] as Callbacks;\n};\n","import { BaseMessage } from \"../messages/index.js\";\nimport { OutputParserException } from \"./base.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport abstract class ListOutputParser extends BaseTransformOutputParser<\n  string[]\n> {\n  re?: RegExp;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<string[]> {\n    let buffer = \"\";\n    for await (const input of inputGenerator) {\n      if (typeof input === \"string\") {\n        // add current chunk to buffer\n        buffer += input;\n      } else {\n        // extract message content and add to buffer\n        buffer += input.content;\n      }\n      // get parts in buffer\n      if (!this.re) {\n        const parts = await this.parse(buffer);\n        if (parts.length > 1) {\n          // if there are multiple parts, yield all but the last one\n          for (const part of parts.slice(0, -1)) {\n            yield [part];\n          }\n          // keep the last part in the buffer\n          buffer = parts[parts.length - 1];\n        }\n      } else {\n        // if there is a regex, get all matches\n        const matches = [...buffer.matchAll(this.re)];\n        if (matches.length > 1) {\n          let doneIdx = 0;\n          // if there are multiple matches, yield all but the last one\n          for (const match of matches.slice(0, -1)) {\n            yield [match[1]];\n            doneIdx += (match.index ?? 0) + match[0].length;\n          }\n          // keep the last match in the buffer\n          buffer = buffer.slice(doneIdx);\n        }\n      }\n    }\n\n    // yield the last part\n    for (const part of await this.parse(buffer)) {\n      yield [part];\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport class CommaSeparatedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"CommaSeparatedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses the given text into an array of strings, using a comma as the\n   * separator. If the parsing fails, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each comma.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      return text\n        .trim()\n        .split(\",\")\n        .map((s) => s.trim());\n    } catch {\n      throw new OutputParserException(`Could not parse output: ${text}`, text);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CommaSeparatedListOutputParser.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of comma separated values, eg: \\`foo, bar, baz\\``;\n  }\n}\n\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport class CustomListOutputParser extends ListOutputParser {\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  private length: number | undefined;\n\n  private separator: string;\n\n  constructor({ length, separator }: { length?: number; separator?: string }) {\n    super(...arguments);\n    this.length = length;\n    this.separator = separator || \",\";\n  }\n\n  /**\n   * Parses the given text into an array of strings, using the specified\n   * separator. If the parsing fails or the number of items in the list\n   * doesn't match the expected length, throws an OutputParserException.\n   * @param text The text to parse.\n   * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n   */\n  async parse(text: string): Promise<string[]> {\n    try {\n      const items = text\n        .trim()\n        .split(this.separator)\n        .map((s) => s.trim());\n      if (this.length !== undefined && items.length !== this.length) {\n        throw new OutputParserException(\n          `Incorrect number of items. Expected ${this.length}, got ${items.length}.`\n        );\n      }\n      return items;\n    } catch (e) {\n      if (Object.getPrototypeOf(e) === OutputParserException.prototype) {\n        throw e;\n      }\n      throw new OutputParserException(`Could not parse output: ${text}`);\n    }\n  }\n\n  /**\n   * Provides instructions on the expected format of the response for the\n   * CustomListOutputParser, including the number of items and the\n   * separator.\n   * @returns A string containing instructions on the expected format of the response.\n   */\n  getFormatInstructions(): string {\n    return `Your response should be a list of ${\n      this.length === undefined ? \"\" : `${this.length} `\n    }items separated by \"${this.separator}\" (eg: \\`foo${this.separator} bar${\n      this.separator\n    } baz\\`)`;\n  }\n}\n\nexport class NumberedListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /\\d+\\.\\s([^\\n]+)/g;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n\nexport class MarkdownListOutputParser extends ListOutputParser {\n  static lc_name() {\n    return \"NumberedListOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"list\"];\n\n  lc_serializable = true;\n\n  getFormatInstructions(): string {\n    return `Your response should be a numbered list with each item on a new line. For example: \\n\\n1. foo\\n\\n2. bar\\n\\n3. baz`;\n  }\n\n  re = /^\\s*[-*]\\s([^\\n]+)$/gm;\n\n  async parse(text: string): Promise<string[]> {\n    return [...(text.matchAll(this.re) ?? [])].map((m) => m[1]);\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport {\n  BaseStore,\n  type Item,\n  type SearchOperation,\n  type PutOperation,\n  type GetOperation,\n  type Operation,\n  OperationResults,\n} from \"./base.js\";\n\n/**\n * Extracts and returns the underlying store from an `AsyncBatchedStore`,\n * or returns the input if it is not an `AsyncBatchedStore`.\n */\nconst extractStore = (input: BaseStore | AsyncBatchedStore): BaseStore => {\n  if (\"lg_name\" in input && input.lg_name === \"AsyncBatchedStore\") {\n    // @ts-expect-error is a protected property\n    return input.store;\n  }\n  return input;\n};\n\nexport class AsyncBatchedStore extends BaseStore {\n  lg_name = \"AsyncBatchedStore\";\n\n  protected store: BaseStore;\n\n  private queue: Map<\n    number,\n    {\n      operation: Operation;\n      resolve: (value: any) => void;\n      reject: (reason?: any) => void;\n    }\n  > = new Map();\n\n  private nextKey: number = 0;\n\n  private running = false;\n\n  private processingTask: Promise<void> | null = null;\n\n  constructor(store: BaseStore) {\n    super();\n    this.store = extractStore(store);\n  }\n\n  get isRunning(): boolean {\n    return this.running;\n  }\n\n  /**\n   * @ignore\n   * Batch is not implemented here as we're only extending `BaseStore`\n   * to allow it to be passed where `BaseStore` is expected, and implement\n   * the convenience methods (get, search, put, delete).\n   */\n  async batch<Op extends Operation[]>(\n    _operations: Op\n  ): Promise<OperationResults<Op>> {\n    throw new Error(\n      \"The `batch` method is not implemented on `AsyncBatchedStore`.\" +\n        \"\\n Instead, it calls the `batch` method on the wrapped store.\" +\n        \"\\n If you are seeing this error, something is wrong.\"\n    );\n  }\n\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    return this.enqueueOperation({ namespace, key } as GetOperation);\n  }\n\n  async search(\n    namespacePrefix: string[],\n    options?: {\n      filter?: Record<string, any>;\n      limit?: number;\n      offset?: number;\n      query?: string;\n    }\n  ): Promise<Item[]> {\n    const { filter, limit = 10, offset = 0, query } = options || {};\n    return this.enqueueOperation({\n      namespacePrefix,\n      filter,\n      limit,\n      offset,\n      query,\n    } as SearchOperation);\n  }\n\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, any>\n  ): Promise<void> {\n    return this.enqueueOperation({ namespace, key, value } as PutOperation);\n  }\n\n  async delete(namespace: string[], key: string): Promise<void> {\n    return this.enqueueOperation({\n      namespace,\n      key,\n      value: null,\n    } as PutOperation);\n  }\n\n  start(): void {\n    if (!this.running) {\n      this.running = true;\n      this.processingTask = this.processBatchQueue();\n    }\n  }\n\n  async stop(): Promise<void> {\n    this.running = false;\n    if (this.processingTask) {\n      await this.processingTask;\n    }\n  }\n\n  private enqueueOperation<T>(operation: Operation): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const key = this.nextKey;\n      this.nextKey += 1;\n      this.queue.set(key, { operation, resolve, reject });\n    });\n  }\n\n  private async processBatchQueue(): Promise<void> {\n    while (this.running) {\n      await new Promise((resolve) => {\n        setTimeout(resolve, 0);\n      });\n      if (this.queue.size === 0) continue;\n\n      const batch = new Map(this.queue);\n      this.queue.clear();\n\n      try {\n        const operations = Array.from(batch.values()).map(\n          ({ operation }) => operation\n        );\n        const results = await this.store.batch(operations);\n\n        batch.forEach(({ resolve }, key) => {\n          const index = Array.from(batch.keys()).indexOf(key);\n          resolve(results[index]);\n        });\n      } catch (e) {\n        batch.forEach(({ reject }) => {\n          reject(e);\n        });\n      }\n    }\n  }\n\n  // AsyncBatchedStore is internal and gets passed as args into traced tasks\n  // some BaseStores contain circular references so just serialize without it\n  // as this causes warnings when tracing with LangSmith.\n  toJSON() {\n    return {\n      queue: this.queue,\n      nextKey: this.nextKey,\n      running: this.running,\n      store: \"[LangGraphStore]\",\n    };\n  }\n}\n","import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { SerializerProtocol } from \"./serde/base.js\";\nimport { uuid6 } from \"./id.js\";\nimport type {\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n} from \"./types.js\";\nimport { ERROR, INTERRUPT, RESUME, SCHEDULED } from \"./serde/types.js\";\nimport { JsonPlusSerializer } from \"./serde/jsonplus.js\";\n\n/** @inline */\ntype ChannelVersion = number | string;\n\nexport type ChannelVersions = Record<string, ChannelVersion>;\n\nexport interface Checkpoint<\n  N extends string = string,\n  C extends string = string\n> {\n  /**\n   * The version of the checkpoint format. Currently 4\n   */\n  v: number;\n  /**\n   * Checkpoint ID {uuid6}\n   */\n  id: string;\n  /**\n   * Timestamp {new Date().toISOString()}\n   */\n  ts: string;\n  /**\n   * @default {}\n   */\n  channel_values: Record<C, unknown>;\n  /**\n   * @default {}\n   */\n  channel_versions: Record<C, ChannelVersion>;\n  /**\n   * @default {}\n   */\n  versions_seen: Record<N, Record<C, ChannelVersion>>;\n}\n\nexport interface ReadonlyCheckpoint extends Readonly<Checkpoint> {\n  readonly channel_values: Readonly<Record<string, unknown>>;\n  readonly channel_versions: Readonly<Record<string, ChannelVersion>>;\n  readonly versions_seen: Readonly<\n    Record<string, Readonly<Record<string, ChannelVersion>>>\n  >;\n}\n\nexport function deepCopy<T>(obj: T): T {\n  if (typeof obj !== \"object\" || obj === null) {\n    return obj;\n  }\n\n  const newObj = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      (newObj as Record<PropertyKey, unknown>)[key] = deepCopy(\n        (obj as Record<string, unknown>)[key]\n      );\n    }\n  }\n\n  return newObj as T;\n}\n\n/** @hidden */\nexport function emptyCheckpoint(): Checkpoint {\n  return {\n    v: 4,\n    id: uuid6(-2),\n    ts: new Date().toISOString(),\n    channel_values: {},\n    channel_versions: {},\n    versions_seen: {},\n  };\n}\n\n/** @hidden */\nexport function copyCheckpoint(checkpoint: ReadonlyCheckpoint): Checkpoint {\n  return {\n    v: checkpoint.v,\n    id: checkpoint.id,\n    ts: checkpoint.ts,\n    channel_values: { ...checkpoint.channel_values },\n    channel_versions: { ...checkpoint.channel_versions },\n    versions_seen: deepCopy(checkpoint.versions_seen),\n  };\n}\n\nexport interface CheckpointTuple {\n  config: RunnableConfig;\n  checkpoint: Checkpoint;\n  metadata?: CheckpointMetadata;\n  parentConfig?: RunnableConfig;\n  pendingWrites?: CheckpointPendingWrite[];\n}\n\nexport type CheckpointListOptions = {\n  limit?: number;\n  before?: RunnableConfig;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter?: Record<string, any>;\n};\n\nexport abstract class BaseCheckpointSaver<V extends string | number = number> {\n  serde: SerializerProtocol = new JsonPlusSerializer();\n\n  constructor(serde?: SerializerProtocol) {\n    this.serde = serde || this.serde;\n  }\n\n  async get(config: RunnableConfig): Promise<Checkpoint | undefined> {\n    const value = await this.getTuple(config);\n    return value ? value.checkpoint : undefined;\n  }\n\n  abstract getTuple(\n    config: RunnableConfig\n  ): Promise<CheckpointTuple | undefined>;\n\n  abstract list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple>;\n\n  abstract put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata,\n    newVersions: ChannelVersions\n  ): Promise<RunnableConfig>;\n\n  /**\n   * Store intermediate writes linked to a checkpoint.\n   */\n  abstract putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void>;\n\n  /**\n   * Delete all checkpoints and writes associated with a specific thread ID.\n   * @param threadId The thread ID whose checkpoints should be deleted.\n   */\n  abstract deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Generate the next version ID for a channel.\n   *\n   * Default is to use integer versions, incrementing by 1. If you override, you can use str/int/float versions,\n   * as long as they are monotonically increasing.\n   */\n  getNextVersion(current: V | undefined): V {\n    if (typeof current === \"string\") {\n      throw new Error(\"Please override this method to use string versions.\");\n    }\n    return (\n      current !== undefined && typeof current === \"number\" ? current + 1 : 1\n    ) as V;\n  }\n}\n\nexport function compareChannelVersions(\n  a: ChannelVersion,\n  b: ChannelVersion\n): number {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return Math.sign(a - b);\n  }\n\n  return String(a).localeCompare(String(b));\n}\n\nexport function maxChannelVersion(\n  ...versions: ChannelVersion[]\n): ChannelVersion {\n  return versions.reduce((max, version, idx) => {\n    if (idx === 0) return version;\n    return compareChannelVersions(max, version) >= 0 ? max : version;\n  });\n}\n\n/**\n * Mapping from error type to error index.\n * Regular writes just map to their index in the list of writes being saved.\n * Special writes (e.g. errors) map to negative indices, to avoid those writes from\n * conflicting with regular writes.\n * Each Checkpointer implementation should use this mapping in put_writes.\n */\nexport const WRITES_IDX_MAP: Record<string, number> = {\n  [ERROR]: -1,\n  [SCHEDULED]: -2,\n  [INTERRUPT]: -3,\n  [RESUME]: -4,\n};\n\nexport function getCheckpointId(config: RunnableConfig): string {\n  return (\n    config.configurable?.checkpoint_id || config.configurable?.thread_ts || \"\"\n  );\n}\n","import type { ContentBlock } from \"./content/index.js\";\nimport type { ResponseMetadata, UsageMetadata } from \"./metadata.js\";\nimport type { $MergeDiscriminatedUnion, $MergeObjects } from \"./utils.js\";\n\n/**\n * Represents the possible types of messages in the system.\n * Includes standard message types (\"ai\", \"human\", \"tool\", \"system\")\n * and allows for custom string types that are non-null.\n *\n * @example\n * ```ts\n * // Standard message types\n * const messageType1: MessageType = \"ai\";\n * const messageType2: MessageType = \"human\";\n *\n * // Custom message type\n * const messageType3: MessageType = \"custom_type\";\n * ```\n */\nexport type MessageType =\n  | \"ai\"\n  | \"human\"\n  | \"tool\"\n  | \"system\"\n  | (string & NonNullable<unknown>);\n\n/**\n * Represents the output version format for message content.\n *\n * This type determines how the content field is structured in a message:\n * - \"v0\": Content is represented as a simple string or array of content blocks\n *   - provides backward compatibility with simpler content representations\n * - \"v1\": Content follows the structured ContentBlock format with typed discriminated unions\n *   - enables full type safety and structured content block handling\n *\n * @example\n * ```ts\n * // v0 format - simple content representation\n * const v0Message: Message<{ outputVersion: \"v0\", content: ... }> = {\n *   type: \"human\",\n *   content: \"Hello world\" // string | Array<ContentBlock | ContentBlock.Text>\n * };\n *\n * // v1 format - structured content blocks\n * const v1Message: Message<{ outputVersion: \"v1\", content: ... }> = {\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello world\" },\n *     { type: \"image\", image_url: \"...\" }\n *   ] // Array<ContentBlock | ...> (determined by the structure)\n * };\n * ```\n */\nexport type MessageOutputVersion = \"v0\" | \"v1\";\n\n/**\n * Represents the input and output types of a tool that can be used in messages.\n *\n * @template TInput - The type of input the tool accepts.\n * @template TOutput - The type of output the tool produces.\n *\n * @example\n * ```ts\n * // Tool that takes a string input and returns a number\n * interface StringToNumberTool extends MessageToolDefinition<string, number> {\n *   input: string;\n *   output: number;\n * }\n * ```\n */\nexport interface MessageToolDefinition<TInput = unknown, TOutput = unknown> {\n  input: TInput;\n  output: TOutput;\n}\n\n/**\n * Represents a structured set of tools by mapping tool names to definitions\n * that can be used in messages.\n *\n * @example\n * ```ts\n * interface MyToolSet extends MessageToolSet {\n *   calculator: MessageToolDefinition<\n *     { operation: string; numbers: number[] },\n *     number\n *   >;\n *   translator: MessageToolDefinition<\n *     { text: string; targetLanguage: string },\n *     string\n *   >;\n * }\n * ```\n */\nexport interface MessageToolSet {\n  [key: string]: MessageToolDefinition;\n}\n\n/**\n * Represents a tool call block within a message structure by mapping tool names to their\n * corresponding tool call formats, including the input arguments and an optional identifier.\n *\n * @template TStructure - A message structure type that may contain tool definitions\n *\n * @example\n * ```ts\n * // Given a message structure with a calculator tool:\n * interface MyStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<{ operation: string, numbers: number[] }, number>\n *   }\n * }\n *\n * // The tool call block would be:\n * type CalcToolCall = $MessageToolCallBlock<MyStructure>;\n * // Resolves to:\n * // {\n * //   type: \"tool_call\";\n * //   name: \"calculator\";\n * //   args: { operation: string, numbers: number[] };\n * //   id?: string;\n * // }\n * ```\n */\nexport type $MessageToolCallBlock<TStructure extends MessageStructure> =\n  TStructure[\"tools\"] extends MessageToolSet\n    ? {\n        [K in keyof TStructure[\"tools\"]]: K extends string\n          ? TStructure[\"tools\"][K] extends MessageToolDefinition\n            ? ContentBlock.Tools.ToolCall<K, TStructure[\"tools\"][K][\"input\"]>\n            : never\n          : never;\n      }[keyof TStructure[\"tools\"]]\n    : never;\n\n/**\n * Core interface that defines the structure of messages.\n *\n * @example\n * ```ts\n * // Basic message structure with just content blocks\n * interface SimpleMessageStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     // allows for text + reasoning blocks in ai messages\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   }\n * }\n *\n * // Message structure with tools and properties\n * interface AdvancedMessageStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<\n *       { operation: string; numbers: number[] },\n *       number\n *     >;\n *   };\n *   content: {\n *     // allows for text + image blocks in human messages\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *     // only allows for text blocks in ai messages\n *     ai: ContentBlock.Text;\n *   };\n *   properties: {\n *     // pins properties to ai messages\n *     ai: {\n *       response_metadata: {\n *         confidence: number;\n *         model: string;\n *       };\n *     };\n *   }\n * }\n *\n * // Using with $MergeMessageStructure to combine structures\n * // The resulting type when passed into BaseMessage will have a calculator tool,\n * // allow for text + image blocks in human messages,\n * // and text + reasoning blocks + additional arbitrary properties in ai messages.\n * type CombinedStructure = $MergeMessageStructure<\n *   SimpleMessageStructure,\n *   AdvancedMessageStructure\n * >;\n *\n * // Using in a Message object\n * const message: Message<CombinedStructure> = {\n *   id: \"msg-123\",\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" }\n *     { type: \"image\", mimeType: \"image/jpeg\", url: \"https://example.com/image.jpg\" }\n *     // this block will throw an error because it's not defined in the structure\n *     { type: \"reasoning\", reasoning: \"The answer is 42\" }\n *   ]\n * };\n * ```\n */\nexport interface MessageStructure {\n  /**\n   * Optional output version for the message structure.\n   * If not provided, defaults to \"v0\".\n   */\n  readonly outputVersion?: MessageOutputVersion;\n  /**\n   * Optional set of tool definitions that can be used in messages.\n   * Each tool is defined with input/output types and can be referenced in tool messages.\n   */\n  readonly tools?: MessageToolSet;\n  /**\n   * Optional mapping of message types to their allowed content blocks.\n   * Each message type can specify what content block types it supports (text, images, etc).\n   */\n  readonly content?: Partial<{\n    [key in MessageType]: ContentBlock;\n  }>;\n  /**\n   * Optional mapping of message types to arbitrary property objects.\n   * Allows attaching custom metadata or other information to specific message types.\n   */\n  readonly properties?: Partial<{\n    [key in MessageType]: Record<string, unknown>;\n  }>;\n}\n\n/**\n * Normalizes an arbitrary type to a message output version or undefined.\n * Accepts unknown and narrows to a valid MessageOutputVersion if present.\n */\ntype $NormalizeMessageOutputVersion<T> =\n  | Extract<T, MessageOutputVersion>\n  | undefined;\n\n/**\n * Merges two output version types from message structures.\n *\n * This utility type determines the resulting output version when combining two message structures.\n * The merge logic follows these rules:\n *\n * - If both T and U are undefined, defaults to \"v0\" for backwards compatibility\n * - If T is undefined but U is defined, uses U's version\n * - If U is undefined but T is defined, uses T's version\n * - If both T and U are defined, U takes precedence (later structure wins)\n *\n * @template T - The output version from the first message structure\n * @template U - The output version from the second message structure\n *\n * @example\n * ```ts\n * // Both undefined - defaults to \"v0\"\n * type Result1 = $MergeOutputVersion<undefined, undefined>; // \"v0\"\n *\n * // One defined - uses the defined version\n * type Result2 = $MergeOutputVersion<undefined, \"v1\">; // \"v1\"\n * type Result3 = $MergeOutputVersion<\"v0\", undefined>; // \"v0\"\n *\n * // Both defined - second takes precedence\n * type Result4 = $MergeOutputVersion<\"v0\", \"v1\">; // \"v1\"\n * ```\n */\nexport type $MergeOutputVersion<T, U> =\n  $NormalizeMessageOutputVersion<T> extends infer TV\n    ? $NormalizeMessageOutputVersion<U> extends infer UV\n      ? [TV, UV] extends [undefined, undefined]\n        ? \"v0\"\n        : [TV] extends [undefined]\n        ? Exclude<UV, undefined>\n        : [UV] extends [undefined]\n        ? Exclude<TV, undefined>\n        : UV\n      : never\n    : never;\n\n/**\n * Merges two content definition objects from message structures.\n *\n * This utility type combines content definitions from two message structures, handling\n * the merging of content block types for each message type. The merge logic follows\n * these rules:\n *\n * - For keys that exist in both T and U: Merges the content blocks using discriminated\n *   union merging based on the \"type\" property. This allows combining different content\n *   block types (e.g., text + image) for the same message type.\n * - For keys that exist only in T: Uses T's content definition as-is\n * - For keys that exist only in U: Uses U's content definition as-is\n *\n * @template T - The content definition from the first message structure\n * @template U - The content definition from the second message structure\n *\n * @example\n * ```ts\n * // T allows text content for human messages\n * type ContentA = {\n *   human: ContentBlock.Text;\n * };\n *\n * // U allows image content for human messages and text for AI messages\n * type ContentB = {\n *   human: ContentBlock.Multimodal.Image;\n *   ai: ContentBlock.Text;\n * };\n *\n * // Merged result allows both text and images for human messages, text for AI\n * type Merged = $MergeContentDefinition<ContentA, ContentB>;\n * // Result: {\n * //   human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n * //   ai: ContentBlock.Text;\n * // }\n * ```\n */\nexport type $MergeContentDefinition<T, U> = {\n  [K in keyof T | keyof U as Extract<\n    (K extends keyof T ? T[K] : never) | (K extends keyof U ? U[K] : never),\n    ContentBlock\n  > extends never\n    ? never\n    : K]: K extends keyof T\n    ? K extends keyof U\n      ? $MergeDiscriminatedUnion<\n          Extract<T[K], ContentBlock>,\n          Extract<U[K], ContentBlock>,\n          \"type\"\n        >\n      : Extract<T[K], ContentBlock>\n    : K extends keyof U\n    ? Extract<U[K], ContentBlock>\n    : never;\n};\n\n/**\n * Merges two message structures A and B into a combined structure.\n * This is a type utility that handles merging of tools, content blocks, and properties\n * from two message structures. The resulting type is usable as its own message structure.\n *\n * @example\n * ```ts\n * // Structure A allows text in human messages and has a confidence property on AI messages\n * interface StructureA extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *   };\n *   properties: {\n *     ai: { confidence: number };\n *   }\n * }\n *\n * // Structure B allows images in human messages and has a model property on AI messages\n * interface StructureB extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Multimodal.Image;\n *   };\n *   properties: {\n *     ai: { model: string };\n *   }\n * }\n *\n * // Merged structure allows both text and images in human messages\n * // AI messages have both confidence and model properties\n * type Merged = $MergeMessageStructure<StructureA, StructureB>;\n * ```\n *\n * @template A - First message structure to merge\n * @template B - Second message structure to merge (takes precedence over A)\n */\nexport type $MergeMessageStructure<\n  T extends MessageStructure,\n  U extends MessageStructure\n> = {\n  outputVersion: $MergeOutputVersion<T[\"outputVersion\"], U[\"outputVersion\"]>;\n  tools: $MergeObjects<T[\"tools\"], U[\"tools\"]>;\n  content: $MergeContentDefinition<T[\"content\"], U[\"content\"]>;\n  properties: $MergeObjects<T[\"properties\"], U[\"properties\"]>;\n};\n\n/**\n * Standard message structured used to define the most basic message structure that's\n * used throughout the library.\n *\n * This is also the message structure that's used when a message structure is not provided.\n */\nexport interface StandardMessageStructure extends MessageStructure {\n  content: {\n    /** Text content for AI messages */\n    ai: ContentBlock.Text;\n    /** Text content for human messages */\n    human: ContentBlock.Text;\n    /** Text content for system messages */\n    system: ContentBlock.Text;\n    /** Text content for tool messages */\n    tool: ContentBlock.Text;\n  };\n  properties: {\n    /** Properties specific to AI messages */\n    ai: {\n      /** Metadata about the AI model response */\n      response_metadata: ResponseMetadata;\n      /** Usage statistics for the AI response */\n      usage_metadata: UsageMetadata;\n    };\n    human: {\n      /** Metadata about the human message */\n      response_metadata: Record<string, unknown>;\n    };\n    system: {\n      /** Metadata about the system message */\n      response_metadata: Record<string, unknown>;\n    };\n    tool: {\n      /** Metadata about the tool message */\n      response_metadata: Record<string, unknown>;\n    };\n  };\n}\n\n/**\n * Takes a message structure type T and normalizes it by merging it with the standard message structure.\n * If T is already a standard message structure, returns T unchanged.\n *\n * This ensures that any custom message structure includes all the standard message structure fields\n * by default while allowing overrides and extensions.\n *\n * @template T - The message structure type to normalize, must extend MessageStructure\n * @returns Either T if it's already a standard structure, or the merged result of T with standard structure\n */\nexport type $NormalizedMessageStructure<T extends MessageStructure> =\n  T extends StandardMessageStructure\n    ? T\n    : $MergeMessageStructure<StandardMessageStructure, T>;\n\n/**\n * Infers the content blocks for a specific message type in a message structure.\n *\n * This utility type extracts the content block type that corresponds to a given message type\n * from the message structure's content definition.\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content block type for the specified type, or never if its not defined in the structure\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContent = $InferMessageContentBlocks<MyStructure, \"human\">;\n * // HumanContent = ContentBlock.Text\n *\n * type AIContent = $InferMessageContentBlocks<MyStructure, \"ai\">;\n * // AIContent = ContentBlock.Text | ContentBlock.ToolCall\n * ```\n */\nexport type $InferMessageContentBlocks<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $NormalizedMessageStructure<TStructure> extends infer S\n  ? S extends MessageStructure\n    ? S[\"content\"] extends infer C\n      ? C extends Record<PropertyKey, ContentBlock>\n        ? TRole extends keyof C\n          ? [$MessageToolCallBlock<TStructure>] extends [never]\n            ? C[TRole]\n            : $MergeDiscriminatedUnion<\n                NonNullable<C[TRole]>,\n                $MessageToolCallBlock<TStructure>,\n                \"type\"\n              >\n          : never\n        : never\n      : never\n    : never\n  : never;\n\n/**\n * Infers the content type for a specific message type from a message structure.\n *\n * This utility type determines the appropriate content type based on the message structure's\n * output version and the specified message type. The content type varies depending on the\n * output version (see {@link MessageOutputVersion})\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content type for the specified role based on the output version\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   outputVersion: \"v0\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContentV0 = $InferMessageContent<MyStructure, \"human\">;\n * // HumanContentV0 = string | Array<ContentBlock | ContentBlock.Text>\n *\n * interface MyStructureV1 extends MessageStructure {\n *   outputVersion: \"v1\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   };\n * }\n *\n * type HumanContentV1 = $InferMessageContent<MyStructureV1, \"human\">;\n * // HumanContentV1 = ContentBlock.Text\n *\n * type AIContentV1 = $InferMessageContent<MyStructureV1, \"ai\">;\n * // AIContentV1 = ContentBlock.Text | ContentBlock.Reasoning\n * ```\n */\nexport type $InferMessageContent<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = TStructure[\"outputVersion\"] extends \"v1\"\n  ? Array<$InferMessageContentBlocks<TStructure, TRole>>\n  : string | Array<ContentBlock | ContentBlock.Text>;\n\n/**\n * Infers the properties for a specific message type from a message structure.\n *\n * This utility type extracts the properties object that corresponds to a given message type\n * from the message structure's properties definition, and excludes the reserved\n * \"content\" and \"type\" properties to avoid conflicts with the core message structure.\n *\n * If the specified type is not defined in the message structure's properties, it returns\n * a generic Record<string, unknown> type to allow for arbitrary properties.\n *\n * @template TStructure - The message structure to infer properties from\n * @template TRole - The message type/role to get properties for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The properties object type for the specified type, excluding \"content\" and \"type\"\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string };\n *       usage_metadata: { tokens: number };\n *       content: string; // This will be omitted\n *       type: string;    // This will be omitted\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIProperties = $InferMessageProperties<MyStructure, \"ai\">;\n * // AIProperties = { response_metadata: { model: string }; usage_metadata: { tokens: number } }\n *\n * type HumanProperties = $InferMessageProperties<MyStructure, \"human\">;\n * // HumanProperties = { metadata: Record<string, unknown> }\n *\n * type SystemProperties = $InferMessageProperties<MyStructure, \"system\">;\n * // SystemProperties = Record<string, unknown> (fallback for undefined role)\n * ```\n */\nexport type $InferMessageProperties<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $NormalizedMessageStructure<TStructure> extends infer S\n  ? S extends MessageStructure\n    ? S[\"properties\"] extends infer P | undefined\n      ? P extends Record<PropertyKey, unknown>\n        ? TRole extends keyof P\n          ? Omit<P[TRole], \"content\" | \"type\">\n          : Record<string, unknown>\n        : Record<string, unknown>\n      : Record<string, unknown>\n    : never\n  : never;\n\n/**\n * Infers the type of a specific property for a message type from a message structure.\n *\n * This utility type extracts the type of a single property by name from the properties\n * object that corresponds to a given message type. If the specified property key does\n * not exist in the type's properties, it returns `never`.\n *\n * @template TStructure - The message structure to infer the property from\n * @template TRole - The message type/role to get the property for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @template K - The property key to extract the type for\n * @returns The type of the specified property, or `never` if the property doesn't exist\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number };\n *       usage_metadata: { input_tokens: number; output_tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type ResponseMetadata = $InferMessageProperty<MyStructure, \"ai\", \"response_metadata\">;\n * // ResponseMetadata = { model: string; temperature: number }\n *\n * type UsageMetadata = $InferMessageProperty<MyStructure, \"ai\", \"usage_metadata\">;\n * // UsageMetadata = { input_tokens: number; output_tokens: number }\n *\n * type NonExistentProperty = $InferMessageProperty<MyStructure, \"ai\", \"nonExistent\">;\n * // NonExistentProperty = Record<string, unknown>\n *\n * type HumanMetadata = $InferMessageProperty<MyStructure, \"human\", \"metadata\">;\n * // HumanMetadata = Record<string, unknown>\n * ```\n */\nexport type $InferMessageProperty<\n  TStructure extends MessageStructure,\n  TRole extends MessageType,\n  K extends string\n> = K extends keyof $InferMessageProperties<TStructure, TRole>\n  ? $InferMessageProperties<TStructure, TRole>[K]\n  : never;\n\n/**\n * Infers the response metadata type for a specific message type from a message structure.\n *\n * This utility type extracts the `response_metadata` property type for a given message type.\n *\n * @template TStructure - The message structure to infer the response metadata from\n * @template TRole - The message type/role to get the response metadata for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The type of the response_metadata property, or `Record<string, unknown>` as fallback\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number; tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIResponseMetadata = $InferResponseMetadata<MyStructure, \"ai\">;\n * // AIResponseMetadata = { model: string; temperature: number; tokens: number }\n *\n * type HumanResponseMetadata = $InferResponseMetadata<MyStructure, \"human\">;\n * // HumanResponseMetadata = Record<string, unknown> (fallback since not defined)\n * ```\n */\nexport type $InferResponseMetadata<\n  TStructure extends MessageStructure,\n  TRole extends MessageType\n> = $InferMessageProperty<\n  TStructure,\n  TRole,\n  \"response_metadata\"\n> extends infer P\n  ? [P] extends [never]\n    ? Record<string, unknown>\n    : P\n  : never;\n\n/**\n * Represents a message object that organizes context for an LLM.\n *\n * @example\n * ```ts\n * // Basic message with text content\n * const message: Message = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"human\",\n *   content: [{ type: \"text\", text: \"Hello!\" }]\n * };\n *\n * // Basic ai message interface extension\n * interface MyMessage extends Message<StandardMessageStructure, \"ai\"> {\n *   // Additional AI-specific properties can be added here\n * }\n *`\n * // Custom message structure\n * interface CustomStructure extends MessageStructure {\n *   content: {\n *     ai: ContentBlock.Text | ContentBlock.ToolCall<\"search\", { query: string }>;\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *   };\n * }\n *\n * // Create a message with custom structure\n * const message: Message<CustomStructure> = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"ai\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" },\n *     {\n *       type: \"tool_call\",\n *       name: \"search\",\n *       args: { query: \"What is the capital of France?\" }\n *     }\n *   ]\n * };\n * ```\n */\nexport interface Message<\n  TStructure extends MessageStructure = StandardMessageStructure,\n  TRole extends MessageType = MessageType\n> {\n  /** The message type/role */\n  readonly type: TRole;\n  /** Unique identifier for this message */\n  id?: string;\n  /** Optional name/identifier for the entity that created this message */\n  name?: string;\n  /** Array of content blocks that make up the message content */\n  content: $InferMessageContent<TStructure, TRole>;\n  /** Metadata about the message */\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n}\n\n/**\n * Type guard to check if a value is a valid Message object.\n *\n * @param message - The value to check\n * @returns true if the value is a valid Message object, false otherwise\n */\nexport function isMessage(message: unknown): message is Message {\n  return (\n    typeof message === \"object\" &&\n    message !== null &&\n    \"type\" in message &&\n    \"content\" in message &&\n    (typeof message.content === \"string\" || Array.isArray(message.content))\n  );\n}\n","import {\n  ZodFirstPartyTypeKind,\n  ZodMapDef,\n  ZodRecordDef,\n  ZodTypeAny,\n} from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7EnumType } from \"./enum.js\";\nimport { JsonSchema7ObjectType } from \"./object.js\";\nimport { JsonSchema7StringType, parseStringDef } from \"./string.js\";\nimport { parseBrandedDef } from \"./branded.js\";\nimport { parseAnyDef } from \"./any.js\";\n\ntype JsonSchema7RecordPropertyNamesType =\n  | Omit<JsonSchema7StringType, \"type\">\n  | Omit<JsonSchema7EnumType, \"type\">;\n\nexport type JsonSchema7RecordType = {\n  type: \"object\";\n  additionalProperties?: JsonSchema7Type | true;\n  propertyNames?: JsonSchema7RecordPropertyNamesType;\n};\n\nexport function parseRecordDef(\n  def: ZodRecordDef<ZodTypeAny, ZodTypeAny> | ZodMapDef,\n  refs: Refs\n): JsonSchema7RecordType {\n  if (refs.target === \"openAi\") {\n    console.warn(\n      \"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\"\n    );\n  }\n\n  if (\n    refs.target === \"openApi3\" &&\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum\n  ) {\n    return {\n      type: \"object\",\n      required: def.keyType._def.values,\n      properties: def.keyType._def.values.reduce(\n        (acc: Record<string, JsonSchema7Type>, key: string) => ({\n          ...acc,\n          [key]:\n            parseDef(def.valueType._def, {\n              ...refs,\n              currentPath: [...refs.currentPath, \"properties\", key],\n            }) ?? parseAnyDef(refs),\n        }),\n        {}\n      ),\n      additionalProperties: refs.rejectedAdditionalProperties,\n    } satisfies JsonSchema7ObjectType as any;\n  }\n\n  const schema: JsonSchema7RecordType = {\n    type: \"object\",\n    additionalProperties:\n      parseDef(def.valueType._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalProperties\"],\n      }) ?? refs.allowedAdditionalProperties,\n  };\n\n  if (refs.target === \"openApi3\") {\n    return schema;\n  }\n\n  if (\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n    def.keyType._def.checks?.length\n  ) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values,\n      },\n    };\n  } else if (\n    def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded &&\n    def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString &&\n    def.keyType._def.type._def.checks?.length\n  ) {\n    const { type, ...keyType } = parseBrandedDef(\n      def.keyType._def,\n      refs\n    ) as JsonSchema7StringType;\n\n    return {\n      ...schema,\n      propertyNames: keyType,\n    };\n  }\n\n  return schema;\n}\n","export * as core from \"../core/index.js\";\nexport * from \"./schemas.js\";\nexport * from \"./checks.js\";\nexport * from \"./errors.js\";\nexport * from \"./parse.js\";\nexport * from \"./compat.js\";\n// zod-specified\nimport { config } from \"../core/index.js\";\nimport en from \"../locales/en.js\";\nconfig(en());\nexport { globalRegistry, registry, config, $output, $input, $brand, clone, regexes, treeifyError, prettifyError, formatError, flattenError, toJSONSchema, TimePrecision, util, NEVER, } from \"../core/index.js\";\nexport * as locales from \"../locales/index.js\";\n// iso\n// must be exported from top-level\n// https://github.com/colinhacks/zod/issues/4491\nexport { ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration } from \"./iso.js\";\nexport * as iso from \"./iso.js\";\nexport * as coerce from \"./coerce.js\";\n","import { PendingWrite } from \"@langchain/langgraph-checkpoint\";\n\n/** Special reserved node name denoting the start of a graph. */\nexport const START = \"__start__\";\n/** Special reserved node name denoting the end of a graph. */\nexport const END = \"__end__\";\nexport const INPUT = \"__input__\";\nexport const COPY = \"__copy__\";\nexport const ERROR = \"__error__\";\n\n/** Special reserved cache namespaces */\nexport const CACHE_NS_WRITES = \"__pregel_ns_writes\";\n\nexport const CONFIG_KEY_SEND = \"__pregel_send\";\n/** config key containing function used to call a node (push task) */\nexport const CONFIG_KEY_CALL = \"__pregel_call\";\nexport const CONFIG_KEY_READ = \"__pregel_read\";\nexport const CONFIG_KEY_CHECKPOINTER = \"__pregel_checkpointer\";\nexport const CONFIG_KEY_RESUMING = \"__pregel_resuming\";\nexport const CONFIG_KEY_TASK_ID = \"__pregel_task_id\";\nexport const CONFIG_KEY_STREAM = \"__pregel_stream\";\nexport const CONFIG_KEY_RESUME_VALUE = \"__pregel_resume_value\";\nexport const CONFIG_KEY_RESUME_MAP = \"__pregel_resume_map\";\nexport const CONFIG_KEY_SCRATCHPAD = \"__pregel_scratchpad\";\n/** config key containing state from previous invocation of graph for the given thread */\nexport const CONFIG_KEY_PREVIOUS_STATE = \"__pregel_previous\";\nexport const CONFIG_KEY_DURABILITY = \"__pregel_durability\";\nexport const CONFIG_KEY_CHECKPOINT_ID = \"checkpoint_id\";\nexport const CONFIG_KEY_CHECKPOINT_NS = \"checkpoint_ns\";\n\nexport const CONFIG_KEY_NODE_FINISHED = \"__pregel_node_finished\";\n\n// this one is part of public API\nexport const CONFIG_KEY_CHECKPOINT_MAP = \"checkpoint_map\";\n\nexport const CONFIG_KEY_ABORT_SIGNALS = \"__pregel_abort_signals\";\n\n/** Special channel reserved for graph interrupts */\nexport const INTERRUPT = \"__interrupt__\";\n/** Special channel reserved for graph resume */\nexport const RESUME = \"__resume__\";\n/** Special channel reserved for cases when a task exits without any writes */\nexport const NO_WRITES = \"__no_writes__\";\n/** Special channel reserved for graph return */\nexport const RETURN = \"__return__\";\n/** Special channel reserved for graph previous state */\nexport const PREVIOUS = \"__previous__\";\nexport const RUNTIME_PLACEHOLDER = \"__pregel_runtime_placeholder__\";\nexport const RECURSION_LIMIT_DEFAULT = 25;\n\nexport const TAG_HIDDEN = \"langsmith:hidden\";\nexport const TAG_NOSTREAM = \"langsmith:nostream\";\nexport const SELF = \"__self__\";\n\nexport const TASKS = \"__pregel_tasks\";\nexport const PUSH = \"__pregel_push\";\nexport const PULL = \"__pregel_pull\";\n\nexport const TASK_NAMESPACE = \"6ba7b831-9dad-11d1-80b4-00c04fd430c8\";\nexport const NULL_TASK_ID = \"00000000-0000-0000-0000-000000000000\";\n\nexport const RESERVED = [\n  TAG_HIDDEN,\n  INPUT,\n  INTERRUPT,\n  RESUME,\n  ERROR,\n  NO_WRITES,\n\n  // reserved config.configurable keys\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_DURABILITY,\n  CONFIG_KEY_STREAM,\n  CONFIG_KEY_RESUMING,\n  CONFIG_KEY_TASK_ID,\n  CONFIG_KEY_CALL,\n  CONFIG_KEY_RESUME_VALUE,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_PREVIOUS_STATE,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CONFIG_KEY_CHECKPOINT_NS,\n  CONFIG_KEY_CHECKPOINT_ID,\n];\n\nexport const CHECKPOINT_NAMESPACE_SEPARATOR = \"|\";\nexport const CHECKPOINT_NAMESPACE_END = \":\";\n\n/** @internal */\nconst COMMAND_SYMBOL = Symbol.for(\"langgraph.command\");\n\n/**\n * Instance of a {@link Command} class.\n *\n * This is used to avoid IntelliSense suggesting public fields\n * of {@link Command} class when a plain object is expected.\n *\n * @see {@link Command}\n * @internal\n */\nexport class CommandInstance<\n  Resume = unknown,\n  Update extends Record<string, unknown> = Record<string, unknown>,\n  Nodes extends string = string\n> {\n  [COMMAND_SYMBOL]: CommandParams<Resume, Update, Nodes>;\n\n  constructor(args: CommandParams<Resume, Update, Nodes>) {\n    this[COMMAND_SYMBOL] = args;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface SendInterface<Node extends string = string, Args = any> {\n  node: Node;\n  args: Args;\n}\n\nexport function _isSendInterface(x: unknown): x is SendInterface {\n  const operation = x as SendInterface;\n  return (\n    operation !== null &&\n    operation !== undefined &&\n    typeof operation.node === \"string\" &&\n    operation.args !== undefined\n  );\n}\n\n/**\n *\n * A message or packet to send to a specific node in the graph.\n *\n * The `Send` class is used within a `StateGraph`'s conditional edges to\n * dynamically invoke a node with a custom state at the next step.\n *\n * Importantly, the sent state can differ from the core graph's state,\n * allowing for flexible and dynamic workflow management.\n *\n * One such example is a \"map-reduce\" workflow where your graph invokes\n * the same node multiple times in parallel with different states,\n * before aggregating the results back into the main graph's state.\n *\n * @example\n * ```typescript\n * import { Annotation, Send, StateGraph } from \"@langchain/langgraph\";\n *\n * const ChainState = Annotation.Root({\n *   subjects: Annotation<string[]>,\n *   jokes: Annotation<string[]>({\n *     reducer: (a, b) => a.concat(b),\n *   }),\n * });\n *\n * const continueToJokes = async (state: typeof ChainState.State) => {\n *   return state.subjects.map((subject) => {\n *     return new Send(\"generate_joke\", { subjects: [subject] });\n *   });\n * };\n *\n * const graph = new StateGraph(ChainState)\n *   .addNode(\"generate_joke\", (state) => ({\n *     jokes: [`Joke about ${state.subjects}`],\n *   }))\n *   .addConditionalEdges(\"__start__\", continueToJokes)\n *   .addEdge(\"generate_joke\", \"__end__\")\n *   .compile();\n *\n * const res = await graph.invoke({ subjects: [\"cats\", \"dogs\"] });\n * console.log(res);\n *\n * // Invoking with two subjects results in a generated joke for each\n * // { subjects: [\"cats\", \"dogs\"], jokes: [`Joke about cats`, `Joke about dogs`] }\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class Send<Node extends string = string, Args = any>\n  implements SendInterface<Node, Args>\n{\n  lg_name = \"Send\";\n\n  public node: Node;\n\n  public args: Args;\n\n  constructor(node: Node, args: Args) {\n    this.node = node;\n    this.args = _deserializeCommandSendObjectGraph(args) as Args;\n  }\n\n  toJSON() {\n    return { lg_name: this.lg_name, node: this.node, args: this.args };\n  }\n}\n\nexport function _isSend(x: unknown): x is Send {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  return x instanceof Send;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Interrupt<Value = any> = {\n  id?: string;\n  value?: Value;\n};\n\n/**\n * Checks if the given graph invoke / stream chunk contains interrupt.\n *\n * @example\n * ```ts\n * import { INTERRUPT, isInterrupted } from \"@langchain/langgraph\";\n *\n * const values = await graph.invoke({ foo: \"bar\" });\n * if (isInterrupted<string>(values)) {\n *   const interrupt = values[INTERRUPT][0].value;\n * }\n * ```\n *\n * @param values - The values to check.\n * @returns `true` if the values contain an interrupt, `false` otherwise.\n */\nexport function isInterrupted<Value = unknown>(\n  values: unknown\n): values is { [INTERRUPT]: Interrupt<Value>[] } {\n  if (!values || typeof values !== \"object\") return false;\n  if (!(INTERRUPT in values)) return false;\n  return Array.isArray(values[INTERRUPT]);\n}\n\nexport type CommandParams<\n  Resume = unknown,\n  Update extends Record<string, unknown> = Record<string, unknown>,\n  Nodes extends string = string\n> = {\n  /**\n   * A discriminator field used to identify the type of object. Must be populated when serializing.\n   *\n   * Optional because it's not required to specify this when directly constructing a {@link Command}\n   * object.\n   */\n  lg_name?: \"Command\";\n\n  /**\n   * Value to resume execution with. To be used together with {@link interrupt}.\n   */\n  resume?: Resume;\n  /**\n   * Graph to send the command to. Supported values are:\n   *   - None: the current graph (default)\n   *   - The specific name of the graph to send the command to\n   *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n   */\n  graph?: string;\n\n  /**\n   * Update to apply to the graph's state.\n   */\n  update?: Update | [string, unknown][];\n\n  /**\n   * Can be one of the following:\n   *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n   *   - sequence of node names to navigate to next\n   *   - `Send` object (to execute a node with the input provided)\n   *   - sequence of `Send` objects\n   */\n  goto?:\n    | Nodes\n    | SendInterface<Nodes> // eslint-disable-line @typescript-eslint/no-explicit-any\n    | (Nodes | SendInterface<Nodes>)[]; // eslint-disable-line @typescript-eslint/no-explicit-any\n};\n\n/**\n * One or more commands to update the graph's state and send messages to nodes.\n * Can be used to combine routing logic with state updates in lieu of conditional edges\n *\n * @example\n * ```ts\n * import { Annotation, Command } from \"@langchain/langgraph\";\n *\n * // Define graph state\n * const StateAnnotation = Annotation.Root({\n *   foo: Annotation<string>,\n * });\n *\n * // Define the nodes\n * const nodeA = async (_state: typeof StateAnnotation.State) => {\n *   console.log(\"Called A\");\n *   // this is a replacement for a real conditional edge function\n *   const goto = Math.random() > .5 ? \"nodeB\" : \"nodeC\";\n *   // note how Command allows you to BOTH update the graph state AND route to the next node\n *   return new Command({\n *     // this is the state update\n *     update: {\n *       foo: \"a\",\n *     },\n *     // this is a replacement for an edge\n *     goto,\n *   });\n * };\n *\n * // Nodes B and C are unchanged\n * const nodeB = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called B\");\n *   return {\n *     foo: state.foo + \"|b\",\n *   };\n * }\n *\n * const nodeC = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called C\");\n *   return {\n *     foo: state.foo + \"|c\",\n *   };\n * }\n * \n * import { StateGraph } from \"@langchain/langgraph\";\n\n * // NOTE: there are no edges between nodes A, B and C!\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(\"nodeA\", nodeA, {\n *     ends: [\"nodeB\", \"nodeC\"],\n *   })\n *   .addNode(\"nodeB\", nodeB)\n *   .addNode(\"nodeC\", nodeC)\n *   .addEdge(\"__start__\", \"nodeA\")\n *   .compile();\n * \n * await graph.invoke({ foo: \"\" });\n *\n * // Randomly oscillates between\n * // { foo: 'a|c' } and { foo: 'a|b' }\n * ```\n */\nexport class Command<\n  Resume = unknown,\n  Update extends Record<string, unknown> = Record<string, unknown>,\n  Nodes extends string = string\n> extends CommandInstance<Resume, Update, Nodes> {\n  readonly lg_name = \"Command\";\n\n  lc_direct_tool_output = true;\n\n  /**\n   * Graph to send the command to. Supported values are:\n   *   - None: the current graph (default)\n   *   - The specific name of the graph to send the command to\n   *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n   */\n  graph?: string;\n\n  /**\n   * Update to apply to the graph's state as a result of executing the node that is returning the command.\n   * Written to the state as if the node had simply returned this value instead of the Command object.\n   */\n  update?: Update | [string, unknown][];\n\n  /**\n   * Value to resume execution with. To be used together with {@link interrupt}.\n   */\n  resume?: Resume;\n\n  /**\n   * Can be one of the following:\n   *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n   *   - sequence of node names to navigate to next\n   *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)\n   *   - sequence of {@link Send} objects\n   */\n  goto?: Nodes | Send<Nodes> | (Nodes | Send<Nodes>)[] = [];\n\n  static PARENT = \"__parent__\";\n\n  constructor(args: Omit<CommandParams<Resume, Update, Nodes>, \"lg_name\">) {\n    super(args);\n    this.resume = args.resume;\n    this.graph = args.graph;\n    this.update = args.update;\n    if (args.goto) {\n      type ValidArg = Nodes | Send<Nodes, Update>;\n\n      this.goto = Array.isArray(args.goto)\n        ? (_deserializeCommandSendObjectGraph(args.goto) as ValidArg[])\n        : [_deserializeCommandSendObjectGraph(args.goto) as ValidArg];\n    }\n  }\n\n  /**\n   * Convert the update field to a list of {@link PendingWrite} tuples\n   * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.\n   * @internal\n   */\n  _updateAsTuples(): PendingWrite[] {\n    if (\n      this.update &&\n      typeof this.update === \"object\" &&\n      !Array.isArray(this.update)\n    ) {\n      return Object.entries(this.update);\n    } else if (\n      Array.isArray(this.update) &&\n      this.update.every(\n        (t): t is [string, unknown] =>\n          Array.isArray(t) && t.length === 2 && typeof t[0] === \"string\"\n      )\n    ) {\n      return this.update;\n    } else {\n      return [[\"__root__\", this.update]];\n    }\n  }\n\n  toJSON() {\n    let serializedGoto;\n    if (typeof this.goto === \"string\") {\n      serializedGoto = this.goto;\n    } else if (_isSend(this.goto)) {\n      serializedGoto = this.goto.toJSON();\n    } else {\n      serializedGoto = this.goto?.map((innerGoto) => {\n        if (typeof innerGoto === \"string\") {\n          return innerGoto;\n        } else {\n          return innerGoto.toJSON();\n        }\n      });\n    }\n    return {\n      lg_name: this.lg_name,\n      update: this.update,\n      resume: this.resume,\n      goto: serializedGoto,\n    };\n  }\n}\n\n/**\n * A type guard to check if the given value is a {@link Command}.\n *\n * Useful for type narrowing when working with the {@link Command} object.\n *\n * @param x - The value to check.\n * @returns `true` if the value is a {@link Command}, `false` otherwise.\n */\nexport function isCommand(x: unknown): x is Command {\n  if (typeof x !== \"object\") {\n    return false;\n  }\n\n  if (x === null || x === undefined) {\n    return false;\n  }\n\n  if (\"lg_name\" in x && x.lg_name === \"Command\") {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Reconstructs Command and Send objects from a deeply nested tree of anonymous objects\n * matching their interfaces.\n *\n * This is only exported for testing purposes. It is NOT intended to be used outside of\n * the Command and Send classes.\n *\n * @internal\n *\n * @param x - The command send tree to convert.\n * @param seen - A map of seen objects to avoid infinite loops.\n * @returns The converted command send tree.\n */\nexport function _deserializeCommandSendObjectGraph(\n  x: unknown,\n  seen: Map<object, unknown> = new Map()\n): unknown {\n  if (x !== undefined && x !== null && typeof x === \"object\") {\n    // If we've already processed this object, return the transformed version\n    if (seen.has(x)) {\n      return seen.get(x);\n    }\n\n    let result: unknown;\n\n    if (Array.isArray(x)) {\n      // Create the array first, then populate it\n      result = [];\n      // Add to seen map before processing elements to handle self-references\n      seen.set(x, result);\n\n      // Now populate the array\n      x.forEach((item, index) => {\n        (result as unknown[])[index] = _deserializeCommandSendObjectGraph(\n          item,\n          seen\n        );\n      });\n      // eslint-disable-next-line no-instanceof/no-instanceof\n    } else if (isCommand(x) && !(x instanceof Command)) {\n      result = new Command(x);\n      seen.set(x, result);\n      // eslint-disable-next-line no-instanceof/no-instanceof\n    } else if (_isSendInterface(x) && !(x instanceof Send)) {\n      result = new Send(x.node, x.args);\n      seen.set(x, result);\n    } else if (isCommand(x) || _isSend(x)) {\n      result = x;\n      seen.set(x, result);\n    } else if (\"lc_serializable\" in x && x.lc_serializable) {\n      result = x;\n      seen.set(x, result);\n    } else {\n      // Create empty object first\n      result = {};\n      // Add to seen map before processing properties to handle self-references\n      seen.set(x, result);\n\n      // Now populate the object\n      for (const [key, value] of Object.entries(x)) {\n        (result as Record<string, unknown>)[key] =\n          _deserializeCommandSendObjectGraph(value, seen);\n      }\n    }\n\n    return result;\n  }\n  return x;\n}\n","import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n","import { ZodNumberDef } from \"zod/v3\";\nimport {\n  addErrorMessage,\n  ErrorMessages,\n  setResponseValueAndErrors,\n} from \"../errorMessages.js\";\nimport { Refs } from \"../Refs.js\";\n\nexport type JsonSchema7NumberType = {\n  type: \"number\" | \"integer\";\n  minimum?: number;\n  exclusiveMinimum?: number;\n  maximum?: number;\n  exclusiveMaximum?: number;\n  multipleOf?: number;\n  errorMessage?: ErrorMessages<JsonSchema7NumberType>;\n};\n\nexport function parseNumberDef(\n  def: ZodNumberDef,\n  refs: Refs\n): JsonSchema7NumberType {\n  const res: JsonSchema7NumberType = {\n    type: \"number\",\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        addErrorMessage(res, \"type\", check.message, refs);\n        break;\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(\n              res,\n              \"minimum\",\n              check.value,\n              check.message,\n              refs\n            );\n          } else {\n            setResponseValueAndErrors(\n              res,\n              \"exclusiveMinimum\",\n              check.value,\n              check.message,\n              refs\n            );\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true as any;\n          }\n          setResponseValueAndErrors(\n            res,\n            \"minimum\",\n            check.value,\n            check.message,\n            refs\n          );\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(\n              res,\n              \"maximum\",\n              check.value,\n              check.message,\n              refs\n            );\n          } else {\n            setResponseValueAndErrors(\n              res,\n              \"exclusiveMaximum\",\n              check.value,\n              check.message,\n              refs\n            );\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true as any;\n          }\n          setResponseValueAndErrors(\n            res,\n            \"maximum\",\n            check.value,\n            check.message,\n            refs\n          );\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(\n          res,\n          \"multipleOf\",\n          check.value,\n          check.message,\n          refs\n        );\n        break;\n    }\n  }\n  return res;\n}\n","import { ZodTypeDef } from \"zod/v3\";\nimport { Refs, Seen } from \"./Refs.js\";\nimport { ignoreOverride } from \"./Options.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\nimport { selectParser } from \"./selectParser.js\";\nimport { getRelativePath } from \"./getRelativePath.js\";\nimport { parseAnyDef } from \"./parsers/any.js\";\n\nexport function parseDef(\n  def: ZodTypeDef,\n  refs: Refs,\n  forceResolution = false // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.\n): JsonSchema7Type | undefined {\n  const seenItem = refs.seen.get(def);\n\n  if (refs.override) {\n    const overrideResult = refs.override?.(\n      def,\n      refs,\n      seenItem,\n      forceResolution\n    );\n\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n\n  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };\n\n  refs.seen.set(def, newItem);\n\n  const jsonSchemaOrGetter = selectParser(def, (def as any).typeName, refs);\n\n  // If the return was a function, then the inner definition needs to be extracted before a call to parseDef (recursive)\n  const jsonSchema =\n    typeof jsonSchemaOrGetter === \"function\"\n      ? parseDef(jsonSchemaOrGetter(), refs)\n      : jsonSchemaOrGetter;\n\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n\n    newItem.jsonSchema = jsonSchema;\n\n    return postProcessResult;\n  }\n\n  newItem.jsonSchema = jsonSchema;\n\n  return jsonSchema;\n}\n\nconst get$ref = (\n  item: Seen,\n  refs: Refs\n):\n  | {\n      $ref: string;\n    }\n  | {}\n  | undefined => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (\n        item.path.length < refs.currentPath.length &&\n        item.path.every((value, index) => refs.currentPath[index] === value)\n      ) {\n        console.warn(\n          `Recursive reference detected at ${refs.currentPath.join(\n            \"/\"\n          )}! Defaulting to any`\n        );\n\n        return parseAnyDef(refs);\n      }\n\n      return refs.$refStrategy === \"seen\" ? parseAnyDef(refs) : undefined;\n    }\n  }\n};\n\nconst addMeta = (\n  def: ZodTypeDef,\n  refs: Refs,\n  jsonSchema: JsonSchema7Type\n): JsonSchema7Type => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};\n","import {\n  Serializable,\n  SerializedConstructor,\n  SerializedNotImplemented,\n  SerializedSecret,\n  get_lc_unique_name,\n} from \"./serializable.js\";\nimport { optionalImportEntrypoints as defaultOptionalImportEntrypoints } from \"./import_constants.js\";\nimport * as coreImportMap from \"./import_map.js\";\nimport type { OptionalImportMap, SecretMap } from \"./import_type.js\";\nimport { type SerializedFields, keyFromJson, mapKeys } from \"./map_keys.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\nfunction combineAliasesAndInvert(constructor: typeof Serializable) {\n  const aliases: { [key: string]: string } = {};\n  for (\n    let current = constructor;\n    current && current.prototype;\n    current = Object.getPrototypeOf(current)\n  ) {\n    Object.assign(aliases, Reflect.get(current.prototype, \"lc_aliases\"));\n  }\n  return Object.entries(aliases).reduce((acc, [key, value]) => {\n    acc[value] = key;\n    return acc;\n  }, {} as Record<string, string>);\n}\n\nasync function reviver(\n  this: {\n    optionalImportsMap?: OptionalImportMap;\n    optionalImportEntrypoints?: string[];\n    secretsMap?: SecretMap;\n    importMap?: Record<string, unknown>;\n    path?: string[];\n  },\n  value: unknown\n): Promise<unknown> {\n  const {\n    optionalImportsMap = {},\n    optionalImportEntrypoints = [],\n    importMap = {},\n    secretsMap = {},\n    path = [\"$\"],\n  } = this;\n  const pathStr = path.join(\".\");\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    \"lc\" in value &&\n    \"type\" in value &&\n    \"id\" in value &&\n    value.lc === 1 &&\n    value.type === \"secret\"\n  ) {\n    const serialized = value as SerializedSecret;\n    const [key] = serialized.id;\n    if (key in secretsMap) {\n      return secretsMap[key as keyof SecretMap];\n    } else {\n      const secretValueInEnv = getEnvironmentVariable(key);\n      if (secretValueInEnv) {\n        return secretValueInEnv;\n      } else {\n        throw new Error(\n          `Missing key \"${key}\" for ${pathStr} in load(secretsMap={})`\n        );\n      }\n    }\n  } else if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    \"lc\" in value &&\n    \"type\" in value &&\n    \"id\" in value &&\n    value.lc === 1 &&\n    value.type === \"not_implemented\"\n  ) {\n    const serialized = value as SerializedNotImplemented;\n    const str = JSON.stringify(serialized);\n    throw new Error(\n      `Trying to load an object that doesn't implement serialization: ${pathStr} -> ${str}`\n    );\n  } else if (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    \"lc\" in value &&\n    \"type\" in value &&\n    \"id\" in value &&\n    \"kwargs\" in value &&\n    value.lc === 1\n  ) {\n    const serialized = value as SerializedConstructor;\n    const str = JSON.stringify(serialized);\n    const [name, ...namespaceReverse] = serialized.id.slice().reverse();\n    const namespace = namespaceReverse.reverse();\n    const importMaps = { langchain_core: coreImportMap, langchain: importMap };\n\n    let module:\n      | (typeof importMaps)[\"langchain_core\"][keyof (typeof importMaps)[\"langchain_core\"]]\n      | (typeof importMaps)[\"langchain\"][keyof (typeof importMaps)[\"langchain\"]]\n      | OptionalImportMap[keyof OptionalImportMap]\n      | null = null;\n\n    const optionalImportNamespaceAliases = [namespace.join(\"/\")];\n    if (namespace[0] === \"langchain_community\") {\n      optionalImportNamespaceAliases.push(\n        [\"langchain\", ...namespace.slice(1)].join(\"/\")\n      );\n    }\n    const matchingNamespaceAlias = optionalImportNamespaceAliases.find(\n      (alias) => alias in optionalImportsMap\n    );\n    if (\n      defaultOptionalImportEntrypoints\n        .concat(optionalImportEntrypoints)\n        .includes(namespace.join(\"/\")) ||\n      matchingNamespaceAlias\n    ) {\n      if (matchingNamespaceAlias !== undefined) {\n        module = await optionalImportsMap[\n          matchingNamespaceAlias as keyof typeof optionalImportsMap\n        ];\n      } else {\n        throw new Error(\n          `Missing key \"${namespace.join(\n            \"/\"\n          )}\" for ${pathStr} in load(optionalImportsMap={})`\n        );\n      }\n    } else {\n      let finalImportMap:\n        | (typeof importMaps)[\"langchain\"]\n        | (typeof importMaps)[\"langchain_core\"];\n      // Currently, we only support langchain and langchain_core imports.\n      if (namespace[0] === \"langchain\" || namespace[0] === \"langchain_core\") {\n        finalImportMap = importMaps[namespace[0]];\n        namespace.shift();\n      } else {\n        throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n      }\n\n      // The root namespace \"langchain\" is not a valid import.\n      if (namespace.length === 0) {\n        throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n      }\n\n      // Find the longest matching namespace.\n      let importMapKey: string;\n      do {\n        importMapKey = namespace.join(\"__\");\n        if (importMapKey in finalImportMap) {\n          break;\n        } else {\n          namespace.pop();\n        }\n      } while (namespace.length > 0);\n\n      // If no matching namespace is found, throw an error.\n      if (importMapKey in finalImportMap) {\n        module = finalImportMap[importMapKey as keyof typeof finalImportMap];\n      }\n    }\n\n    if (typeof module !== \"object\" || module === null) {\n      throw new Error(`Invalid namespace: ${pathStr} -> ${str}`);\n    }\n\n    // Extract the builder from the import map.\n    const builder =\n      // look for a named export with the same name as the class\n      module[name as keyof typeof module] ??\n      // look for an export with a lc_name property matching the class name\n      // this is necessary for classes that are minified\n      Object.values(module).find(\n        (v) =>\n          typeof v === \"function\" &&\n          get_lc_unique_name(v as typeof Serializable) === name\n      );\n    if (typeof builder !== \"function\") {\n      throw new Error(`Invalid identifer: ${pathStr} -> ${str}`);\n    }\n\n    // Recurse on the arguments, which may be serialized objects themselves\n    const kwargs = await reviver.call(\n      { ...this, path: [...path, \"kwargs\"] },\n      serialized.kwargs\n    );\n\n    // Construct the object\n    if (serialized.type === \"constructor\") {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const instance = new (builder as any)(\n        mapKeys(\n          kwargs as SerializedFields,\n          keyFromJson,\n          combineAliasesAndInvert(builder)\n        )\n      );\n\n      // Minification in severless/edge runtimes will mange the\n      // name of classes presented in traces. As the names in import map\n      // are present as-is even with minification, use these names instead\n      Object.defineProperty(instance.constructor, \"name\", { value: name });\n\n      return instance;\n    } else {\n      throw new Error(`Invalid type: ${pathStr} -> ${str}`);\n    }\n  } else if (typeof value === \"object\" && value !== null) {\n    if (Array.isArray(value)) {\n      return Promise.all(\n        value.map((v, i) =>\n          reviver.call({ ...this, path: [...path, `${i}`] }, v)\n        )\n      );\n    } else {\n      return Object.fromEntries(\n        await Promise.all(\n          Object.entries(value).map(async ([key, value]) => [\n            key,\n            await reviver.call({ ...this, path: [...path, key] }, value),\n          ])\n        )\n      );\n    }\n  }\n  return value;\n}\n\nexport async function load<T>(\n  text: string,\n  mappings?: {\n    secretsMap?: SecretMap;\n    optionalImportsMap?: OptionalImportMap;\n    optionalImportEntrypoints?: string[];\n    importMap?: Record<string, unknown>;\n  }\n): Promise<T> {\n  const json = JSON.parse(text);\n  return reviver.call({ ...mappings }, json) as Promise<T>;\n}\n","import isNetworkError from 'is-network-error';\n\nfunction validateRetries(retries) {\n\tif (typeof retries === 'number') {\n\t\tif (retries < 0) {\n\t\t\tthrow new TypeError('Expected `retries` to be a non-negative number.');\n\t\t}\n\n\t\tif (Number.isNaN(retries)) {\n\t\t\tthrow new TypeError('Expected `retries` to be a valid number or Infinity, got NaN.');\n\t\t}\n\t} else if (retries !== undefined) {\n\t\tthrow new TypeError('Expected `retries` to be a number or Infinity.');\n\t}\n}\n\nfunction validateNumberOption(name, value, {min = 0, allowInfinity = false} = {}) {\n\tif (value === undefined) {\n\t\treturn;\n\t}\n\n\tif (typeof value !== 'number' || Number.isNaN(value)) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? ' or Infinity' : ''}.`);\n\t}\n\n\tif (!allowInfinity && !Number.isFinite(value)) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n\t}\n\n\tif (value < min) {\n\t\tthrow new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n\t}\n}\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nfunction calculateDelay(retriesConsumed, options) {\n\tconst attempt = Math.max(1, retriesConsumed + 1);\n\tconst random = options.randomize ? (Math.random() + 1) : 1;\n\n\tlet timeout = Math.round(random * options.minTimeout * (options.factor ** (attempt - 1)));\n\ttimeout = Math.min(timeout, options.maxTimeout);\n\n\treturn timeout;\n}\n\nfunction calculateRemainingTime(start, max) {\n\tif (!Number.isFinite(max)) {\n\t\treturn max;\n\t}\n\n\treturn max - (performance.now() - start);\n}\n\nasync function onAttemptFailure({error, attemptNumber, retriesConsumed, startTime, options}) {\n\tconst normalizedError = error instanceof Error\n\t\t? error\n\t\t: new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\n\tif (normalizedError instanceof AbortError) {\n\t\tthrow normalizedError.originalError;\n\t}\n\n\tconst retriesLeft = Number.isFinite(options.retries)\n\t\t? Math.max(0, options.retries - retriesConsumed)\n\t\t: options.retries;\n\n\tconst maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n\n\tconst context = Object.freeze({\n\t\terror: normalizedError,\n\t\tattemptNumber,\n\t\tretriesLeft,\n\t\tretriesConsumed,\n\t});\n\n\tawait options.onFailedAttempt(context);\n\n\tif (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n\t\tthrow normalizedError;\n\t}\n\n\tconst consumeRetry = await options.shouldConsumeRetry(context);\n\n\tconst remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n\n\tif (remainingTime <= 0 || retriesLeft <= 0) {\n\t\tthrow normalizedError;\n\t}\n\n\tif (normalizedError instanceof TypeError && !isNetworkError(normalizedError)) {\n\t\tif (consumeRetry) {\n\t\t\tthrow normalizedError;\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\t\treturn false;\n\t}\n\n\tif (!await options.shouldRetry(context)) {\n\t\tthrow normalizedError;\n\t}\n\n\tif (!consumeRetry) {\n\t\toptions.signal?.throwIfAborted();\n\t\treturn false;\n\t}\n\n\tconst delayTime = calculateDelay(retriesConsumed, options);\n\tconst finalDelay = Math.min(delayTime, remainingTime);\n\n\tif (finalDelay > 0) {\n\t\tawait new Promise((resolve, reject) => {\n\t\t\tconst onAbort = () => {\n\t\t\t\tclearTimeout(timeoutToken);\n\t\t\t\toptions.signal?.removeEventListener('abort', onAbort);\n\t\t\t\treject(options.signal.reason);\n\t\t\t};\n\n\t\t\tconst timeoutToken = setTimeout(() => {\n\t\t\t\toptions.signal?.removeEventListener('abort', onAbort);\n\t\t\t\tresolve();\n\t\t\t}, finalDelay);\n\n\t\t\tif (options.unref) {\n\t\t\t\ttimeoutToken.unref?.();\n\t\t\t}\n\n\t\t\toptions.signal?.addEventListener('abort', onAbort, {once: true});\n\t\t});\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\treturn true;\n}\n\nexport default async function pRetry(input, options = {}) {\n\toptions = {...options};\n\n\tvalidateRetries(options.retries);\n\n\tif (Object.hasOwn(options, 'forever')) {\n\t\tthrow new Error('The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.');\n\t}\n\n\toptions.retries ??= 10;\n\toptions.factor ??= 2;\n\toptions.minTimeout ??= 1000;\n\toptions.maxTimeout ??= Number.POSITIVE_INFINITY;\n\toptions.maxRetryTime ??= Number.POSITIVE_INFINITY;\n\toptions.randomize ??= false;\n\toptions.onFailedAttempt ??= () => {};\n\toptions.shouldRetry ??= () => true;\n\toptions.shouldConsumeRetry ??= () => true;\n\n\t// Validate numeric options and normalize edge cases\n\tvalidateNumberOption('factor', options.factor, {min: 0, allowInfinity: false});\n\tvalidateNumberOption('minTimeout', options.minTimeout, {min: 0, allowInfinity: false});\n\tvalidateNumberOption('maxTimeout', options.maxTimeout, {min: 0, allowInfinity: true});\n\tvalidateNumberOption('maxRetryTime', options.maxRetryTime, {min: 0, allowInfinity: true});\n\n\t// Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n\tif (!(options.factor > 0)) {\n\t\toptions.factor = 1;\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tlet attemptNumber = 0;\n\tlet retriesConsumed = 0;\n\tconst startTime = performance.now();\n\n\twhile (Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true) {\n\t\tattemptNumber++;\n\n\t\ttry {\n\t\t\toptions.signal?.throwIfAborted();\n\n\t\t\tconst result = await input(attemptNumber);\n\n\t\t\toptions.signal?.throwIfAborted();\n\n\t\t\treturn result;\n\t\t} catch (error) {\n\t\t\tif (await onAttemptFailure({\n\t\t\t\terror,\n\t\t\t\tattemptNumber,\n\t\t\t\tretriesConsumed,\n\t\t\t\tstartTime,\n\t\t\t\toptions,\n\t\t\t})) {\n\t\t\t\tretriesConsumed++;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Should not reach here, but in case it does, throw an error\n\tthrow new Error('Retry attempts exhausted without throwing an error.');\n}\n\nexport function makeRetriable(function_, options) {\n\treturn function (...arguments_) {\n\t\treturn pRetry(() => function_.apply(this, arguments_), options);\n\t};\n}\n","import { _mergeDicts } from \"./base.js\";\nimport type { MessageOutputVersion } from \"./message.js\";\n\nexport type ResponseMetadata = {\n  model_provider?: string;\n  model_name?: string;\n  output_version?: MessageOutputVersion;\n  [key: string]: unknown;\n};\n\nexport function mergeResponseMetadata(\n  a?: ResponseMetadata,\n  b?: ResponseMetadata\n): ResponseMetadata {\n  const output: ResponseMetadata = _mergeDicts(a ?? {}, b ?? {});\n  return output;\n}\n\nexport type ModalitiesTokenDetails = {\n  /**\n   * Text tokens.\n   * Does not need to be reported, but some models will do so.\n   */\n  text?: number;\n\n  /**\n   * Image (non-video) tokens.\n   */\n  image?: number;\n\n  /**\n   * Audio tokens.\n   */\n  audio?: number;\n\n  /**\n   * Video tokens.\n   */\n  video?: number;\n\n  /**\n   * Document tokens.\n   * e.g. PDF\n   */\n  document?: number;\n};\n\nfunction mergeModalitiesTokenDetails(\n  a?: ModalitiesTokenDetails,\n  b?: ModalitiesTokenDetails\n): ModalitiesTokenDetails {\n  const output: ModalitiesTokenDetails = {};\n  if (a?.audio !== undefined || b?.audio !== undefined) {\n    output.audio = (a?.audio ?? 0) + (b?.audio ?? 0);\n  }\n  if (a?.image !== undefined || b?.image !== undefined) {\n    output.image = (a?.image ?? 0) + (b?.image ?? 0);\n  }\n  if (a?.video !== undefined || b?.video !== undefined) {\n    output.video = (a?.video ?? 0) + (b?.video ?? 0);\n  }\n  if (a?.document !== undefined || b?.document !== undefined) {\n    output.document = (a?.document ?? 0) + (b?.document ?? 0);\n  }\n  if (a?.text !== undefined || b?.text !== undefined) {\n    output.text = (a?.text ?? 0) + (b?.text ?? 0);\n  }\n  return output;\n}\n\n/**\n * Breakdown of input token counts.\n *\n * Does not *need* to sum to full input token count. Does *not* need to have all keys.\n */\nexport type InputTokenDetails = ModalitiesTokenDetails & {\n  /**\n   * Input tokens that were cached and there was a cache hit.\n   *\n   * Since there was a cache hit, the tokens were read from the cache.\n   * More precisely, the model state given these tokens was read from the cache.\n   */\n  cache_read?: number;\n\n  /**\n   * Input tokens that were cached and there was a cache miss.\n   *\n   * Since there was a cache miss, the cache was created from these tokens.\n   */\n  cache_creation?: number;\n};\n\nfunction mergeInputTokenDetails(\n  a?: InputTokenDetails,\n  b?: InputTokenDetails\n): InputTokenDetails {\n  const output: InputTokenDetails = {\n    ...mergeModalitiesTokenDetails(a, b),\n  };\n  if (a?.cache_read !== undefined || b?.cache_read !== undefined) {\n    output.cache_read = (a?.cache_read ?? 0) + (b?.cache_read ?? 0);\n  }\n  if (a?.cache_creation !== undefined || b?.cache_creation !== undefined) {\n    output.cache_creation = (a?.cache_creation ?? 0) + (b?.cache_creation ?? 0);\n  }\n  return output;\n}\n\n/**\n * Breakdown of output token counts.\n *\n * Does *not* need to sum to full output token count. Does *not* need to have all keys.\n */\nexport type OutputTokenDetails = ModalitiesTokenDetails & {\n  /**\n   * Reasoning output tokens.\n   *\n   * Tokens generated by the model in a chain of thought process (i.e. by\n   * OpenAI's o1 models) that are not returned as part of model output.\n   */\n  reasoning?: number;\n};\n\nfunction mergeOutputTokenDetails(\n  a?: OutputTokenDetails,\n  b?: OutputTokenDetails\n): OutputTokenDetails {\n  const output: OutputTokenDetails = {\n    ...mergeModalitiesTokenDetails(a, b),\n  };\n  if (a?.reasoning !== undefined || b?.reasoning !== undefined) {\n    output.reasoning = (a?.reasoning ?? 0) + (b?.reasoning ?? 0);\n  }\n  return output;\n}\n\n/**\n * Usage metadata for a message, such as token counts.\n */\nexport type UsageMetadata = {\n  /**\n   * Count of input (or prompt) tokens. Sum of all input token types.\n   */\n  input_tokens: number;\n  /**\n   * Count of output (or completion) tokens. Sum of all output token types.\n   */\n  output_tokens: number;\n  /**\n   * Total token count. Sum of input_tokens + output_tokens.\n   */\n  total_tokens: number;\n\n  /**\n   * Breakdown of input token counts.\n   *\n   * Does *not* need to sum to full input token count. Does *not* need to have all keys.\n   */\n  input_token_details?: InputTokenDetails;\n\n  /**\n   * Breakdown of output token counts.\n   *\n   * Does *not* need to sum to full output token count. Does *not* need to have all keys.\n   */\n  output_token_details?: OutputTokenDetails;\n};\n\nexport function mergeUsageMetadata(\n  a?: UsageMetadata,\n  b?: UsageMetadata\n): UsageMetadata {\n  return {\n    input_tokens: (a?.input_tokens ?? 0) + (b?.input_tokens ?? 0),\n    output_tokens: (a?.output_tokens ?? 0) + (b?.output_tokens ?? 0),\n    total_tokens: (a?.total_tokens ?? 0) + (b?.total_tokens ?? 0),\n    input_token_details: mergeInputTokenDetails(\n      a?.input_token_details,\n      b?.input_token_details\n    ),\n    output_token_details: mergeOutputTokenDetails(\n      a?.output_token_details,\n      b?.output_token_details\n    ),\n  };\n}\n","import { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { ChatGeneration, Generation, GenerationChunk } from \"../outputs.js\";\nimport { BaseMessage } from \"../messages/base.js\";\n\n/**\n * Data associated with a StreamEvent.\n */\nexport type StreamEventData = {\n  /**\n   * The input passed to the runnable that generated the event.\n   * Inputs will sometimes be available at the *START* of the runnable, and\n   * sometimes at the *END* of the runnable.\n   * If a runnable is able to stream its inputs, then its input by definition\n   * won't be known until the *END* of the runnable when it has finished streaming\n   * its inputs.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any;\n\n  /**\n   * The output of the runnable that generated the event.\n   * Outputs will only be available at the *END* of the runnable.\n   * For most runnables, this field can be inferred from the `chunk` field,\n   * though there might be some exceptions for special cased runnables (e.g., like\n   * chat models), which may return more information.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output?: any;\n\n  /**\n   * A streaming chunk from the output that generated the event.\n   * chunks support addition in general, and adding them up should result\n   * in the output of the runnable that generated the event.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk?: any;\n};\n\n/**\n * A streaming event.\n *\n * Schema of a streaming event which is produced from the streamEvents method.\n */\nexport type StreamEvent = {\n  /**\n   * Event names are of the format: on_[runnable_type]_(start|stream|end).\n   *\n   * Runnable types are one of:\n   * - llm - used by non chat models\n   * - chat_model - used by chat models\n   * - prompt --  e.g., ChatPromptTemplate\n   * - tool -- LangChain tools\n   * - chain - most Runnables are of this type\n   *\n   * Further, the events are categorized as one of:\n   * - start - when the runnable starts\n   * - stream - when the runnable is streaming\n   * - end - when the runnable ends\n   *\n   * start, stream and end are associated with slightly different `data` payload.\n   *\n   * Please see the documentation for `EventData` for more details.\n   */\n  event: string;\n  /** The name of the runnable that generated the event. */\n  name: string;\n  /**\n   * An randomly generated ID to keep track of the execution of the given runnable.\n   *\n   * Each child runnable that gets invoked as part of the execution of a parent runnable\n   * is assigned its own unique ID.\n   */\n  run_id: string;\n  /**\n   * Tags associated with the runnable that generated this event.\n   * Tags are always inherited from parent runnables.\n   */\n  tags?: string[];\n  /** Metadata associated with the runnable that generated this event. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /**\n   * Event data.\n   *\n   * The contents of the event data depend on the event type.\n   */\n  data: StreamEventData;\n};\n\ntype RunInfo = {\n  name: string;\n  tags: string[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  runType: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: Record<string, any>;\n};\n\nexport interface EventStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n}\n\nfunction assignName({\n  name,\n  serialized,\n}: {\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  serialized?: Record<string, any>;\n}): string {\n  if (name !== undefined) {\n    return name;\n  }\n  if (serialized?.name !== undefined) {\n    return serialized.name;\n  } else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n    return serialized.id[serialized.id.length - 1];\n  }\n  return \"Unnamed\";\n}\n\nexport const isStreamEventsHandler = (\n  handler: BaseCallbackHandler\n): handler is EventStreamCallbackHandler =>\n  handler.name === \"event_stream_tracer\";\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  private runInfoMap: Map<string, RunInfo> = new Map();\n\n  private tappedPromises: Map<string, Promise<void>> = new Map();\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<StreamEvent>;\n\n  name = \"event_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: EventStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: RunInfo): boolean {\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.runType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.runType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    outputStream: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    const firstChunk = await outputStream.next();\n    if (firstChunk.done) {\n      return;\n    }\n    const runInfo = this.runInfoMap.get(runId);\n    // Run has finished, don't issue any stream events.\n    // An example of this is for runnables that use the default\n    // implementation of .stream(), which delegates to .invoke()\n    // and calls .onChainEnd() before passing it to the iterator.\n    if (runInfo === undefined) {\n      yield firstChunk.value;\n      return;\n    }\n    // Match format from handlers below\n    function _formatOutputChunk(eventType: string, data: unknown) {\n      if (eventType === \"llm\" && typeof data === \"string\") {\n        return new GenerationChunk({ text: data });\n      }\n      return data;\n    }\n    let tappedPromise = this.tappedPromises.get(runId);\n    // if we are the first to tap, issue stream events\n    if (tappedPromise === undefined) {\n      let tappedPromiseResolver: (() => void) | undefined;\n      tappedPromise = new Promise((resolve) => {\n        tappedPromiseResolver = resolve;\n      });\n      this.tappedPromises.set(runId, tappedPromise);\n      try {\n        const event: StreamEvent = {\n          event: `on_${runInfo.runType}_stream`,\n          run_id: runId,\n          name: runInfo.name,\n          tags: runInfo.tags,\n          metadata: runInfo.metadata,\n          data: {},\n        };\n        await this.send(\n          {\n            ...event,\n            data: {\n              chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n            },\n          },\n          runInfo\n        );\n        yield firstChunk.value;\n        for await (const chunk of outputStream) {\n          // Don't yield tool and retriever stream events\n          if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n            await this.send(\n              {\n                ...event,\n                data: {\n                  chunk: _formatOutputChunk(runInfo.runType, chunk),\n                },\n              },\n              runInfo\n            );\n          }\n          yield chunk;\n        }\n      } finally {\n        tappedPromiseResolver?.();\n        // Don't delete from the promises map to keep track of which runs have been tapped.\n      }\n    } else {\n      // otherwise just pass through\n      yield firstChunk.value;\n      for await (const chunk of outputStream) {\n        yield chunk;\n      }\n    }\n  }\n\n  async send(payload: StreamEvent, run: RunInfo) {\n    if (this._includeRun(run)) {\n      await this.writer.write(payload);\n    }\n  }\n\n  async sendEndEvent(payload: StreamEvent, run: RunInfo) {\n    const tappedPromise = this.tappedPromises.get(payload.run_id);\n    if (tappedPromise !== undefined) {\n      // eslint-disable-next-line no-void\n      void tappedPromise.then(() => {\n        // eslint-disable-next-line no-void\n        void this.send(payload, run);\n      });\n    } else {\n      await this.send(payload, run);\n    }\n  }\n\n  async onLLMStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: run.inputs,\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    const eventName = `on_${runType}_start`;\n    await this.send(\n      {\n        event: eventName,\n        data: {\n          input: run.inputs,\n        },\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    let chunk;\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n    }\n    // Top-level streaming events are covered by tapOutputIterable\n    if (this.runInfoMap.size === 1) {\n      return;\n    }\n    if (runInfo.runType === \"chat_model\") {\n      eventName = \"on_chat_model_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new AIMessageChunk({ content: token, id: `run-${run.id}` });\n      } else {\n        chunk = kwargs.chunk.message;\n      }\n    } else if (runInfo.runType === \"llm\") {\n      eventName = \"on_llm_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new GenerationChunk({ text: token });\n      } else {\n        chunk = kwargs.chunk;\n      }\n    } else {\n      throw new Error(`Unexpected run type ${runInfo.runType}`);\n    }\n    await this.send(\n      {\n        event: eventName,\n        data: {\n          chunk,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onLLMEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    let eventName: string;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const generations: ChatGeneration[][] | Generation[][] | undefined =\n      run.outputs?.generations;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let output: BaseMessage | Record<string, any> | undefined;\n    if (runInfo.runType === \"chat_model\") {\n      for (const generation of generations ?? []) {\n        if (output !== undefined) {\n          break;\n        }\n        output = (generation[0] as ChatGeneration | undefined)?.message;\n      }\n      eventName = \"on_chat_model_end\";\n    } else if (runInfo.runType === \"llm\") {\n      output = {\n        generations: generations?.map((generation) => {\n          return generation.map((chunk) => {\n            return {\n              text: chunk.text,\n              generationInfo: chunk.generationInfo,\n            };\n          });\n        }),\n        llmOutput: run.outputs?.llmOutput ?? {},\n      };\n      eventName = \"on_llm_end\";\n    } else {\n      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n    }\n    await this.sendEndEvent(\n      {\n        event: eventName,\n        data: {\n          output,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onChainStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = run.run_type ?? \"chain\";\n    const runInfo: RunInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: run.run_type,\n    };\n    let eventData: StreamEventData = {};\n    // Workaround Runnable core code not sending input when transform streaming.\n    if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n      eventData = {};\n      runInfo.inputs = {};\n    } else if (run.inputs.input !== undefined) {\n      eventData.input = run.inputs.input;\n      runInfo.inputs = run.inputs.input;\n    } else {\n      eventData.input = run.inputs;\n      runInfo.inputs = run.inputs;\n    }\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: `on_${runType}_start`,\n        data: eventData,\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onChainEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const eventName = `on_${run.run_type}_end`;\n    const inputs = run.inputs ?? runInfo.inputs ?? {};\n    const outputs = run.outputs?.output ?? run.outputs;\n    const data: StreamEventData = {\n      output: outputs,\n      input: inputs,\n    };\n    if (inputs.input && Object.keys(inputs).length === 1) {\n      data.input = inputs.input;\n      runInfo.inputs = inputs.input;\n    }\n    await this.sendEndEvent(\n      {\n        event: eventName,\n        data,\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onToolStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: \"tool\",\n      inputs: run.inputs ?? {},\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: \"on_tool_start\",\n        data: {\n          input: run.inputs ?? {},\n        },\n        name: runName,\n        run_id: run.id,\n        tags: run.tags ?? [],\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onToolEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n    }\n    if (runInfo.inputs === undefined) {\n      throw new Error(\n        `onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`\n      );\n    }\n    const output =\n      run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n    await this.sendEndEvent(\n      {\n        event: \"on_tool_end\",\n        data: {\n          output,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  async onRetrieverStart(run: Run): Promise<void> {\n    const runName = assignName(run);\n    const runType = \"retriever\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: {\n        query: run.inputs.query,\n      },\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send(\n      {\n        event: \"on_retriever_start\",\n        data: {\n          input: {\n            query: run.inputs.query,\n          },\n        },\n        name: runName,\n        tags: run.tags ?? [],\n        run_id: run.id,\n        metadata: run.extra?.metadata ?? {},\n      },\n      runInfo\n    );\n  }\n\n  async onRetrieverEnd(run: Run): Promise<void> {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n    }\n    await this.sendEndEvent(\n      {\n        event: \"on_retriever_end\",\n        data: {\n          output: run.outputs?.documents ?? run.outputs,\n          input: runInfo.inputs,\n        },\n        run_id: run.id,\n        name: runInfo.name,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n      },\n      runInfo\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleCustomEvent(eventName: string, data: any, runId: string) {\n    const runInfo = this.runInfoMap.get(runId);\n    if (runInfo === undefined) {\n      throw new Error(\n        `handleCustomEvent: Run ID ${runId} not found in run map.`\n      );\n    }\n    await this.send(\n      {\n        event: \"on_custom_event\",\n        run_id: runId,\n        name: eventName,\n        tags: runInfo.tags,\n        metadata: runInfo.metadata,\n        data,\n      },\n      runInfo\n    );\n  }\n\n  async finish() {\n    const pendingPromises = [...this.tappedPromises.values()];\n    // eslint-disable-next-line no-void\n    void Promise.all(pendingPromises).finally(() => {\n      // eslint-disable-next-line no-void\n      void this.writer.close();\n    });\n  }\n}\n","import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\n\n/**\n * Convert a v1 UUID to a v6 UUID\n *\n * @param {string|Uint8Array} uuid - The v1 UUID to convert to v6\n * @returns {string|Uint8Array} The v6 UUID as the same type as the `uuid` arg\n * (string or Uint8Array)\n */\nexport default function v1ToV6(uuid) {\n  const v1Bytes = typeof uuid === 'string' ? parse(uuid) : uuid;\n  const v6Bytes = _v1ToV6(v1Bytes);\n  return typeof uuid === 'string' ? unsafeStringify(v6Bytes) : v6Bytes;\n}\n\n// Do the field transformation needed for v1 -> v6\nfunction _v1ToV6(v1Bytes, randomize = false) {\n  return Uint8Array.of((v1Bytes[6] & 0x0f) << 4 | v1Bytes[7] >> 4 & 0x0f, (v1Bytes[7] & 0x0f) << 4 | (v1Bytes[4] & 0xf0) >> 4, (v1Bytes[4] & 0x0f) << 4 | (v1Bytes[5] & 0xf0) >> 4, (v1Bytes[5] & 0x0f) << 4 | (v1Bytes[0] & 0xf0) >> 4, (v1Bytes[0] & 0x0f) << 4 | (v1Bytes[1] & 0xf0) >> 4, (v1Bytes[1] & 0x0f) << 4 | (v1Bytes[2] & 0xf0) >> 4, 0x60 | v1Bytes[2] & 0x0f, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}","/**\n *Returns the Inner Product similarity between vectors a and b\n * @link [Inner Product Similarity algorithm](https://www.naun.org/main/NAUN/ijmmas/mmmas-49.pdf)\n * @param a - first vector\n * @param b - second vector\n *\n */\nexport function innerProduct(a: number[], b: number[]): number {\n  let ans = 0;\n  for (let i = 0; i < a.length; i++) {\n    ans += a[i] * b[i];\n  }\n  return ans;\n}\n","import { All } from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/index.js\";\nimport { INTERRUPT } from \"../constants.js\";\nimport { PregelNode } from \"./read.js\";\n\nexport class GraphValidationError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"GraphValidationError\";\n  }\n}\n\nexport function validateGraph<\n  Nn extends Record<string, PregelNode>,\n  Cc extends Record<string, BaseChannel>\n>({\n  nodes,\n  channels,\n  inputChannels,\n  outputChannels,\n  streamChannels,\n  interruptAfterNodes,\n  interruptBeforeNodes,\n}: {\n  nodes: Nn;\n  channels: Cc;\n  inputChannels: keyof Cc | Array<keyof Cc>;\n  outputChannels: keyof Cc | Array<keyof Cc>;\n  streamChannels?: keyof Cc | Array<keyof Cc>;\n  interruptAfterNodes?: Array<keyof Nn> | All;\n  interruptBeforeNodes?: Array<keyof Nn> | All;\n}): void {\n  if (!channels) {\n    throw new GraphValidationError(\"Channels not provided\");\n  }\n\n  const subscribedChannels = new Set<keyof Cc>();\n  const allOutputChannels = new Set<keyof Cc>();\n\n  for (const [name, node] of Object.entries(nodes)) {\n    if (name === INTERRUPT) {\n      throw new GraphValidationError(`\"Node name ${INTERRUPT} is reserved\"`);\n    }\n    if (node.constructor === PregelNode) {\n      node.triggers.forEach((trigger) => subscribedChannels.add(trigger));\n    } else {\n      throw new GraphValidationError(\n        `Invalid node type ${typeof node}, expected PregelNode`\n      );\n    }\n  }\n\n  // side effect: update channels\n  for (const chan of subscribedChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Subscribed channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  if (!Array.isArray(inputChannels)) {\n    if (!subscribedChannels.has(inputChannels)) {\n      throw new GraphValidationError(\n        `Input channel ${String(\n          inputChannels\n        )} is not subscribed to by any node`\n      );\n    }\n  } else {\n    if (inputChannels.every((channel) => !subscribedChannels.has(channel))) {\n      throw new GraphValidationError(\n        `None of the input channels ${inputChannels} are subscribed to by any node`\n      );\n    }\n  }\n\n  if (!Array.isArray(outputChannels)) {\n    allOutputChannels.add(outputChannels);\n  } else {\n    outputChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  if (streamChannels && !Array.isArray(streamChannels)) {\n    allOutputChannels.add(streamChannels);\n  } else if (Array.isArray(streamChannels)) {\n    streamChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  for (const chan of allOutputChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Output channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  // validate interrupt before/after\n  if (interruptAfterNodes && interruptAfterNodes !== \"*\") {\n    for (const node of interruptAfterNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n\n  if (interruptBeforeNodes && interruptBeforeNodes !== \"*\") {\n    for (const node of interruptBeforeNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n}\n\nexport function validateKeys<Cc extends Record<string, BaseChannel>>(\n  keys: keyof Cc | Array<keyof Cc>,\n  channels: Cc\n): void {\n  if (Array.isArray(keys)) {\n    for (const key of keys) {\n      if (!(key in channels)) {\n        throw new Error(`Key ${String(key)} not found in channels`);\n      }\n    }\n  } else {\n    if (!(keys in channels)) {\n      throw new Error(`Key ${String(keys)} not found in channels`);\n    }\n  }\n}\n","import { Client } from \"./client.js\";\nimport { isTracingEnabled } from \"./env.js\";\nimport { isConflictingEndpointsError, ConflictingEndpointsError, } from \"./utils/error.js\";\nimport { _LC_CONTEXT_VARIABLES_KEY, _REPLICA_TRACE_ROOTS_KEY, } from \"./singletons/constants.js\";\nimport { getContextVar, setContextVar } from \"./utils/context_vars.js\";\nimport { getEnvironmentVariable, getRuntimeEnvironment, } from \"./utils/env.js\";\nimport { getDefaultProjectName } from \"./utils/project.js\";\nimport { getLangSmithEnvironmentVariable } from \"./utils/env.js\";\nimport { warnOnce } from \"./utils/warn.js\";\nimport { uuid7FromTime } from \"./utils/_uuid.js\";\nimport { v5 as uuidv5 } from \"uuid\";\nconst TIMESTAMP_LENGTH = 36;\n// DNS namespace for UUID v5 (same as Python's uuid.NAMESPACE_DNS)\nconst UUID_NAMESPACE_DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\nfunction getReplicaKey(replica) {\n    // Generate a unique key by hashing the replica's identifying properties\n    // This ensures each unique replica (combination of projectName, apiUrl, workspaceId, apiKey) gets a unique key\n    // Sort keys to ensure consistent hashing\n    const sortedKeys = Object.keys(replica).sort();\n    const keyData = sortedKeys\n        .map((key) => `${key}:${replica[key] ?? \"\"}`)\n        .join(\"|\");\n    return uuidv5(keyData, UUID_NAMESPACE_DNS);\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;\n}\nexport function convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);\n    return {\n        dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,\n        microsecondPrecisionDatestring,\n    };\n}\n/**\n * Baggage header information\n */\nclass Baggage {\n    constructor(metadata, tags, project_name, replicas) {\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n        this.project_name = project_name;\n        this.replicas = replicas;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        let project_name;\n        let replicas;\n        for (const item of items) {\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            }\n            else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            }\n            else if (key === \"langsmith-project\") {\n                project_name = value;\n            }\n            else if (key === \"langsmith-replicas\") {\n                replicas = JSON.parse(value);\n            }\n        }\n        return new Baggage(metadata, tags, project_name, replicas);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        if (this.project_name) {\n            items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);\n        }\n        return items.join(\",\");\n    }\n}\nexport class RunTree {\n    constructor(originalConfig) {\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Attachments associated with the run.\n         * Each entry is a tuple of [mime_type, bytes]\n         */\n        Object.defineProperty(this, \"attachments\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Projects to replicate this run to with optional updates.\n         */\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"distributedParentId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_serialized_start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, { ...originalConfig });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata,\n        };\n        config.extra = { ...config.extra, metadata: dedupedMetadata };\n        if (\"id\" in config && config.id == null) {\n            delete config.id;\n        }\n        Object.assign(this, { ...defaultConfig, ...config, client });\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        // Generate serialized start time for ID generation\n        if (!this.dotted_order) {\n            this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);\n        }\n        // Generate id from serialized start_time if not provided\n        if (!this.id) {\n            this.id = uuid7FromTime(this._serialized_start_time ?? this.start_time);\n        }\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            }\n            else {\n                this.trace_id = this.id;\n            }\n        }\n        this.replicas = _ensureWriteReplicas(this.replicas);\n        // Now set the dotted order with the actual ID\n        if (!this.dotted_order) {\n            const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + dottedOrder;\n            }\n            else {\n                this.dotted_order = dottedOrder;\n            }\n        }\n    }\n    set metadata(metadata) {\n        this.extra = {\n            ...this.extra,\n            metadata: {\n                ...this.extra?.metadata,\n                ...metadata,\n            },\n        };\n    }\n    get metadata() {\n        return this.extra?.metadata;\n    }\n    static getDefaultConfig() {\n        const start_time = Date.now();\n        return {\n            run_type: \"chain\",\n            project_name: getDefaultProjectName(),\n            child_runs: [],\n            api_url: getEnvironmentVariable(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: getEnvironmentVariable(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time,\n            serialized: {},\n            inputs: {},\n            extra: {},\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        // Handle replicas: if child has its own replicas, use those; otherwise inherit parent's (with reroot stripped)\n        // Reroot should only apply to the run where it's explicitly configured, not propagate down\n        const inheritedReplicas = this.replicas?.map((replica) => {\n            const { reroot, ...rest } = replica;\n            return rest;\n        });\n        const childReplicas = config.replicas ?? inheritedReplicas;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            replicas: childReplicas,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order,\n        });\n        // Copy context vars over into the new run tree.\n        if (_LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_LC_CONTEXT_VARIABLES_KEY] =\n                this[_LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ??\n            this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = { ...presentConfig };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks)\n                ? newConfig.callbacks.copy?.()\n                : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, { _parentRunId: child.id });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers\n                    ?.find(isLangChainTracerLike)\n                    ?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while (current != null && !visited.has(current.id)) {\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra\n                ? { ...this.extra, metadata: { ...this.extra.metadata, ...metadata } }\n                : { metadata };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        // Avoid overwriting the runtime environment if it's already set\n        if (runExtra?.runtime?.library === undefined) {\n            if (!runExtra.runtime) {\n                runExtra.runtime = {};\n            }\n            if (runtimeEnv) {\n                for (const [k, v] of Object.entries(runtimeEnv)) {\n                    if (!runExtra.runtime[k]) {\n                        runExtra.runtime[k] = v;\n                    }\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run) => this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        }\n        else {\n            parent_run_id = run.parent_run?.id ?? run.parent_run_id;\n            child_runs = [];\n        }\n        return {\n            id: run.id,\n            name: run.name,\n            start_time: run._serialized_start_time ?? run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n            attachments: run.attachments,\n            events: run.events,\n        };\n    }\n    _sliceParentId(parentId, run) {\n        /**\n         * Slice the parent id from dotted order.\n         * Additionally check if the current run is a child of the parent. If so, update\n         * the parent_run_id to undefined, and set the trace id to the new root id after\n         * parent_id.\n         */\n        if (run.dotted_order) {\n            const segs = run.dotted_order.split(\".\");\n            let startIdx = null;\n            // Find the index of the parent ID in the dotted order\n            for (let idx = 0; idx < segs.length; idx++) {\n                const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                if (segId === parentId) {\n                    startIdx = idx;\n                    break;\n                }\n            }\n            if (startIdx !== null) {\n                // Trim segments to start after parent_id (exclusive)\n                const trimmedSegs = segs.slice(startIdx + 1);\n                // Rebuild dotted_order\n                run.dotted_order = trimmedSegs.join(\".\");\n                if (trimmedSegs.length > 0) {\n                    run.trace_id = trimmedSegs[0].slice(-TIMESTAMP_LENGTH);\n                }\n                else {\n                    run.trace_id = run.id;\n                }\n            }\n        }\n        if (run.parent_run_id === parentId) {\n            // We've found the new root node.\n            run.parent_run_id = undefined;\n        }\n    }\n    _setReplicaTraceRoot(replicaKey, traceRootId) {\n        // Set the replica trace root in context vars on this run and all descendants\n        const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};\n        replicaTraceRoots[replicaKey] = traceRootId;\n        setContextVar(this, _REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);\n        // Recursively update all descendants to avoid race conditions\n        // around run tree creation vs processing time\n        for (const child of this.child_runs) {\n            child._setReplicaTraceRoot(replicaKey, traceRootId);\n        }\n    }\n    _remapForProject(params) {\n        const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId, } = params;\n        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n        // Skip remapping if project name is the same\n        if (projectName === this.project_name) {\n            return {\n                ...baseRun,\n                session_name: projectName,\n            };\n        }\n        // Apply reroot logic before ID remapping\n        if (reroot) {\n            if (distributedParentId) {\n                // If we have a distributed parent ID, slice at that point\n                this._sliceParentId(distributedParentId, baseRun);\n            }\n            else {\n                // If no distributed parent ID, simply make this run a root run\n                // by removing parent_run_id and resetting trace info\n                baseRun.parent_run_id = undefined;\n                // Keep the current run as the trace root\n                if (baseRun.dotted_order) {\n                    // Reset dotted order to just this run\n                    const segs = baseRun.dotted_order.split(\".\");\n                    if (segs.length > 0) {\n                        baseRun.dotted_order = segs[segs.length - 1];\n                        baseRun.trace_id = baseRun.id;\n                    }\n                }\n            }\n            // Store this run's original ID in context vars so descendants know the new trace root\n            // We store the original ID (before remapping) so it can be found in dotted_order\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId,\n            });\n            this._setReplicaTraceRoot(replicaKey, baseRun.id);\n        }\n        // If an ancestor was rerooted for this replica, update trace_id and dotted_order\n        // to reflect the new trace hierarchy. This is tracked via context variables.\n        let ancestorRerootedTraceId;\n        if (!reroot) {\n            const replicaTraceRoots = getContextVar(this, _REPLICA_TRACE_ROOTS_KEY) ?? {};\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId,\n            });\n            ancestorRerootedTraceId = replicaTraceRoots[replicaKey];\n            if (ancestorRerootedTraceId) {\n                // An ancestor was rerooted for this replica, so set our trace_id\n                // to the ancestor's original (unmapped) ID. It will be remapped along with other IDs.\n                baseRun.trace_id = ancestorRerootedTraceId;\n                // Also slice the dotted_order to start from the new trace root\n                // This ensures descendants of a rerooted ancestor have correct hierarchy\n                if (baseRun.dotted_order) {\n                    const segs = baseRun.dotted_order.split(\".\");\n                    let rootIdx = null;\n                    // Find the new trace root's segment in dotted_order\n                    for (let idx = 0; idx < segs.length; idx++) {\n                        const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                        if (segId === ancestorRerootedTraceId) {\n                            rootIdx = idx;\n                            break;\n                        }\n                    }\n                    if (rootIdx !== null) {\n                        // Keep segments from new trace root onwards\n                        const trimmedSegs = segs.slice(rootIdx);\n                        baseRun.dotted_order = trimmedSegs.join(\".\");\n                    }\n                }\n            }\n        }\n        // Remap IDs for the replica using uuid5 (deterministic)\n        // This ensures consistency across runs in the same replica\n        const oldId = baseRun.id;\n        const newId = uuidv5(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);\n        // Remap trace_id\n        let newTraceId;\n        if (baseRun.trace_id) {\n            newTraceId = uuidv5(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        else {\n            newTraceId = newId;\n        }\n        // Remap parent_run_id\n        let newParentId;\n        if (baseRun.parent_run_id) {\n            newParentId = uuidv5(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        // Remap dotted_order segments\n        let newDottedOrder;\n        if (baseRun.dotted_order) {\n            const segs = baseRun.dotted_order.split(\".\");\n            const remappedSegs = segs.map((seg) => {\n                // Extract the UUID from the segment (last TIMESTAMP_LENGTH characters)\n                const segId = seg.slice(-TIMESTAMP_LENGTH);\n                const remappedId = uuidv5(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);\n                // Replace the UUID part while keeping the timestamp prefix\n                return seg.slice(0, -TIMESTAMP_LENGTH) + remappedId;\n            });\n            newDottedOrder = remappedSegs.join(\".\");\n        }\n        return {\n            ...baseRun,\n            id: newId,\n            trace_id: newTraceId,\n            parent_run_id: newParentId,\n            dotted_order: newDottedOrder,\n            session_name: projectName,\n        };\n    }\n    async postRun(excludeChildRuns = true) {\n        try {\n            const runtimeEnv = getRuntimeEnvironment();\n            if (this.replicas && this.replicas.length > 0) {\n                for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this\n                    .replicas) {\n                    const runCreate = this._remapForProject({\n                        projectName: projectName ?? this.project_name,\n                        runtimeEnv,\n                        excludeChildRuns: true,\n                        reroot,\n                        distributedParentId: this.distributedParentId,\n                        apiUrl,\n                        apiKey,\n                        workspaceId,\n                    });\n                    await this.client.createRun(runCreate, {\n                        apiKey,\n                        apiUrl,\n                        workspaceId,\n                    });\n                }\n            }\n            else {\n                const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n                await this.client.createRun(runCreate);\n            }\n            if (!excludeChildRuns) {\n                warnOnce(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs) {\n                    await childRun.postRun(false);\n                }\n            }\n        }\n        catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun(options) {\n        if (this.replicas && this.replicas.length > 0) {\n            for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot, } of this.replicas) {\n                const runData = this._remapForProject({\n                    projectName: projectName ?? this.project_name,\n                    runtimeEnv: undefined,\n                    excludeChildRuns: true,\n                    reroot,\n                    distributedParentId: this.distributedParentId,\n                    apiUrl,\n                    apiKey,\n                    workspaceId,\n                });\n                const updatePayload = {\n                    id: runData.id,\n                    name: runData.name,\n                    run_type: runData.run_type,\n                    start_time: runData.start_time,\n                    outputs: runData.outputs,\n                    error: runData.error,\n                    parent_run_id: runData.parent_run_id,\n                    session_name: runData.session_name,\n                    reference_example_id: runData.reference_example_id,\n                    end_time: runData.end_time,\n                    dotted_order: runData.dotted_order,\n                    trace_id: runData.trace_id,\n                    events: runData.events,\n                    tags: runData.tags,\n                    extra: runData.extra,\n                    attachments: this.attachments,\n                    ...updates,\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    updatePayload.inputs = runData.inputs;\n                }\n                await this.client.updateRun(runData.id, updatePayload, {\n                    apiKey,\n                    apiUrl,\n                    workspaceId,\n                });\n            }\n        }\n        else {\n            try {\n                const runUpdate = {\n                    name: this.name,\n                    run_type: this.run_type,\n                    start_time: this._serialized_start_time ?? this.start_time,\n                    end_time: this.end_time,\n                    error: this.error,\n                    outputs: this.outputs,\n                    parent_run_id: this.parent_run?.id ?? this.parent_run_id,\n                    reference_example_id: this.reference_example_id,\n                    extra: this.extra,\n                    events: this.events,\n                    dotted_order: this.dotted_order,\n                    trace_id: this.trace_id,\n                    tags: this.tags,\n                    attachments: this.attachments,\n                    session_name: this.project_name,\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    runUpdate.inputs = this.inputs;\n                }\n                await this.client.updateRun(this.id, runUpdate);\n            }\n            catch (error) {\n                console.error(`Error in patchRun for run ${this.id}`, error);\n            }\n        }\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    /**\n     * Add an event to the run tree.\n     * @param event - A single event or string to add\n     */\n    addEvent(event) {\n        if (!this.events) {\n            this.events = [];\n        }\n        if (typeof event === \"string\") {\n            this.events.push({\n                name: \"event\",\n                time: new Date().toISOString(),\n                message: event,\n            });\n        }\n        else {\n            this.events.push({\n                ...event,\n                time: event.time ?? new Date().toISOString(),\n            });\n        }\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = isTracingEnabled();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler) => handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName,\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? [])),\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata,\n                },\n            },\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({ \"langsmith-trace\": dottedOrder });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\"\n            ? {\n                \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n                baggage: headers.get(\"baggage\"),\n            }\n            : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\")\n            return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part) => {\n            const [strTime, uuid] = part.split(\"Z\");\n            return { strTime, time: Date.parse(strTime + \"Z\"), uuid };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder,\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n            config.project_name = baggage.project_name;\n            config.replicas = baggage.replicas;\n        }\n        const runTree = new RunTree(config);\n        // Set the distributed parent ID to this run's ID for rerooting\n        runTree.distributedParentId = runTree.id;\n        return runTree;\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader(),\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)) {\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nexport function isRunTree(x) {\n    return (x != null &&\n        typeof x.createChild === \"function\" &&\n        typeof x.postRun === \"function\");\n}\nfunction isLangChainTracerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        typeof x.name === \"string\" &&\n        x.name === \"langchain_tracer\");\n}\nfunction containsLangChainTracerLike(x) {\n    return (Array.isArray(x) && x.some((callback) => isLangChainTracerLike(callback)));\n}\nfunction isCallbackManagerLike(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        Array.isArray(x.handlers));\n}\nexport function isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    return (x != null &&\n        typeof x.callbacks === \"object\" &&\n        // Callback manager with a langchain tracer\n        (containsLangChainTracerLike(x.callbacks?.handlers) ||\n            // Or it's an array with a LangChainTracerLike object within it\n            containsLangChainTracerLike(x.callbacks)));\n}\nfunction _getWriteReplicasFromEnv() {\n    const envVar = getEnvironmentVariable(\"LANGSMITH_RUNS_ENDPOINTS\");\n    if (!envVar)\n        return [];\n    try {\n        const parsed = JSON.parse(envVar);\n        if (Array.isArray(parsed)) {\n            const replicas = [];\n            for (const item of parsed) {\n                if (typeof item !== \"object\" || item === null) {\n                    console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected object, got ${typeof item}`);\n                    continue;\n                }\n                if (typeof item.api_url !== \"string\") {\n                    console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected string, got ${typeof item.api_url}`);\n                    continue;\n                }\n                if (typeof item.api_key !== \"string\") {\n                    console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: ` +\n                        `expected string, got ${typeof item.api_key}`);\n                    continue;\n                }\n                replicas.push({\n                    apiUrl: item.api_url.replace(/\\/$/, \"\"),\n                    apiKey: item.api_key,\n                });\n            }\n            return replicas;\n        }\n        else if (typeof parsed === \"object\" && parsed !== null) {\n            _checkEndpointEnvUnset(parsed);\n            const replicas = [];\n            for (const [url, key] of Object.entries(parsed)) {\n                const cleanUrl = url.replace(/\\/$/, \"\");\n                if (typeof key === \"string\") {\n                    replicas.push({\n                        apiUrl: cleanUrl,\n                        apiKey: key,\n                    });\n                }\n                else {\n                    console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: ` +\n                        `expected string, got ${typeof key}`);\n                    continue;\n                }\n            }\n            return replicas;\n        }\n        else {\n            console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" +\n                `objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);\n            return [];\n        }\n    }\n    catch (e) {\n        if (isConflictingEndpointsError(e)) {\n            throw e;\n        }\n        console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" +\n            \"objects with api_url and api_key properties, or object mapping url->apiKey\");\n        return [];\n    }\n}\nfunction _ensureWriteReplicas(replicas) {\n    // If null -> fetch from env\n    if (replicas) {\n        return replicas.map((replica) => {\n            if (Array.isArray(replica)) {\n                return {\n                    projectName: replica[0],\n                    updates: replica[1],\n                };\n            }\n            return replica;\n        });\n    }\n    return _getWriteReplicasFromEnv();\n}\nfunction _checkEndpointEnvUnset(parsed) {\n    if (Object.keys(parsed).length > 0 &&\n        getLangSmithEnvironmentVariable(\"ENDPOINT\")) {\n        throw new ConflictingEndpointsError();\n    }\n}\n","import { unsafeStringify } from './stringify.js';\nimport v1 from './v1.js';\nimport v1ToV6 from './v1ToV6.js';\n\n/**\n *\n * @param {object} options\n * @param {Uint8Array=} buf\n * @param {number=} offset\n * @returns\n */\nexport default function v6(options = {}, buf, offset = 0) {\n  // v6 is v1 with different field layout, so we start with a v1 UUID, albeit\n  // with slightly different behavior around how the clock_seq and node fields\n  // are randomized, which is why we call v1 with _v6: true.\n  let bytes = v1({\n    ...options,\n    _v6: true\n  }, new Uint8Array(16));\n\n  // Reorder the fields to v6 layout.\n  bytes = v1ToV6(bytes);\n\n  // Return as a byte array if requested\n  if (buf) {\n    for (let i = 0; i < 16; i++) {\n      buf[offset + i] = bytes[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(bytes);\n}","import { RunnableConfig } from \"../runnables/config.js\";\nimport { BaseTracer, Run } from \"./base.js\";\n\nexport class RootListenersTracer extends BaseTracer {\n  name = \"RootListenersTracer\";\n\n  /** The Run's ID. Type UUID */\n  rootId?: string;\n\n  config: RunnableConfig;\n\n  argOnStart?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  argOnEnd?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  argOnError?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n\n  constructor({\n    config,\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    config: RunnableConfig;\n    onStart?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config: RunnableConfig) => void | Promise<void>;\n  }) {\n    super({ _awaitHandler: true });\n    this.config = config;\n    this.argOnStart = onStart;\n    this.argOnEnd = onEnd;\n    this.argOnError = onError;\n  }\n\n  /**\n   * This is a legacy method only called once for an entire run tree\n   * therefore not useful here\n   * @param {Run} _ Not used\n   */\n  persistRun(_: Run): Promise<void> {\n    return Promise.resolve();\n  }\n\n  async onRunCreate(run: Run) {\n    if (this.rootId) {\n      return;\n    }\n\n    this.rootId = run.id;\n\n    if (this.argOnStart) {\n      await this.argOnStart(run, this.config);\n    }\n  }\n\n  async onRunUpdate(run: Run) {\n    if (run.id !== this.rootId) {\n      return;\n    }\n    if (!run.error) {\n      if (this.argOnEnd) {\n        await this.argOnEnd(run, this.config);\n      }\n    } else if (this.argOnError) {\n      await this.argOnError(run, this.config);\n    }\n  }\n}\n","import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport {\n  parse,\n  parseAsync,\n  globalRegistry,\n  util,\n  clone,\n  _unknown,\n  _never,\n  $ZodUnknown,\n  $ZodNever,\n  $ZodOptional,\n} from \"zod/v4/core\";\n\nexport type ZodStringV3 = z3.ZodString;\n\nexport type ZodStringV4 = z4.$ZodType<string, unknown>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ZodObjectV3 = z3.ZodObject<any, any, any, any>;\n\nexport type ZodObjectV4 = z4.$ZodObject;\n\nexport type ZodDefaultV3<T extends z3.ZodTypeAny> = z3.ZodDefault<T>;\nexport type ZodDefaultV4<T extends z4.SomeType> = z4.$ZodDefault<T>;\nexport type ZodOptionalV3<T extends z3.ZodTypeAny> = z3.ZodOptional<T>;\nexport type ZodOptionalV4<T extends z4.SomeType> = z4.$ZodOptional<T>;\nexport type ZodNullableV4<T extends z4.SomeType> = z4.$ZodNullable<T>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InteropZodType<Output = any, Input = Output> =\n  | z3.ZodType<Output, z3.ZodTypeDef, Input>\n  | z4.$ZodType<Output, Input>;\n\nexport type InteropZodObject = ZodObjectV3 | ZodObjectV4;\nexport type InteropZodDefault<T = InteropZodObjectShape> =\n  T extends z3.ZodTypeAny\n    ? ZodDefaultV3<T>\n    : T extends z4.SomeType\n    ? ZodDefaultV4<T>\n    : never;\nexport type InteropZodOptional<T = InteropZodObjectShape> =\n  T extends z3.ZodTypeAny\n    ? ZodOptionalV3<T>\n    : T extends z4.SomeType\n    ? ZodOptionalV4<T>\n    : never;\n\nexport type InteropZodObjectShape<\n  T extends InteropZodObject = InteropZodObject\n> = T extends z3.ZodObject<infer Shape>\n  ? { [K in keyof Shape]: Shape[K] }\n  : T extends z4.$ZodObject<infer Shape>\n  ? { [K in keyof Shape]: Shape[K] }\n  : never;\n\nexport type InteropZodIssue = z3.ZodIssue | z4.$ZodIssue;\n\n// Simplified type inference to avoid circular dependencies\nexport type InferInteropZodInput<T> = T extends z3.ZodType<\n  unknown,\n  z3.ZodTypeDef,\n  infer Input\n>\n  ? Input\n  : T extends z4.$ZodType<unknown, infer Input>\n  ? Input\n  : T extends { _zod: { input: infer Input } }\n  ? Input\n  : never;\n\nexport type InferInteropZodOutput<T> = T extends z3.ZodType<\n  infer Output,\n  z3.ZodTypeDef,\n  unknown\n>\n  ? Output\n  : T extends z4.$ZodType<infer Output, unknown>\n  ? Output\n  : T extends { _zod: { output: infer Output } }\n  ? Output\n  : never;\n\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\nexport function isZodSchemaV4(\n  schema: unknown\n): schema is z4.$ZodType<unknown, unknown> {\n  if (typeof schema !== \"object\" || schema === null) {\n    return false;\n  }\n\n  const obj = schema as Record<string, unknown>;\n  if (!(\"_zod\" in obj)) {\n    return false;\n  }\n\n  const zod = obj._zod;\n  return (\n    typeof zod === \"object\" &&\n    zod !== null &&\n    \"def\" in (zod as Record<string, unknown>)\n  );\n}\n\nexport function isZodSchemaV3(\n  schema: unknown\n): schema is z3.ZodType<unknown, z3.ZodTypeDef, unknown> {\n  if (typeof schema !== \"object\" || schema === null) {\n    return false;\n  }\n\n  const obj = schema as Record<string, unknown>;\n  if (!(\"_def\" in obj) || \"_zod\" in obj) {\n    return false;\n  }\n\n  const def = obj._def;\n  return (\n    typeof def === \"object\" &&\n    def != null &&\n    \"typeName\" in (def as Record<string, unknown>)\n  );\n}\n\n/** Backward compatible isZodSchema for Zod 3 */\nexport function isZodSchema<\n  RunOutput extends Record<string, unknown> = Record<string, unknown>\n>(\n  schema: z3.ZodType<RunOutput> | Record<string, unknown>\n): schema is z3.ZodType<RunOutput> {\n  if (isZodSchemaV4(schema)) {\n    console.warn(\n      \"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\"\n    );\n  }\n  return isZodSchemaV3(schema);\n}\n\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nexport function isInteropZodSchema(input: unknown): input is InteropZodType {\n  if (!input) {\n    return false;\n  }\n  if (typeof input !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(input)) {\n    return false;\n  }\n  if (\n    isZodSchemaV4(input) ||\n    isZodSchemaV3(input as z3.ZodType<Record<string, unknown>>)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport type InteropZodLiteral = z3.ZodLiteral<unknown> | z4.$ZodLiteral;\n\nexport function isZodLiteralV3(obj: unknown): obj is z3.ZodLiteral<unknown> {\n  // Zod v3 literal schemas have _def.typeName === \"ZodLiteral\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_def\" in obj &&\n    typeof obj._def === \"object\" &&\n    obj._def !== null &&\n    \"typeName\" in obj._def &&\n    obj._def.typeName === \"ZodLiteral\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodLiteralV4(obj: unknown): obj is z4.$ZodLiteral {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 literal schemas have _zod.def.type === \"literal\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"literal\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if the provided value is an InteropZodLiteral (Zod v3 or v4 literal schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 literal schema, false otherwise.\n */\nexport function isInteropZodLiteral(obj: unknown): obj is InteropZodLiteral {\n  if (isZodLiteralV3(obj)) return true;\n  if (isZodLiteralV4(obj)) return true;\n  return false;\n}\n\ntype InteropZodSafeParseResult<T> = z3.SafeParseReturnType<T, T>;\n\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopSafeParseAsync<T>(\n  schema: InteropZodType<T>,\n  input: unknown\n): Promise<InteropZodSafeParseResult<T>> {\n  if (isZodSchemaV4(schema)) {\n    try {\n      const data = await parseAsync(schema, input);\n      return {\n        success: true,\n        data,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as z3.ZodError<T>,\n      };\n    }\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return await schema.safeParseAsync(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopParseAsync<T>(\n  schema: InteropZodType<T>,\n  input: unknown\n): Promise<T> {\n  if (isZodSchemaV4(schema)) {\n    return await parseAsync(schema, input);\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return await schema.parseAsync(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopSafeParse<T>(\n  schema: InteropZodType<T>,\n  input: unknown\n): InteropZodSafeParseResult<T> {\n  if (isZodSchemaV4(schema)) {\n    try {\n      const data = parse(schema, input);\n      return {\n        success: true,\n        data,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as z3.ZodError<T>,\n      };\n    }\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return schema.safeParse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopParse<T>(schema: InteropZodType<T>, input: unknown): T {\n  if (isZodSchemaV4(schema)) {\n    return parse(schema, input);\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return schema.parse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nexport function getSchemaDescription(\n  schema: InteropZodType<unknown> | Record<string, unknown>\n): string | undefined {\n  if (isZodSchemaV4(schema)) {\n    return globalRegistry.get(schema)?.description;\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return schema.description as string | undefined;\n  }\n  if (\"description\" in schema && typeof schema.description === \"string\") {\n    return schema.description;\n  }\n  return undefined;\n}\n\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nexport function isShapelessZodSchema(schema: unknown): boolean {\n  if (!isInteropZodSchema(schema)) {\n    return false;\n  }\n\n  // Check for v3 schemas\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n    const def = schema._def as { typeName?: string };\n\n    // ZodObject is only shaped if it has actual shape keys\n    if (def.typeName === \"ZodObject\") {\n      const obj = schema as { shape?: Record<string, unknown> };\n      return !obj.shape || Object.keys(obj.shape).length === 0;\n    }\n\n    // ZodRecord is shapeless (dynamic key-value mapping)\n    if (def.typeName === \"ZodRecord\") {\n      return true;\n    }\n  }\n\n  // Check for v4 schemas\n  if (isZodSchemaV4(schema)) {\n    const def = schema._zod.def;\n\n    // Object type is only shaped if it has actual shape keys\n    if (def.type === \"object\") {\n      const obj = schema as { shape?: Record<string, unknown> };\n      return !obj.shape || Object.keys(obj.shape).length === 0;\n    }\n\n    // Record type is shapeless (dynamic key-value mapping)\n    if (def.type === \"record\") {\n      return true;\n    }\n  }\n\n  // For other schemas, check if they have a `shape` property\n  // If they don't have shape, they're likely shapeless\n  if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nexport function isSimpleStringZodSchema(\n  schema: unknown\n): schema is InteropZodType<string | undefined> {\n  if (!isInteropZodSchema(schema)) {\n    return false;\n  }\n\n  // For v3 schemas\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n    const def = schema._def as { typeName?: string };\n\n    // Only accept basic ZodString\n    return def.typeName === \"ZodString\";\n  }\n\n  // For v4 schemas\n  if (isZodSchemaV4(schema)) {\n    const def = schema._zod.def;\n\n    // Only accept basic string type\n    return def.type === \"string\";\n  }\n\n  return false;\n}\n\nexport function isZodObjectV3(obj: unknown): obj is ZodObjectV3 {\n  // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_def\" in obj &&\n    typeof obj._def === \"object\" &&\n    obj._def !== null &&\n    \"typeName\" in obj._def &&\n    obj._def.typeName === \"ZodObject\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodObjectV4(obj: unknown): obj is z4.$ZodObject {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 object schemas have _zod.def.type === \"object\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"object\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodArrayV4(obj: unknown): obj is z4.$ZodArray {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 array schemas have _zod.def.type === \"array\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"array\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodOptionalV4(obj: unknown): obj is z4.$ZodOptional {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 optional schemas have _zod.def.type === \"optional\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"optional\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodNullableV4(obj: unknown): obj is z4.$ZodNullable {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 nullable schemas have _zod.def.type === \"nullable\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"nullable\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nexport function isInteropZodObject(obj: unknown): obj is InteropZodObject {\n  if (isZodObjectV3(obj)) return true;\n  if (isZodObjectV4(obj)) return true;\n  return false;\n}\n\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function getInteropZodObjectShape<T extends InteropZodObject>(\n  schema: T\n): InteropZodObjectShape<T> {\n  if (isZodSchemaV3(schema)) {\n    return schema.shape;\n  }\n  if (isZodSchemaV4(schema)) {\n    return schema._zod.def.shape as InteropZodObjectShape<T>;\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function extendInteropZodObject<T extends InteropZodObject>(\n  schema: T,\n  extension: InteropZodObjectShape\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    return schema.extend(extension as z3.ZodRawShape);\n  }\n  if (isZodSchemaV4(schema)) {\n    return util.extend(schema, extension);\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPartial<T extends InteropZodObject>(\n  schema: T\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    // z3: .partial() exists and works as expected\n    return schema.partial();\n  }\n  if (isZodSchemaV4(schema)) {\n    // z4: util.partial exists and works as expected\n    return util.partial($ZodOptional, schema, undefined);\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectStrict<T extends InteropZodObject>(\n  schema: T,\n  recursive = false\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema.strict();\n  }\n  if (isZodObjectV4(schema)) {\n    const outputShape: Mutable<z4.$ZodShape> = schema._zod.def.shape;\n    if (recursive) {\n      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n        // If the shape key is a v4 object schema, we need to make it strict\n        if (isZodObjectV4(keySchema)) {\n          const outputSchema = interopZodObjectStrict(keySchema, recursive);\n          outputShape[key] = outputSchema as ZodObjectV4;\n        }\n        // If the shape key is a v4 array schema, we need to make the element\n        // schema strict if it's an object schema\n        else if (isZodArrayV4(keySchema)) {\n          let elementSchema = keySchema._zod.def.element;\n          if (isZodObjectV4(elementSchema)) {\n            elementSchema = interopZodObjectStrict(\n              elementSchema,\n              recursive\n            ) as ZodObjectV4;\n          }\n          outputShape[key] = clone(keySchema, {\n            ...keySchema._zod.def,\n            element: elementSchema,\n          });\n        }\n        // Otherwise, just use the keySchema\n        else {\n          outputShape[key] = keySchema;\n        }\n        // Assign meta fields to the keySchema\n        const meta = globalRegistry.get(keySchema);\n        if (meta) globalRegistry.add(outputShape[key], meta);\n      }\n    }\n    const modifiedSchema = clone<ZodObjectV4>(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n      catchall: _never($ZodNever),\n    });\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n    return modifiedSchema;\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPassthrough<T extends InteropZodObject>(\n  schema: T,\n  recursive = false\n): InteropZodObject {\n  if (isZodObjectV3(schema)) {\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema.passthrough();\n  }\n  if (isZodObjectV4(schema)) {\n    const outputShape: Mutable<z4.$ZodShape> = schema._zod.def.shape;\n    if (recursive) {\n      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n        // If the shape key is a v4 object schema, we need to make it passthrough\n        if (isZodObjectV4(keySchema)) {\n          const outputSchema = interopZodObjectPassthrough(\n            keySchema,\n            recursive\n          );\n          outputShape[key] = outputSchema as ZodObjectV4;\n        }\n        // If the shape key is a v4 array schema, we need to make the element\n        // schema passthrough if it's an object schema\n        else if (isZodArrayV4(keySchema)) {\n          let elementSchema = keySchema._zod.def.element;\n          if (isZodObjectV4(elementSchema)) {\n            elementSchema = interopZodObjectPassthrough(\n              elementSchema,\n              recursive\n            ) as ZodObjectV4;\n          }\n          outputShape[key] = clone(keySchema, {\n            ...keySchema._zod.def,\n            element: elementSchema,\n          });\n        }\n        // Otherwise, just use the keySchema\n        else {\n          outputShape[key] = keySchema;\n        }\n        // Assign meta fields to the keySchema\n        const meta = globalRegistry.get(keySchema);\n        if (meta) globalRegistry.add(outputShape[key], meta);\n      }\n    }\n    const modifiedSchema = clone<ZodObjectV4>(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n      catchall: _unknown($ZodUnknown),\n    });\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n    return modifiedSchema;\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nexport function getInteropZodDefaultGetter<T extends InteropZodType>(\n  schema: T\n): (() => InferInteropZodOutput<T>) | undefined {\n  if (isZodSchemaV3(schema)) {\n    try {\n      const defaultValue = schema.parse(undefined);\n      return () => defaultValue as InferInteropZodOutput<T>;\n    } catch {\n      return undefined;\n    }\n  }\n  if (isZodSchemaV4(schema)) {\n    try {\n      const defaultValue = parse(schema, undefined);\n      return () => defaultValue as InferInteropZodOutput<T>;\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nfunction isZodTransformV3(\n  schema: InteropZodType\n): schema is z3.ZodEffects<z3.ZodTypeAny> {\n  return (\n    isZodSchemaV3(schema) &&\n    \"typeName\" in schema._def &&\n    schema._def.typeName === \"ZodEffects\"\n  );\n}\n\nfunction isZodTransformV4(schema: InteropZodType): schema is z4.$ZodPipe {\n  return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n\nfunction interopZodTransformInputSchemaImpl(\n  schema: InteropZodType,\n  recursive: boolean,\n  cache: WeakMap<InteropZodType, InteropZodType>\n): InteropZodType {\n  const cached = cache.get(schema);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n  if (isZodSchemaV3(schema)) {\n    if (isZodTransformV3(schema)) {\n      return interopZodTransformInputSchemaImpl(\n        schema._def.schema,\n        recursive,\n        cache\n      );\n    }\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema;\n  }\n\n  // Zod v4: _def.type is the input schema for ZodEffects (transform)\n  if (isZodSchemaV4(schema)) {\n    let outputSchema: InteropZodType = schema;\n    if (isZodTransformV4(schema)) {\n      outputSchema = interopZodTransformInputSchemaImpl(\n        schema._zod.def.in,\n        recursive,\n        cache\n      );\n    }\n    if (recursive) {\n      // Handle nested object schemas\n      if (isZodObjectV4(outputSchema)) {\n        const outputShape: Mutable<z4.$ZodShape> = outputSchema._zod.def.shape;\n        for (const [key, keySchema] of Object.entries(\n          outputSchema._zod.def.shape\n        )) {\n          outputShape[key] = interopZodTransformInputSchemaImpl(\n            keySchema,\n            recursive,\n            cache\n          ) as z4.$ZodType;\n        }\n        outputSchema = clone<ZodObjectV4>(outputSchema, {\n          ...outputSchema._zod.def,\n          shape: outputShape,\n        });\n      }\n      // Handle nested array schemas\n      else if (isZodArrayV4(outputSchema)) {\n        const elementSchema = interopZodTransformInputSchemaImpl(\n          outputSchema._zod.def.element,\n          recursive,\n          cache\n        );\n        outputSchema = clone<z4.$ZodArray>(outputSchema, {\n          ...outputSchema._zod.def,\n          element: elementSchema as z4.$ZodType,\n        });\n      }\n      // Handle optional schemas\n      else if (isZodOptionalV4(outputSchema)) {\n        const innerSchema = interopZodTransformInputSchemaImpl(\n          outputSchema._zod.def.innerType as InteropZodType,\n          recursive,\n          cache\n        );\n        outputSchema = clone<z4.$ZodOptional>(outputSchema, {\n          ...outputSchema._zod.def,\n          innerType: innerSchema as z4.$ZodType,\n        });\n      }\n      // Handle nullable schemas\n      else if (isZodNullableV4(outputSchema)) {\n        const innerSchema = interopZodTransformInputSchemaImpl(\n          outputSchema._zod.def.innerType as InteropZodType,\n          recursive,\n          cache\n        );\n        outputSchema = clone<z4.$ZodNullable>(outputSchema, {\n          ...outputSchema._zod.def,\n          innerType: innerSchema as z4.$ZodType,\n        });\n      }\n    }\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(outputSchema as z4.$ZodType, meta);\n    cache.set(schema, outputSchema);\n    return outputSchema;\n  }\n\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nexport function interopZodTransformInputSchema(\n  schema: InteropZodType,\n  recursive = false\n): InteropZodType {\n  const cache = new WeakMap<InteropZodType, InteropZodType>();\n  return interopZodTransformInputSchemaImpl(schema, recursive, cache);\n}\n\n/**\n * Creates a modified version of a Zod object schema where fields matching a predicate are made optional.\n * Supports both Zod v3 and v4 schemas and preserves the original schema version.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {(key: string, value: InteropZodType) => boolean} predicate - Function to determine which fields should be optional.\n * @returns {InteropZodObject} The modified Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectMakeFieldsOptional<T extends InteropZodObject>(\n  schema: T,\n  predicate: (key: string, value: InteropZodType) => boolean\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    const shape = getInteropZodObjectShape(schema);\n    const modifiedShape: Record<string, z3.ZodTypeAny> = {};\n\n    for (const [key, value] of Object.entries(shape)) {\n      if (predicate(key, value)) {\n        // Make this field optional using v3 methods\n        modifiedShape[key] = (value as z3.ZodTypeAny).optional();\n      } else {\n        // Keep field as-is\n        modifiedShape[key] = value;\n      }\n    }\n\n    // Use v3's extend method to create a new schema with the modified shape\n    return schema.extend(modifiedShape as z3.ZodRawShape);\n  }\n\n  if (isZodSchemaV4(schema)) {\n    const shape = getInteropZodObjectShape(schema);\n    const outputShape: Mutable<z4.$ZodShape> = { ...schema._zod.def.shape };\n\n    for (const [key, value] of Object.entries(shape)) {\n      if (predicate(key, value)) {\n        // Make this field optional using v4 methods\n        outputShape[key] = new $ZodOptional({\n          type: \"optional\" as const,\n          innerType: value as z4.$ZodType,\n        });\n      }\n      // Otherwise keep the field as-is (already in outputShape)\n    }\n\n    const modifiedSchema = clone<ZodObjectV4>(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n    });\n\n    // Preserve metadata\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n\n    return modifiedSchema;\n  }\n\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\nexport function isInteropZodError(e: unknown) {\n  return (\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    e instanceof Error &&\n    (e.constructor.name === \"ZodError\" || e.constructor.name === \"$ZodError\")\n  );\n}\n","import { ZodNullableDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7NullType } from \"./null.js\";\nimport { primitiveMappings } from \"./union.js\";\n\nexport type JsonSchema7NullableType =\n  | {\n      anyOf: [JsonSchema7Type, JsonSchema7NullType];\n    }\n  | {\n      type: [string, \"null\"];\n    };\n\nexport function parseNullableDef(\n  def: ZodNullableDef,\n  refs: Refs\n): JsonSchema7NullableType | undefined {\n  if (\n    [\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(\n      def.innerType._def.typeName\n    ) &&\n    (!def.innerType._def.checks || !def.innerType._def.checks.length)\n  ) {\n    if (refs.target === \"openApi3\") {\n      return {\n        type: primitiveMappings[\n          def.innerType._def.typeName as keyof typeof primitiveMappings\n        ],\n        nullable: true,\n      } as any;\n    }\n\n    return {\n      type: [\n        primitiveMappings[\n          def.innerType._def.typeName as keyof typeof primitiveMappings\n        ],\n        \"null\",\n      ],\n    };\n  }\n\n  if (refs.target === \"openApi3\") {\n    const base = parseDef(def.innerType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath],\n    });\n\n    if (base && \"$ref\" in base) return { allOf: [base], nullable: true } as any;\n\n    return base && ({ ...base, nullable: true } as any);\n  }\n\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"],\n  });\n\n  return base && { anyOf: [base, { type: \"null\" }] };\n}\n","import { ZodBigIntDef } from \"zod/v3\";\nimport { Refs } from \"../Refs.js\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\n\nexport type JsonSchema7BigintType = {\n  type: \"integer\";\n  format: \"int64\";\n  minimum?: BigInt;\n  exclusiveMinimum?: BigInt;\n  maximum?: BigInt;\n  exclusiveMaximum?: BigInt;\n  multipleOf?: BigInt;\n  errorMessage?: ErrorMessages<JsonSchema7BigintType>;\n};\n\nexport function parseBigintDef(\n  def: ZodBigIntDef,\n  refs: Refs\n): JsonSchema7BigintType {\n  const res: JsonSchema7BigintType = {\n    type: \"integer\",\n    format: \"int64\",\n  };\n\n  if (!def.checks) return res;\n\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(\n              res,\n              \"minimum\",\n              check.value,\n              check.message,\n              refs\n            );\n          } else {\n            setResponseValueAndErrors(\n              res,\n              \"exclusiveMinimum\",\n              check.value,\n              check.message,\n              refs\n            );\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true as any;\n          }\n          setResponseValueAndErrors(\n            res,\n            \"minimum\",\n            check.value,\n            check.message,\n            refs\n          );\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(\n              res,\n              \"maximum\",\n              check.value,\n              check.message,\n              refs\n            );\n          } else {\n            setResponseValueAndErrors(\n              res,\n              \"exclusiveMaximum\",\n              check.value,\n              check.message,\n              refs\n            );\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true as any;\n          }\n          setResponseValueAndErrors(\n            res,\n            \"maximum\",\n            check.value,\n            check.message,\n            refs\n          );\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(\n          res,\n          \"multipleOf\",\n          check.value,\n          check.message,\n          refs\n        );\n        break;\n    }\n  }\n  return res;\n}\n","import { Refs } from \"../Refs.js\";\nimport { getRelativePath } from \"../getRelativePath.js\";\n\nexport type JsonSchema7AnyType = { $ref?: string };\n\nexport function parseAnyDef(refs: Refs): JsonSchema7AnyType {\n  if (refs.target !== \"openAi\") {\n    return {};\n  }\n\n  const anyDefinitionPath = [\n    ...refs.basePath,\n    refs.definitionPath,\n    refs.openAiAnyTypeName,\n  ];\n\n  refs.flags.hasReferencedOpenAiAnyType = true;\n\n  return {\n    $ref:\n      refs.$refStrategy === \"relative\"\n        ? getRelativePath(anyDefinitionPath, refs.currentPath)\n        : anyDefinitionPath.join(\"/\"),\n  };\n}\n","import { StateGraph, END, START, Annotation } from '@langchain/langgraph';\r\nimport {\r\n    OrderResolutionStateType,\r\n    createInitialState,\r\n    WarehouseResultType,\r\n    DriverResultType\r\n} from './state';\r\nimport { resolveOrderNode } from './nodes/resolve-order';\r\nimport { checkWarehouseNode } from './nodes/check-warehouse';\r\nimport { assignDriverNode } from './nodes/assign-driver';\r\nimport { confirmDispatchNode } from './nodes/confirm-dispatch';\r\n\r\n// Define state annotation for LangGraph\r\nconst OrderStateAnnotation = Annotation.Root({\r\n    orderId: Annotation<string>(),\r\n    orderDetails: Annotation<{\r\n        customer: string;\r\n        items: number;\r\n        total: number;\r\n        address: string;\r\n    }>(),\r\n    currentStep: Annotation<string>(),\r\n    stepMessages: Annotation<Array<{\r\n        step: string;\r\n        message: string;\r\n        timestamp: string;\r\n    }>>({\r\n        reducer: (current, update) => [...(current || []), ...(update || [])],\r\n        default: () => [],\r\n    }),\r\n    warehouseResult: Annotation<WarehouseResultType | undefined>(),\r\n    driverResult: Annotation<DriverResultType | undefined>(),\r\n    error: Annotation<string | undefined>(),\r\n    dispatchConfirmed: Annotation<boolean>(),\r\n    estimatedDeliveryTime: Annotation<string | undefined>(),\r\n});\r\n\r\ntype OrderState = typeof OrderStateAnnotation.State;\r\n\r\n/**\r\n * Conditional edge to check if we should continue or handle error\r\n */\r\nfunction shouldContinue(state: OrderState): string {\r\n    if (state.currentStep === 'error') {\r\n        return END;\r\n    }\r\n    return 'continue';\r\n}\r\n\r\n/**\r\n * Create and compile the order resolution workflow graph\r\n */\r\nexport function createOrderResolutionGraph() {\r\n    const workflow = new StateGraph(OrderStateAnnotation)\r\n        // Add nodes\r\n        .addNode('resolveOrder', resolveOrderNode as any)\r\n        .addNode('checkWarehouse', checkWarehouseNode as any)\r\n        .addNode('assignDriver', assignDriverNode as any)\r\n        .addNode('confirmDispatch', confirmDispatchNode as any)\r\n\r\n        // Define edges (linear workflow)\r\n        .addEdge(START, 'resolveOrder')\r\n        .addConditionalEdges('resolveOrder', shouldContinue, {\r\n            continue: 'checkWarehouse',\r\n            [END]: END,\r\n        })\r\n        .addConditionalEdges('checkWarehouse', shouldContinue, {\r\n            continue: 'assignDriver',\r\n            [END]: END,\r\n        })\r\n        .addConditionalEdges('assignDriver', shouldContinue, {\r\n            continue: 'confirmDispatch',\r\n            [END]: END,\r\n        })\r\n        .addEdge('confirmDispatch', END);\r\n\r\n    return workflow.compile();\r\n}\r\n\r\n/**\r\n * Execute the order resolution workflow\r\n */\r\nexport async function executeOrderResolution(\r\n    orderId: string,\r\n    orderDetails: OrderResolutionStateType['orderDetails']\r\n): Promise<OrderResolutionStateType> {\r\n    const graph = createOrderResolutionGraph();\r\n    const initialState = createInitialState(orderId, orderDetails);\r\n\r\n    const result = await graph.invoke(initialState as any);\r\n    return result as unknown as OrderResolutionStateType;\r\n}\r\n\r\n// Re-export types and utilities\r\nexport { createInitialState } from './state';\r\nexport type { OrderResolutionStateType, WorkflowStepType } from './state';\r\n","import { ZodObjectDef, ZodTypeAny } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\n\nexport type JsonSchema7ObjectType = {\n  type: \"object\";\n  properties: Record<string, JsonSchema7Type>;\n  additionalProperties?: boolean | JsonSchema7Type;\n  required?: string[];\n};\n\nexport function parseObjectDef(def: ZodObjectDef, refs: Refs) {\n  const forceOptionalIntoNullable = refs.target === \"openAi\";\n\n  const result: JsonSchema7ObjectType = {\n    type: \"object\",\n    properties: {},\n  };\n\n  const required: string[] = [];\n\n  const shape = def.shape();\n\n  for (const propName in shape) {\n    let propDef = shape[propName];\n\n    if (propDef === undefined || propDef._def === undefined) {\n      continue;\n    }\n\n    let propOptional = safeIsOptional(propDef);\n\n    if (propOptional && forceOptionalIntoNullable) {\n      if (propDef._def.typeName === \"ZodOptional\") {\n        propDef = propDef._def.innerType;\n      }\n\n      if (!propDef.isNullable()) {\n        propDef = propDef.nullable();\n      }\n\n      propOptional = false;\n    }\n\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName],\n    });\n\n    if (parsedDef === undefined) {\n      continue;\n    }\n\n    result.properties[propName] = parsedDef;\n\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n\n  if (required.length) {\n    result.required = required;\n  }\n\n  const additionalProperties = decideAdditionalProperties(def, refs);\n\n  if (additionalProperties !== undefined) {\n    result.additionalProperties = additionalProperties;\n  }\n\n  return result;\n}\n\nfunction decideAdditionalProperties(def: ZodObjectDef, refs: Refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"],\n    });\n  }\n\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\"\n        ? refs.allowedAdditionalProperties\n        : refs.rejectedAdditionalProperties;\n  }\n}\n\nfunction safeIsOptional(schema: ZodTypeAny): boolean {\n  try {\n    return schema.isOptional();\n  } catch {\n    return true;\n  }\n}\n","import snakeCase from \"decamelize\";\nimport camelCase from \"camelcase\";\n\nexport interface SerializedFields {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\nexport interface SerializedKeyAlias {\n  [key: string]: string;\n}\n\nexport function keyToJson(key: string, map?: SerializedKeyAlias): string {\n  return map?.[key] || snakeCase(key);\n}\n\nexport function keyFromJson(key: string, map?: SerializedKeyAlias): string {\n  return map?.[key] || camelCase(key);\n}\n\nexport function mapKeys(\n  fields: SerializedFields,\n  mapper: typeof keyToJson,\n  map?: SerializedKeyAlias\n): SerializedFields {\n  const mapped: SerializedFields = {};\n\n  for (const key in fields) {\n    if (Object.hasOwn(fields, key)) {\n      mapped[mapper(key, map)] = fields[key];\n    }\n  }\n\n  return mapped;\n}\n","import { deepCompareStrict } from \"@cfworker/json-schema\";\nimport { BaseOutputParser } from \"./base.js\";\nimport {\n  type BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n} from \"../messages/base.js\";\nimport { convertToChunk } from \"../messages/utils.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  type Generation,\n  type ChatGeneration,\n  GenerationChunk,\n  ChatGenerationChunk,\n} from \"../outputs.js\";\n\n/**\n * Class to parse the output of an LLM call that also allows streaming inputs.\n */\nexport abstract class BaseTransformOutputParser<\n  T = unknown\n> extends BaseOutputParser<T> {\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk === \"string\") {\n        yield this.parseResult([{ text: chunk }]);\n      } else {\n        yield this.parseResult([\n          {\n            message: chunk,\n            text: this._baseMessageToString(chunk),\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Transforms an asynchronous generator of input into an asynchronous\n   * generator of parsed output.\n   * @param inputGenerator An asynchronous generator of input.\n   * @param options A configuration object.\n   * @returns An asynchronous generator of parsed output.\n   */\n  async *transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>,\n    options: BaseCallbackConfig\n  ): AsyncGenerator<T> {\n    yield* this._transformStreamWithConfig(\n      inputGenerator,\n      this._transform.bind(this),\n      {\n        ...options,\n        runType: \"parser\",\n      }\n    );\n  }\n}\n\nexport type BaseCumulativeTransformOutputParserInput = { diff?: boolean };\n\n/**\n * A base class for output parsers that can handle streaming input. It\n * extends the `BaseTransformOutputParser` class and provides a method for\n * converting parsed outputs into a diff format.\n */\nexport abstract class BaseCumulativeTransformOutputParser<\n  T = unknown\n> extends BaseTransformOutputParser<T> {\n  protected diff = false;\n\n  constructor(fields?: BaseCumulativeTransformOutputParserInput) {\n    super(fields);\n    this.diff = fields?.diff ?? this.diff;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected abstract _diff(prev: any | undefined, next: any): any;\n\n  abstract parsePartialResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<T | undefined>;\n\n  async *_transform(\n    inputGenerator: AsyncGenerator<string | BaseMessage>\n  ): AsyncGenerator<T> {\n    let prevParsed: T | undefined;\n    let accGen: GenerationChunk | undefined;\n    for await (const chunk of inputGenerator) {\n      if (typeof chunk !== \"string\" && typeof chunk.content !== \"string\") {\n        throw new Error(\"Cannot handle non-string output.\");\n      }\n      let chunkGen: GenerationChunk;\n      if (isBaseMessageChunk(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: chunk,\n          text: chunk.content,\n        });\n      } else if (isBaseMessage(chunk)) {\n        if (typeof chunk.content !== \"string\") {\n          throw new Error(\"Cannot handle non-string message output.\");\n        }\n        chunkGen = new ChatGenerationChunk({\n          message: convertToChunk(chunk),\n          text: chunk.content,\n        });\n      } else {\n        chunkGen = new GenerationChunk({ text: chunk });\n      }\n\n      if (accGen === undefined) {\n        accGen = chunkGen;\n      } else {\n        accGen = accGen.concat(chunkGen);\n      }\n\n      const parsed = await this.parsePartialResult([accGen]);\n      if (\n        parsed !== undefined &&\n        parsed !== null &&\n        !deepCompareStrict(parsed, prevParsed)\n      ) {\n        if (this.diff) {\n          yield this._diff(prevParsed, parsed);\n        } else {\n          yield parsed;\n        }\n        prevParsed = parsed;\n      }\n    }\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n","import * as uuid from \"uuid\";\nimport { LangSmithToOTELTranslator, } from \"./experimental/otel/translator.js\";\nimport { getDefaultOTLPTracerComponents, getOTELTrace, getOTELContext, } from \"./singletons/otel.js\";\nimport { AsyncCaller } from \"./utils/async_caller.js\";\nimport { convertLangChainMessageToExample, isLangChainMessage, } from \"./utils/messages.js\";\nimport { getEnvironmentVariable, getLangSmithEnvVarsMetadata, getLangSmithEnvironmentVariable, getRuntimeEnvironment, getOtelEnabled, getEnv, } from \"./utils/env.js\";\nimport { __version__ } from \"./index.js\";\nimport { assertUuid } from \"./utils/_uuid.js\";\nimport { warnOnce } from \"./utils/warn.js\";\nimport { parsePromptIdentifier } from \"./utils/prompts.js\";\nimport { raiseForStatus } from \"./utils/error.js\";\nimport { _globalFetchImplementationIsNodeFetch, _getFetchImplementation, } from \"./singletons/fetch.js\";\nimport { serialize as serializePayloadForTracing } from \"./utils/fast-safe-stringify/index.js\";\nexport function mergeRuntimeEnvIntoRun(run, cachedEnvVars) {\n    const runtimeEnv = getRuntimeEnvironment();\n    const envVars = cachedEnvVars ?? getLangSmithEnvVarsMetadata();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime,\n        },\n        metadata: {\n            ...envVars,\n            ...(envVars.revision_id || (\"revision_id\" in run && run.revision_id)\n                ? {\n                    revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ??\n                        envVars.revision_id,\n                }\n                : {}),\n            ...metadata,\n        },\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate) => {\n    const samplingRateStr = configRate?.toString() ??\n        getLangSmithEnvironmentVariable(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url) => {\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return (hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\");\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str\n        .trim()\n        .replace(/^\"(.*)\"$/, \"$1\")\n        .replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response) => {\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"10\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve) => setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nexport const DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;\n/** Default maximum memory (1GB) for queue size limits. */\nexport const DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024; // 1GB\nconst SERVER_INFO_REQUEST_TIMEOUT_MS = 10000;\n/** Maximum number of operations to batch in a single request. */\nconst DEFAULT_BATCH_SIZE_LIMIT = 100;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nexport class AutoBatchQueue {\n    constructor(maxSizeBytes) {\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"maxSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve) => {\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = serializePayloadForTracing(item.item, `Serializing run with id: ${item.item.id}`).length;\n        // Check if adding this item would exceed the size limit\n        // Allow the run if the queue is empty (to support large single traces)\n        if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {\n            console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. ` +\n                `Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);\n            // Resolve immediately to avoid blocking caller\n            itemPromiseResolve();\n            return itemPromise;\n        }\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size,\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop({ upToSizeBytes, upToSize, }) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while (poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes &&\n            this.items.length > 0 &&\n            popped.length < upToSize) {\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it) => ({\n                action: it.action,\n                item: it.payload,\n                otelContext: it.otelContext,\n                apiKey: it.apiKey,\n                apiUrl: it.apiUrl,\n                size: it.size,\n            })),\n            () => popped.forEach((it) => it.itemPromiseResolve()),\n        ];\n    }\n}\nexport class Client {\n    get _fetch() {\n        return this.fetchImplementation || _getFetchImplementation(this.debug);\n    }\n    constructor(config = {}) {\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"workspaceId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSizeLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getEnvironmentVariable(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cachedLSEnvVarsForMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: getEnvironmentVariable(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.workspaceId = trimQuotes(config.workspaceId ?? getLangSmithEnvironmentVariable(\"WORKSPACE_ID\"));\n        this.timeout_ms = config.timeout_ms ?? 90_000;\n        this.caller = new AsyncCaller({\n            ...(config.callerOptions ?? {}),\n            maxRetries: 4,\n            debug: config.debug ?? this.debug,\n        });\n        this.traceBatchConcurrency =\n            config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.fetchImplementation = config.fetchImplementation;\n        // Use maxIngestMemoryBytes for both queues\n        const maxMemory = config.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;\n        this.batchIngestCaller = new AsyncCaller({\n            maxRetries: 4,\n            maxConcurrency: this.traceBatchConcurrency,\n            maxQueueSizeBytes: maxMemory,\n            ...(config.callerOptions ?? {}),\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug,\n        });\n        this.hideInputs =\n            config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs =\n            config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.autoBatchQueue = new AutoBatchQueue(maxMemory);\n        this.blockOnRootRunFinalization =\n            config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.batchSizeLimit = config.batchSizeLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if (getOtelEnabled()) {\n            this.langSmithToOTELTranslator = new LangSmithToOTELTranslator();\n        }\n        // Cache metadata env vars once during construction to avoid repeatedly scanning process.env\n        this.cachedLSEnvVarsForMetadata = getLangSmithEnvVarsMetadata();\n    }\n    static getDefaultClientConfig() {\n        const apiKey = getLangSmithEnvironmentVariable(\"API_KEY\");\n        const apiUrl = getLangSmithEnvironmentVariable(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = getLangSmithEnvironmentVariable(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = getLangSmithEnvironmentVariable(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs,\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        }\n        else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.includes(\"/api\") &&\n            !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        }\n        else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${__version__}`,\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        if (this.workspaceId) {\n            headers[\"x-tenant-id\"] = this.workspaceId;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = { ...run };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `fetch ${path}`);\n            return res;\n        });\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while (true) {\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"GET\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await raiseForStatus(res, `fetch ${path}`);\n                return res;\n            });\n            const items = transform\n                ? transform(await response.json())\n                : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? { ...body } : {};\n        while (true) {\n            const body = JSON.stringify(bodyParams);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: requestMethod,\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await raiseForStatus(res, `fetch ${path}`);\n                return res;\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs) {\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                }\n                else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        }\n        else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs) {\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    }\n                    else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                }\n                else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeBytesLimit ??\n            serverInfo.batch_ingest_config?.size_limit_bytes ??\n            DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES);\n    }\n    /**\n     * Get the maximum number of operations to batch in a single request.\n     */\n    async _getBatchSizeLimit() {\n        const serverInfo = await this._ensureServerInfo();\n        return (this.batchSizeLimit ??\n            serverInfo.batch_ingest_config?.size_limit ??\n            DEFAULT_BATCH_SIZE_LIMIT);\n    }\n    async _getDatasetExamplesMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return (serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false);\n    }\n    drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit, }) {\n        const promises = [];\n        while (this.autoBatchQueue.items.length > 0) {\n            const [batch, done] = this.autoBatchQueue.pop({\n                upToSizeBytes: batchSizeLimitBytes,\n                upToSize: batchSizeLimit,\n            });\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item) => {\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)) {\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1],\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        // Calculate total batch size for queue tracking\n        const batchSizeBytes = batch.reduce((sum, item) => sum + (item.size ?? 0), 0);\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            }\n            else {\n                const ingestParams = {\n                    runCreates: batch\n                        .filter((item) => item.action === \"create\")\n                        .map((item) => item.item),\n                    runUpdates: batch\n                        .filter((item) => item.action === \"update\")\n                        .map((item) => item.item),\n                };\n                const serverInfo = await this._ensureServerInfo();\n                if (serverInfo?.batch_ingest_config?.use_multipart_endpoint) {\n                    const useGzip = serverInfo?.instance_flags?.gzip_body_enabled;\n                    await this.multipartIngestRuns(ingestParams, {\n                        ...options,\n                        useGzip,\n                        sizeBytes: batchSizeBytes,\n                    });\n                }\n                else {\n                    await this.batchIngestRuns(ingestParams, {\n                        ...options,\n                        sizeBytes: batchSizeBytes,\n                    });\n                }\n            }\n        }\n        catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch) {\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                    else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item,\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes ||\n            this.autoBatchQueue.items.length > sizeLimit) {\n            void this.drainAutoBatchQueue({\n                batchSizeLimitBytes: sizeLimitBytes,\n                batchSizeLimit: sizeLimit,\n            });\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(() => {\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue({\n                    batchSizeLimitBytes: sizeLimitBytes,\n                    batchSizeLimit: sizeLimit,\n                });\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/info`, {\n                method: \"GET\",\n                headers: { Accept: \"application/json\" },\n                signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get server info\");\n            return res;\n        });\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" +\n                JSON.stringify(json, null, 2) +\n                \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async () => {\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    }\n                    catch (e) {\n                        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? \"Unspecified status code\"} ${e.message}`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo) => {\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */\n    async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        await this.drainAutoBatchQueue({\n            batchSizeLimitBytes: sizeLimitBytes,\n            batchSizeLimit: sizeLimit,\n        });\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = getOTELTrace();\n        const otel_context = getOTELContext();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([run]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now(),\n        });\n        if (this.autoBatchTracing &&\n            runCreate.trace_id !== undefined &&\n            runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl,\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = serializePayloadForTracing(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async batchIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create) => this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update) => this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams,\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: [],\n        };\n        for (const k of [\"post\", \"patch\"]) {\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while (batchItem !== undefined) {\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post\n                .map((item) => item.id)\n                .concat(batchChunks.patch.map((item) => item.id))\n                .join(\",\");\n            await this._postBatchIngestRuns(serializePayloadForTracing(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        await this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"batch create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */\n    async multipartIngestRuns({ runCreates, runUpdates, }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []) {\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined &&\n                preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []) {\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate) => {\n            return (runCreate.trace_id === undefined || runCreate.dotted_order === undefined);\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate) => {\n            return (runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined);\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run) => {\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams) {\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam,\n                    };\n                }\n                else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 &&\n            preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\"post\", preparedCreateParams],\n            [\"patch\", preparedUpdateParams],\n        ]) {\n            for (const originalPayload of payloads) {\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = { inputs, outputs, events, extra, error, serialized };\n                // encode the main run payload\n                const stringifiedPayload = serializePayloadForTracing(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([stringifiedPayload], {\n                        type: `application/json; length=${stringifiedPayload.length}`, // encoding=gzip\n                    }),\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)) {\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = serializePayloadForTracing(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([stringifiedValue], {\n                            type: `application/json; length=${stringifiedValue.length}`,\n                        }),\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)) {\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            }\n                            else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` +\n                                    `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([content], {\n                                    type: `${contentType}; length=${content.byteLength}`,\n                                }),\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts) {\n            // Add field boundary\n            chunks.push(new Blob([`--${boundary}\\r\\n`]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`,\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\"\\r\\n\"]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([`--${boundary}--\\r\\n`]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start(controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk) => {\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    }\n                    else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts) {\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while (!(result = await reader.read()).done) {\n                            controller.enqueue(result.value);\n                        }\n                    }\n                    finally {\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            },\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = _globalFetchImplementationIsNodeFetch();\n        const buildBuffered = () => this._createNodeFetchBody(parts, boundary);\n        const buildStream = () => this._createMultipartStream(parts, boundary);\n        const sendWithRetry = async (bodyFactory) => {\n            return this.batchIngestCaller.callWithOptions({ sizeBytes: options?.sizeBytes }, async () => {\n                const body = await bodyFactory();\n                const headers = {\n                    ...this.headers,\n                    \"Content-Type\": `multipart/form-data; boundary=${boundary}`,\n                };\n                if (options?.apiKey !== undefined) {\n                    headers[\"x-api-key\"] = options.apiKey;\n                }\n                let transformedBody = body;\n                if (options?.useGzip &&\n                    typeof body === \"object\" &&\n                    \"pipeThrough\" in body) {\n                    transformedBody = body.pipeThrough(new CompressionStream(\"gzip\"));\n                    headers[\"Content-Encoding\"] = \"gzip\";\n                }\n                const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                    method: \"POST\",\n                    headers,\n                    body: transformedBody,\n                    duplex: \"half\",\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                });\n                await raiseForStatus(response, `Failed to send multipart request`, true);\n                return response;\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch or Bun\n            if (!isNodeFetch &&\n                !this.multipartStreamingDisabled &&\n                getEnv() !== \"bun\") {\n                streamedAttempt = true;\n                res = await sendWithRetry(buildStream);\n            }\n            else {\n                res = await sendWithRetry(buildBuffered);\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) &&\n                res.status === 422 &&\n                (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` +\n                    `This usually means the host does not support chunked uploads. ` +\n                    `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await sendWithRetry(buildBuffered);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        assertUuid(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = { ...run, id: runId };\n        if (!this._filterForSampling([data], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing &&\n            data.trace_id !== undefined &&\n            data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined &&\n                data.parent_run_id === undefined &&\n                this.blockOnRootRunFinalization &&\n                !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n                return;\n            }\n            else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl,\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = serializePayloadForTracing(run, `Serializing payload to update run with id: ${runId}`);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n                method: \"PATCH\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update run\", true);\n            return res;\n        });\n    }\n    async readRun(runId, { loadChildRuns } = { loadChildRuns: false }) {\n        assertUuid(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts, }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            }\n            else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({ projectName: projectOpts?.projectName })).id;\n            }\n            else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            }\n            else {\n                const project = await this.readProject({\n                    projectName: getLangSmithEnvironmentVariable(\"PROJECT\") || \"default\",\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        }\n        else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        }\n        else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id,\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b) => (a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns) {\n            if (childRun.parent_run_id === null ||\n                childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") &&\n                childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for (const runId in treemap) {\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */\n    async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order, } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [projectId];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName)\n                ? projectName\n                : [projectName];\n            const projectIds_ = await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\",\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order,\n        };\n        if (body.select.includes(\"child_run_ids\")) {\n            warnOnce(\"Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.\");\n        }\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)) {\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            }\n            else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset, } = props;\n        const sessionId = projectId || (await this.readProject({ projectName })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100,\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while (true) {\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset,\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value]) => value !== undefined));\n            const body = JSON.stringify(filteredPayload);\n            const response = await this.caller.call(async () => {\n                const res = await this._fetch(url, {\n                    method: \"POST\",\n                    headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body,\n                });\n                await raiseForStatus(res, `Failed to fetch ${path}`);\n                return res;\n            });\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups) {\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType, }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...(projectIds || []),\n                ...(await Promise.all(projectNames.map((name) => this.readProject({ projectName: name }).then((project) => project.id)))),\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType,\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value]) => value !== undefined));\n        const body = JSON.stringify(filteredPayload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/stats`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"get run stats\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid.v4(),\n        };\n        assertUuid(runId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"share run\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        assertUuid(runId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"unshare run\", true);\n            return res;\n        });\n    }\n    async readRunSharedLink(runId) {\n        assertUuid(runId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read run shared link\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds, } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken,\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds) {\n                queryParams.append(\"id\", runId);\n            }\n        }\n        assertUuid(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"list shared runs\");\n            return res;\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        assertUuid(datasetId);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read dataset shared schema\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId,\n        };\n        assertUuid(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"share dataset\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        assertUuid(datasetId);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"unshare dataset\", true);\n            return res;\n        });\n    }\n    async readSharedDataset(shareToken) {\n        assertUuid(shareToken);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read shared dataset\");\n            return res;\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */\n    async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach((v) => urlParams.append(key, v));\n            }\n            else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"list shared examples\");\n            return res;\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail)\n                    ? result.detail.join(\"\\n\")\n                    : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example) => ({\n            ...example,\n            _hostUrl: this.getHostUrl(),\n        }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null, }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description,\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null, }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = { ...(extra || {}), metadata };\n        }\n        const body = JSON.stringify({\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null,\n        });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(endpoint, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName, }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"has project\");\n            return res;\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats, }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId !== undefined) {\n            assertUuid(projectId);\n            path += `/${projectId}`;\n        }\n        else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        }\n        else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName, }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({ projectId, projectName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName, }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({ datasetId, datasetName });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({ limit: \"1\" });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)) {\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata, } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds) {\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        }\n        else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName,\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        if (datasetVersion !== undefined) {\n            params.append(\"dataset_version\", datasetVersion);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)) {\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName, }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        }\n        else if (projectId === undefined) {\n            projectId_ = (await this.readProject({ projectName })).id;\n        }\n        else {\n            projectId_ = projectId;\n        }\n        assertUuid(projectId_);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete session ${projectId_} (${projectName})`, true);\n            return res;\n        });\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name, }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key) => {\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key) => {\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await raiseForStatus(res, \"upload CSV\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata, } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? { metadata } : undefined,\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create dataset\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({ limit: \"1\" });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId) {\n            assertUuid(datasetId);\n            path += `/${datasetId}`;\n        }\n        else if (datasetName) {\n            params.append(\"name\", datasetName);\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        }\n        else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName, }) {\n        try {\n            await this.readDataset({ datasetId, datasetName });\n            return true;\n        }\n        catch (e) {\n            if (\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error &&\n                e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion, }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\"\n                ? fromVersion\n                : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString(),\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName, }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n            // do nothing\n        }\n        else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({ datasetName })).id;\n        }\n        else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText\n            .trim()\n            .split(\"\\n\")\n            .map((line) => JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata, } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString(),\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)) {\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */\n    async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        assertUuid(_datasetId);\n        const body = JSON.stringify(update);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update dataset\");\n            return res;\n        });\n        return (await response.json());\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */\n    async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({ datasetName })).id;\n        assertUuid(_datasetId);\n        const body = JSON.stringify({\n            as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n            tag,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update dataset tags\", true);\n            return res;\n        });\n    }\n    async deleteDataset({ datasetId, datasetName, }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            assertUuid(datasetId_);\n            path += `/${datasetId_}`;\n        }\n        else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async indexDataset({ datasetId, datasetName, tag, }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (!datasetId_) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        assertUuid(datasetId_);\n        const data = {\n            tag: tag,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"index dataset\");\n            return res;\n        });\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */\n    async similarExamples(inputs, datasetId, limit, { filter, } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs,\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        assertUuid(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                method: \"POST\",\n                body,\n            });\n            await raiseForStatus(res, \"fetch similar examples\");\n            return res;\n        });\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs\n            ? options?.datasetName\n            : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments,\n            };\n        }\n        else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [data]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid.v4());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            }\n            else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            }\n            else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({ datasetName: datasetName_ });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName, } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({ datasetName: datasetName_ });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx) => {\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx],\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id) => this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({ input }, { output: generation }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message) => {\n            if (isLangChainMessage(message)) {\n                return convertLangChainMessageToExample(message);\n            }\n            return message;\n        });\n        const finalOutput = isLangChainMessage(generations)\n            ? convertLangChainMessageToExample(generations)\n            : generations;\n        return this.createExample({ input: finalInput }, { output: finalOutput }, options);\n    }\n    async readExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type,\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments, } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        }\n        else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({ dataset: datasetId_ });\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds) {\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits) {\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\"attachment_urls\", \"outputs\", \"metadata\"].forEach((field) => params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)) {\n            for (const rawExample of rawExamples) {\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value]) => {\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined,\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        assertUuid(exampleId);\n        const path = `/examples/${exampleId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        }\n        else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        assertUuid(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = { id: exampleId, ...update };\n        }\n        else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        }\n        else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [updateToUse]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        }\n        else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */\n    async readDatasetVersion({ datasetId, datasetName, asOf, tag, }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({ datasetName });\n            resolvedDatasetId = dataset.id;\n        }\n        else {\n            resolvedDatasetId = datasetId;\n        }\n        assertUuid(resolvedDatasetId);\n        if ((asOf && tag) || (!asOf && !tag)) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n                method: \"GET\",\n                headers: { ...this.headers },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read dataset version\");\n            return res;\n        });\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        assertUuid(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf\n            ? typeof asOf === \"string\"\n                ? asOf\n                : asOf?.toISOString()\n            : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false, }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        }\n        else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        }\n        else if (datasetId === undefined) {\n            const dataset = await this.readDataset({ datasetName });\n            datasetId_ = dataset.id;\n        }\n        else {\n            datasetId_ = datasetId;\n        }\n        assertUuid(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id) => {\n                assertUuid(id);\n                return id;\n            }),\n            remove,\n        };\n        const body = JSON.stringify(data);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {\n                method: \"PUT\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update dataset splits\", true);\n            return res;\n        });\n    }\n    /**\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\n     */\n    async evaluateRun(run, evaluator, { sourceInfo, loadChildRuns, referenceExample, } = { loadChildRuns: false }) {\n        warnOnce(\"This method is deprecated and will be removed in future LangSmith versions, use `evaluate` from `langsmith/evaluation` instead.\");\n        let run_;\n        if (typeof run === \"string\") {\n            run_ = await this.readRun(run, { loadChildRuns });\n        }\n        else if (typeof run === \"object\" && \"id\" in run) {\n            run_ = run;\n        }\n        else {\n            throw new Error(`Invalid run type: ${typeof run}`);\n        }\n        if (run_.reference_example_id !== null &&\n            run_.reference_example_id !== undefined) {\n            referenceExample = await this.readExample(run_.reference_example_id);\n        }\n        const feedbackResult = await evaluator.evaluateRun(run_, referenceExample);\n        const [_, feedbacks] = await this._logEvaluationFeedback(feedbackResult, run_, sourceInfo);\n        return feedbacks[0];\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId, }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {},\n        };\n        if (sourceRunId !== undefined &&\n            feedback_source?.metadata !== undefined &&\n            !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = { run_id: sourceRunId };\n        }\n        if (feedback_source?.metadata !== undefined &&\n            feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            assertUuid(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid.v4(),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId,\n        };\n        const body = JSON.stringify(feedback);\n        const url = `${this.apiUrl}/feedback`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create feedback\", true);\n            return res;\n        });\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment, }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        assertUuid(feedbackId);\n        const body = JSON.stringify(feedbackUpdate);\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update feedback\", true);\n            return res;\n        });\n    }\n    async readFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        assertUuid(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        await this.caller.call(async () => {\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes, } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            for (const runId of runIds) {\n                assertUuid(runId);\n                queryParams.append(\"run\", runId);\n            }\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys) {\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes) {\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)) {\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */\n    async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig, } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig,\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            }\n            else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        }\n        else {\n            body[\"expires_in\"] = {\n                hours: 3,\n            };\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create presigned feedback token\");\n            return res;\n        });\n        return await response.json();\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id, }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0],\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {},\n        };\n        if (metadata)\n            body.extra[\"metadata\"] = metadata;\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create comparative experiment\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */\n    async *listPresignedFeedbackTokens(runId) {\n        assertUuid(runId);\n        const params = new URLSearchParams({ run_id: runId });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)) {\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        }\n        else if (Array.isArray(results)) {\n            results_ = results;\n        }\n        else {\n            results_ = [results];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults) {\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = { ...res.evaluatorInfo, ...sourceInfo_ };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            }\n            else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\",\n            }));\n        }\n        return [evalResults, feedbacks];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */\n    /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */\n    async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i) => {\n                assertUuid(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name)\n            params.append(\"name\", name);\n        if (nameContains)\n            params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)) {\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit)\n                break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */\n    async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid.v4(),\n            rubric_instructions: rubricInstructions,\n        };\n        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v]) => v !== undefined)));\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody,\n            });\n            await raiseForStatus(res, \"create annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */\n    async readAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"read annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */\n    async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const body = JSON.stringify({\n            name,\n            description,\n            rubric_instructions: rubricInstructions,\n        });\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n                method: \"PATCH\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */\n    async deleteAnnotationQueue(queueId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"delete annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */\n    async addRunsToAnnotationQueue(queueId, runIds) {\n        const body = JSON.stringify(runIds.map((id, i) => assertUuid(id, `runIds[${i}]`).toString()));\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"add runs to annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */\n    async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${assertUuid(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get run from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */\n    async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/runs/${assertUuid(queueRunId, \"queueRunId\")}`, {\n                method: \"DELETE\",\n                headers: { ...this.headers, Accept: \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"delete run from annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */\n    async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${assertUuid(queueId, \"queueId\")}/size`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get size from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"get latest commit hash\");\n            return res;\n        });\n        const json = await response.json();\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const body = JSON.stringify({ like: like });\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, `${like ? \"like\" : \"unlike\"} prompt`);\n            return res;\n        });\n        return response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            }\n            else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        }\n        else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            }\n            else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res) => res.commits)) {\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res) => res.repos)) {\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            if (res?.status === 404) {\n                return null;\n            }\n            await raiseForStatus(res, \"get prompt\");\n            return res;\n        });\n        const result = await response?.json();\n        if (result?.repo) {\n            return result.repo;\n        }\n        else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...(options?.description && { description: options.description }),\n            ...(options?.readme && { readme: options.readme }),\n            ...(options?.tags && { tags: options.tags }),\n            is_public: !!options?.isPublic,\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create prompt\");\n            return res;\n        });\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash\n            ? await this._getLatestCommitHash(`${owner}/${promptName}`)\n            : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash,\n        };\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: { ...this.headers, \"Content-Type\": \"application/json\" },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"create commit\");\n            return res;\n        });\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */\n    async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates) {\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n            };\n            // Add main example data\n            const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = serializePayloadForTracing(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([stringifiedAttachmentsOperations], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n                method: \"PATCH\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await raiseForStatus(res, \"update examples\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */\n    async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!(await this._getDatasetExamplesMultiPartSupport())) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads) {\n            const exampleId = (example.id ?? uuid.v4()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...(example.metadata && { metadata: example.metadata }),\n                ...(example.split && { split: example.split }),\n                ...(example.source_run_id && { source_run_id: example.source_run_id }),\n                ...(example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io,\n                }),\n                ...(example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments,\n                }),\n            };\n            // Add main example data\n            const stringifiedExample = serializePayloadForTracing(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([stringifiedExample], {\n                type: \"application/json\",\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = serializePayloadForTracing(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([stringifiedInputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = serializePayloadForTracing(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([stringifiedOutputs], {\n                    type: \"application/json\",\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)) {\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    }\n                    else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([data], {\n                        type: `${mimeType}; length=${data.byteLength}`,\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData,\n            });\n            await raiseForStatus(res, \"upload examples\");\n            return res;\n        });\n        return response.json();\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined)\n            payload.description = options.description;\n        if (options?.readme !== undefined)\n            payload.readme = options.readme;\n        if (options?.tags !== undefined)\n            payload.tags = options.tags;\n        if (options?.isPublic !== undefined)\n            payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined)\n            payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\",\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body,\n            });\n            await raiseForStatus(res, \"update prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!(await this.promptExists(promptIdentifier))) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = parsePromptIdentifier(promptIdentifier);\n        if (!(await this._currentTenantIsOwner(owner))) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"delete prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = parsePromptIdentifier(promptIdentifier);\n        const response = await this.caller.call(async () => {\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n            });\n            await raiseForStatus(res, \"pull prompt commit\");\n            return res;\n        });\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples,\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */\n    async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel,\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key) => key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic,\n                });\n            }\n        }\n        else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic,\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash,\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */\n    async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\",\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({ datasetId: finalDatasetName })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        }\n        catch (_) {\n            // `.hasDataset` will throw an error if the dataset does not exist.\n            // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined,\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e) => e.inputs),\n                outputs: examples.flatMap((e) => (e.outputs ? [e.outputs] : [])),\n                datasetId: dataset.id,\n            });\n        }\n        catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` +\n                \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            assertUuid(urlOrToken); // Will throw if it's not a UUID.\n            return [apiUrl, urlOrToken];\n        }\n        catch (_) {\n            // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname\n                .split(\"/\")\n                .filter((part) => part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [apiUrl, tokenUuid];\n            }\n            else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */\n    async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise }) => itemPromise),\n            this.batchIngestCaller.queue.onIdle(),\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await getDefaultOTLPTracerComponents()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n","import {\n  BaseMessage,\n  BaseMessageLike,\n  coerceMessageLikeToMessage,\n} from \"@langchain/core/messages\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { v4 } from \"uuid\";\nimport { StateGraph } from \"./state.js\";\nimport { ensureLangGraphConfig } from \"../pregel/utils/config.js\";\nimport type { StreamMessagesHandler } from \"../pregel/messages.js\";\n\nexport const REMOVE_ALL_MESSAGES = \"__remove_all__\";\n\nexport type Messages =\n  | Array<BaseMessage | BaseMessageLike>\n  | BaseMessage\n  | BaseMessageLike;\n\n/**\n * Prebuilt reducer that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n */\nexport function messagesStateReducer(\n  left: Messages,\n  right: Messages\n): BaseMessage[] {\n  const leftArray = Array.isArray(left) ? left : [left];\n  const rightArray = Array.isArray(right) ? right : [right];\n  // coerce to message\n  const leftMessages = (leftArray as BaseMessageLike[]).map(\n    coerceMessageLikeToMessage\n  );\n  const rightMessages = (rightArray as BaseMessageLike[]).map(\n    coerceMessageLikeToMessage\n  );\n  // assign missing ids\n  for (const m of leftMessages) {\n    if (m.id === null || m.id === undefined) {\n      m.id = v4();\n      m.lc_kwargs.id = m.id;\n    }\n  }\n\n  let removeAllIdx: number | undefined;\n  for (let i = 0; i < rightMessages.length; i += 1) {\n    const m = rightMessages[i];\n    if (m.id === null || m.id === undefined) {\n      m.id = v4();\n      m.lc_kwargs.id = m.id;\n    }\n\n    if (m.getType() === \"remove\" && m.id === REMOVE_ALL_MESSAGES) {\n      removeAllIdx = i;\n    }\n  }\n\n  if (removeAllIdx != null) return rightMessages.slice(removeAllIdx + 1);\n\n  // merge\n  const merged = [...leftMessages];\n  const mergedById = new Map(merged.map((m, i) => [m.id, i]));\n  const idsToRemove = new Set();\n  for (const m of rightMessages) {\n    const existingIdx = mergedById.get(m.id);\n    if (existingIdx !== undefined) {\n      if (m.getType() === \"remove\") {\n        idsToRemove.add(m.id);\n      } else {\n        idsToRemove.delete(m.id);\n        merged[existingIdx] = m;\n      }\n    } else {\n      if (m.getType() === \"remove\") {\n        throw new Error(\n          `Attempting to delete a message with an ID that doesn't exist ('${m.id}')`\n        );\n      }\n      mergedById.set(m.id, merged.length);\n      merged.push(m);\n    }\n  }\n  return merged.filter((m) => !idsToRemove.has(m.id));\n}\n\n/** @ignore */\nexport class MessageGraph extends StateGraph<\n  BaseMessage[],\n  BaseMessage[],\n  Messages\n> {\n  constructor() {\n    super({\n      channels: {\n        __root__: {\n          reducer: messagesStateReducer,\n          default: () => [],\n        },\n      },\n    });\n  }\n}\n\n/**\n * Manually push a message to a message stream.\n *\n * This is useful when you need to push a manually created message before the node\n * has finished executing.\n *\n * When a message is pushed, it will be automatically persisted to the state after the node has finished executing.\n * To disable persisting, set `options.stateKey` to `null`.\n *\n * @param message The message to push. The message must have an ID set, otherwise an error will be thrown.\n * @param options RunnableConfig / Runtime coming from node context.\n */\nexport function pushMessage(\n  message: BaseMessage | BaseMessageLike,\n  options?: RunnableConfig & {\n    /**\n     * The key of the state to push the message to. Set to `null` to avoid persisting.\n     * @default \"messages\"\n     */\n    stateKey?: string | null;\n  }\n) {\n  const { stateKey: userStateKey, ...userConfig } = options ?? {};\n  const config = ensureLangGraphConfig(userConfig);\n\n  let stateKey: string | undefined = userStateKey ?? \"messages\";\n  if (userStateKey === null) stateKey = undefined;\n\n  // coerce to message\n  const validMessage = coerceMessageLikeToMessage(message);\n  if (!validMessage.id) throw new Error(\"Message ID is required.\");\n\n  const callbacks = (() => {\n    if (Array.isArray(config.callbacks)) {\n      return config.callbacks;\n    }\n\n    if (typeof config.callbacks !== \"undefined\") {\n      return config.callbacks.handlers;\n    }\n\n    return [];\n  })();\n\n  const messagesHandler = callbacks.find(\n    (cb): cb is StreamMessagesHandler =>\n      \"name\" in cb && cb.name === \"StreamMessagesHandler\"\n  );\n\n  if (messagesHandler) {\n    const metadata = config.metadata ?? {};\n    const namespace = (\n      (metadata.langgraph_checkpoint_ns ?? \"\") as string\n    ).split(\"|\");\n\n    messagesHandler._emit(\n      [namespace, metadata],\n      validMessage,\n      undefined,\n      false\n    );\n  }\n\n  if (stateKey) {\n    config.configurable?.__pregel_send?.([[stateKey, validMessage]]);\n  }\n\n  return validMessage;\n}\n","import { Edge, Node } from \"./types.js\";\nimport { toBase64Url } from \"./utils.js\";\n\nfunction _escapeNodeLabel(nodeLabel: string): string {\n  // Escapes the node label for Mermaid syntax.\n  return nodeLabel.replace(/[^a-zA-Z-_0-9]/g, \"_\");\n}\n\nconst MARKDOWN_SPECIAL_CHARS = [\"*\", \"_\", \"`\"];\n\nfunction _generateMermaidGraphStyles(\n  nodeColors: Record<string, string>\n): string {\n  let styles = \"\";\n  for (const [className, color] of Object.entries(nodeColors)) {\n    styles += `\\tclassDef ${className} ${color};\\n`;\n  }\n  return styles;\n}\n\n/**\n * Draws a Mermaid graph using the provided graph data\n */\nexport function drawMermaid(\n  nodes: Record<string, Node>,\n  edges: Edge[],\n  config?: {\n    firstNode?: string;\n    lastNode?: string;\n    curveStyle?: string;\n    withStyles?: boolean;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }\n): string {\n  const {\n    firstNode,\n    lastNode,\n    nodeColors,\n    withStyles = true,\n    curveStyle = \"linear\",\n    wrapLabelNWords = 9,\n  } = config ?? {};\n  // Initialize Mermaid graph configuration\n  let mermaidGraph = withStyles\n    ? `%%{init: {'flowchart': {'curve': '${curveStyle}'}}}%%\\ngraph TD;\\n`\n    : \"graph TD;\\n\";\n  if (withStyles) {\n    // Node formatting templates\n    const defaultClassLabel = \"default\";\n    const formatDict: Record<string, string> = {\n      [defaultClassLabel]: \"{0}({1})\",\n    };\n    if (firstNode !== undefined) {\n      formatDict[firstNode] = \"{0}([{1}]):::first\";\n    }\n    if (lastNode !== undefined) {\n      formatDict[lastNode] = \"{0}([{1}]):::last\";\n    }\n\n    // Add nodes to the graph\n    for (const [key, node] of Object.entries(nodes)) {\n      const nodeName = node.name.split(\":\").pop() ?? \"\";\n      const label = MARKDOWN_SPECIAL_CHARS.some(\n        (char) => nodeName.startsWith(char) && nodeName.endsWith(char)\n      )\n        ? `<p>${nodeName}</p>`\n        : nodeName;\n\n      let finalLabel = label;\n      if (Object.keys(node.metadata ?? {}).length) {\n        finalLabel += `<hr/><small><em>${Object.entries(node.metadata ?? {})\n          .map(([k, v]) => `${k} = ${v}`)\n          .join(\"\\n\")}</em></small>`;\n      }\n\n      const nodeLabel = (formatDict[key] ?? formatDict[defaultClassLabel])\n        .replace(\"{0}\", _escapeNodeLabel(key))\n        .replace(\"{1}\", finalLabel);\n\n      mermaidGraph += `\\t${nodeLabel}\\n`;\n    }\n  }\n\n  // Group edges by their common prefixes\n  const edgeGroups: Record<string, Edge[]> = {};\n  for (const edge of edges) {\n    const srcParts = edge.source.split(\":\");\n    const tgtParts = edge.target.split(\":\");\n    const commonPrefix = srcParts\n      .filter((src, i) => src === tgtParts[i])\n      .join(\":\");\n    if (!edgeGroups[commonPrefix]) {\n      edgeGroups[commonPrefix] = [];\n    }\n    edgeGroups[commonPrefix].push(edge);\n  }\n\n  const seenSubgraphs = new Set<string>();\n\n  function addSubgraph(edges: Edge[], prefix: string): void {\n    const selfLoop = edges.length === 1 && edges[0].source === edges[0].target;\n    if (prefix && !selfLoop) {\n      const subgraph = prefix.split(\":\").pop()!;\n      if (seenSubgraphs.has(subgraph)) {\n        throw new Error(\n          `Found duplicate subgraph '${subgraph}' -- this likely means that ` +\n            \"you're reusing a subgraph node with the same name. \" +\n            \"Please adjust your graph to have subgraph nodes with unique names.\"\n        );\n      }\n\n      seenSubgraphs.add(subgraph);\n      mermaidGraph += `\\tsubgraph ${subgraph}\\n`;\n    }\n\n    for (const edge of edges) {\n      const { source, target, data, conditional } = edge;\n\n      let edgeLabel = \"\";\n      if (data !== undefined) {\n        let edgeData = data;\n        const words = edgeData.split(\" \");\n        if (words.length > wrapLabelNWords) {\n          edgeData = Array.from(\n            { length: Math.ceil(words.length / wrapLabelNWords) },\n            (_, i) =>\n              words\n                .slice(i * wrapLabelNWords, (i + 1) * wrapLabelNWords)\n                .join(\" \")\n          ).join(\"&nbsp;<br>&nbsp;\");\n        }\n        edgeLabel = conditional\n          ? ` -. &nbsp;${edgeData}&nbsp; .-> `\n          : ` -- &nbsp;${edgeData}&nbsp; --> `;\n      } else {\n        edgeLabel = conditional ? \" -.-> \" : \" --> \";\n      }\n\n      mermaidGraph += `\\t${_escapeNodeLabel(\n        source\n      )}${edgeLabel}${_escapeNodeLabel(target)};\\n`;\n    }\n\n    // Recursively add nested subgraphs\n    for (const nestedPrefix in edgeGroups) {\n      if (nestedPrefix.startsWith(`${prefix}:`) && nestedPrefix !== prefix) {\n        addSubgraph(edgeGroups[nestedPrefix], nestedPrefix);\n      }\n    }\n\n    if (prefix && !selfLoop) {\n      mermaidGraph += \"\\tend\\n\";\n    }\n  }\n\n  // Start with the top-level edges (no common prefix)\n  addSubgraph(edgeGroups[\"\"] ?? [], \"\");\n\n  // Add remaining subgraphs\n  for (const prefix in edgeGroups) {\n    if (!prefix.includes(\":\") && prefix !== \"\") {\n      addSubgraph(edgeGroups[prefix], prefix);\n    }\n  }\n\n  // Add custom styles for nodes\n  if (withStyles) {\n    mermaidGraph += _generateMermaidGraphStyles(nodeColors ?? {});\n  }\n\n  return mermaidGraph;\n}\n\n/**\n * Renders Mermaid graph using the Mermaid.INK API.\n *\n * @example\n * ```javascript\n * const image = await drawMermaidImage(mermaidSyntax, {\n *   backgroundColor: \"white\",\n *   imageType: \"png\",\n * });\n * fs.writeFileSync(\"image.png\", image);\n * ```\n *\n * @param mermaidSyntax - The Mermaid syntax to render.\n * @param config - The configuration for the image.\n * @returns The image as a Blob.\n */\nexport async function drawMermaidImage(\n  mermaidSyntax: string,\n  config?: {\n    /**\n     * The type of image to render.\n     * @default \"png\"\n     */\n    imageType?: \"png\" | \"jpeg\" | \"webp\";\n    backgroundColor?: string;\n  }\n) {\n  let backgroundColor = config?.backgroundColor ?? \"white\";\n  const imageType = config?.imageType ?? \"png\";\n\n  const mermaidSyntaxEncoded = toBase64Url(mermaidSyntax);\n\n  // Check if the background color is a hexadecimal color code using regex\n  if (backgroundColor !== undefined) {\n    const hexColorPattern = /^#(?:[0-9a-fA-F]{3}){1,2}$/;\n    if (!hexColorPattern.test(backgroundColor)) {\n      backgroundColor = `!${backgroundColor}`;\n    }\n  }\n  const imageUrl = `https://mermaid.ink/img/${mermaidSyntaxEncoded}?bgColor=${backgroundColor}&type=${imageType}`;\n  const res = await fetch(imageUrl);\n  if (!res.ok) {\n    throw new Error(\n      [\n        `Failed to render the graph using the Mermaid.INK API.`,\n        `Status code: ${res.status}`,\n        `Status text: ${res.statusText}`,\n      ].join(\"\\n\")\n    );\n  }\n  const content = await res.blob();\n  return content;\n}\n","/**\n * Checks if the provided argument is an object and not an array.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isObject(obj: any): obj is object {\n  return obj && typeof obj === \"object\" && !Array.isArray(obj);\n}\n\n/**\n * Checks if a provided filter is empty. The filter can be a function, an\n * object, a string, or undefined.\n */\nexport function isFilterEmpty(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  filter: ((q: any) => any) | object | string | undefined\n): filter is undefined {\n  if (!filter) return true;\n  // for Milvus\n  if (typeof filter === \"string\" && filter.length > 0) {\n    return false;\n  }\n  if (typeof filter === \"function\") {\n    return false;\n  }\n  return isObject(filter) && Object.keys(filter).length === 0;\n}\n\n/**\n * Checks if the provided value is an integer.\n */\nexport function isInt(value: unknown): boolean {\n  if (typeof value === \"number\") {\n    return value % 1 === 0;\n  } else if (typeof value === \"string\") {\n    const numberValue = parseInt(value, 10);\n    return (\n      !Number.isNaN(numberValue) &&\n      numberValue % 1 === 0 &&\n      numberValue.toString() === value\n    );\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided value is a floating-point number.\n */\nexport function isFloat(value: unknown): boolean {\n  if (typeof value === \"number\") {\n    return value % 1 !== 0;\n  } else if (typeof value === \"string\") {\n    const numberValue = parseFloat(value);\n    return (\n      !Number.isNaN(numberValue) &&\n      numberValue % 1 !== 0 &&\n      numberValue.toString() === value\n    );\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided value is a string that cannot be parsed into a\n * number.\n */\nexport function isString(value: unknown): boolean {\n  return (\n    typeof value === \"string\" &&\n    (Number.isNaN(parseFloat(value)) || parseFloat(value).toString() !== value)\n  );\n}\n\n/**\n * Checks if the provided value is a boolean.\n */\nexport function isBoolean(value: unknown): boolean {\n  return typeof value === \"boolean\";\n}\n\n/**\n * Casts a value that might be string or number to actual string or number.\n * Since LLM might return back an integer/float as a string, we need to cast\n * it back to a number, as many vector databases can't handle number as string\n * values as a comparator.\n */\nexport function castValue(input: unknown): string | number | boolean {\n  let value;\n  if (isString(input)) {\n    value = input as string;\n  } else if (isInt(input)) {\n    value = parseInt(input as string, 10);\n  } else if (isFloat(input)) {\n    value = parseFloat(input as string);\n  } else if (isBoolean(input)) {\n    value = Boolean(input);\n  } else {\n    throw new Error(\"Unsupported value type\");\n  }\n\n  return value;\n}\n","import {\n  Tiktoken,\n  TiktokenEncoding,\n  TiktokenModel,\n  getEncodingNameForModel,\n} from \"js-tiktoken/lite\";\nimport { AsyncCaller } from \"./async_caller.js\";\n\nconst cache: Record<string, Promise<Tiktoken>> = {};\n\nconst caller = /* #__PURE__ */ new AsyncCaller({});\n\nexport async function getEncoding(encoding: TiktokenEncoding) {\n  if (!(encoding in cache)) {\n    cache[encoding] = caller\n      .fetch(`https://tiktoken.pages.dev/js/${encoding}.json`)\n      .then((res) => res.json())\n      .then((data) => new Tiktoken(data))\n      .catch((e) => {\n        delete cache[encoding];\n        throw e;\n      });\n  }\n\n  return await cache[encoding];\n}\n\nexport async function encodingForModel(model: TiktokenModel) {\n  return getEncoding(getEncodingNameForModel(model));\n}\n","import { v4 as uuidv4, validate as isUuid } from \"uuid\";\nimport type {\n  RunnableInterface,\n  RunnableIOSchema,\n  Node,\n  Edge,\n} from \"./types.js\";\nimport { isRunnableInterface } from \"./utils.js\";\nimport { drawMermaid, drawMermaidImage } from \"./graph_mermaid.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\n\nexport { Node, Edge };\n\nfunction nodeDataStr(\n  id: string | undefined,\n  data: RunnableInterface | RunnableIOSchema\n): string {\n  if (id !== undefined && !isUuid(id)) {\n    return id;\n  } else if (isRunnableInterface(data)) {\n    try {\n      let dataStr = data.getName();\n      dataStr = dataStr.startsWith(\"Runnable\")\n        ? dataStr.slice(\"Runnable\".length)\n        : dataStr;\n      return dataStr;\n    } catch {\n      return data.getName();\n    }\n  } else {\n    return data.name ?? \"UnknownSchema\";\n  }\n}\n\nfunction nodeDataJson(node: Node) {\n  // if node.data implements Runnable\n  if (isRunnableInterface(node.data)) {\n    return {\n      type: \"runnable\",\n      data: {\n        id: node.data.lc_id,\n        name: node.data.getName(),\n      },\n    };\n  } else {\n    return {\n      type: \"schema\",\n      data: { ...toJsonSchema(node.data.schema), title: node.data.name },\n    };\n  }\n}\n\nexport class Graph {\n  nodes: Record<string, Node> = {};\n\n  edges: Edge[] = [];\n\n  constructor(params?: { nodes: Record<string, Node>; edges: Edge[] }) {\n    this.nodes = params?.nodes ?? this.nodes;\n    this.edges = params?.edges ?? this.edges;\n  }\n\n  // Convert the graph to a JSON-serializable format.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON(): Record<string, any> {\n    const stableNodeIds: Record<string, string | number> = {};\n    Object.values(this.nodes).forEach((node, i) => {\n      stableNodeIds[node.id] = isUuid(node.id) ? i : node.id;\n    });\n\n    return {\n      nodes: Object.values(this.nodes).map((node) => ({\n        id: stableNodeIds[node.id],\n        ...nodeDataJson(node),\n      })),\n      edges: this.edges.map((edge) => {\n        const item: Record<string, unknown> = {\n          source: stableNodeIds[edge.source],\n          target: stableNodeIds[edge.target],\n        };\n\n        if (typeof edge.data !== \"undefined\") {\n          item.data = edge.data;\n        }\n\n        if (typeof edge.conditional !== \"undefined\") {\n          item.conditional = edge.conditional;\n        }\n        return item;\n      }),\n    };\n  }\n\n  addNode(\n    data: RunnableInterface | RunnableIOSchema,\n    id?: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): Node {\n    if (id !== undefined && this.nodes[id] !== undefined) {\n      throw new Error(`Node with id ${id} already exists`);\n    }\n    const nodeId = id ?? uuidv4();\n    const node: Node = {\n      id: nodeId,\n      data,\n      name: nodeDataStr(id, data),\n      metadata,\n    };\n    this.nodes[nodeId] = node;\n    return node;\n  }\n\n  removeNode(node: Node): void {\n    // Remove the node from the nodes map\n    delete this.nodes[node.id];\n\n    // Filter out edges connected to the node\n    this.edges = this.edges.filter(\n      (edge) => edge.source !== node.id && edge.target !== node.id\n    );\n  }\n\n  addEdge(\n    source: Node,\n    target: Node,\n    data?: string,\n    conditional?: boolean\n  ): Edge {\n    if (this.nodes[source.id] === undefined) {\n      throw new Error(`Source node ${source.id} not in graph`);\n    }\n    if (this.nodes[target.id] === undefined) {\n      throw new Error(`Target node ${target.id} not in graph`);\n    }\n    const edge: Edge = {\n      source: source.id,\n      target: target.id,\n      data,\n      conditional,\n    };\n    this.edges.push(edge);\n    return edge;\n  }\n\n  firstNode(): Node | undefined {\n    return _firstNode(this);\n  }\n\n  lastNode(): Node | undefined {\n    return _lastNode(this);\n  }\n\n  /**\n   * Add all nodes and edges from another graph.\n   * Note this doesn't check for duplicates, nor does it connect the graphs.\n   */\n  extend(graph: Graph, prefix = \"\") {\n    let finalPrefix = prefix;\n    const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n    if (nodeIds.every(isUuid)) {\n      finalPrefix = \"\";\n    }\n\n    const prefixed = (id: string) => {\n      return finalPrefix ? `${finalPrefix}:${id}` : id;\n    };\n\n    Object.entries(graph.nodes).forEach(([key, value]) => {\n      this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n    });\n\n    const newEdges = graph.edges.map((edge) => {\n      return {\n        ...edge,\n        source: prefixed(edge.source),\n        target: prefixed(edge.target),\n      };\n    });\n    // Add all edges from the other graph\n    this.edges = [...this.edges, ...newEdges];\n    const first = graph.firstNode();\n    const last = graph.lastNode();\n    return [\n      first ? { id: prefixed(first.id), data: first.data } : undefined,\n      last ? { id: prefixed(last.id), data: last.data } : undefined,\n    ];\n  }\n\n  trimFirstNode(): void {\n    const firstNode = this.firstNode();\n    if (firstNode && _firstNode(this, [firstNode.id])) {\n      this.removeNode(firstNode);\n    }\n  }\n\n  trimLastNode(): void {\n    const lastNode = this.lastNode();\n    if (lastNode && _lastNode(this, [lastNode.id])) {\n      this.removeNode(lastNode);\n    }\n  }\n\n  /**\n   * Return a new graph with all nodes re-identified,\n   * using their unique, readable names where possible.\n   */\n  reid(): Graph {\n    const nodeLabels: Record<string, string> = Object.fromEntries(\n      Object.values(this.nodes).map((node) => [node.id, node.name])\n    );\n    const nodeLabelCounts = new Map<string, number>();\n    Object.values(nodeLabels).forEach((label) => {\n      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n    });\n\n    const getNodeId = (nodeId: string): string => {\n      const label = nodeLabels[nodeId];\n      if (isUuid(nodeId) && nodeLabelCounts.get(label) === 1) {\n        return label;\n      } else {\n        return nodeId;\n      }\n    };\n\n    return new Graph({\n      nodes: Object.fromEntries(\n        Object.entries(this.nodes).map(([id, node]) => [\n          getNodeId(id),\n          { ...node, id: getNodeId(id) },\n        ])\n      ),\n      edges: this.edges.map((edge) => ({\n        ...edge,\n        source: getNodeId(edge.source),\n        target: getNodeId(edge.target),\n      })),\n    });\n  }\n\n  drawMermaid(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }): string {\n    const {\n      withStyles,\n      curveStyle,\n      nodeColors = {\n        default: \"fill:#f2f0ff,line-height:1.2\",\n        first: \"fill-opacity:0\",\n        last: \"fill:#bfb6fc\",\n      },\n      wrapLabelNWords,\n    } = params ?? {};\n    const graph = this.reid();\n    const firstNode = graph.firstNode();\n\n    const lastNode = graph.lastNode();\n\n    return drawMermaid(graph.nodes, graph.edges, {\n      firstNode: firstNode?.id,\n      lastNode: lastNode?.id,\n      withStyles,\n      curveStyle,\n      nodeColors,\n      wrapLabelNWords,\n    });\n  }\n\n  async drawMermaidPng(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }): Promise<Blob> {\n    const mermaidSyntax = this.drawMermaid(params);\n    return drawMermaidImage(mermaidSyntax, {\n      backgroundColor: params?.backgroundColor,\n    });\n  }\n}\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph: Graph, exclude: string[] = []): Node | undefined {\n  const targets = new Set(\n    graph.edges\n      .filter((edge) => !exclude.includes(edge.source))\n      .map((edge) => edge.target)\n  );\n\n  const found: Node[] = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !targets.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph: Graph, exclude: string[] = []): Node | undefined {\n  const sources = new Set(\n    graph.edges\n      .filter((edge) => !exclude.includes(edge.target))\n      .map((edge) => edge.source)\n  );\n\n  const found: Node[] = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !sources.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n","import {\n  ZodDiscriminatedUnionDef,\n  ZodLiteralDef,\n  ZodTypeAny,\n  ZodUnionDef,\n} from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\n\nexport const primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\",\n} as const;\ntype ZodPrimitive = keyof typeof primitiveMappings;\ntype JsonSchema7Primitive =\n  (typeof primitiveMappings)[keyof typeof primitiveMappings];\n\nexport type JsonSchema7UnionType =\n  | JsonSchema7PrimitiveUnionType\n  | JsonSchema7AnyOfType;\n\ntype JsonSchema7PrimitiveUnionType =\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n    }\n  | {\n      type: JsonSchema7Primitive | JsonSchema7Primitive[];\n      enum: (string | number | bigint | boolean | null)[];\n    };\n\ntype JsonSchema7AnyOfType = {\n  anyOf: JsonSchema7Type[];\n};\n\nexport function parseUnionDef(\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined {\n  if (refs.target === \"openApi3\") return asAnyOf(def, refs);\n\n  const options: readonly ZodTypeAny[] =\n    def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n\n  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  if (\n    options.every(\n      (x) =>\n        x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length)\n    )\n  ) {\n    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n\n    const types = options.reduce((types: JsonSchema7Primitive[], x) => {\n      const type = primitiveMappings[x._def.typeName as ZodPrimitive]; //Can be safely casted due to row 43\n      return type && !types.includes(type) ? [...types, type] : types;\n    }, []);\n\n    return {\n      type: types.length > 1 ? types : types[0],\n    };\n  } else if (\n    options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)\n  ) {\n    // all options literals\n\n    const types = options.reduce(\n      (acc: JsonSchema7Primitive[], x: { _def: ZodLiteralDef }) => {\n        const type = typeof x._def.value;\n        switch (type) {\n          case \"string\":\n          case \"number\":\n          case \"boolean\":\n            return [...acc, type];\n          case \"bigint\":\n            return [...acc, \"integer\" as const];\n          case \"object\":\n            if (x._def.value === null) return [...acc, \"null\" as const];\n            return acc;\n          case \"symbol\":\n          case \"undefined\":\n          case \"function\":\n          default:\n            return acc;\n        }\n      },\n      []\n    );\n\n    if (types.length === options.length) {\n      // all the literals are primitive, as far as null can be considered primitive\n\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [] as (string | number | bigint | boolean | null)[]),\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce(\n        (acc: string[], x) => [\n          ...acc,\n          ...x._def.values.filter((x: string) => !acc.includes(x)),\n        ],\n        []\n      ),\n    };\n  }\n\n  return asAnyOf(def, refs);\n}\n\nconst asAnyOf = (\n  def: ZodUnionDef | ZodDiscriminatedUnionDef<any, any>,\n  refs: Refs\n): JsonSchema7PrimitiveUnionType | JsonSchema7AnyOfType | undefined => {\n  const anyOf = (\n    (def.options instanceof Map\n      ? Array.from(def.options.values())\n      : def.options) as any[]\n  )\n    .map((x, i) =>\n      parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n      })\n    )\n    .filter(\n      (x): x is JsonSchema7Type =>\n        !!x &&\n        (!refs.strictUnions ||\n          (typeof x === \"object\" && Object.keys(x).length > 0))\n    );\n\n  return anyOf.length ? { anyOf } : undefined;\n};\n","import { Embeddings, EmbeddingsParams } from \"../../embeddings.js\";\n\n/**\n * An interface that defines additional parameters specific to the\n * SyntheticEmbeddings class.\n */\ninterface SyntheticEmbeddingsParams extends EmbeddingsParams {\n  vectorSize: number;\n}\n\n/**\n * A class that provides synthetic embeddings by overriding the\n * embedDocuments and embedQuery methods to generate embeddings based on\n * the input documents. The embeddings are generated by converting each\n * document into chunks, calculating a numerical value for each chunk, and\n * returning an array of these values as the embedding.\n */\nexport class SyntheticEmbeddings\n  extends Embeddings\n  implements SyntheticEmbeddingsParams\n{\n  vectorSize: number;\n\n  constructor(params?: SyntheticEmbeddingsParams) {\n    super(params ?? {});\n    this.vectorSize = params?.vectorSize ?? 4;\n  }\n\n  /**\n   * Generates synthetic embeddings for a list of documents.\n   * @param documents List of documents to generate embeddings for.\n   * @returns A promise that resolves with a list of synthetic embeddings for each document.\n   */\n  async embedDocuments(documents: string[]): Promise<number[][]> {\n    return Promise.all(documents.map((doc) => this.embedQuery(doc)));\n  }\n\n  /**\n   * Generates a synthetic embedding for a document. The document is\n   * converted into chunks, a numerical value is calculated for each chunk,\n   * and an array of these values is returned as the embedding.\n   * @param document The document to generate an embedding for.\n   * @returns A promise that resolves with a synthetic embedding for the document.\n   */\n  async embedQuery(document: string): Promise<number[]> {\n    let doc = document;\n\n    // Only use the letters (and space) from the document, and make them lower case\n    doc = doc.toLowerCase().replaceAll(/[^a-z ]/g, \"\");\n\n    // Pad the document to make sure it has a divisible number of chunks\n    const padMod = doc.length % this.vectorSize;\n    const padGapSize = padMod === 0 ? 0 : this.vectorSize - padMod;\n    const padSize = doc.length + padGapSize;\n    doc = doc.padEnd(padSize, \" \");\n\n    // Break it into chunks\n    const chunkSize = doc.length / this.vectorSize;\n    const docChunk = [];\n    for (let co = 0; co < doc.length; co += chunkSize) {\n      docChunk.push(doc.slice(co, co + chunkSize));\n    }\n\n    // Turn each chunk into a number\n    const ret: number[] = docChunk.map((s) => {\n      let sum = 0;\n      // Get a total value by adding the value of each character in the string\n      for (let co = 0; co < s.length; co += 1) {\n        sum += s === \" \" ? 0 : s.charCodeAt(co);\n      }\n      // Reduce this to a number between 0 and 25 inclusive\n      // Then get the fractional number by dividing it by 26\n      const ret = (sum % 26) / 26;\n      return ret;\n    });\n\n    return ret;\n  }\n}\n\n/**\n * A class that provides fake embeddings by overriding the embedDocuments\n * and embedQuery methods to return fixed values.\n */\nexport class FakeEmbeddings extends Embeddings {\n  constructor(params?: EmbeddingsParams) {\n    super(params ?? {});\n  }\n\n  /**\n   * Generates fixed embeddings for a list of documents.\n   * @param documents List of documents to generate embeddings for.\n   * @returns A promise that resolves with a list of fixed embeddings for each document.\n   */\n  embedDocuments(documents: string[]): Promise<number[][]> {\n    return Promise.resolve(documents.map(() => [0.1, 0.2, 0.3, 0.4]));\n  }\n\n  /**\n   * Generates a fixed embedding for a query.\n   * @param _ The query to generate an embedding for.\n   * @returns A promise that resolves with a fixed embedding for the query.\n   */\n  embedQuery(_: string): Promise<number[]> {\n    return Promise.resolve([0.1, 0.2, 0.3, 0.4]);\n  }\n}\n","import { BaseCache, type CacheFullKey, type CacheNamespace } from \"./base.js\";\n\nexport class InMemoryCache<V = unknown> extends BaseCache<V> {\n  private cache: {\n    [namespace: string]: {\n      [key: string]: {\n        enc: string;\n        val: Uint8Array | string;\n        exp: number | null;\n      };\n    };\n  } = {};\n\n  async get(keys: CacheFullKey[]): Promise<{ key: CacheFullKey; value: V }[]> {\n    if (!keys.length) return [];\n    const now = Date.now();\n    return (\n      await Promise.all(\n        keys.map(\n          async (fullKey): Promise<{ key: CacheFullKey; value: V }[]> => {\n            const [namespace, key] = fullKey;\n            const strNamespace = namespace.join(\",\");\n\n            if (strNamespace in this.cache && key in this.cache[strNamespace]) {\n              const cached = this.cache[strNamespace][key];\n              if (cached.exp == null || now < cached.exp) {\n                const value = await this.serde.loadsTyped(\n                  cached.enc,\n                  cached.val\n                );\n                return [{ key: fullKey, value }];\n              } else {\n                delete this.cache[strNamespace][key];\n              }\n            }\n\n            return [];\n          }\n        )\n      )\n    ).flat();\n  }\n\n  async set(\n    pairs: { key: CacheFullKey; value: V; ttl?: number }[]\n  ): Promise<void> {\n    const now = Date.now();\n    for (const { key: fullKey, value, ttl } of pairs) {\n      const [namespace, key] = fullKey;\n      const strNamespace = namespace.join(\",\");\n      const [enc, val] = await this.serde.dumpsTyped(value);\n      const exp = ttl != null ? ttl * 1000 + now : null;\n\n      this.cache[strNamespace] ??= {};\n      this.cache[strNamespace][key] = { enc, val, exp };\n    }\n  }\n\n  async clear(namespaces: CacheNamespace[]): Promise<void> {\n    if (!namespaces.length) {\n      this.cache = {};\n      return;\n    }\n\n    for (const namespace of namespaces) {\n      const strNamespace = namespace.join(\",\");\n      if (strNamespace in this.cache) delete this.cache[strNamespace];\n    }\n  }\n}\n","// @ts-nocheck\n\n// Inlined because of ESM import issues\n\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\nimport {\n  _deepClone,\n  _objectKeys,\n  escapePathComponent,\n  hasOwnProperty,\n} from \"./helpers.js\";\nimport { applyPatch, Operation } from \"./core.js\";\n\nexport interface Observer<T> {\n  object: T;\n  patches: Operation[];\n  unobserve: () => void;\n  callback: (patches: Operation[]) => void;\n}\n\nvar beforeDict = new WeakMap();\n\nclass Mirror {\n  obj: any;\n  observers: Map<Function, ObserverInfo> = new Map();\n  value: Object | Array<any>;\n\n  constructor(obj: Object) {\n    this.obj = obj;\n  }\n}\n\nclass ObserverInfo {\n  callback: Function;\n  observer: ObserverInfo;\n\n  constructor(callback: Function, observer: ObserverInfo) {\n    this.callback = callback;\n    this.observer = observer;\n  }\n}\n\nfunction getMirror(obj: Object): Mirror {\n  return beforeDict.get(obj);\n}\n\nfunction getObserverFromMirror(mirror: Mirror, callback): ObserverInfo {\n  return mirror.observers.get(callback);\n}\n\nfunction removeObserverFromMirror(mirror: Mirror, observer): void {\n  mirror.observers.delete(observer.callback);\n}\n\n/**\n * Detach an observer from an object\n */\nexport function unobserve<T>(root: T, observer: Observer<T>) {\n  observer.unobserve();\n}\n\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nexport function observe<T>(\n  obj: Object | Array<T>,\n  callback?: (patches: Operation[]) => void\n): Observer<T> {\n  var patches = [];\n  var observer;\n  var mirror = getMirror(obj);\n\n  if (!mirror) {\n    mirror = new Mirror(obj);\n    beforeDict.set(obj, mirror);\n  } else {\n    const observerInfo = getObserverFromMirror(mirror, callback);\n    observer = observerInfo && observerInfo.observer;\n  }\n\n  if (observer) {\n    return observer;\n  }\n\n  observer = {};\n\n  mirror.value = _deepClone(obj);\n\n  if (callback) {\n    observer.callback = callback;\n    observer.next = null;\n\n    var dirtyCheck = () => {\n      generate(observer);\n    };\n    var fastCheck = () => {\n      clearTimeout(observer.next);\n      observer.next = setTimeout(dirtyCheck);\n    };\n    if (typeof window !== \"undefined\") {\n      //not Node\n      window.addEventListener(\"mouseup\", fastCheck);\n      window.addEventListener(\"keyup\", fastCheck);\n      window.addEventListener(\"mousedown\", fastCheck);\n      window.addEventListener(\"keydown\", fastCheck);\n      window.addEventListener(\"change\", fastCheck);\n    }\n  }\n  observer.patches = patches;\n  observer.object = obj;\n\n  observer.unobserve = () => {\n    generate(observer);\n    clearTimeout(observer.next);\n    removeObserverFromMirror(mirror, observer);\n\n    if (typeof window !== \"undefined\") {\n      window.removeEventListener(\"mouseup\", fastCheck);\n      window.removeEventListener(\"keyup\", fastCheck);\n      window.removeEventListener(\"mousedown\", fastCheck);\n      window.removeEventListener(\"keydown\", fastCheck);\n      window.removeEventListener(\"change\", fastCheck);\n    }\n  };\n\n  mirror.observers.set(callback, new ObserverInfo(callback, observer));\n\n  return observer;\n}\n\n/**\n * Generate an array of patches from an observer\n */\nexport function generate<T>(\n  observer: Observer<Object>,\n  invertible = false\n): Operation[] {\n  var mirror = beforeDict.get(observer.object);\n\n  _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n  if (observer.patches.length) {\n    applyPatch(mirror.value, observer.patches);\n  }\n  var temp = observer.patches;\n  if (temp.length > 0) {\n    observer.patches = [];\n    if (observer.callback) {\n      observer.callback(temp);\n    }\n  }\n  return temp;\n}\n\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n  if (obj === mirror) {\n    return;\n  }\n\n  if (typeof obj.toJSON === \"function\") {\n    obj = obj.toJSON();\n  }\n\n  var newKeys = _objectKeys(obj);\n  var oldKeys = _objectKeys(mirror);\n  var changed = false;\n  var deleted = false;\n\n  //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n\n  for (var t = oldKeys.length - 1; t >= 0; t--) {\n    var key = oldKeys[t];\n    var oldVal = mirror[key];\n\n    if (\n      hasOwnProperty(obj, key) &&\n      !(\n        obj[key] === undefined &&\n        oldVal !== undefined &&\n        Array.isArray(obj) === false\n      )\n    ) {\n      var newVal = obj[key];\n\n      if (\n        typeof oldVal == \"object\" &&\n        oldVal != null &&\n        typeof newVal == \"object\" &&\n        newVal != null &&\n        Array.isArray(oldVal) === Array.isArray(newVal)\n      ) {\n        _generate(\n          oldVal,\n          newVal,\n          patches,\n          path + \"/\" + escapePathComponent(key),\n          invertible\n        );\n      } else {\n        if (oldVal !== newVal) {\n          changed = true;\n          if (invertible) {\n            patches.push({\n              op: \"test\",\n              path: path + \"/\" + escapePathComponent(key),\n              value: _deepClone(oldVal),\n            });\n          }\n          patches.push({\n            op: \"replace\",\n            path: path + \"/\" + escapePathComponent(key),\n            value: _deepClone(newVal),\n          });\n        }\n      }\n    } else if (Array.isArray(mirror) === Array.isArray(obj)) {\n      if (invertible) {\n        patches.push({\n          op: \"test\",\n          path: path + \"/\" + escapePathComponent(key),\n          value: _deepClone(oldVal),\n        });\n      }\n      patches.push({\n        op: \"remove\",\n        path: path + \"/\" + escapePathComponent(key),\n      });\n      deleted = true; // property has been deleted\n    } else {\n      if (invertible) {\n        patches.push({ op: \"test\", path, value: mirror });\n      }\n      patches.push({ op: \"replace\", path, value: obj });\n      changed = true;\n    }\n  }\n\n  if (!deleted && newKeys.length == oldKeys.length) {\n    return;\n  }\n\n  for (var t = 0; t < newKeys.length; t++) {\n    var key = newKeys[t];\n    if (!hasOwnProperty(mirror, key) && obj[key] !== undefined) {\n      patches.push({\n        op: \"add\",\n        path: path + \"/\" + escapePathComponent(key),\n        value: _deepClone(obj[key]),\n      });\n    }\n  }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nexport function compare(\n  tree1: Object | Array<any>,\n  tree2: Object | Array<any>,\n  invertible = false\n): Operation[] {\n  var patches = [];\n  _generate(tree1, tree2, patches, \"\", invertible);\n  return patches;\n}\n","import { ZodSetDef } from \"zod/v3\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\n\nexport type JsonSchema7SetType = {\n  type: \"array\";\n  uniqueItems: true;\n  items?: JsonSchema7Type;\n  minItems?: number;\n  maxItems?: number;\n  errorMessage?: ErrorMessages<JsonSchema7SetType>;\n};\n\nexport function parseSetDef(def: ZodSetDef, refs: Refs): JsonSchema7SetType {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"],\n  });\n\n  const schema: JsonSchema7SetType = {\n    type: \"array\",\n    uniqueItems: true,\n    items,\n  };\n\n  if (def.minSize) {\n    setResponseValueAndErrors(\n      schema,\n      \"minItems\",\n      def.minSize.value,\n      def.minSize.message,\n      refs\n    );\n  }\n\n  if (def.maxSize) {\n    setResponseValueAndErrors(\n      schema,\n      \"maxItems\",\n      def.maxSize.value,\n      def.maxSize.message,\n      refs\n    );\n  }\n\n  return schema;\n}\n","import { EmptyChannelError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\nexport type BinaryOperator<ValueType, UpdateType> = (\n  a: ValueType,\n  b: UpdateType\n) => ValueType;\n\n/**\n * Stores the result of applying a binary operator to the current value and each new value.\n */\nexport class BinaryOperatorAggregate<\n  ValueType,\n  UpdateType = ValueType\n> extends BaseChannel<ValueType, UpdateType, ValueType> {\n  lc_graph_name = \"BinaryOperatorAggregate\";\n\n  value: ValueType | undefined;\n\n  operator: BinaryOperator<ValueType, UpdateType>;\n\n  initialValueFactory?: () => ValueType;\n\n  constructor(\n    operator: BinaryOperator<ValueType, UpdateType>,\n    initialValueFactory?: () => ValueType\n  ) {\n    super();\n\n    this.operator = operator;\n    this.initialValueFactory = initialValueFactory;\n    this.value = initialValueFactory?.();\n  }\n\n  public fromCheckpoint(checkpoint?: ValueType) {\n    const empty = new BinaryOperatorAggregate(\n      this.operator,\n      this.initialValueFactory\n    );\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = checkpoint;\n    }\n    return empty as this;\n  }\n\n  public update(values: UpdateType[]): boolean {\n    let newValues = values;\n    if (!newValues.length) return false;\n\n    if (this.value === undefined) {\n      [this.value as UpdateType] = newValues;\n      newValues = newValues.slice(1);\n    }\n\n    for (const value of newValues) {\n      if (this.value !== undefined) {\n        this.value = this.operator(this.value, value);\n      }\n    }\n    return true;\n  }\n\n  public get(): ValueType {\n    if (this.value === undefined) {\n      throw new EmptyChannelError();\n    }\n    return this.value;\n  }\n\n  public checkpoint(): ValueType {\n    if (this.value === undefined) {\n      throw new EmptyChannelError();\n    }\n    return this.value;\n  }\n\n  isAvailable(): boolean {\n    return this.value !== undefined;\n  }\n}\n","import { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  mergeConfigs,\n  patchConfig,\n  Runnable,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { ensureLangGraphConfig } from \"./pregel/utils/config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface RunnableCallableArgs extends Partial<any> {\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  func: (...args: any[]) => any;\n  tags?: string[];\n  trace?: boolean;\n  recurse?: boolean;\n}\n\nexport class RunnableCallable<I = unknown, O = unknown> extends Runnable<I, O> {\n  lc_namespace: string[] = [\"langgraph\"];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  func: (...args: any[]) => any;\n\n  tags?: string[];\n\n  config?: RunnableConfig;\n\n  trace: boolean = true;\n\n  recurse: boolean = true;\n\n  constructor(fields: RunnableCallableArgs) {\n    super();\n    this.name = fields.name ?? fields.func.name;\n    this.func = fields.func;\n    this.config = fields.tags ? { tags: fields.tags } : undefined;\n    this.trace = fields.trace ?? this.trace;\n    this.recurse = fields.recurse ?? this.recurse;\n  }\n\n  protected async _tracedInvoke(\n    input: I,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    return new Promise<O>((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n      });\n      void AsyncLocalStorageProviderSingleton.runWithConfig(\n        childConfig,\n        async () => {\n          try {\n            const output = await this.func(input, childConfig);\n            resolve(output);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      );\n    });\n  }\n\n  async invoke(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: I,\n    options?: Partial<RunnableConfig> | undefined\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<O> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnValue: any;\n    const config = ensureLangGraphConfig(options);\n    const mergedConfig = mergeConfigs(this.config, config);\n\n    if (this.trace) {\n      returnValue = await this._callWithConfig(\n        this._tracedInvoke,\n        input,\n        mergedConfig\n      );\n    } else {\n      returnValue = await AsyncLocalStorageProviderSingleton.runWithConfig(\n        mergedConfig,\n        async () => this.func(input, mergedConfig)\n      );\n    }\n\n    if (Runnable.isRunnable(returnValue) && this.recurse) {\n      return await AsyncLocalStorageProviderSingleton.runWithConfig(\n        mergedConfig,\n        async () => returnValue.invoke(input, mergedConfig)\n      );\n    }\n\n    return returnValue;\n  }\n}\n\nexport function prefixGenerator<T, Prefix extends string>(\n  generator: Generator<T>,\n  prefix: Prefix\n): Generator<[Prefix, T]>;\n\nexport function prefixGenerator<T>(\n  generator: Generator<T>,\n  prefix?: undefined\n): Generator<T>;\n\nexport function prefixGenerator<\n  T,\n  Prefix extends string | undefined = undefined\n>(\n  generator: Generator<T>,\n  prefix?: Prefix | undefined\n): Generator<Prefix extends string ? [Prefix, T] : T>;\nexport function* prefixGenerator<\n  T,\n  Prefix extends string | undefined = undefined\n>(\n  generator: Generator<T>,\n  prefix?: Prefix | undefined\n): Generator<Prefix extends string ? [Prefix, T] : T> {\n  if (prefix === undefined) {\n    yield* generator as Generator<Prefix extends string ? [Prefix, T] : T>;\n  } else {\n    for (const value of generator) {\n      yield [prefix, value] as Prefix extends string ? [Prefix, T] : T;\n    }\n  }\n}\n\n// https://github.com/tc39/proposal-array-from-async\nexport async function gatherIterator<T>(\n  i:\n    | AsyncIterable<T>\n    | Promise<AsyncIterable<T>>\n    | Iterable<T>\n    | Promise<Iterable<T>>\n): Promise<Array<T>> {\n  const out: T[] = [];\n  for await (const item of await i) {\n    out.push(item);\n  }\n  return out;\n}\n\nexport function gatherIteratorSync<T>(i: Iterable<T>): Array<T> {\n  const out: T[] = [];\n  for (const item of i) {\n    out.push(item);\n  }\n  return out;\n}\n\nexport function patchConfigurable(\n  config: RunnableConfig | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  patch: Record<string, any>\n): RunnableConfig {\n  if (!config) {\n    return {\n      configurable: patch,\n    };\n  } else if (!(\"configurable\" in config)) {\n    return {\n      ...config,\n      configurable: patch,\n    };\n  } else {\n    return {\n      ...config,\n      configurable: {\n        ...config.configurable,\n        ...patch,\n      },\n    };\n  }\n}\n\nexport function isAsyncGeneratorFunction(\n  val: unknown\n): val is AsyncGeneratorFunction {\n  return (\n    val != null &&\n    typeof val === \"function\" &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    val instanceof Object.getPrototypeOf(async function* () {}).constructor\n  );\n}\n\nexport function isGeneratorFunction(val: unknown): val is GeneratorFunction {\n  return (\n    val != null &&\n    typeof val === \"function\" &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    val instanceof Object.getPrototypeOf(function* () {}).constructor\n  );\n}\n","import { type SerializedFields, keyToJson, mapKeys } from \"./map_keys.js\";\n\nexport interface BaseSerialized<T extends string> {\n  lc: number;\n  type: T;\n  id: string[];\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  graph?: Record<string, any>;\n}\n\nexport interface SerializedConstructor extends BaseSerialized<\"constructor\"> {\n  kwargs: SerializedFields;\n}\n\nexport interface SerializedSecret extends BaseSerialized<\"secret\"> {}\n\nexport interface SerializedNotImplemented\n  extends BaseSerialized<\"not_implemented\"> {}\n\nexport type Serialized =\n  | SerializedConstructor\n  | SerializedSecret\n  | SerializedNotImplemented;\n\nfunction shallowCopy<T extends object>(obj: T): T {\n  return Array.isArray(obj) ? ([...obj] as T) : ({ ...obj } as T);\n}\n\nfunction replaceSecrets(\n  root: SerializedFields,\n  secretsMap: { [key: string]: string }\n): SerializedFields {\n  const result = shallowCopy(root);\n  for (const [path, secretId] of Object.entries(secretsMap)) {\n    const [last, ...partsReverse] = path.split(\".\").reverse();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let current: any = result;\n    for (const part of partsReverse.reverse()) {\n      if (current[part] === undefined) {\n        break;\n      }\n      current[part] = shallowCopy(current[part]);\n      current = current[part];\n    }\n    if (current[last] !== undefined) {\n      current[last] = {\n        lc: 1,\n        type: \"secret\",\n        id: [secretId],\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nexport function get_lc_unique_name(\n  serializableClass: typeof Serializable\n): string {\n  // \"super\" here would refer to the parent class of Serializable,\n  // when we want the parent class of the module actually calling this method.\n  const parentClass = Object.getPrototypeOf(serializableClass);\n  const lcNameIsSubclassed =\n    typeof serializableClass.lc_name === \"function\" &&\n    (typeof parentClass.lc_name !== \"function\" ||\n      serializableClass.lc_name() !== parentClass.lc_name());\n  if (lcNameIsSubclassed) {\n    return serializableClass.lc_name();\n  } else {\n    return serializableClass.name;\n  }\n}\n\nexport interface SerializableInterface {\n  get lc_id(): string[];\n}\n\nexport abstract class Serializable implements SerializableInterface {\n  lc_serializable = false;\n\n  lc_kwargs: SerializedFields;\n\n  /**\n   * A path to the module that contains the class, eg. [\"langchain\", \"llms\"]\n   * Usually should be the same as the entrypoint the class is exported from.\n   */\n  abstract lc_namespace: string[];\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof Serializable),\n    ];\n  }\n\n  /**\n   * A map of secrets, which will be omitted from serialization.\n   * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n   * Values are the secret ids, which will be used when deserializing.\n   */\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of additional attributes to merge with constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the attribute values, which will be serialized.\n   * These attributes need to be accepted by the constructor as arguments.\n   */\n  get lc_attributes(): SerializedFields | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of aliases for constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the alias that will replace the key in serialization.\n   * This is used to eg. make argument names match Python.\n   */\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A manual list of keys that should be serialized.\n   * If not overridden, all fields passed into the constructor will be serialized.\n   */\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  constructor(kwargs?: SerializedFields, ..._args: never[]) {\n    if (this.lc_serializable_keys !== undefined) {\n      this.lc_kwargs = Object.fromEntries(\n        Object.entries(kwargs || {}).filter(([key]) =>\n          this.lc_serializable_keys?.includes(key)\n        )\n      );\n    } else {\n      this.lc_kwargs = kwargs ?? {};\n    }\n  }\n\n  toJSON(): Serialized {\n    if (!this.lc_serializable) {\n      return this.toJSONNotImplemented();\n    }\n    if (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      this.lc_kwargs instanceof Serializable ||\n      typeof this.lc_kwargs !== \"object\" ||\n      Array.isArray(this.lc_kwargs)\n    ) {\n      // We do not support serialization of classes with arg not a POJO\n      // I'm aware the check above isn't as strict as it could be\n      return this.toJSONNotImplemented();\n    }\n\n    const aliases: { [key: string]: string } = {};\n    const secrets: { [key: string]: string } = {};\n    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n      acc[key] = key in this ? this[key as keyof this] : this.lc_kwargs[key];\n      return acc;\n    }, {} as SerializedFields);\n    // get secrets, attributes and aliases from all superclasses\n    for (\n      let current = Object.getPrototypeOf(this);\n      current;\n      current = Object.getPrototypeOf(current)\n    ) {\n      Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n      Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n      Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n    }\n\n    // include all secrets used, even if not in kwargs,\n    // will be replaced with sentinel value in replaceSecrets\n    Object.keys(secrets).forEach((keyPath) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let read: any = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let write: any = kwargs;\n\n      const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n      for (const key of partsReverse.reverse()) {\n        if (!(key in read) || read[key] === undefined) return;\n        if (!(key in write) || write[key] === undefined) {\n          if (typeof read[key] === \"object\" && read[key] != null) {\n            write[key] = {};\n          } else if (Array.isArray(read[key])) {\n            write[key] = [];\n          }\n        }\n\n        read = read[key];\n        write = write[key];\n      }\n\n      if (last in read && read[last] !== undefined) {\n        write[last] = write[last] || read[last];\n      }\n    });\n\n    return {\n      lc: 1,\n      type: \"constructor\",\n      id: this.lc_id,\n      kwargs: mapKeys(\n        Object.keys(secrets).length ? replaceSecrets(kwargs, secrets) : kwargs,\n        keyToJson,\n        aliases\n      ),\n    };\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return {\n      lc: 1,\n      type: \"not_implemented\",\n      id: this.lc_id,\n    };\n  }\n}\n","export interface DocumentInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> {\n  pageContent: string;\n\n  metadata?: Metadata;\n\n  /**\n   * An optional identifier for the document.\n   *\n   * Ideally this should be unique across the document collection and formatted\n   * as a UUID, but this will not be enforced.\n   */\n  id?: string;\n}\n\nexport interface DocumentInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> {\n  pageContent: string;\n\n  metadata: Metadata;\n\n  /**\n   * An optional identifier for the document.\n   *\n   * Ideally this should be unique across the document collection and formatted\n   * as a UUID, but this will not be enforced.\n   */\n  id?: string;\n}\n\n/**\n * Interface for interacting with a document.\n */\nexport class Document<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> implements DocumentInput, DocumentInterface\n{\n  pageContent: string;\n\n  metadata: Metadata;\n\n  // The ID field is optional at the moment.\n  // It will likely become required in a future major release after\n  // it has been adopted by enough vectorstore implementations.\n  /**\n   * An optional identifier for the document.\n   *\n   * Ideally this should be unique across the document collection and formatted\n   * as a UUID, but this will not be enforced.\n   */\n  id?: string;\n\n  constructor(fields: DocumentInput<Metadata>) {\n    this.pageContent =\n      fields.pageContent !== undefined ? fields.pageContent.toString() : \"\";\n    this.metadata = fields.metadata ?? ({} as Metadata);\n    this.id = fields.id;\n  }\n}\n","import { pickRunnableConfigKeys } from \"../runnables/config.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport type { IterableReadableStreamInterface } from \"../types/_internal.js\";\nimport { raceWithSignal } from \"./signal.js\";\n\n// Re-exported for backwards compatibility\n// Do NOT import this type from this file inside the project. Instead, always import from `types/_internal.js`\n// when using internally\nexport type { IterableReadableStreamInterface };\n\n/*\n * Support async iterator syntax for ReadableStreams in all environments.\n * Source: https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport class IterableReadableStream<T>\n  extends ReadableStream<T>\n  implements IterableReadableStreamInterface<T>\n{\n  public reader: ReadableStreamDefaultReader<T>;\n\n  ensureReader() {\n    if (!this.reader) {\n      this.reader = this.getReader();\n    }\n  }\n\n  async next(): Promise<IteratorResult<T>> {\n    this.ensureReader();\n    try {\n      const result = await this.reader.read();\n      if (result.done) {\n        this.reader.releaseLock(); // release lock when stream becomes closed\n        return {\n          done: true,\n          value: undefined,\n        };\n      } else {\n        return {\n          done: false,\n          value: result.value,\n        };\n      }\n    } catch (e) {\n      this.reader.releaseLock(); // release lock when stream becomes errored\n      throw e;\n    }\n  }\n\n  async return(): Promise<IteratorResult<T>> {\n    this.ensureReader();\n    // If wrapped in a Node stream, cancel is already called.\n    if (this.locked) {\n      const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n      this.reader.releaseLock(); // release lock first\n      await cancelPromise; // now await it\n    }\n    return { done: true, value: undefined };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async throw(e: any): Promise<IteratorResult<T>> {\n    this.ensureReader();\n    if (this.locked) {\n      const cancelPromise = this.reader.cancel(); // cancel first, but don't await yet\n      this.reader.releaseLock(); // release lock first\n      await cancelPromise; // now await it\n    }\n    throw e;\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore Not present in Node 18 types, required in latest Node 22\n  async [Symbol.asyncDispose]() {\n    await this.return();\n  }\n\n  static fromReadableStream<T>(stream: ReadableStream<T>) {\n    // From https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams#reading_the_stream\n    const reader = stream.getReader();\n    return new IterableReadableStream<T>({\n      start(controller) {\n        return pump();\n        function pump(): Promise<T | undefined> {\n          return reader.read().then(({ done, value }) => {\n            // When no more data needs to be consumed, close the stream\n            if (done) {\n              controller.close();\n              return;\n            }\n            // Enqueue the next data chunk into our target stream\n            controller.enqueue(value);\n            return pump();\n          });\n        }\n      },\n      cancel() {\n        reader.releaseLock();\n      },\n    });\n  }\n\n  static fromAsyncGenerator<T>(generator: AsyncGenerator<T>) {\n    return new IterableReadableStream<T>({\n      async pull(controller) {\n        const { value, done } = await generator.next();\n        // When no more data needs to be consumed, close the stream\n        if (done) {\n          controller.close();\n        }\n        // Fix: `else if (value)` will hang the streaming when nullish value (e.g. empty string) is pulled\n        controller.enqueue(value);\n      },\n      async cancel(reason) {\n        await generator.return(reason);\n      },\n    });\n  }\n}\n\nexport function atee<T>(\n  iter: AsyncGenerator<T>,\n  length = 2\n): AsyncGenerator<T>[] {\n  const buffers = Array.from(\n    { length },\n    () => [] as Array<IteratorResult<T> | IteratorReturnResult<T>>\n  );\n  return buffers.map(async function* makeIter(buffer) {\n    while (true) {\n      if (buffer.length === 0) {\n        const result = await iter.next();\n        for (const buffer of buffers) {\n          buffer.push(result);\n        }\n      } else if (buffer[0].done) {\n        return;\n      } else {\n        yield buffer.shift()!.value;\n      }\n    }\n  });\n}\n\nexport function concat<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Array<any> | string | number | Record<string, any> | any\n>(first: T, second: T): T {\n  if (Array.isArray(first) && Array.isArray(second)) {\n    return first.concat(second) as T;\n  } else if (typeof first === \"string\" && typeof second === \"string\") {\n    return (first + second) as T;\n  } else if (typeof first === \"number\" && typeof second === \"number\") {\n    return (first + second) as T;\n  } else if (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"concat\" in (first as any) &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (first as any).concat === \"function\"\n  ) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (first as any).concat(second) as T;\n  } else if (typeof first === \"object\" && typeof second === \"object\") {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const chunk = { ...first } as Record<string, any>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    for (const [key, value] of Object.entries(second as Record<string, any>)) {\n      if (key in chunk && !Array.isArray(chunk[key])) {\n        chunk[key] = concat(chunk[key], value);\n      } else {\n        chunk[key] = value;\n      }\n    }\n    return chunk as T;\n  } else {\n    throw new Error(`Cannot concat ${typeof first} and ${typeof second}`);\n  }\n}\n\nexport class AsyncGeneratorWithSetup<\n  S = unknown,\n  T = unknown,\n  TReturn = unknown,\n  TNext = unknown\n> implements AsyncGenerator<T, TReturn, TNext>\n{\n  private generator: AsyncGenerator<T>;\n\n  public setup: Promise<S>;\n\n  public config?: unknown;\n\n  public signal?: AbortSignal;\n\n  private firstResult: Promise<IteratorResult<T>>;\n\n  private firstResultUsed = false;\n\n  constructor(params: {\n    generator: AsyncGenerator<T>;\n    startSetup?: () => Promise<S>;\n    config?: unknown;\n    signal?: AbortSignal;\n  }) {\n    this.generator = params.generator;\n    this.config = params.config;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.signal = params.signal ?? (this.config as any)?.signal;\n    // setup is a promise that resolves only after the first iterator value\n    // is available. this is useful when setup of several piped generators\n    // needs to happen in logical order, ie. in the order in which input to\n    // to each generator is available.\n    this.setup = new Promise((resolve, reject) => {\n      // eslint-disable-next-line no-void\n      void AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(\n          params.config as Record<string, unknown> | undefined\n        ),\n        async () => {\n          this.firstResult = params.generator.next();\n          if (params.startSetup) {\n            this.firstResult.then(params.startSetup).then(resolve, reject);\n          } else {\n            this.firstResult.then((_result) => resolve(undefined as S), reject);\n          }\n        },\n        true\n      );\n    });\n  }\n\n  async next(...args: [] | [TNext]): Promise<IteratorResult<T>> {\n    this.signal?.throwIfAborted();\n\n    if (!this.firstResultUsed) {\n      this.firstResultUsed = true;\n      return this.firstResult;\n    }\n\n    return AsyncLocalStorageProviderSingleton.runWithConfig(\n      pickRunnableConfigKeys(\n        this.config as Record<string, unknown> | undefined\n      ),\n      this.signal\n        ? async () => {\n            return raceWithSignal(this.generator.next(...args), this.signal);\n          }\n        : async () => {\n            return this.generator.next(...args);\n          },\n      true\n    );\n  }\n\n  async return(\n    value?: TReturn | PromiseLike<TReturn>\n  ): Promise<IteratorResult<T>> {\n    return this.generator.return(value);\n  }\n\n  async throw(e: Error): Promise<IteratorResult<T>> {\n    return this.generator.throw(e);\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore Not present in Node 18 types, required in latest Node 22\n  async [Symbol.asyncDispose]() {\n    await this.return();\n  }\n}\n\nexport async function pipeGeneratorWithSetup<\n  S,\n  A extends unknown[],\n  T,\n  TReturn,\n  TNext,\n  U,\n  UReturn,\n  UNext\n>(\n  to: (\n    g: AsyncGenerator<T, TReturn, TNext>,\n    s: S,\n    ...args: A\n  ) => AsyncGenerator<U, UReturn, UNext>,\n  generator: AsyncGenerator<T, TReturn, TNext>,\n  startSetup: () => Promise<S>,\n  signal: AbortSignal | undefined,\n  ...args: A\n) {\n  const gen = new AsyncGeneratorWithSetup({\n    generator,\n    startSetup,\n    signal,\n  });\n  const setup = await gen.setup;\n  return { output: to(gen, setup, ...args), setup };\n}\n","import { Serializable, SerializedConstructor } from \"../load/serializable.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport { isDataContentBlock } from \"./content/data.js\";\nimport { convertToV1FromAnthropicInput } from \"./block_translators/anthropic.js\";\nimport { convertToV1FromDataContent } from \"./block_translators/data.js\";\nimport { convertToV1FromChatCompletionsInput } from \"./block_translators/openai.js\";\nimport {\n  $InferMessageContent,\n  $InferResponseMetadata,\n  MessageStructure,\n  MessageType,\n  isMessage,\n  Message,\n} from \"./message.js\";\nimport {\n  convertToFormattedString,\n  type MessageStringFormat,\n} from \"./format.js\";\n\n/** @internal */\nconst MESSAGE_SYMBOL = Symbol.for(\"langchain.message\");\n\nexport interface StoredMessageData {\n  content: string;\n  role: string | undefined;\n  name: string | undefined;\n  tool_call_id: string | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  additional_kwargs?: Record<string, any>;\n  /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response_metadata?: Record<string, any>;\n  id?: string;\n}\n\nexport interface StoredMessage {\n  type: string;\n  data: StoredMessageData;\n}\n\nexport interface StoredGeneration {\n  text: string;\n  message?: StoredMessage;\n}\n\nexport interface StoredMessageV1 {\n  type: string;\n  role: string | undefined;\n  text: string;\n}\n\nexport type MessageContent = string | Array<ContentBlock>;\n\nexport interface FunctionCall {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\nexport type BaseMessageFields<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType\n> = {\n  id?: string;\n  name?: string;\n  content?: $InferMessageContent<TStructure, TRole>;\n  contentBlocks?: Array<ContentBlock.Standard>;\n  /** @deprecated */\n  additional_kwargs?: {\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    function_call?: FunctionCall;\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    tool_calls?: OpenAIToolCall[];\n    [key: string]: unknown;\n  };\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n};\n\nexport function mergeContent(\n  firstContent: MessageContent,\n  secondContent: MessageContent\n): MessageContent {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (firstContent === \"\") {\n      return secondContent;\n    }\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else if (Array.isArray(secondContent) && secondContent.length === 0) {\n      return firstContent;\n    } else if (\n      Array.isArray(secondContent) &&\n      secondContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        {\n          type: \"text\",\n          source_type: \"text\",\n          text: firstContent,\n        },\n        ...secondContent,\n      ];\n    } else {\n      return [{ type: \"text\", text: firstContent }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return (\n      _mergeLists(firstContent, secondContent) ?? [\n        ...firstContent,\n        ...secondContent,\n      ]\n    );\n  } else {\n    if (secondContent === \"\") {\n      return firstContent;\n    } else if (\n      Array.isArray(firstContent) &&\n      firstContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        ...firstContent,\n        {\n          type: \"file\",\n          source_type: \"text\",\n          text: secondContent,\n        },\n      ];\n    } else {\n      return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n  }\n}\n\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nexport function _mergeStatus(\n  left?: \"success\" | \"error\",\n  right?: \"success\" | \"error\"\n): \"success\" | \"error\" | undefined {\n  if (left === \"error\" || right === \"error\") {\n    return \"error\";\n  }\n  return \"success\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj: any, depthLimit: number): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function helper(obj: any, currentDepth: number): any {\n    if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n      return obj;\n    }\n    if (currentDepth >= depthLimit) {\n      if (Array.isArray(obj)) {\n        return \"[Array]\";\n      }\n      return \"[Object]\";\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map((item) => helper(item, currentDepth + 1));\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = helper(obj[key], currentDepth + 1);\n    }\n    return result;\n  }\n\n  return JSON.stringify(helper(obj, 0), null, 2);\n}\n\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport abstract class BaseMessage<\n    TStructure extends MessageStructure = MessageStructure,\n    TRole extends MessageType = MessageType\n  >\n  extends Serializable\n  implements Message<TStructure, TRole>\n{\n  lc_namespace = [\"langchain_core\", \"messages\"];\n\n  lc_serializable = true;\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\",\n      response_metadata: \"response_metadata\",\n    };\n  }\n\n  readonly [MESSAGE_SYMBOL] = true as const;\n\n  abstract readonly type: TRole;\n\n  id?: string;\n\n  name?: string;\n\n  content: $InferMessageContent<TStructure, TRole>;\n\n  additional_kwargs: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"additional_kwargs\"]\n  >;\n\n  response_metadata: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"response_metadata\"]\n  >;\n\n  /**\n   * @deprecated Use .getType() instead or import the proper typeguard.\n   * For example:\n   *\n   * ```ts\n   * import { isAIMessage } from \"@langchain/core/messages\";\n   *\n   * const message = new AIMessage(\"Hello!\");\n   * isAIMessage(message); // true\n   * ```\n   */\n  _getType(): MessageType {\n    return this.type;\n  }\n\n  /**\n   * @deprecated Use .type instead\n   * The type of the message.\n   */\n  getType(): MessageType {\n    return this._getType();\n  }\n\n  constructor(\n    arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>\n  ) {\n    const fields: BaseMessageFields<TStructure, TRole> =\n      typeof arg === \"string\" || Array.isArray(arg) ? { content: arg } : arg;\n    if (!fields.additional_kwargs) {\n      fields.additional_kwargs = {};\n    }\n    if (!fields.response_metadata) {\n      fields.response_metadata = {};\n    }\n    super(fields);\n    this.name = fields.name;\n    if (fields.content === undefined && fields.contentBlocks !== undefined) {\n      this.content = fields.contentBlocks as $InferMessageContent<\n        TStructure,\n        TRole\n      >;\n      this.response_metadata = {\n        output_version: \"v1\",\n        ...fields.response_metadata,\n      };\n    } else if (fields.content !== undefined) {\n      this.content = fields.content ?? [];\n      this.response_metadata = fields.response_metadata;\n    } else {\n      this.content = [] as $InferMessageContent<TStructure, TRole>;\n      this.response_metadata = fields.response_metadata;\n    }\n    this.additional_kwargs = fields.additional_kwargs;\n    this.id = fields.id;\n  }\n\n  /** Get text content of the message. */\n  get text(): string {\n    if (typeof this.content === \"string\") {\n      return this.content;\n    }\n    if (!Array.isArray(this.content)) return \"\";\n    return this.content\n      .map((c) => {\n        if (typeof c === \"string\") return c;\n        if (c.type === \"text\") return c.text;\n        return \"\";\n      })\n      .join(\"\");\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    const blocks: Array<ContentBlock> =\n      typeof this.content === \"string\"\n        ? [{ type: \"text\", text: this.content }]\n        : this.content;\n    const parsingSteps = [\n      convertToV1FromDataContent,\n      convertToV1FromChatCompletionsInput,\n      convertToV1FromAnthropicInput,\n    ];\n    const parsedBlocks = parsingSteps.reduce(\n      (blocks, step) => step(blocks),\n      blocks\n    );\n    return parsedBlocks as Array<ContentBlock.Standard>;\n  }\n\n  toDict(): StoredMessage {\n    return {\n      type: this.getType(),\n      data: (this.toJSON() as SerializedConstructor)\n        .kwargs as StoredMessageData,\n    };\n  }\n\n  static lc_name() {\n    return \"BaseMessage\";\n  }\n\n  // Can't be protected for silly reasons\n  get _printableFields(): Record<string, unknown> {\n    return {\n      id: this.id,\n      content: this.content,\n      name: this.name,\n      additional_kwargs: this.additional_kwargs,\n      response_metadata: this.response_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is BaseMessage {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      MESSAGE_SYMBOL in obj &&\n      obj[MESSAGE_SYMBOL] === true &&\n      isMessage(obj)\n    );\n  }\n\n  // this private method is used to update the ID for the runtime\n  // value as well as in lc_kwargs for serialisation\n  _updateId(value: string | undefined) {\n    this.id = value;\n\n    // lc_attributes wouldn't work here, because jest compares the\n    // whole object\n    this.lc_kwargs.id = value;\n  }\n\n  get [Symbol.toStringTag]() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.constructor as any).lc_name();\n  }\n\n  // Override the default behavior of console.log\n  [Symbol.for(\"nodejs.util.inspect.custom\")](depth: number | null) {\n    if (depth === null) {\n      return this;\n    }\n    const printable = stringifyWithDepthLimit(\n      this._printableFields,\n      Math.max(4, depth)\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return `${(this.constructor as any).lc_name()} ${printable}`;\n  }\n\n  toFormattedString(format: MessageStringFormat = \"pretty\"): string {\n    return convertToFormattedString(this, format);\n  }\n}\n\n/**\n * @deprecated Use \"tool_calls\" field on AIMessages instead\n */\nexport type OpenAIToolCall = {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: FunctionCall;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: \"function\";\n\n  index?: number;\n};\n\nexport function isOpenAIToolCallArray(\n  value?: unknown\n): value is OpenAIToolCall[] {\n  return (\n    Array.isArray(value) &&\n    value.every((v) => typeof (v as OpenAIToolCall).index === \"number\")\n  );\n}\n\nexport function _mergeDicts(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  left: Record<string, any> = {},\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  right: Record<string, any> = {}\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> {\n  const merged = { ...left };\n  for (const [key, value] of Object.entries(right)) {\n    if (merged[key] == null) {\n      merged[key] = value;\n    } else if (value == null) {\n      continue;\n    } else if (\n      typeof merged[key] !== typeof value ||\n      Array.isArray(merged[key]) !== Array.isArray(value)\n    ) {\n      throw new Error(\n        `field[${key}] already exists in the message chunk, but with a different type.`\n      );\n    } else if (typeof merged[key] === \"string\") {\n      if (key === \"type\") {\n        // Do not merge 'type' fields\n        continue;\n      } else if (\n        [\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)\n      ) {\n        // Keep the incoming value for these fields if its defined\n        if (value) {\n          merged[key] = value;\n        }\n      } else {\n        merged[key] += value;\n      }\n    } else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n      merged[key] = _mergeDicts(merged[key], value);\n    } else if (Array.isArray(merged[key])) {\n      merged[key] = _mergeLists(merged[key], value);\n    } else if (merged[key] === value) {\n      continue;\n    } else {\n      console.warn(\n        `field[${key}] already exists in this message chunk and value has unsupported type.`\n      );\n    }\n  }\n  return merged;\n}\n\nexport function _mergeLists<Content extends ContentBlock>(\n  left?: Content[],\n  right?: Content[]\n): Content[] | undefined {\n  if (left === undefined && right === undefined) {\n    return undefined;\n  } else if (left === undefined || right === undefined) {\n    return left || right;\n  } else {\n    const merged = [...left];\n    for (const item of right) {\n      if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"index\" in item &&\n        typeof item.index === \"number\"\n      ) {\n        const toMerge = merged.findIndex((leftItem) => {\n          const isObject = typeof leftItem === \"object\";\n          const indiciesMatch =\n            \"index\" in leftItem && leftItem.index === item.index;\n          const idsMatch =\n            \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n          const eitherItemMissingID =\n            !(\"id\" in leftItem) ||\n            !leftItem?.id ||\n            !(\"id\" in item) ||\n            !item?.id;\n          return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n        });\n        if (\n          toMerge !== -1 &&\n          typeof merged[toMerge] === \"object\" &&\n          merged[toMerge] !== null\n        ) {\n          merged[toMerge] = _mergeDicts(\n            merged[toMerge] as Record<string, unknown>,\n            item as Record<string, unknown>\n          ) as Content;\n        } else {\n          merged.push(item);\n        }\n      } else if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"text\" in item &&\n        item.text === \"\"\n      ) {\n        // No-op - skip empty text blocks\n        continue;\n      } else {\n        merged.push(item);\n      }\n    }\n    return merged;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _mergeObj<T = any>(\n  left: T | undefined,\n  right: T | undefined\n): T {\n  if (!left && !right) {\n    throw new Error(\"Cannot merge two undefined objects.\");\n  }\n  if (!left || !right) {\n    return left || (right as T);\n  } else if (typeof left !== typeof right) {\n    throw new Error(\n      `Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`\n    );\n  } else if (typeof left === \"string\" && typeof right === \"string\") {\n    return (left + right) as T;\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    return _mergeLists(left, right) as T;\n  } else if (typeof left === \"object\" && typeof right === \"object\") {\n    return _mergeDicts(left, right) as T;\n  } else if (left === right) {\n    return left;\n  } else {\n    throw new Error(\n      `Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`\n    );\n  }\n}\n\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport abstract class BaseMessageChunk<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType\n> extends BaseMessage<TStructure, TRole> {\n  abstract concat(chunk: BaseMessageChunk): BaseMessageChunk<TStructure, TRole>;\n\n  static isInstance(obj: unknown): obj is BaseMessageChunk {\n    if (!super.isInstance(obj)) {\n      return false;\n    }\n    // Check if obj is an instance of BaseMessageChunk by traversing the prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while (proto !== null) {\n      if (proto === BaseMessageChunk.prototype) {\n        return true;\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n    return false;\n  }\n}\n\nexport type MessageFieldWithRole = {\n  role: MessageType;\n  content: MessageContent;\n  name?: string;\n} & Record<string, unknown>;\n\nexport function _isMessageFieldWithRole(\n  x: BaseMessageLike\n): x is MessageFieldWithRole {\n  return typeof (x as MessageFieldWithRole).role === \"string\";\n}\n\nexport type BaseMessageLike =\n  | BaseMessage\n  | MessageFieldWithRole\n  | [MessageType, MessageContent]\n  | string\n  /**\n   * @deprecated Specifying \"type\" is deprecated and will be removed in 0.4.0.\n   */\n  | ({\n      type: MessageType | \"user\" | \"assistant\" | \"placeholder\";\n    } & BaseMessageFields &\n      Record<string, unknown>)\n  | SerializedConstructor;\n\n/**\n * @deprecated Use {@link BaseMessage.isInstance} instead\n */\nexport function isBaseMessage(\n  messageLike?: unknown\n): messageLike is BaseMessage {\n  return typeof (messageLike as BaseMessage)?._getType === \"function\";\n}\n\n/**\n * @deprecated Use {@link BaseMessageChunk.isInstance} instead\n */\nexport function isBaseMessageChunk(\n  messageLike?: unknown\n): messageLike is BaseMessageChunk {\n  return BaseMessageChunk.isInstance(messageLike);\n}\n","// Inlined from https://github.com/flexdinesh/browser-or-node\ndeclare global {\n  const Deno:\n    | {\n        version: {\n          deno: string;\n        };\n        env: {\n          get: (name: string) => string | undefined;\n        };\n      }\n    | undefined;\n}\n\nexport const isBrowser = () =>\n  typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\nexport const isWebWorker = () =>\n  typeof globalThis === \"object\" &&\n  globalThis.constructor &&\n  globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\n\nexport const isJsDom = () =>\n  (typeof window !== \"undefined\" && window.name === \"nodejs\") ||\n  (typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\"));\n\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nexport const isDeno = () => typeof Deno !== \"undefined\";\n\n// Mark not-as-node if in Supabase Edge Function\nexport const isNode = () =>\n  typeof process !== \"undefined\" &&\n  typeof process.versions !== \"undefined\" &&\n  typeof process.versions.node !== \"undefined\" &&\n  !isDeno();\n\nexport const getEnv = () => {\n  let env: string;\n  if (isBrowser()) {\n    env = \"browser\";\n  } else if (isNode()) {\n    env = \"node\";\n  } else if (isWebWorker()) {\n    env = \"webworker\";\n  } else if (isJsDom()) {\n    env = \"jsdom\";\n  } else if (isDeno()) {\n    env = \"deno\";\n  } else {\n    env = \"other\";\n  }\n\n  return env;\n};\n\nexport type RuntimeEnvironment = {\n  library: string;\n  libraryVersion?: string;\n  runtime: string;\n  runtimeVersion?: string;\n};\n\nlet runtimeEnvironment: RuntimeEnvironment | undefined;\n\nexport function getRuntimeEnvironment(): RuntimeEnvironment {\n  if (runtimeEnvironment === undefined) {\n    const env = getEnv();\n\n    runtimeEnvironment = {\n      library: \"langchain-js\",\n      runtime: env,\n    };\n  }\n  return runtimeEnvironment;\n}\n\nexport function getEnvironmentVariable(name: string): string | undefined {\n  // Certain Deno setups will throw an error if you try to access environment variables\n  // https://github.com/langchain-ai/langchainjs/issues/1412\n  try {\n    if (typeof process !== \"undefined\") {\n      // eslint-disable-next-line no-process-env\n      return process.env?.[name];\n    } else if (isDeno()) {\n      return Deno?.env.get(name);\n    } else {\n      return undefined;\n    }\n  } catch {\n    return undefined;\n  }\n}\n","import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface ChatMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"generic\"> {\n  role: string;\n}\n\n/**\n * Represents a chat message in a conversation.\n */\nexport class ChatMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"generic\">\n  implements ChatMessageFields<TStructure>\n{\n  static lc_name() {\n    return \"ChatMessage\";\n  }\n\n  readonly type = \"generic\" as const;\n\n  role: string;\n\n  static _chatMessageClass(): typeof ChatMessage {\n    return ChatMessage;\n  }\n\n  constructor(\n    content: $InferMessageContent<TStructure, \"generic\">,\n    role: string\n  );\n\n  constructor(fields: ChatMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>,\n    role?: string\n  ) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = { content: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  static isInstance(obj: unknown): obj is ChatMessage {\n    return super.isInstance(obj) && obj.type === \"generic\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      role: this.role,\n    };\n  }\n}\n\n/**\n * Represents a chunk of a chat message, which can be concatenated with\n * other chat message chunks.\n */\nexport class ChatMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"generic\"> {\n  static lc_name() {\n    return \"ChatMessageChunk\";\n  }\n\n  readonly type = \"generic\" as const;\n\n  role: string;\n\n  constructor(\n    content: $InferMessageContent<TStructure, \"generic\">,\n    role: string\n  );\n\n  constructor(fields: ChatMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"generic\">\n      | ChatMessageFields<TStructure>,\n    role?: string\n  ) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-non-null-assertion\n      fields = { content: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  concat(chunk: ChatMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      role: this.role,\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is ChatMessageChunk {\n    return super.isInstance(obj) && obj.type === \"generic\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      role: this.role,\n    };\n  }\n}\n\n/**\n * @deprecated Use {@link ChatMessage.isInstance} instead\n */\nexport function isChatMessage(x: BaseMessage): x is ChatMessage {\n  return x._getType() === \"generic\";\n}\n\n/**\n * @deprecated Use {@link ChatMessageChunk.isInstance} instead\n */\nexport function isChatMessageChunk(x: BaseMessageChunk): x is ChatMessageChunk {\n  return x._getType() === \"generic\";\n}\n","import { Document } from \"../../documents/document.js\";\nimport { EmbeddingsInterface } from \"../../embeddings.js\";\nimport { VectorStore } from \"../../vectorstores.js\";\nimport { cosine } from \"../ml-distance/similarities.js\";\n\n/**\n * Interface representing a vector in memory. It includes the content\n * (text), the corresponding embedding (vector), and any associated\n * metadata.\n */\ninterface MemoryVector {\n  content: string;\n  embedding: number[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n}\n\n/**\n * Interface for the arguments that can be passed to the\n * `FakeVectorStore` constructor. It includes an optional `similarity`\n * function.\n */\nexport interface FakeVectorStoreArgs {\n  similarity?: typeof cosine;\n}\n\n/**\n * Class that extends `VectorStore` to store vectors in memory. Provides\n * methods for adding documents, performing similarity searches, and\n * creating instances from texts, documents, or an existing index.\n */\nexport class FakeVectorStore extends VectorStore {\n  declare FilterType: (doc: Document) => boolean;\n\n  memoryVectors: MemoryVector[] = [];\n\n  similarity: typeof cosine;\n\n  _vectorstoreType(): string {\n    return \"memory\";\n  }\n\n  constructor(\n    embeddings: EmbeddingsInterface,\n    { similarity, ...rest }: FakeVectorStoreArgs = {}\n  ) {\n    super(embeddings, rest);\n\n    this.similarity = similarity ?? cosine;\n  }\n\n  /**\n   * Method to add documents to the memory vector store. It extracts the\n   * text from each document, generates embeddings for them, and adds the\n   * resulting vectors to the store.\n   * @param documents Array of `Document` instances to be added to the store.\n   * @returns Promise that resolves when all documents have been added.\n   */\n  async addDocuments(documents: Document[]): Promise<void> {\n    const texts = documents.map(({ pageContent }) => pageContent);\n    return this.addVectors(\n      await this.embeddings.embedDocuments(texts),\n      documents\n    );\n  }\n\n  /**\n   * Method to add vectors to the memory vector store. It creates\n   * `MemoryVector` instances for each vector and document pair and adds\n   * them to the store.\n   * @param vectors Array of vectors to be added to the store.\n   * @param documents Array of `Document` instances corresponding to the vectors.\n   * @returns Promise that resolves when all vectors have been added.\n   */\n  async addVectors(vectors: number[][], documents: Document[]): Promise<void> {\n    const memoryVectors = vectors.map((embedding, idx) => ({\n      content: documents[idx].pageContent,\n      embedding,\n      metadata: documents[idx].metadata,\n    }));\n\n    this.memoryVectors = this.memoryVectors.concat(memoryVectors);\n  }\n\n  /**\n   * Method to perform a similarity search in the memory vector store. It\n   * calculates the similarity between the query vector and each vector in\n   * the store, sorts the results by similarity, and returns the top `k`\n   * results along with their scores.\n   * @param query Query vector to compare against the vectors in the store.\n   * @param k Number of top results to return.\n   * @param filter Optional filter function to apply to the vectors before performing the search.\n   * @returns Promise that resolves with an array of tuples, each containing a `Document` and its similarity score.\n   */\n  async similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[Document, number][]> {\n    const filterFunction = (memoryVector: MemoryVector) => {\n      if (!filter) {\n        return true;\n      }\n\n      const doc = new Document({\n        metadata: memoryVector.metadata,\n        pageContent: memoryVector.content,\n      });\n      return filter(doc);\n    };\n    const filteredMemoryVectors = this.memoryVectors.filter(filterFunction);\n    const searches = filteredMemoryVectors\n      .map((vector, index) => ({\n        similarity: this.similarity(query, vector.embedding),\n        index,\n      }))\n      .sort((a, b) => (a.similarity > b.similarity ? -1 : 0))\n      .slice(0, k);\n\n    const result: [Document, number][] = searches.map((search) => [\n      new Document({\n        metadata: filteredMemoryVectors[search.index].metadata,\n        pageContent: filteredMemoryVectors[search.index].content,\n      }),\n      search.similarity,\n    ]);\n\n    return result;\n  }\n\n  /**\n   * Static method to create a `FakeVectorStore` instance from an array of\n   * texts. It creates a `Document` for each text and metadata pair, and\n   * adds them to the store.\n   * @param texts Array of texts to be added to the store.\n   * @param metadatas Array or single object of metadata corresponding to the texts.\n   * @param embeddings `Embeddings` instance used to generate embeddings for the texts.\n   * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n   * @returns Promise that resolves with a new `FakeVectorStore` instance.\n   */\n  static async fromTexts(\n    texts: string[],\n    metadatas: object[] | object,\n    embeddings: EmbeddingsInterface,\n    dbConfig?: FakeVectorStoreArgs\n  ): Promise<FakeVectorStore> {\n    const docs: Document[] = [];\n    for (let i = 0; i < texts.length; i += 1) {\n      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;\n      const newDoc = new Document({\n        pageContent: texts[i],\n        metadata,\n      });\n      docs.push(newDoc);\n    }\n    return FakeVectorStore.fromDocuments(docs, embeddings, dbConfig);\n  }\n\n  /**\n   * Static method to create a `FakeVectorStore` instance from an array of\n   * `Document` instances. It adds the documents to the store.\n   * @param docs Array of `Document` instances to be added to the store.\n   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n   * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n   * @returns Promise that resolves with a new `FakeVectorStore` instance.\n   */\n  static async fromDocuments(\n    docs: Document[],\n    embeddings: EmbeddingsInterface,\n    dbConfig?: FakeVectorStoreArgs\n  ): Promise<FakeVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    await instance.addDocuments(docs);\n    return instance;\n  }\n\n  /**\n   * Static method to create a `FakeVectorStore` instance from an existing\n   * index. It creates a new `FakeVectorStore` instance without adding any\n   * documents or vectors.\n   * @param embeddings `Embeddings` instance used to generate embeddings for the documents.\n   * @param dbConfig Optional `FakeVectorStoreArgs` to configure the `FakeVectorStore` instance.\n   * @returns Promise that resolves with a new `FakeVectorStore` instance.\n   */\n  static async fromExistingIndex(\n    embeddings: EmbeddingsInterface,\n    dbConfig?: FakeVectorStoreArgs\n  ): Promise<FakeVectorStore> {\n    const instance = new this(embeddings, dbConfig);\n    return instance;\n  }\n}\n","import {\n  Runnable,\n  RunnableBinding,\n  RunnableBindingArgs,\n  RunnableConfig,\n  RunnablePassthrough,\n  RunnableSequence,\n  _coerceToRunnable,\n  type RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { CONFIG_KEY_READ } from \"../constants.js\";\nimport { ChannelWrite } from \"./write.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport type { CachePolicy, RetryPolicy } from \"./utils/index.js\";\n\nexport class ChannelRead<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable {\n  lc_graph_name = \"ChannelRead\";\n\n  channel: string | Array<string>;\n\n  fresh: boolean = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(\n    channel: string | Array<string>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mapper?: (args: any) => any,\n    fresh: boolean = false\n  ) {\n    super({\n      func: (_: RunInput, config: RunnableConfig) =>\n        ChannelRead.doRead(config, this.channel, this.fresh, this.mapper),\n    });\n    this.fresh = fresh;\n    this.mapper = mapper;\n    this.channel = channel;\n    this.name = Array.isArray(channel)\n      ? `ChannelRead<${channel.join(\",\")}>`\n      : `ChannelRead<${channel}>`;\n  }\n\n  static doRead<T = unknown>(\n    config: RunnableConfig,\n    channel: string | Array<string>,\n    fresh: boolean,\n    mapper?: (args: unknown) => unknown\n  ): T {\n    const read: (arg: string | string[], fresh: boolean) => unknown =\n      config.configurable?.[CONFIG_KEY_READ];\n    if (!read) {\n      throw new Error(\n        \"Runnable is not configured with a read function. Make sure to call in the context of a Pregel process\"\n      );\n    }\n    if (mapper) {\n      return mapper(read(channel, fresh)) as T;\n    } else {\n      return read(channel, fresh) as T;\n    }\n  }\n}\n\nconst defaultRunnableBound =\n  /* #__PURE__ */ new RunnablePassthrough<PregelNodeInputType>();\n\ninterface PregelNodeArgs<RunInput, RunOutput>\n  extends Partial<RunnableBindingArgs<RunInput, RunOutput>> {\n  channels: Record<string, string> | string[];\n  triggers: Array<string>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n  writers?: Runnable<RunOutput, unknown>[];\n  tags?: string[];\n  bound?: Runnable<RunInput, RunOutput>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs?: Record<string, any>;\n  config?: RunnableConfig;\n  metadata?: Record<string, unknown>;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n  subgraphs?: Runnable[];\n  ends?: string[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeOutputType = any;\n\nexport class PregelNode<\n  RunInput = PregelNodeInputType,\n  RunOutput = PregelNodeOutputType\n> extends RunnableBinding<RunInput, RunOutput, RunnableConfig> {\n  lc_graph_name = \"PregelNode\";\n\n  channels: Record<string, string> | string[];\n\n  triggers: string[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  writers: Runnable[] = [];\n\n  bound: Runnable<RunInput, RunOutput> = defaultRunnableBound;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs: Record<string, any> = {};\n\n  metadata: Record<string, unknown> = {};\n\n  tags: string[] = [];\n\n  retryPolicy?: RetryPolicy;\n\n  cachePolicy?: CachePolicy;\n\n  subgraphs?: Runnable[];\n\n  ends?: string[];\n\n  constructor(fields: PregelNodeArgs<RunInput, RunOutput>) {\n    const {\n      channels,\n      triggers,\n      mapper,\n      writers,\n      bound,\n      kwargs,\n      metadata,\n      retryPolicy,\n      cachePolicy,\n      tags,\n      subgraphs,\n      ends,\n    } = fields;\n    const mergedTags = [\n      ...(fields.config?.tags ? fields.config.tags : []),\n      ...(tags ?? []),\n    ];\n\n    super({\n      ...fields,\n      bound:\n        fields.bound ??\n        (defaultRunnableBound as unknown as Runnable<RunInput, RunOutput>),\n      config: {\n        ...(fields.config ? fields.config : {}),\n        tags: mergedTags,\n      },\n    });\n\n    this.channels = channels;\n    this.triggers = triggers;\n    this.mapper = mapper;\n    this.writers = writers ?? this.writers;\n    this.bound = bound ?? this.bound;\n    this.kwargs = kwargs ?? this.kwargs;\n    this.metadata = metadata ?? this.metadata;\n    this.tags = mergedTags;\n    this.retryPolicy = retryPolicy;\n    this.cachePolicy = cachePolicy;\n    this.subgraphs = subgraphs;\n    this.ends = ends;\n  }\n\n  getWriters(): Array<Runnable> {\n    const newWriters = [...this.writers];\n    while (\n      newWriters.length > 1 &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 1] instanceof ChannelWrite &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 2] instanceof ChannelWrite\n    ) {\n      // we can combine writes if they are consecutive\n      // careful to not modify the original writers list or ChannelWrite\n      const endWriters = newWriters.slice(-2) as ChannelWrite[];\n      const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);\n      newWriters[newWriters.length - 2] = new ChannelWrite(\n        combinedWrites,\n        endWriters[0].config?.tags\n      );\n      newWriters.pop();\n    }\n    return newWriters;\n  }\n\n  getNode(): Runnable<RunInput, RunOutput> | undefined {\n    const writers = this.getWriters();\n    if (this.bound === defaultRunnableBound && writers.length === 0) {\n      return undefined;\n    } else if (this.bound === defaultRunnableBound && writers.length === 1) {\n      return writers[0];\n    } else if (this.bound === defaultRunnableBound) {\n      return new RunnableSequence({\n        first: writers[0],\n        middle: writers.slice(1, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else if (writers.length > 0) {\n      return new RunnableSequence({\n        first: this.bound,\n        middle: writers.slice(0, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else {\n      return this.bound;\n    }\n  }\n\n  join(channels: Array<string>): PregelNode<RunInput, RunOutput> {\n    if (!Array.isArray(channels)) {\n      throw new Error(\"channels must be a list\");\n    }\n    if (typeof this.channels !== \"object\") {\n      throw new Error(\"all channels must be named when using .join()\");\n    }\n\n    return new PregelNode<RunInput, RunOutput>({\n      channels: {\n        ...this.channels,\n        ...Object.fromEntries(channels.map((chan) => [chan, chan])),\n      },\n      triggers: this.triggers,\n      mapper: this.mapper,\n      writers: this.writers,\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      retryPolicy: this.retryPolicy,\n      cachePolicy: this.cachePolicy,\n    });\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike\n  ): PregelNode<RunInput, Exclude<NewRunOutput, Error>> {\n    if (ChannelWrite.isWriter(coerceable)) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: [...this.writers, coerceable],\n        bound: this.bound as unknown as PregelNode<\n          RunInput,\n          Exclude<NewRunOutput, Error>\n        >,\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    } else if (this.bound === defaultRunnableBound) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: _coerceToRunnable<RunInput, NewRunOutput>(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    } else {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: this.bound.pipe(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    }\n  }\n}\n","import { BaseDocumentTransformer } from \"../documents/transformers.js\";\nimport { BaseLanguageModel } from \"../language_models/base.js\";\nimport { Runnable, RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessage,\n  BaseMessageChunk,\n  BaseMessageFields,\n  isBaseMessageChunk,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk, ChatMessageFields } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { MessageType } from \"./message.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk, ToolMessageFields } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\n\nexport type MessageUnion =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage\n  | typeof ChatMessage\n  | typeof FunctionMessage\n  | typeof ToolMessage\n  | typeof RemoveMessage;\nexport type MessageChunkUnion =\n  | typeof HumanMessageChunk\n  | typeof AIMessageChunk\n  | typeof SystemMessageChunk\n  | typeof FunctionMessageChunk\n  | typeof ToolMessageChunk\n  | typeof ChatMessageChunk\n  | typeof RemoveMessage; // RemoveMessage does not have a chunk class.\nexport type MessageTypeOrClass = MessageType | MessageUnion | MessageChunkUnion;\n\nconst _isMessageType = (msg: BaseMessage, types: MessageTypeOrClass[]) => {\n  const typesAsStrings = [\n    ...new Set<string>(\n      types?.map((t) => {\n        if (typeof t === \"string\") {\n          return t;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const instantiatedMsgClass = new (t as any)({});\n        if (\n          !(\"getType\" in instantiatedMsgClass) ||\n          typeof instantiatedMsgClass.getType !== \"function\"\n        ) {\n          throw new Error(\"Invalid type provided.\");\n        }\n        return instantiatedMsgClass.getType();\n      })\n    ),\n  ];\n  const msgType = msg.getType();\n  return typesAsStrings.some((t) => t === msgType);\n};\n\nexport interface FilterMessagesFields {\n  /**\n   * @param {string[] | undefined} includeNames Message names to include.\n   */\n  includeNames?: string[];\n  /**\n   * @param {string[] | undefined} excludeNames Messages names to exclude.\n   */\n  excludeNames?: string[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} includeTypes Message types to include. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  includeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {(MessageType | BaseMessage)[] | undefined} excludeTypes Message types to exclude. Can be specified as string names (e.g.\n   *     \"system\", \"human\", \"ai\", ...) or as BaseMessage classes (e.g.\n   *     SystemMessage, HumanMessage, AIMessage, ...).\n   */\n  excludeTypes?: MessageTypeOrClass[];\n  /**\n   * @param {string[] | undefined} includeIds Message IDs to include.\n   */\n  includeIds?: string[];\n  /**\n   * @param {string[] | undefined} excludeIds Message IDs to exclude.\n   */\n  excludeIds?: string[];\n}\n\n/**\n * Filter messages based on name, type or id.\n *\n * @param {BaseMessage[] | FilterMessagesFields} messagesOrOptions - Either an array of BaseMessage objects to filter or the filtering options. If an array is provided, the `options` parameter should also be supplied. If filtering options are provided, a RunnableLambda is returned.\n * @param {FilterMessagesFields} [options] - Optional filtering options. Should only be provided if `messagesOrOptions` is an array of BaseMessage objects.\n * @returns A list of Messages that meets at least one of the include conditions and none\n *     of the exclude conditions, or a RunnableLambda which does the same. If no include conditions are specified then\n *     anything that is not explicitly excluded will be included.\n * @throws {Error} If two incompatible arguments are provided.\n *\n * @example\n * ```typescript\n * import { filterMessages, AIMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n *   new AIMessage({ content: \"steve-o\", id: \"bar\", name: \"example_assistant\" }),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"baz\" }),\n *   new AIMessage({ content: \"silicon blue\" , id: \"blah\" }),\n * ];\n *\n * filterMessages(messages, {\n *   includeNames: [\"example_user\", \"example_assistant\"],\n *   includeTypes: [\"system\"],\n *   excludeIds: [\"bar\"],\n * });\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your name\", id: \"foo\", name: \"example_user\" }),\n * ]\n * ```\n */\nexport function filterMessages(\n  options?: FilterMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function filterMessages(\n  messages: BaseMessage[],\n  options?: FilterMessagesFields\n): BaseMessage[];\nexport function filterMessages(\n  messagesOrOptions?: BaseMessage[] | FilterMessagesFields,\n  options?: FilterMessagesFields\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    return _filterMessages(messagesOrOptions, options);\n  }\n  return RunnableLambda.from((input: BaseMessage[]): BaseMessage[] => {\n    return _filterMessages(input, messagesOrOptions);\n  });\n}\n\nfunction _filterMessages(\n  messages: BaseMessage[],\n  options: FilterMessagesFields = {}\n): BaseMessage[] {\n  const {\n    includeNames,\n    excludeNames,\n    includeTypes,\n    excludeTypes,\n    includeIds,\n    excludeIds,\n  } = options;\n\n  const filtered: BaseMessage[] = [];\n\n  for (const msg of messages) {\n    if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n      continue;\n    } else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n      continue;\n    } else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n      continue;\n    }\n\n    // default to inclusion when no inclusion criteria given.\n    if (!(includeTypes || includeIds || includeNames)) {\n      filtered.push(msg);\n    } else if (\n      includeNames &&\n      msg.name &&\n      includeNames.some((iName) => iName === msg.name)\n    ) {\n      filtered.push(msg);\n    } else if (includeTypes && _isMessageType(msg, includeTypes)) {\n      filtered.push(msg);\n    } else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n      filtered.push(msg);\n    }\n  }\n\n  return filtered;\n}\n\n/**\n * Merge consecutive Messages of the same type.\n *\n * **NOTE**: ToolMessages are not merged, as each has a distinct tool call id that\n * can't be merged.\n *\n * @param {BaseMessage[] | undefined} messages Sequence of Message-like objects to merge. Optional. If not provided, a RunnableLambda is returned.\n * @returns List of BaseMessages with consecutive runs of message types merged into single\n *     messages, or a RunnableLambda which returns a list of BaseMessages If two messages being merged both have string contents, the merged\n *     content is a concatenation of the two strings with a new-line separator. If at\n *     least one of the messages has a list of content blocks, the merged content is a\n *     list of content blocks.\n *\n * @example\n * ```typescript\n * import { mergeMessageRuns, AIMessage, HumanMessage, SystemMessage, ToolCall } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({ content: \"what's your favorite color\", id: \"foo\" }),\n *   new HumanMessage({ content: \"wait your favorite food\", id: \"bar\" }),\n *   new AIMessage({\n *     content: \"my favorite colo\",\n *     tool_calls: [{ name: \"blah_tool\", args: { x: 2 }, id: \"123\" }],\n *     id: \"baz\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"my favorite dish is lasagna\" }],\n *     tool_calls: [{ name: \"blah_tool\", args: { x: -10 }, id: \"456\" }],\n *     id: \"blur\",\n *   }),\n * ];\n *\n * mergeMessageRuns(messages);\n * ```\n *\n * The above example would return:\n * ```typescript\n * [\n *   new SystemMessage(\"you're a good assistant.\"),\n *   new HumanMessage({\n *     content: \"what's your favorite colorwait your favorite food\",\n *     id: \"foo\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"my favorite colo\" },\n *       { type: \"text\", text: \"my favorite dish is lasagna\" },\n *     ],\n *     tool_calls: [\n *       { name: \"blah_tool\", args: { x: 2 }, id: \"123\" },\n *       { name: \"blah_tool\", args: { x: -10 }, id: \"456\" },\n *     ],\n *     id: \"baz\",\n *   }),\n * ]\n * ```\n */\nexport function mergeMessageRuns(): Runnable<BaseMessage[], BaseMessage[]>;\nexport function mergeMessageRuns(messages: BaseMessage[]): BaseMessage[];\nexport function mergeMessageRuns(\n  messages?: BaseMessage[]\n): BaseMessage[] | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messages)) {\n    return _mergeMessageRuns(messages);\n  }\n  return RunnableLambda.from(_mergeMessageRuns);\n}\n\nfunction _mergeMessageRuns(messages: BaseMessage[]): BaseMessage[] {\n  if (!messages.length) {\n    return [];\n  }\n  const merged: BaseMessage[] = [];\n  for (const msg of messages) {\n    const curr = msg;\n    const last = merged.pop();\n    if (!last) {\n      merged.push(curr);\n    } else if (\n      curr.getType() === \"tool\" ||\n      !(curr.getType() === last.getType())\n    ) {\n      merged.push(last, curr);\n    } else {\n      const lastChunk = convertToChunk(last) as BaseMessageChunk;\n      const currChunk = convertToChunk(curr) as BaseMessageChunk;\n      const mergedChunks = lastChunk.concat(currChunk);\n      if (\n        typeof lastChunk.content === \"string\" &&\n        typeof currChunk.content === \"string\"\n      ) {\n        mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n      }\n      merged.push(_chunkToMsg(mergedChunks));\n    }\n  }\n  return merged;\n}\n\n// Since we can not import from `@langchain/textsplitters` we need\n// to reconstruct the interface here.\ninterface _TextSplitterInterface extends BaseDocumentTransformer {\n  splitText(text: string): Promise<string[]>;\n}\n\nexport interface TrimMessagesFields {\n  /**\n   * @param {number} maxTokens Max token count of trimmed messages.\n   */\n  maxTokens: number;\n  /**\n   * @param {((messages: BaseMessage[]) => number) | ((messages: BaseMessage[]) => Promise<number>) | BaseLanguageModel} tokenCounter\n   * Function or LLM for counting tokens in an array of `BaseMessage`s.\n   * If a `BaseLanguageModel` is passed in then `BaseLanguageModel.getNumTokens()` will be used.\n   */\n  tokenCounter:\n    | ((messages: BaseMessage[]) => number)\n    | ((messages: BaseMessage[]) => Promise<number>)\n    | BaseLanguageModel;\n  /**\n   * @param {\"first\" | \"last\"} [strategy=\"last\"] Strategy for trimming.\n   * - \"first\": Keep the first <= n_count tokens of the messages.\n   * - \"last\": Keep the last <= n_count tokens of the messages.\n   * @default \"last\"\n   */\n  strategy?: \"first\" | \"last\";\n  /**\n   * @param {boolean} [allowPartial=false] Whether to split a message if only part of the message can be included.\n   * If `strategy: \"last\"` then the last partial contents of a message are included.\n   * If `strategy: \"first\"` then the first partial contents of a message are included.\n   * @default false\n   */\n  allowPartial?: boolean;\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [endOn] The message type to end on.\n   * If specified then every message after the last occurrence of this type is ignored.\n   * If `strategy === \"last\"` then this is done before we attempt to get the last `maxTokens`.\n   * If `strategy === \"first\"` then this is done after we get the first `maxTokens`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {MessageTypeOrClass | MessageTypeOrClass[]} [startOn] The message type to start on.\n   * Should only be specified if `strategy: \"last\"`. If specified then every message before the first occurrence\n   * of this type is ignored. This is done after we trim the initial messages to the last `maxTokens`.\n   * Does not apply to a `SystemMessage` at index 0 if `includeSystem: true`.\n   * Can be specified as string names (e.g. \"system\", \"human\", \"ai\", ...) or as `BaseMessage` classes\n   * (e.g. `SystemMessage`, `HumanMessage`, `AIMessage`, ...). Can be a single type or an array of types.\n   */\n  startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  /**\n   * @param {boolean} [includeSystem=false] Whether to keep the `SystemMessage` if there is one at index 0.\n   * Should only be specified if `strategy: \"last\"`.\n   * @default false\n   */\n  includeSystem?: boolean;\n  /**\n   * @param {((text: string) => string[]) | BaseDocumentTransformer} [textSplitter] Function or `BaseDocumentTransformer` for\n   * splitting the string contents of a message. Only used if `allowPartial: true`.\n   * If `strategy: \"last\"` then the last split tokens from a partial message will be included.\n   * If `strategy: \"first\"` then the first split tokens from a partial message will be included.\n   * Token splitter assumes that separators are kept, so that split contents can be directly concatenated\n   * to recreate the original text. Defaults to splitting on newlines.\n   */\n  textSplitter?:\n    | ((text: string) => string[])\n    | ((text: string) => Promise<string[]>)\n    | _TextSplitterInterface;\n}\n\n/**\n * Trim messages to be below a token count.\n *\n * @param {BaseMessage[]} messages Array of `BaseMessage` instances to trim.\n * @param {TrimMessagesFields} options Trimming options.\n * @returns An array of trimmed `BaseMessage`s or a `Runnable` that takes a sequence of `BaseMessage`-like objects and returns\n *     an array of trimmed `BaseMessage`s.\n * @throws {Error} If two incompatible arguments are specified or an unrecognized `strategy` is specified.\n *\n * @example\n * ```typescript\n * import { trimMessages, AIMessage, BaseMessage, HumanMessage, SystemMessage } from \"@langchain/core/messages\";\n *\n * const messages = [\n *   new SystemMessage(\"This is a 4 token text. The full message is 10 tokens.\"),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [\n *       { type: \"text\", text: \"This is the FIRST 4 token block.\" },\n *       { type: \"text\", text: \"This is the SECOND 4 token block.\" },\n *     ],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ];\n *\n * function dummyTokenCounter(messages: BaseMessage[]): number {\n *   // treat each message like it adds 3 default tokens at the beginning\n *   // of the message and at the end of the message. 3 + 4 + 3 = 10 tokens\n *   // per message.\n *\n *   const defaultContentLen = 4;\n *   const defaultMsgPrefixLen = 3;\n *   const defaultMsgSuffixLen = 3;\n *\n *   let count = 0;\n *   for (const msg of messages) {\n *     if (typeof msg.content === \"string\") {\n *       count += defaultMsgPrefixLen + defaultContentLen + defaultMsgSuffixLen;\n *     }\n *     if (Array.isArray(msg.content)) {\n *       count +=\n *         defaultMsgPrefixLen +\n *         msg.content.length * defaultContentLen +\n *         defaultMsgSuffixLen;\n *     }\n *   }\n *   return count;\n * }\n * ```\n *\n * First 30 tokens, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n * ]\n * ```\n *\n * First 30 tokens, allowing partial messages, have to end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"first\",\n *   allowPartial: true,\n *   endOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"first\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, not allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   includeSystem: true,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   allowPartial: true,\n *   includeSystem: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n *\n * Last 30 tokens, including system message, allowing partial messages, end on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 30,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   endOn: \"human\",\n *   includeSystem: true,\n *   allowPartial: true,\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new AIMessage({\n *     content: [{ type: \"text\", text: \"This is the FIRST 4 token block.\" }],\n *     id: \"second\",\n *   }),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n * ]\n * ```\n *\n * Last 40 tokens, including system message, allowing partial messages, start on HumanMessage:\n * ```typescript\n * await trimMessages(messages, {\n *   maxTokens: 40,\n *   tokenCounter: dummyTokenCounter,\n *   strategy: \"last\",\n *   includeSystem: true,\n *   allowPartial: true,\n *   startOn: \"human\",\n * });\n * ```\n *\n * Output:\n * ```typescript\n * [\n *   new SystemMessage(\n *     \"This is a 4 token text. The full message is 10 tokens.\"\n *   ),\n *   new HumanMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"third\",\n *   }),\n *   new AIMessage({\n *     content: \"This is a 4 token text. The full message is 10 tokens.\",\n *     id: \"fourth\",\n *   }),\n * ]\n * ```\n */\nexport function trimMessages(\n  options: TrimMessagesFields\n): Runnable<BaseMessage[], BaseMessage[]>;\nexport function trimMessages(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<BaseMessage[]>;\nexport function trimMessages(\n  messagesOrOptions: BaseMessage[] | TrimMessagesFields,\n  options?: TrimMessagesFields\n): Promise<BaseMessage[]> | Runnable<BaseMessage[], BaseMessage[]> {\n  if (Array.isArray(messagesOrOptions)) {\n    const messages = messagesOrOptions;\n    if (!options) {\n      throw new Error(\"Options parameter is required when providing messages.\");\n    }\n    return _trimMessagesHelper(messages, options);\n  } else {\n    const trimmerOptions = messagesOrOptions;\n    return RunnableLambda.from((input: BaseMessage[]) =>\n      _trimMessagesHelper(input, trimmerOptions)\n    ).withConfig({\n      runName: \"trim_messages\",\n    });\n  }\n}\n\nasync function _trimMessagesHelper(\n  messages: BaseMessage[],\n  options: TrimMessagesFields\n): Promise<Array<BaseMessage>> {\n  const {\n    maxTokens,\n    tokenCounter,\n    strategy = \"last\",\n    allowPartial = false,\n    endOn,\n    startOn,\n    includeSystem = false,\n    textSplitter,\n  } = options;\n  if (startOn && strategy === \"first\") {\n    throw new Error(\n      \"`startOn` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n  if (includeSystem && strategy === \"first\") {\n    throw new Error(\n      \"`includeSystem` should only be specified if `strategy` is 'last'.\"\n    );\n  }\n\n  let listTokenCounter: (msgs: BaseMessage[]) => Promise<number>;\n  if (\"getNumTokens\" in tokenCounter) {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> => {\n      const tokenCounts = await Promise.all(\n        msgs.map((msg) => tokenCounter.getNumTokens(msg.content))\n      );\n      return tokenCounts.reduce((sum, count) => sum + count, 0);\n    };\n  } else {\n    listTokenCounter = async (msgs: BaseMessage[]): Promise<number> =>\n      tokenCounter(msgs);\n  }\n\n  let textSplitterFunc: (text: string) => Promise<string[]> =\n    defaultTextSplitter;\n  if (textSplitter) {\n    if (\"splitText\" in textSplitter) {\n      textSplitterFunc = textSplitter.splitText;\n    } else {\n      textSplitterFunc = async (text: string): Promise<string[]> =>\n        textSplitter(text);\n    }\n  }\n\n  if (strategy === \"first\") {\n    return _firstMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      partialStrategy: allowPartial ? \"first\" : undefined,\n      endOn,\n    });\n  } else if (strategy === \"last\") {\n    return _lastMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      allowPartial,\n      includeSystem,\n      startOn,\n      endOn,\n    });\n  } else {\n    throw new Error(\n      `Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`\n    );\n  }\n}\n\nasync function _firstMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    partialStrategy?: \"first\" | \"last\";\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } =\n    options;\n  let messagesCopy = [...messages];\n  let idx = 0;\n  for (let i = 0; i < messagesCopy.length; i += 1) {\n    const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n    if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n      idx = messagesCopy.length - i;\n      break;\n    }\n  }\n  if (idx < messagesCopy.length && partialStrategy) {\n    let includedPartial = false;\n    if (Array.isArray(messagesCopy[idx].content)) {\n      const excluded = messagesCopy[idx];\n      if (typeof excluded.content === \"string\") {\n        throw new Error(\"Expected content to be an array.\");\n      }\n\n      const numBlock = excluded.content.length;\n      const reversedContent =\n        partialStrategy === \"last\"\n          ? [...excluded.content].reverse()\n          : excluded.content;\n      for (let i = 1; i <= numBlock; i += 1) {\n        const partialContent =\n          partialStrategy === \"first\"\n            ? reversedContent.slice(0, i)\n            : reversedContent.slice(-i);\n        const fields = Object.fromEntries(\n          Object.entries(excluded).filter(\n            ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n          )\n        ) as BaseMessageFields;\n        const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n          ...fields,\n          content: partialContent,\n        });\n        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n        if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n          messagesCopy = slicedMessages;\n          idx += 1;\n          includedPartial = true;\n        } else {\n          break;\n        }\n      }\n      if (includedPartial && partialStrategy === \"last\") {\n        excluded.content = [...reversedContent].reverse();\n      }\n    }\n    if (!includedPartial) {\n      const excluded = messagesCopy[idx];\n      let text: string | undefined;\n      if (\n        Array.isArray(excluded.content) &&\n        excluded.content.some(\n          (block) => typeof block === \"string\" || block.type === \"text\"\n        )\n      ) {\n        const textBlock = excluded.content.find(\n          (block) => block.type === \"text\" && block.text\n        ) as { type: \"text\"; text: string } | undefined;\n        text = textBlock?.text;\n      } else if (typeof excluded.content === \"string\") {\n        text = excluded.content;\n      }\n      if (text) {\n        const splitTexts = await textSplitter(text);\n        const numSplits = splitTexts.length;\n        if (partialStrategy === \"last\") {\n          splitTexts.reverse();\n        }\n        for (let _ = 0; _ < numSplits - 1; _ += 1) {\n          splitTexts.pop();\n          excluded.content = splitTexts.join(\"\");\n          if (\n            (await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n            maxTokens\n          ) {\n            if (partialStrategy === \"last\") {\n              excluded.content = [...splitTexts].reverse().join(\"\");\n            }\n            messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n            idx += 1;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n      idx -= 1;\n    }\n  }\n\n  return messagesCopy.slice(0, idx);\n}\n\nasync function _lastMaxTokens(\n  messages: BaseMessage[],\n  options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }\n): Promise<BaseMessage[]> {\n  const {\n    allowPartial = false,\n    includeSystem = false,\n    endOn,\n    startOn,\n    ...rest\n  } = options;\n\n  // Create a copy of messages to avoid mutation\n  let messagesCopy = messages.map((message) => {\n    const fields = Object.fromEntries(\n      Object.entries(message).filter(\n        ([k]) => k !== \"type\" && !k.startsWith(\"lc_\")\n      )\n    ) as BaseMessageFields;\n    return _switchTypeToMessage(\n      message.getType(),\n      fields,\n      isBaseMessageChunk(message)\n    );\n  });\n\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (\n      messagesCopy.length > 0 &&\n      !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)\n    ) {\n      messagesCopy = messagesCopy.slice(0, -1);\n    }\n  }\n\n  const swappedSystem =\n    includeSystem && messagesCopy[0]?.getType() === \"system\";\n  let reversed_ = swappedSystem\n    ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n    : messagesCopy.reverse();\n\n  reversed_ = await _firstMaxTokens(reversed_, {\n    ...rest,\n    partialStrategy: allowPartial ? \"last\" : undefined,\n    endOn: startOn,\n  });\n\n  if (swappedSystem) {\n    return [reversed_[0], ...reversed_.slice(1).reverse()];\n  } else {\n    return reversed_.reverse();\n  }\n}\n\nconst _MSG_CHUNK_MAP: Record<\n  MessageType,\n  {\n    message: MessageUnion;\n    messageChunk: MessageChunkUnion;\n  }\n> = {\n  human: {\n    message: HumanMessage,\n    messageChunk: HumanMessageChunk,\n  },\n  ai: {\n    message: AIMessage,\n    messageChunk: AIMessageChunk,\n  },\n  system: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  developer: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk,\n  },\n  tool: {\n    message: ToolMessage,\n    messageChunk: ToolMessageChunk,\n  },\n  function: {\n    message: FunctionMessage,\n    messageChunk: FunctionMessageChunk,\n  },\n  generic: {\n    message: ChatMessage,\n    messageChunk: ChatMessageChunk,\n  },\n  remove: {\n    message: RemoveMessage,\n    messageChunk: RemoveMessage, // RemoveMessage does not have a chunk class.\n  },\n};\n\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields\n): BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk: true\n): BaseMessageChunk;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage;\nfunction _switchTypeToMessage(\n  messageType: MessageType,\n  fields: BaseMessageFields,\n  returnChunk?: boolean\n): BaseMessageChunk | BaseMessage {\n  let chunk: BaseMessageChunk | undefined;\n  let msg: BaseMessage | undefined;\n\n  switch (messageType) {\n    case \"human\":\n      if (returnChunk) {\n        chunk = new HumanMessageChunk(fields);\n      } else {\n        msg = new HumanMessage(fields);\n      }\n      break;\n    case \"ai\":\n      if (returnChunk) {\n        let aiChunkFields: AIMessageChunkFields = {\n          ...fields,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n          aiChunkFields = {\n            ...aiChunkFields,\n            tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n              ...tc,\n              type: \"tool_call_chunk\",\n              index: undefined,\n              args: JSON.stringify(tc.args),\n            })),\n          };\n        }\n        chunk = new AIMessageChunk(aiChunkFields);\n      } else {\n        msg = new AIMessage(fields);\n      }\n      break;\n    case \"system\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk(fields);\n      } else {\n        msg = new SystemMessage(fields);\n      }\n      break;\n    case \"developer\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      } else {\n        msg = new SystemMessage({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\",\n          },\n        });\n      }\n      break;\n    case \"tool\":\n      if (\"tool_call_id\" in fields) {\n        if (returnChunk) {\n          chunk = new ToolMessageChunk(fields as ToolMessageFields);\n        } else {\n          msg = new ToolMessage(fields as ToolMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\"\n        );\n      }\n      break;\n    case \"function\":\n      if (returnChunk) {\n        chunk = new FunctionMessageChunk(fields as FunctionMessageFields);\n      } else {\n        if (!fields.name) {\n          throw new Error(\"FunctionMessage must have a 'name' field\");\n        }\n        msg = new FunctionMessage(fields as FunctionMessageFields);\n      }\n      break;\n    case \"generic\":\n      if (\"role\" in fields) {\n        if (returnChunk) {\n          chunk = new ChatMessageChunk(fields as ChatMessageFields);\n        } else {\n          msg = new ChatMessage(fields as ChatMessageFields);\n        }\n      } else {\n        throw new Error(\n          \"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\"\n        );\n      }\n      break;\n    default:\n      throw new Error(`Unrecognized message type ${messageType}`);\n  }\n\n  if (returnChunk && chunk) {\n    return chunk;\n  }\n  if (msg) {\n    return msg;\n  }\n  throw new Error(`Unrecognized message type ${messageType}`);\n}\n\nfunction _chunkToMsg(chunk: BaseMessageChunk): BaseMessage {\n  const chunkType = chunk.getType();\n  let msg: BaseMessage | undefined;\n  const fields = Object.fromEntries(\n    Object.entries(chunk).filter(\n      ([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")\n    )\n  ) as BaseMessageFields;\n\n  if (chunkType in _MSG_CHUNK_MAP) {\n    msg = _switchTypeToMessage(chunkType, fields);\n  }\n\n  if (!msg) {\n    throw new Error(\n      `Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(\n        _MSG_CHUNK_MAP\n      )}`\n    );\n  }\n\n  return msg;\n}\n\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text: string): Promise<string[]> {\n  const splits = text.split(\"\\n\");\n  return Promise.resolve([\n    ...splits.slice(0, -1).map((s) => `${s}\\n`),\n    splits[splits.length - 1],\n  ]);\n}\n","import { ZodStringDef } from \"zod/v3\";\nimport { ErrorMessages, setResponseValueAndErrors } from \"../errorMessages.js\";\nimport { Refs } from \"../Refs.js\";\n\nlet emojiRegex: RegExp | undefined = undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email:\n    /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp(\n        \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\",\n        \"u\"\n      );\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr:\n    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr:\n    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url:\n    /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: \"string\";\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | \"email\"\n    | \"idn-email\"\n    | \"uri\"\n    | \"uuid\"\n    | \"date-time\"\n    | \"ipv4\"\n    | \"ipv6\"\n    | \"date\"\n    | \"time\"\n    | \"duration\";\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n    errorMessage?: ErrorMessages<{ pattern: string }>;\n  }[];\n  anyOf?: {\n    format: string;\n    errorMessage?: ErrorMessages<{ format: string }>;\n  }[];\n  errorMessage?: ErrorMessages<JsonSchema7StringType>;\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(\n  def: ZodStringDef,\n  refs: Refs\n): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: \"string\",\n  };\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          setResponseValueAndErrors(\n            res,\n            \"minLength\",\n            typeof res.minLength === \"number\"\n              ? Math.max(res.minLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          break;\n        case \"max\":\n          setResponseValueAndErrors(\n            res,\n            \"maxLength\",\n            typeof res.maxLength === \"number\"\n              ? Math.min(res.maxLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(\n            res,\n            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),\n            check.message,\n            refs\n          );\n          break;\n        case \"endsWith\":\n          addPattern(\n            res,\n            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),\n            check.message,\n            refs\n          );\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          setResponseValueAndErrors(\n            res,\n            \"minLength\",\n            typeof res.minLength === \"number\"\n              ? Math.max(res.minLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          setResponseValueAndErrors(\n            res,\n            \"maxLength\",\n            typeof res.maxLength === \"number\"\n              ? Math.min(res.maxLength, check.value)\n              : check.value,\n            check.message,\n            refs\n          );\n          break;\n        case \"includes\": {\n          addPattern(\n            res,\n            RegExp(escapeLiteralCheckValue(check.value, refs)),\n            check.message,\n            refs\n          );\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\" as any, check.message, refs);\n              break;\n            }\n\n            case \"contentEncoding:base64\": {\n              setResponseValueAndErrors(\n                res,\n                \"contentEncoding\",\n                \"base64\",\n                check.message,\n                refs\n              );\n              break;\n            }\n\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n          break;\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* c8 ignore next */\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction escapeLiteralCheckValue(literal: string, refs: Refs): string {\n  return refs.patternStrategy === \"escape\"\n    ? escapeNonAlphaNumeric(literal)\n    : literal;\n}\n\nconst ALPHA_NUMERIC = new Set(\n  \"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\"\n);\n\nfunction escapeNonAlphaNumeric(source: string) {\n  let result = \"\";\n\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n\n    result += source[i];\n  }\n\n  return result;\n}\n\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>[\"format\"],\n  message: string | undefined,\n  refs: Refs\n) {\n  if (schema.format || schema.anyOf?.some((x) => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { format: schema.errorMessage.format },\n          }),\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message &&\n        refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"format\", value, message, refs);\n  }\n}\n\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(\n  schema: JsonSchema7StringType,\n  regex: RegExp,\n  message: string | undefined,\n  refs: Refs\n) {\n  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { pattern: schema.errorMessage.pattern },\n          }),\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.allOf!.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message &&\n        refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(\n      schema,\n      \"pattern\",\n      stringifyRegExpWithFlags(regex, refs),\n      message,\n      refs\n    );\n  }\n}\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex: RegExp, refs: Refs): string {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes(\"i\"), // Case-insensitive\n    m: regex.flags.includes(\"m\"), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes(\"s\"), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        \"/\"\n      )} to a flag-independent form! Falling back to the flag-ignorant source`\n    );\n    return regex.source;\n  }\n\n  return pattern;\n}\n","import { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\n\n/**\n * The parameters required to initialize an instance of the Embeddings\n * class.\n */\nexport type EmbeddingsParams = AsyncCallerParams;\n\nexport interface EmbeddingsInterface<TOutput = number[]> {\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  embedQuery(document: string): Promise<TOutput>;\n}\n\n/**\n * An abstract class that provides methods for embedding documents and\n * queries using LangChain.\n */\nexport abstract class Embeddings<TOutput = number[]>\n  implements EmbeddingsInterface<TOutput>\n{\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  constructor(params: EmbeddingsParams) {\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  /**\n   * An abstract method that takes an array of documents as input and\n   * returns a promise that resolves to an array of vectors for each\n   * document.\n   * @param documents An array of documents to be embedded.\n   * @returns A promise that resolves to an array of vectors for each document.\n   */\n  abstract embedDocuments(documents: string[]): Promise<TOutput[]>;\n\n  /**\n   * An abstract method that takes a single document as input and returns a\n   * promise that resolves to a vector for the query document.\n   * @param document A single document to be embedded.\n   * @returns A promise that resolves to a vector for the query document.\n   */\n  abstract embedQuery(document: string): Promise<TOutput>;\n}\n","import { Document } from \"../documents/document.js\";\nimport {\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n} from \"./ir.js\";\nimport { BaseTranslator } from \"./base.js\";\nimport { castValue, isFilterEmpty } from \"./utils.js\";\n\n/**\n * A type alias for an object that maps comparison operators to string or\n * number values. This is used in the comparison functions to determine\n * the result of a comparison operation.\n */\ntype ValueType = {\n  eq: string | number | boolean;\n  ne: string | number | boolean;\n  lt: string | number;\n  lte: string | number;\n  gt: string | number;\n  gte: string | number;\n};\n\n/**\n * A type alias for a function that takes a `Document` as an argument and\n * returns a boolean. This function is used as a filter for documents.\n */\nexport type FunctionFilter = (document: Document) => boolean;\n\n/**\n * A class that extends `BaseTranslator` to translate structured queries\n * into functional filters.\n * @example\n * ```typescript\n * const functionalTranslator = new FunctionalTranslator();\n * const relevantDocuments = await functionalTranslator.getRelevantDocuments(\n *   \"Which movies are rated higher than 8.5?\",\n * );\n * ```\n */\nexport class FunctionalTranslator extends BaseTranslator {\n  declare VisitOperationOutput: FunctionFilter;\n\n  declare VisitComparisonOutput: FunctionFilter;\n\n  declare VisitStructuredQueryOutput:\n    | { filter: FunctionFilter }\n    | { [k: string]: never };\n\n  allowedOperators: Operator[] = [Operators.and, Operators.or];\n\n  allowedComparators: Comparator[] = [\n    Comparators.eq,\n    Comparators.ne,\n    Comparators.gt,\n    Comparators.gte,\n    Comparators.lt,\n    Comparators.lte,\n  ];\n\n  formatFunction(): string {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Returns the allowed comparators for a given data type.\n   * @param input The input value to get the allowed comparators for.\n   * @returns An array of allowed comparators for the input data type.\n   */\n  getAllowedComparatorsForType(inputType: string): Comparator[] {\n    switch (inputType) {\n      case \"string\": {\n        return [\n          Comparators.eq,\n          Comparators.ne,\n          Comparators.gt,\n          Comparators.gte,\n          Comparators.lt,\n          Comparators.lte,\n        ];\n      }\n      case \"number\": {\n        return [\n          Comparators.eq,\n          Comparators.ne,\n          Comparators.gt,\n          Comparators.gte,\n          Comparators.lt,\n          Comparators.lte,\n        ];\n      }\n      case \"boolean\": {\n        return [Comparators.eq, Comparators.ne];\n      }\n      default: {\n        throw new Error(`Unsupported data type: ${inputType}`);\n      }\n    }\n  }\n\n  /**\n   * Returns a function that performs a comparison based on the provided\n   * comparator.\n   * @param comparator The comparator to base the comparison function on.\n   * @returns A function that takes two arguments and returns a boolean based on the comparison.\n   */\n  getComparatorFunction<C extends Comparator>(\n    comparator: Comparator\n  ): (a: string | number, b: ValueType[C]) => boolean {\n    switch (comparator) {\n      case Comparators.eq: {\n        return (a: string | number, b: ValueType[C]) => a === b;\n      }\n      case Comparators.ne: {\n        return (a: string | number, b: ValueType[C]) => a !== b;\n      }\n      case Comparators.gt: {\n        return (a: string | number, b: ValueType[C]) => a > b;\n      }\n      case Comparators.gte: {\n        return (a: string | number, b: ValueType[C]) => a >= b;\n      }\n      case Comparators.lt: {\n        return (a: string | number, b: ValueType[C]) => a < b;\n      }\n      case Comparators.lte: {\n        return (a: string | number, b: ValueType[C]) => a <= b;\n      }\n      default: {\n        throw new Error(\"Unknown comparator\");\n      }\n    }\n  }\n\n  /**\n   * Returns a function that performs an operation based on the provided\n   * operator.\n   * @param operator The operator to base the operation function on.\n   * @returns A function that takes two boolean arguments and returns a boolean based on the operation.\n   */\n  getOperatorFunction(operator: Operator): (a: boolean, b: boolean) => boolean {\n    switch (operator) {\n      case Operators.and: {\n        return (a, b) => a && b;\n      }\n      case Operators.or: {\n        return (a, b) => a || b;\n      }\n      default: {\n        throw new Error(\"Unknown operator\");\n      }\n    }\n  }\n\n  /**\n   * Visits the operation part of a structured query and translates it into\n   * a functional filter.\n   * @param operation The operation part of a structured query.\n   * @returns A function that takes a `Document` as an argument and returns a boolean based on the operation.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const { operator, args } = operation;\n    if (this.allowedOperators.includes(operator)) {\n      const operatorFunction = this.getOperatorFunction(operator);\n      return (document: Document) => {\n        if (!args) {\n          return true;\n        }\n\n        return args.reduce((acc, arg) => {\n          const result = arg.accept(this);\n          if (typeof result === \"function\") {\n            return operatorFunction(acc, result(document));\n          } else {\n            throw new Error(\"Filter is not a function\");\n          }\n        }, true);\n      };\n    } else {\n      throw new Error(\"Operator not allowed\");\n    }\n  }\n\n  /**\n   * Visits the comparison part of a structured query and translates it into\n   * a functional filter.\n   * @param comparison The comparison part of a structured query.\n   * @returns A function that takes a `Document` as an argument and returns a boolean based on the comparison.\n   */\n  visitComparison(\n    comparison: Comparison<string | number | boolean>\n  ): this[\"VisitComparisonOutput\"] {\n    const { comparator, attribute, value } = comparison;\n    const undefinedTrue = [Comparators.ne];\n    if (this.allowedComparators.includes(comparator)) {\n      if (\n        !this.getAllowedComparatorsForType(typeof value).includes(comparator)\n      ) {\n        throw new Error(\n          `'${comparator}' comparator not allowed to be used with ${typeof value}`\n        );\n      }\n      const comparatorFunction = this.getComparatorFunction(comparator);\n      return (document: Document) => {\n        const documentValue = document.metadata[attribute];\n        if (documentValue === undefined) {\n          if (undefinedTrue.includes(comparator)) {\n            return true;\n          }\n          return false;\n        }\n        return comparatorFunction(documentValue, castValue(value));\n      };\n    } else {\n      throw new Error(\"Comparator not allowed\");\n    }\n  }\n\n  /**\n   * Visits a structured query and translates it into a functional filter.\n   * @param query The structured query to translate.\n   * @returns An object containing a `filter` property, which is a function that takes a `Document` as an argument and returns a boolean based on the structured query.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    if (!query.filter) {\n      return {};\n    }\n    const filterFunction = query.filter?.accept(this);\n    if (typeof filterFunction !== \"function\") {\n      throw new Error(\"Structured query filter is not a function\");\n    }\n    return { filter: filterFunction as FunctionFilter };\n  }\n\n  /**\n   * Merges two filters into one, based on the specified merge type.\n   * @param defaultFilter The default filter function.\n   * @param generatedFilter The generated filter function.\n   * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'. Default is 'and'.\n   * @returns A function that takes a `Document` as an argument and returns a boolean based on the merged filters, or `undefined` if both filters are empty.\n   */\n  mergeFilters(\n    defaultFilter: FunctionFilter,\n    generatedFilter: FunctionFilter,\n    mergeType = \"and\"\n  ): FunctionFilter | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n\n    if (mergeType === \"and\") {\n      return (document: Document) =>\n        defaultFilter(document) && generatedFilter(document);\n    } else if (mergeType === \"or\") {\n      return (document: Document) =>\n        defaultFilter(document) || generatedFilter(document);\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n","/* eslint-disable no-param-reassign */\nimport {\n  mergeConfigs,\n  patchConfig,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  All,\n  BaseCheckpointSaver,\n  Checkpoint,\n  ReadonlyCheckpoint,\n  copyCheckpoint,\n  type PendingWrite,\n  type PendingWriteValue,\n  uuid5,\n  maxChannelVersion,\n  BaseStore,\n  CheckpointPendingWrite,\n  SendProtocol,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  getOnlyChannels,\n} from \"../channels/base.js\";\nimport { PregelNode } from \"./read.js\";\nimport { readChannel, readChannels } from \"./io.js\";\nimport {\n  _isSend,\n  _isSendInterface,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_TASK_ID,\n  CONFIG_KEY_SEND,\n  INTERRUPT,\n  RESERVED,\n  Send,\n  TAG_HIDDEN,\n  TASKS,\n  CHECKPOINT_NAMESPACE_END,\n  PUSH,\n  PULL,\n  RESUME,\n  NULL_TASK_ID,\n  CONFIG_KEY_SCRATCHPAD,\n  RETURN,\n  ERROR,\n  NO_WRITES,\n  CONFIG_KEY_PREVIOUS_STATE,\n  PREVIOUS,\n  CACHE_NS_WRITES,\n  CONFIG_KEY_RESUME_MAP,\n  START,\n} from \"../constants.js\";\nimport {\n  Call,\n  isCall,\n  PregelExecutableTask,\n  PregelScratchpad,\n  PregelTaskDescription,\n  SimpleTaskPath,\n  TaskPath,\n  VariadicTaskPath,\n} from \"./types.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { getNullChannelVersion } from \"./utils/index.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { getRunnableForFunc } from \"./call.js\";\nimport { IterableReadableWritableStream } from \"./stream.js\";\nimport { XXH3 } from \"../hash.js\";\nimport { Topic } from \"../channels/topic.js\";\n\n/**\n * Construct a type with a set of properties K of type T\n */\nexport type StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport type WritesProtocol<C = string> = {\n  name: string;\n  writes: PendingWrite<C>[];\n  triggers: string[];\n  path?: TaskPath;\n};\n\nexport const increment = (current?: number) => {\n  return current !== undefined ? current + 1 : 1;\n};\n\nfunction triggersNextStep(\n  updatedChannels: Set<string>,\n  triggerToNodes: Record<string, string[]> | undefined\n) {\n  if (triggerToNodes == null) return false;\n\n  for (const chan of updatedChannels) {\n    if (triggerToNodes[chan]) return true;\n  }\n\n  return false;\n}\n\n// Avoids unnecessary double iteration\nfunction maxChannelMapVersion(\n  channelVersions: Record<string, number | string>\n): number | string | undefined {\n  let maxVersion: number | string | undefined;\n  for (const chan in channelVersions) {\n    if (!Object.prototype.hasOwnProperty.call(channelVersions, chan)) continue;\n    if (maxVersion == null) {\n      maxVersion = channelVersions[chan];\n    } else {\n      maxVersion = maxChannelVersion(maxVersion, channelVersions[chan]);\n    }\n  }\n  return maxVersion;\n}\n\nexport function shouldInterrupt<N extends PropertyKey, C extends PropertyKey>(\n  checkpoint: Checkpoint,\n  interruptNodes: All | N[],\n  tasks: PregelExecutableTask<N, C>[]\n): boolean {\n  const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n  const seen = checkpoint.versions_seen[INTERRUPT] ?? {};\n\n  let anyChannelUpdated = false;\n\n  if (\n    (checkpoint.channel_versions[START] ?? nullVersion) >\n    (seen[START] ?? nullVersion)\n  ) {\n    anyChannelUpdated = true;\n  } else {\n    for (const chan in checkpoint.channel_versions) {\n      if (\n        !Object.prototype.hasOwnProperty.call(checkpoint.channel_versions, chan)\n      )\n        continue;\n\n      if (checkpoint.channel_versions[chan] > (seen[chan] ?? nullVersion)) {\n        anyChannelUpdated = true;\n        break;\n      }\n    }\n  }\n\n  const anyTriggeredNodeInInterruptNodes = tasks.some((task) =>\n    interruptNodes === \"*\"\n      ? !task.config?.tags?.includes(TAG_HIDDEN)\n      : interruptNodes.includes(task.name)\n  );\n\n  return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;\n}\n\nexport function _localRead<Cc extends Record<string, BaseChannel>>(\n  checkpoint: ReadonlyCheckpoint,\n  channels: Cc,\n  task: WritesProtocol<keyof Cc>,\n  select: Array<keyof Cc> | keyof Cc,\n  fresh: boolean = false\n): Record<string, unknown> | unknown {\n  let updated = new Set<keyof Cc>();\n\n  if (!Array.isArray(select)) {\n    for (const [c] of task.writes) {\n      if (c === select) {\n        updated = new Set([c]);\n        break;\n      }\n    }\n    updated = updated || new Set();\n  } else {\n    updated = new Set(\n      select.filter((c) => task.writes.some(([key, _]) => key === c))\n    );\n  }\n\n  let values: Record<string, unknown>;\n\n  if (fresh && updated.size > 0) {\n    const localChannels = Object.fromEntries(\n      Object.entries(channels).filter(([k, _]) => updated.has(k as keyof Cc))\n    ) as Partial<Cc>;\n\n    const newCheckpoint = createCheckpoint(checkpoint, localChannels as Cc, -1);\n    const newChannels = emptyChannels(localChannels as Cc, newCheckpoint);\n\n    _applyWrites(\n      copyCheckpoint(newCheckpoint),\n      newChannels,\n      [task],\n      undefined,\n      undefined\n    );\n    values = readChannels({ ...channels, ...newChannels }, select);\n  } else {\n    values = readChannels(channels, select);\n  }\n\n  return values;\n}\n\nexport function _localWrite(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  commit: (writes: [string, any][]) => any,\n  processes: Record<string, PregelNode>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  writes: [string, any][]\n) {\n  for (const [chan, value] of writes) {\n    if ([PUSH, TASKS].includes(chan) && value != null) {\n      if (!_isSend(value)) {\n        throw new InvalidUpdateError(\n          `Invalid packet type, expected SendProtocol, got ${JSON.stringify(\n            value\n          )}`\n        );\n      }\n      if (!(value.node in processes)) {\n        throw new InvalidUpdateError(\n          `Invalid node name \"${value.node}\" in Send packet`\n        );\n      }\n    }\n  }\n  commit(writes);\n}\n\nconst IGNORE = new Set<string | number | symbol>([\n  NO_WRITES,\n  PUSH,\n  RESUME,\n  INTERRUPT,\n  RETURN,\n  ERROR,\n]);\n\nexport function _applyWrites<Cc extends Record<string, BaseChannel>>(\n  checkpoint: Checkpoint,\n  channels: Cc,\n  tasks: WritesProtocol<keyof Cc>[],\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getNextVersion: ((version: any) => any) | undefined,\n  triggerToNodes: Record<string, string[]> | undefined\n): Set<string> {\n  // Sort tasks by first 3 path elements for deterministic order\n  // Later path parts (like task IDs) are ignored for sorting\n  tasks.sort((a, b) => {\n    const aPath = a.path?.slice(0, 3) || [];\n    const bPath = b.path?.slice(0, 3) || [];\n\n    // Compare each path element\n    for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {\n      if (aPath[i] < bPath[i]) return -1;\n      if (aPath[i] > bPath[i]) return 1;\n    }\n\n    // If one path is shorter, it comes first\n    return aPath.length - bPath.length;\n  });\n\n  // if no task has triggers this is applying writes from the null task only\n  // so we don't do anything other than update the channels written to\n  const bumpStep = tasks.some((task) => task.triggers.length > 0);\n\n  // Filter out non instances of BaseChannel\n  const onlyChannels = getOnlyChannels(channels);\n\n  // Update seen versions\n  for (const task of tasks) {\n    checkpoint.versions_seen[task.name] ??= {};\n    for (const chan of task.triggers) {\n      if (chan in checkpoint.channel_versions) {\n        checkpoint.versions_seen[task.name][chan] =\n          checkpoint.channel_versions[chan];\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  let maxVersion = maxChannelMapVersion(checkpoint.channel_versions);\n\n  // Consume all channels that were read\n  const channelsToConsume = new Set(\n    tasks\n      .flatMap((task) => task.triggers)\n      .filter((chan) => !RESERVED.includes(chan))\n  );\n\n  let usedNewVersion = false;\n  for (const chan of channelsToConsume) {\n    if (chan in onlyChannels && onlyChannels[chan].consume()) {\n      if (getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n        usedNewVersion = true;\n      }\n    }\n  }\n\n  // Group writes by channel\n  const pendingWritesByChannel = {} as Record<keyof Cc, PendingWriteValue[]>;\n  for (const task of tasks) {\n    for (const [chan, val] of task.writes) {\n      if (IGNORE.has(chan)) {\n        // do nothing\n      } else if (chan in onlyChannels) {\n        pendingWritesByChannel[chan] ??= [];\n        pendingWritesByChannel[chan].push(val);\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  if (maxVersion != null && getNextVersion != null) {\n    maxVersion = usedNewVersion ? getNextVersion(maxVersion) : maxVersion;\n  }\n\n  const updatedChannels: Set<string> = new Set();\n  // Apply writes to channels\n  for (const [chan, vals] of Object.entries(pendingWritesByChannel)) {\n    if (chan in onlyChannels) {\n      const channel = onlyChannels[chan];\n      let updated;\n      try {\n        updated = channel.update(vals);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === InvalidUpdateError.unminifiable_name) {\n          const wrappedError = new InvalidUpdateError(\n            `Invalid update for channel \"${chan}\" with values ${JSON.stringify(\n              vals\n            )}: ${e.message}`\n          );\n          wrappedError.lc_error_code = e.lc_error_code;\n          throw wrappedError;\n        } else {\n          throw e;\n        }\n      }\n      if (updated && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n        // unavailable channels can't trigger tasks, so don't add them\n        if (channel.isAvailable()) updatedChannels.add(chan);\n      }\n    }\n  }\n\n  // Channels that weren't updated in this step are notified of a new step\n  if (bumpStep) {\n    for (const chan in onlyChannels) {\n      if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;\n\n      const channel = onlyChannels[chan];\n      if (channel.isAvailable() && !updatedChannels.has(chan)) {\n        const updated = channel.update([]);\n\n        if (updated && getNextVersion !== undefined) {\n          checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n          // unavailable channels can't trigger tasks, so don't add them\n          if (channel.isAvailable()) updatedChannels.add(chan);\n        }\n      }\n    }\n  }\n\n  // If this is (tentatively) the last superstep, notify all channels of finish\n  if (bumpStep && !triggersNextStep(updatedChannels, triggerToNodes)) {\n    for (const chan in onlyChannels) {\n      if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;\n\n      const channel = onlyChannels[chan];\n      if (channel.finish() && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n        // unavailable channels can't trigger tasks, so don't add them\n        if (channel.isAvailable()) updatedChannels.add(chan);\n      }\n    }\n  }\n\n  return updatedChannels;\n}\n\nfunction* candidateNodes(\n  checkpoint: ReadonlyCheckpoint,\n  processes: StrRecord<string, PregelNode>,\n  extra: NextTaskExtraFields\n) {\n  // This section is an optimization that allows which\n  // nodes will be active during the next step.\n  // When there's information about:\n  // 1. Which channels were updated in the previous step\n  // 2. Which nodes are triggered by which channels\n  // Then we can determine which nodes should be triggered\n  // in the next step without having to cycle through all nodes.\n  if (extra.updatedChannels != null && extra.triggerToNodes != null) {\n    const triggeredNodes = new Set<string>();\n\n    // Get all nodes that have triggers associated with an updated channel\n    for (const channel of extra.updatedChannels) {\n      const nodeIds = extra.triggerToNodes[channel];\n      for (const id of nodeIds ?? []) triggeredNodes.add(id);\n    }\n\n    // Sort the nodes to ensure deterministic order\n    yield* [...triggeredNodes].sort();\n    return;\n  }\n\n  // If there are no values in checkpoint, no need to run\n  // through all the PULL candidates\n  const isEmptyChannelVersions = (() => {\n    for (const chan in checkpoint.channel_versions) {\n      if (checkpoint.channel_versions[chan] !== null) return false;\n    }\n    return true;\n  })();\n\n  if (isEmptyChannelVersions) return;\n  for (const name in processes) {\n    if (!Object.prototype.hasOwnProperty.call(processes, name)) continue;\n    yield name;\n  }\n}\n\nexport type NextTaskExtraFields = {\n  step: number;\n  isResuming?: boolean;\n  checkpointer?: BaseCheckpointSaver;\n  manager?: CallbackManagerForChainRun;\n  store?: BaseStore;\n  stream?: IterableReadableWritableStream;\n  triggerToNodes?: Record<string, string[]>;\n  updatedChannels?: Set<string>;\n};\n\nexport type NextTaskExtraFieldsWithStore = NextTaskExtraFields & {\n  store?: BaseStore;\n};\n\nexport type NextTaskExtraFieldsWithoutStore = NextTaskExtraFields & {\n  store?: never;\n};\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFieldsWithoutStore\n): Record<string, PregelTaskDescription>;\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFieldsWithStore\n): Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>;\n\n/**\n * Prepare the set of tasks that will make up the next Pregel step.\n * This is the union of all PUSH tasks (Sends) and PULL tasks (nodes triggered\n * by edges).\n */\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore | NextTaskExtraFieldsWithoutStore\n):\n  | Record<string, PregelTaskDescription>\n  | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>> {\n  const tasks:\n    | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>\n    | Record<string, PregelTaskDescription> = {};\n\n  // Consume pending tasks\n  const tasksChannel = channels[TASKS] as Topic<SendProtocol> | undefined;\n\n  if (tasksChannel?.isAvailable()) {\n    const len = tasksChannel.get().length;\n    for (let i = 0; i < len; i += 1) {\n      const task = _prepareSingleTask(\n        [PUSH, i],\n        checkpoint,\n        pendingWrites,\n        processes,\n        channels,\n        config,\n        forExecution,\n        extra\n      );\n      if (task !== undefined) {\n        tasks[task.id] = task;\n      }\n    }\n  }\n\n  // Check if any processes should be run in next step\n  // If so, prepare the values to be passed to them\n  for (const name of candidateNodes(checkpoint, processes, extra)) {\n    const task = _prepareSingleTask(\n      [PULL, name],\n      checkpoint,\n      pendingWrites,\n      processes,\n      channels,\n      config,\n      forExecution,\n      extra\n    );\n    if (task !== undefined) {\n      tasks[task.id] = task;\n    }\n  }\n  return tasks;\n}\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: SimpleTaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFields\n): PregelTaskDescription | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFields\n): PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore\n): PregelTaskDescription | PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\n/**\n * Prepares a single task for the next Pregel step, given a task path, which\n * uniquely identifies a PUSH or PULL task within the graph.\n */\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: LangGraphRunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFields\n):\n  | PregelTaskDescription\n  | PregelExecutableTask<keyof Nn, keyof Cc>\n  | undefined {\n  const { step, checkpointer, manager } = extra;\n  const configurable = config.configurable ?? {};\n  const parentNamespace = configurable.checkpoint_ns ?? \"\";\n\n  if (taskPath[0] === PUSH && isCall(taskPath[taskPath.length - 1])) {\n    const call = taskPath[taskPath.length - 1] as Call;\n    const proc = getRunnableForFunc(call.name, call.func);\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? call.name\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${call.name}`;\n    const id = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        call.name,\n        PUSH,\n        taskPath[1],\n        taskPath[2],\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${id}`;\n\n    // we append `true` to the task path to indicate that a call is being made\n    // so we should not return interrupts from this task (responsibility lies with the parent)\n    const outputTaskPath = [...taskPath.slice(0, 3), true] as VariadicTaskPath;\n    const metadata = {\n      langgraph_step: step,\n      langgraph_node: call.name,\n      langgraph_triggers: triggers,\n      langgraph_path: outputTaskPath,\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const writes: [keyof Cc, unknown][] = [];\n      const task = {\n        name: call.name,\n        input: call.input,\n        proc,\n        writes,\n        config: patchConfig(\n          mergeConfigs(config, {\n            metadata,\n            store: extra.store ?? config.store,\n          }),\n          {\n            runName: call.name,\n            callbacks: manager?.getChild(`graph:step:${step}`),\n            configurable: {\n              [CONFIG_KEY_TASK_ID]: id,\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                _localWrite(\n                  (items: PendingWrite<keyof Cc>[]) => writes.push(...items),\n                  processes,\n                  writes_\n                ),\n              [CONFIG_KEY_READ]: (\n                select_: Array<keyof Cc> | keyof Cc,\n                fresh_: boolean = false\n              ) =>\n                _localRead(\n                  checkpoint,\n                  channels,\n                  {\n                    name: call.name,\n                    writes: writes as PendingWrite[],\n                    triggers,\n                    path: outputTaskPath,\n                  },\n                  select_,\n                  fresh_\n                ),\n              [CONFIG_KEY_CHECKPOINTER]:\n                checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n              [CONFIG_KEY_CHECKPOINT_MAP]: {\n                ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                [parentNamespace]: checkpoint.id,\n              },\n              [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                pendingWrites: pendingWrites ?? [],\n                taskId: id,\n                currentTaskInput: call.input,\n                resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                namespaceHash: XXH3(taskCheckpointNamespace),\n              }),\n              [CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[PREVIOUS],\n              checkpoint_id: undefined,\n              checkpoint_ns: taskCheckpointNamespace,\n            },\n          }\n        ),\n        triggers,\n        retry_policy: call.retry,\n        cache_key: call.cache\n          ? {\n              key: XXH3((call.cache.keyFunc ?? JSON.stringify)([call.input])),\n              ns: [CACHE_NS_WRITES, call.name ?? \"__dynamic__\"],\n              ttl: call.cache.ttl,\n            }\n          : undefined,\n        id,\n        path: outputTaskPath,\n        writers: [],\n      } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n      return task;\n    } else {\n      return {\n        id,\n        name: call.name,\n        interrupts: [],\n        path: outputTaskPath,\n      };\n    }\n  } else if (taskPath[0] === PUSH) {\n    const index =\n      typeof taskPath[1] === \"number\"\n        ? taskPath[1]\n        : parseInt(taskPath[1] as string, 10);\n\n    if (!channels[TASKS]?.isAvailable()) {\n      return undefined;\n    }\n\n    const sends = channels[TASKS].get() as SendProtocol[];\n    if (index < 0 || index >= sends.length) {\n      return undefined;\n    }\n\n    const packet =\n      _isSendInterface(sends[index]) && !_isSend(sends[index])\n        ? new Send(sends[index].node, sends[index].args)\n        : sends[index];\n\n    if (!_isSendInterface(packet)) {\n      console.warn(\n        `Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`\n      );\n      return undefined;\n    }\n    if (!(packet.node in processes)) {\n      console.warn(\n        `Ignoring unknown node name ${packet.node} in pending sends.`\n      );\n      return undefined;\n    }\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? packet.node\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;\n    const taskId = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        packet.node,\n        PUSH,\n        index.toString(),\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n    let metadata = {\n      langgraph_step: step,\n      langgraph_node: packet.node,\n      langgraph_triggers: triggers,\n      langgraph_path: taskPath.slice(0, 3),\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const proc = processes[packet.node];\n      const node = proc.getNode();\n      if (node !== undefined) {\n        if (proc.metadata !== undefined) {\n          metadata = { ...metadata, ...proc.metadata };\n        }\n        const writes: [keyof Cc, unknown][] = [];\n        return {\n          name: packet.node,\n          input: packet.args,\n          proc: node,\n          subgraphs: proc.subgraphs,\n          writes,\n          config: patchConfig(\n            mergeConfigs(config, {\n              metadata,\n              tags: proc.tags,\n              store: extra.store ?? config.store,\n            }),\n            {\n              runName: packet.node,\n              callbacks: manager?.getChild(`graph:step:${step}`),\n              configurable: {\n                [CONFIG_KEY_TASK_ID]: taskId,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                  _localWrite(\n                    (items: PendingWrite<keyof Cc>[]) => writes.push(...items),\n                    processes,\n                    writes_\n                  ),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Cc> | keyof Cc,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    checkpoint,\n                    channels,\n                    {\n                      name: packet.node,\n                      writes: writes as PendingWrite[],\n                      triggers,\n                      path: taskPath,\n                    },\n                    select_,\n                    fresh_\n                  ),\n                [CONFIG_KEY_CHECKPOINTER]:\n                  checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                [CONFIG_KEY_CHECKPOINT_MAP]: {\n                  ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                  [parentNamespace]: checkpoint.id,\n                },\n                [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                  pendingWrites: pendingWrites ?? [],\n                  taskId,\n                  currentTaskInput: packet.args,\n                  resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                  namespaceHash: XXH3(taskCheckpointNamespace),\n                }),\n                [CONFIG_KEY_PREVIOUS_STATE]:\n                  checkpoint.channel_values[PREVIOUS],\n                checkpoint_id: undefined,\n                checkpoint_ns: taskCheckpointNamespace,\n              },\n            }\n          ),\n          triggers,\n          retry_policy: proc.retryPolicy,\n          cache_key: proc.cachePolicy\n            ? {\n                key: XXH3(\n                  (proc.cachePolicy.keyFunc ?? JSON.stringify)([packet.args])\n                ),\n                ns: [CACHE_NS_WRITES, proc.name ?? \"__dynamic__\", packet.node],\n                ttl: proc.cachePolicy.ttl,\n              }\n            : undefined,\n          id: taskId,\n          path: taskPath,\n          writers: proc.getWriters(),\n        } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n      }\n    } else {\n      return {\n        id: taskId,\n        name: packet.node,\n        interrupts: [],\n        path: taskPath,\n      } satisfies PregelTaskDescription;\n    }\n  } else if (taskPath[0] === PULL) {\n    const name = taskPath[1].toString();\n    const proc = processes[name];\n    if (proc === undefined) {\n      return undefined;\n    }\n\n    // Check if this task already has successful writes in the pending writes\n    if (pendingWrites?.length) {\n      // Find the task ID for this node/path\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          name,\n        ]),\n        checkpoint.id\n      );\n\n      // Check if there are successful writes (not ERROR) for this task ID\n      const hasSuccessfulWrites = pendingWrites.some(\n        (w) => w[0] === taskId && w[1] !== ERROR\n      );\n\n      // If task completed successfully, don't include it in next tasks\n      if (hasSuccessfulWrites) {\n        return undefined;\n      }\n    }\n\n    const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n    if (nullVersion === undefined) {\n      return undefined;\n    }\n    const seen = checkpoint.versions_seen[name] ?? {};\n\n    // Find the first trigger that is available and has a new version\n    const trigger = proc.triggers.find((chan) => {\n      if (!channels[chan].isAvailable()) return false;\n\n      return (\n        (checkpoint.channel_versions[chan] ?? nullVersion) >\n        (seen[chan] ?? nullVersion)\n      );\n    });\n\n    // If any of the channels read by this process were updated\n    if (trigger !== undefined) {\n      const val = _procInput(proc, channels, forExecution);\n      if (val === undefined) {\n        return undefined;\n      }\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          [trigger],\n        ]),\n        checkpoint.id\n      );\n      const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n      let metadata = {\n        langgraph_step: step,\n        langgraph_node: name,\n        langgraph_triggers: [trigger],\n        langgraph_path: taskPath,\n        langgraph_checkpoint_ns: taskCheckpointNamespace,\n      };\n      if (forExecution) {\n        const node = proc.getNode();\n        if (node !== undefined) {\n          if (proc.metadata !== undefined) {\n            metadata = { ...metadata, ...proc.metadata };\n          }\n          const writes: [keyof Cc, unknown][] = [];\n          return {\n            name,\n            input: val,\n            proc: node,\n            subgraphs: proc.subgraphs,\n            writes,\n            config: patchConfig(\n              mergeConfigs(config, {\n                metadata,\n                tags: proc.tags,\n                store: extra.store ?? config.store,\n              }),\n              {\n                runName: name,\n                callbacks: manager?.getChild(`graph:step:${step}`),\n                configurable: {\n                  [CONFIG_KEY_TASK_ID]: taskId,\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                    _localWrite(\n                      (items: PendingWrite<keyof Cc>[]) => {\n                        writes.push(...items);\n                      },\n                      processes,\n                      writes_\n                    ),\n                  [CONFIG_KEY_READ]: (\n                    select_: Array<keyof Cc> | keyof Cc,\n                    fresh_: boolean = false\n                  ) =>\n                    _localRead(\n                      checkpoint,\n                      channels,\n                      {\n                        name,\n                        writes: writes as PendingWrite[],\n                        triggers: [trigger],\n                        path: taskPath,\n                      },\n                      select_,\n                      fresh_\n                    ),\n                  [CONFIG_KEY_CHECKPOINTER]:\n                    checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                  [CONFIG_KEY_CHECKPOINT_MAP]: {\n                    ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                    [parentNamespace]: checkpoint.id,\n                  },\n                  [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                    pendingWrites: pendingWrites ?? [],\n                    taskId,\n                    currentTaskInput: val,\n                    resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                    namespaceHash: XXH3(taskCheckpointNamespace),\n                  }),\n                  [CONFIG_KEY_PREVIOUS_STATE]:\n                    checkpoint.channel_values[PREVIOUS],\n                  checkpoint_id: undefined,\n                  checkpoint_ns: taskCheckpointNamespace,\n                },\n              }\n            ),\n            triggers: [trigger],\n            retry_policy: proc.retryPolicy,\n            cache_key: proc.cachePolicy\n              ? {\n                  key: XXH3(\n                    (proc.cachePolicy.keyFunc ?? JSON.stringify)([val])\n                  ),\n                  ns: [CACHE_NS_WRITES, proc.name ?? \"__dynamic__\", name],\n                  ttl: proc.cachePolicy.ttl,\n                }\n              : undefined,\n            id: taskId,\n            path: taskPath,\n            writers: proc.getWriters(),\n          } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n        }\n      } else {\n        return {\n          id: taskId,\n          name,\n          interrupts: [],\n          path: taskPath,\n        } satisfies PregelTaskDescription;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n *  Function injected under CONFIG_KEY_READ in task config, to read current state.\n *  Used by conditional edges to read a copy of the state with reflecting the writes\n *  from that node only.\n *\n * @internal\n */\nfunction _procInput(\n  proc: PregelNode,\n  channels: StrRecord<string, BaseChannel>,\n  forExecution: boolean\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let val: any;\n\n  if (typeof proc.channels === \"object\" && !Array.isArray(proc.channels)) {\n    val = {};\n    for (const [k, chan] of Object.entries(proc.channels)) {\n      if (proc.triggers.includes(chan)) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            return undefined;\n          } else {\n            throw e;\n          }\n        }\n      } else if (chan in channels) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            continue;\n          } else {\n            throw e;\n          }\n        }\n      }\n    }\n  } else if (Array.isArray(proc.channels)) {\n    let successfulRead = false;\n    for (const chan of proc.channels) {\n      try {\n        val = readChannel(channels, chan, false);\n        successfulRead = true;\n        break;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (!successfulRead) {\n      return undefined;\n    }\n  } else {\n    throw new Error(\n      `Invalid channels type, expected list or dict, got ${proc.channels}`\n    );\n  }\n\n  // If the process has a mapper, apply it to the value\n  if (forExecution && proc.mapper !== undefined) {\n    val = proc.mapper(val);\n  }\n\n  return val;\n}\n\nfunction _scratchpad({\n  pendingWrites,\n  taskId,\n  currentTaskInput,\n  resumeMap,\n  namespaceHash,\n}: {\n  pendingWrites: CheckpointPendingWrite[];\n  taskId: string;\n  currentTaskInput: unknown;\n  resumeMap: Record<string, unknown> | undefined;\n  namespaceHash: string;\n}): PregelScratchpad {\n  const nullResume = pendingWrites.find(\n    ([writeTaskId, chan]) => writeTaskId === NULL_TASK_ID && chan === RESUME\n  )?.[2];\n\n  const resume = (() => {\n    const result = pendingWrites\n      .filter(\n        ([writeTaskId, chan]) => writeTaskId === taskId && chan === RESUME\n      )\n      .flatMap(([_writeTaskId, _chan, resume]) => resume);\n\n    if (resumeMap != null && namespaceHash in resumeMap) {\n      const mappedResume = resumeMap[namespaceHash];\n      result.push(mappedResume);\n    }\n\n    return result;\n  })();\n\n  const scratchpad = {\n    callCounter: 0,\n    interruptCounter: -1,\n    resume,\n    nullResume,\n    subgraphCounter: 0,\n    currentTaskInput,\n    consumeNullResume: () => {\n      if (scratchpad.nullResume) {\n        delete scratchpad.nullResume;\n        pendingWrites.splice(\n          pendingWrites.findIndex(\n            ([writeTaskId, chan]) =>\n              writeTaskId === NULL_TASK_ID && chan === RESUME\n          ),\n          1\n        );\n        return nullResume;\n      }\n\n      return undefined;\n    },\n  };\n  return scratchpad;\n}\n","import { EmptyChannelError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * Stores the last value received, assumes that if multiple values are received, they are all equal.\n *\n * Note: Unlike 'LastValue' if multiple nodes write to this channel in a single step, the values\n * will be continuously overwritten.\n */\nexport class AnyValue<Value> extends BaseChannel<Value, Value, Value> {\n  lc_graph_name = \"AnyValue\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  constructor() {\n    super();\n  }\n\n  fromCheckpoint(checkpoint?: Value) {\n    const empty = new AnyValue<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = [checkpoint];\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      const updated = this.value.length > 0;\n      this.value = [];\n      return updated;\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return false;\n  }\n\n  get(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  _coerceToRunnable,\n  Runnable,\n  RunnableConfig,\n  RunnableInterface,\n  RunnableIOSchema,\n  type RunnableLike as LangChainRunnableLike,\n} from \"@langchain/core/runnables\";\nimport {\n  Node as DrawableGraphNode,\n  Graph as DrawableGraph,\n} from \"@langchain/core/runnables/graph\";\nimport { All, BaseCheckpointSaver } from \"@langchain/langgraph-checkpoint\";\nimport { z } from \"zod/v4\";\nimport { validate as isUuid } from \"uuid\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n} from \"../pregel/runnable_types.js\";\nimport { PregelNode } from \"../pregel/read.js\";\nimport { Channel, Pregel } from \"../pregel/index.js\";\nimport type { PregelParams } from \"../pregel/types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"../pregel/write.js\";\nimport {\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  END,\n  Send,\n  START,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  RunnableCallable,\n} from \"../utils.js\";\nimport {\n  InvalidUpdateError,\n  NodeInterrupt,\n  UnreachableNodeError,\n} from \"../errors.js\";\nimport { StateDefinition, StateType } from \"./annotation.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\n\nexport interface BranchOptions<\n  IO,\n  N extends string,\n  CallOptions extends LangGraphRunnableConfig = LangGraphRunnableConfig\n> {\n  source: N;\n  path: RunnableLike<IO, BranchPathReturnValue, CallOptions>;\n  pathMap?: Record<string, N | typeof END> | (N | typeof END)[];\n}\n\nexport type BranchPathReturnValue =\n  | string\n  | Send\n  | (string | Send)[]\n  | Promise<string | Send | (string | Send)[]>;\n\ntype NodeAction<S, U, C extends StateDefinition> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  LangGraphRunnableConfig<StateType<C>>\n>;\n\nexport class Branch<\n  IO,\n  N extends string,\n  CallOptions extends LangGraphRunnableConfig = LangGraphRunnableConfig\n> {\n  path: Runnable<IO, BranchPathReturnValue, CallOptions>;\n\n  ends?: Record<string, N | typeof END>;\n\n  constructor(options: Omit<BranchOptions<IO, N, CallOptions>, \"source\">) {\n    if (Runnable.isRunnable(options.path)) {\n      this.path = options.path as Runnable<\n        IO,\n        BranchPathReturnValue,\n        CallOptions\n      >;\n    } else {\n      this.path = _coerceToRunnable(\n        options.path as LangChainRunnableLike<\n          IO,\n          BranchPathReturnValue,\n          CallOptions\n        >\n      ).withConfig({ runName: `Branch` } as CallOptions);\n    }\n    this.ends = Array.isArray(options.pathMap)\n      ? options.pathMap.reduce((acc, n) => {\n          acc[n] = n;\n          return acc;\n        }, {} as Record<string, N | typeof END>)\n      : options.pathMap;\n  }\n\n  run(\n    writer: (\n      dests: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => Runnable | void | Promise<void>,\n    reader?: (config: CallOptions) => IO\n  ) {\n    return ChannelWrite.registerWriter(\n      new RunnableCallable({\n        name: \"<branch_run>\",\n        trace: false,\n        func: async (input: IO, config: CallOptions) => {\n          try {\n            return await this._route(input, config, writer, reader);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } catch (e: any) {\n            // Detect & warn if NodeInterrupt is thrown in a conditional edge\n            if (e.name === NodeInterrupt.unminifiable_name) {\n              console.warn(\n                \"[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\\n\" +\n                  \"NodeInterrupt should only be thrown inside a node, not in edge conditions.\"\n              );\n            }\n            throw e;\n          }\n        },\n      })\n    );\n  }\n\n  async _route(\n    input: IO,\n    config: CallOptions,\n    writer: (\n      dests: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => Runnable | void | Promise<void>,\n    reader?: (config: CallOptions) => IO\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<Runnable | any> {\n    let result = await this.path.invoke(\n      reader ? reader(config) : input,\n      config\n    );\n    if (!Array.isArray(result)) {\n      result = [result];\n    }\n\n    let destinations: (string | Send)[];\n    if (this.ends) {\n      destinations = result.map((r) => (_isSend(r) ? r : this.ends![r]));\n    } else {\n      destinations = result;\n    }\n    if (destinations.some((dest) => !dest)) {\n      throw new Error(\"Branch condition returned unknown or null destination\");\n    }\n    if (destinations.filter(_isSend).some((packet) => packet.node === END)) {\n      throw new InvalidUpdateError(\"Cannot send a packet to the END node\");\n    }\n    const writeResult = await writer(destinations, config);\n    return writeResult ?? input;\n  }\n}\n\nexport type NodeSpec<RunInput, RunOutput> = {\n  runnable: Runnable<RunInput, RunOutput>;\n  metadata?: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subgraphs?: Pregel<any, any>[];\n  ends?: string[];\n  defer?: boolean;\n};\n\nexport type AddNodeOptions<Nodes extends string = string> = {\n  metadata?: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subgraphs?: Pregel<any, any>[];\n  ends?: Nodes[];\n  defer?: boolean;\n};\n\nexport class Graph<\n  N extends string = typeof START | typeof END,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  NodeSpecType extends NodeSpec<RunInput, RunOutput> = NodeSpec<\n    RunInput,\n    RunOutput\n  >,\n  C extends StateDefinition = StateDefinition\n> {\n  nodes: Record<N, NodeSpecType>;\n\n  edges: Set<[N | typeof START, N | typeof END]>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  branches: Record<string, Record<string, Branch<RunInput, N, any>>>;\n\n  entryPoint?: string;\n\n  compiled = false;\n\n  constructor() {\n    this.nodes = {} as Record<N, NodeSpecType>;\n    this.edges = new Set();\n    this.branches = {};\n  }\n\n  protected warnIfCompiled(message: string): void {\n    if (this.compiled) {\n      console.warn(message);\n    }\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return this.edges;\n  }\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    nodes:\n      | Record<K, NodeAction<NodeInput, NodeOutput, C>>\n      | [\n          key: K,\n          action: NodeAction<NodeInput, NodeOutput, C>,\n          options?: AddNodeOptions\n        ][]\n  ): Graph<N | K, RunInput, RunOutput>;\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C>,\n    options?: AddNodeOptions\n  ): Graph<N | K, RunInput, RunOutput>;\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<NodeInput, NodeOutput, C>,\n          options?: AddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, NodeOutput, C>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, NodeOutput, C>,\n                options?: AddNodeOptions\n              ][]\n        ]\n  ): Graph<N | K, RunInput, RunOutput> {\n    function isMutlipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, RunOutput, C>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, RunOutput, C>,\n            options?: AddNodeOptions\n          ][],\n      options?: AddNodeOptions\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMutlipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0])\n        : [[args[0], args[1], args[2]]]\n    ) as [K, NodeAction<NodeInput, RunOutput, C>, AddNodeOptions][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      const runnable = _coerceToRunnable<RunInput, RunOutput>(\n        // Account for arbitrary state due to Send API\n        action as RunnableLike<RunInput, RunOutput>\n      );\n\n      this.nodes[key as unknown as N] = {\n        runnable,\n        metadata: options?.metadata,\n        subgraphs: isPregelLike(runnable) ? [runnable] : options?.subgraphs,\n        ends: options?.ends,\n      } as NodeSpecType;\n    }\n\n    return this as Graph<N | K, RunInput, RunOutput, NodeSpecType>;\n  }\n\n  addEdge(startKey: N | typeof START, endKey: N | typeof END): this {\n    this.warnIfCompiled(\n      `Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n    );\n\n    if (startKey === END) {\n      throw new Error(\"END cannot be a start node\");\n    }\n    if (endKey === START) {\n      throw new Error(\"START cannot be an end node\");\n    }\n    if (\n      Array.from(this.edges).some(([start]) => start === startKey) &&\n      !(\"channels\" in this)\n    ) {\n      throw new Error(\n        `Already found path for ${startKey}. For multiple edges, use StateGraph.`\n      );\n    }\n\n    this.edges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addConditionalEdges(\n    source: BranchOptions<RunInput, N, LangGraphRunnableConfig<StateType<C>>>\n  ): this;\n\n  addConditionalEdges(\n    source: N,\n    path: RunnableLike<\n      RunInput,\n      BranchPathReturnValue,\n      LangGraphRunnableConfig<StateType<C>>\n    >,\n    pathMap?: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    >[\"pathMap\"]\n  ): this;\n\n  addConditionalEdges(\n    source:\n      | N\n      | BranchOptions<RunInput, N, LangGraphRunnableConfig<StateType<C>>>,\n    path?: RunnableLike<\n      RunInput,\n      BranchPathReturnValue,\n      LangGraphRunnableConfig<StateType<C>>\n    >,\n    pathMap?: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    >[\"pathMap\"]\n  ): this {\n    const options: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    > = typeof source === \"object\" ? source : { source, path: path!, pathMap };\n\n    this.warnIfCompiled(\n      \"Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n    if (!Runnable.isRunnable(options.path)) {\n      const pathDisplayValues = Array.isArray(options.pathMap)\n        ? options.pathMap.join(\",\")\n        : Object.keys(options.pathMap ?? {}).join(\",\");\n      options.path = _coerceToRunnable(\n        options.path as LangChainRunnableLike<\n          RunInput,\n          BranchPathReturnValue,\n          LangGraphRunnableConfig<StateType<C>>\n        >\n      ).withConfig({\n        runName: `Branch<${options.source}${\n          pathDisplayValues !== \"\" ? `,${pathDisplayValues}` : \"\"\n        }>`.slice(0, 63),\n      });\n    }\n    // find a name for condition\n    const name =\n      options.path.getName() === \"RunnableLambda\"\n        ? \"condition\"\n        : options.path.getName();\n    // validate condition\n    if (this.branches[options.source] && this.branches[options.source][name]) {\n      throw new Error(\n        `Condition \\`${name}\\` already present for node \\`${source}\\``\n      );\n    }\n    // save it\n    this.branches[options.source] ??= {};\n    this.branches[options.source][name] = new Branch(options);\n    return this;\n  }\n\n  /**\n   * @deprecated use `addEdge(START, key)` instead\n   */\n  setEntryPoint(key: N): this {\n    this.warnIfCompiled(\n      \"Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n\n    return this.addEdge(START, key);\n  }\n\n  /**\n   * @deprecated use `addEdge(key, END)` instead\n   */\n  setFinishPoint(key: N): this {\n    this.warnIfCompiled(\n      \"Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n\n    return this.addEdge(key, END);\n  }\n\n  compile({\n    checkpointer,\n    interruptBefore,\n    interruptAfter,\n    name,\n  }: {\n    checkpointer?: BaseCheckpointSaver | false;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n  } = {}): CompiledGraph<N> {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // create empty compiled graph\n    const compiled = new CompiledGraph({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<RunInput, RunOutput>>,\n      channels: {\n        [START]: new EphemeralValue(),\n        [END]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels: END,\n      streamChannels: [] as N[],\n      streamMode: \"values\",\n      name,\n    });\n\n    // attach nodes, edges and branches\n    for (const [key, node] of Object.entries<NodeSpec<RunInput, RunOutput>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n\n  validate(interrupt?: string[]): void {\n    // assemble sources\n    const allSources = new Set([...this.allEdges].map(([src, _]) => src));\n    for (const [start] of Object.entries(this.branches)) {\n      allSources.add(start);\n    }\n\n    // validate sources\n    for (const source of allSources) {\n      if (source !== START && !(source in this.nodes)) {\n        throw new Error(`Found edge starting at unknown node \\`${source}\\``);\n      }\n    }\n\n    // assemble targets\n    const allTargets = new Set([...this.allEdges].map(([_, target]) => target));\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const branch of Object.values(branches)) {\n        if (branch.ends != null) {\n          for (const end of Object.values(branch.ends)) {\n            allTargets.add(end);\n          }\n        } else {\n          allTargets.add(END);\n          for (const node of Object.keys(this.nodes)) {\n            if (node !== start) {\n              allTargets.add(node);\n            }\n          }\n        }\n      }\n    }\n    for (const node of Object.values<NodeSpecType>(this.nodes)) {\n      for (const target of node.ends ?? []) {\n        allTargets.add(target);\n      }\n    }\n    // validate targets\n    for (const node of Object.keys(this.nodes)) {\n      if (!allTargets.has(node)) {\n        throw new UnreachableNodeError(\n          [\n            `Node \\`${node}\\` is not reachable.`,\n            \"\",\n            \"If you are returning Command objects from your node,\",\n            'make sure you are passing names of potential destination nodes as an \"ends\" array',\n            'into \".addNode(..., { ends: [\"node1\", \"node2\"] })\".',\n          ].join(\"\\n\"),\n          {\n            lc_error_code: \"UNREACHABLE_NODE\",\n          }\n        );\n      }\n    }\n    for (const target of allTargets) {\n      if (target !== END && !(target in this.nodes)) {\n        throw new Error(`Found edge ending at unknown node \\`${target}\\``);\n      }\n    }\n\n    // validate interrupts\n    if (interrupt) {\n      for (const node of interrupt) {\n        if (!(node in this.nodes)) {\n          throw new Error(`Interrupt node \\`${node}\\` is not present`);\n        }\n      }\n    }\n\n    this.compiled = true;\n  }\n}\n\nexport class CompiledGraph<\n  N extends string,\n  State = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Update = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  InputType = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  OutputType = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  NodeReturnType = unknown,\n  CommandType = unknown,\n  StreamCustomType = any // eslint-disable-line @typescript-eslint/no-explicit-any\n> extends Pregel<\n  Record<N | typeof START, PregelNode<State, Update>>,\n  Record<N | typeof START | typeof END | string, BaseChannel>,\n  ContextType & Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  InputType,\n  OutputType,\n  InputType,\n  OutputType,\n  NodeReturnType,\n  CommandType,\n  StreamCustomType\n> {\n  declare \"~NodeType\": N;\n\n  declare \"~NodeReturnType\": NodeReturnType;\n\n  declare \"~RunInput\": Update;\n\n  declare \"~RunOutput\": State;\n\n  builder: Graph<N, State, Update>;\n\n  constructor({\n    builder,\n    ...rest\n  }: { builder: Graph<N, State, Update> } & PregelParams<\n    Record<N | typeof START, PregelNode<State, Update>>,\n    Record<N | typeof START | typeof END | string, BaseChannel>\n  >) {\n    super(rest);\n    this.builder = builder;\n  }\n\n  attachNode(key: N, node: NodeSpec<State, Update>): void {\n    this.channels[key] = new EphemeralValue();\n    this.nodes[key] = new PregelNode({\n      channels: [],\n      triggers: [],\n      metadata: node.metadata,\n      subgraphs: node.subgraphs,\n      ends: node.ends,\n    })\n      .pipe(node.runnable)\n      .pipe(\n        new ChannelWrite([{ channel: key, value: PASSTHROUGH }], [TAG_HIDDEN])\n      );\n    (this.streamChannels as N[]).push(key);\n  }\n\n  attachEdge(start: N | typeof START, end: N | typeof END): void {\n    if (end === END) {\n      if (start === START) {\n        throw new Error(\"Cannot have an edge from START to END\");\n      }\n      this.nodes[start].writers.push(\n        new ChannelWrite([{ channel: END, value: PASSTHROUGH }], [TAG_HIDDEN])\n      );\n    } else {\n      this.nodes[end].triggers.push(start);\n      (this.nodes[end].channels as string[]).push(start);\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    name: string,\n    branch: Branch<State, N>\n  ) {\n    // add hidden start node\n    if (start === START && !this.nodes[START]) {\n      this.nodes[START] = Channel.subscribeTo(START, { tags: [TAG_HIDDEN] });\n    }\n\n    // attach branch writer\n    this.nodes[start].pipe(\n      branch.run((dests) => {\n        const writes = dests.map((dest) => {\n          if (_isSend(dest)) {\n            return dest;\n          }\n          return {\n            channel: dest === END ? END : `branch:${start}:${name}:${dest}`,\n            value: PASSTHROUGH,\n          };\n        });\n        return new ChannelWrite(writes, [TAG_HIDDEN]);\n      })\n    );\n\n    // attach branch readers\n    const ends = branch.ends\n      ? Object.values(branch.ends)\n      : (Object.keys(this.nodes) as N[]);\n    for (const end of ends) {\n      if (end !== END) {\n        const channelName = `branch:${start}:${name}:${end}`;\n        (this.channels as Record<string, BaseChannel>)[channelName] =\n          new EphemeralValue();\n        this.nodes[end].triggers.push(channelName);\n        (this.nodes[end].channels as string[]).push(channelName);\n      }\n    }\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   */\n  override async getGraphAsync(\n    config?: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph> {\n    const xray = config?.xray;\n    const graph = new DrawableGraph();\n    const startNodes: Record<string, DrawableGraphNode> = {\n      [START]: graph.addNode({ schema: z.any() }, START),\n    };\n    const endNodes: Record<string, DrawableGraphNode> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let subgraphs: Record<string, CompiledGraph<any>> = {};\n    if (xray) {\n      subgraphs = Object.fromEntries(\n        (await gatherIterator(this.getSubgraphsAsync())).filter(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (x): x is [string, CompiledGraph<any>] => isCompiledGraph(x[1])\n        )\n      );\n    }\n\n    function addEdge(\n      start: string,\n      end: string,\n      label?: string,\n      conditional = false\n    ) {\n      if (end === END && endNodes[END] === undefined) {\n        endNodes[END] = graph.addNode({ schema: z.any() }, END);\n      }\n      if (startNodes[start] === undefined) {\n        return;\n      }\n      if (endNodes[end] === undefined) {\n        throw new Error(`End node ${end} not found!`);\n      }\n      return graph.addEdge(\n        startNodes[start],\n        endNodes[end],\n        label !== end ? label : undefined,\n        conditional\n      );\n    }\n\n    for (const [key, nodeSpec] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      const displayKey = _escapeMermaidKeywords(key);\n      const node = nodeSpec.runnable;\n      const metadata = nodeSpec.metadata ?? {};\n      if (\n        this.interruptBefore?.includes(key) &&\n        this.interruptAfter?.includes(key)\n      ) {\n        metadata.__interrupt = \"before,after\";\n      } else if (this.interruptBefore?.includes(key)) {\n        metadata.__interrupt = \"before\";\n      } else if (this.interruptAfter?.includes(key)) {\n        metadata.__interrupt = \"after\";\n      }\n      if (xray) {\n        const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n        const drawableSubgraph =\n          subgraphs[key] !== undefined\n            ? await subgraphs[key].getGraphAsync({\n                ...config,\n                xray: newXrayValue,\n              })\n            : node.getGraph(config);\n\n        drawableSubgraph.trimFirstNode();\n        drawableSubgraph.trimLastNode();\n\n        if (Object.keys(drawableSubgraph.nodes).length > 1) {\n          const [e, s] = graph.extend(drawableSubgraph, displayKey);\n          if (e === undefined) {\n            throw new Error(\n              `Could not extend subgraph \"${key}\" due to missing entrypoint.`\n            );\n          }\n\n          // TODO: Remove default name once we stop supporting core 0.2.0\n          // eslint-disable-next-line no-inner-declarations\n          function _isRunnableInterface(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            thing: any\n          ): thing is RunnableInterface {\n            return thing ? thing.lc_runnable : false;\n          }\n          // eslint-disable-next-line no-inner-declarations\n          function _nodeDataStr(\n            id: string | undefined,\n            data: RunnableInterface | RunnableIOSchema\n          ): string {\n            if (id !== undefined && !isUuid(id)) {\n              return id;\n            } else if (_isRunnableInterface(data)) {\n              try {\n                let dataStr = data.getName();\n                dataStr = dataStr.startsWith(\"Runnable\")\n                  ? dataStr.slice(\"Runnable\".length)\n                  : dataStr;\n                return dataStr;\n              } catch (error) {\n                return data.getName();\n              }\n            } else {\n              return data.name ?? \"UnknownSchema\";\n            }\n          }\n          // TODO: Remove casts when we stop supporting core 0.2.0\n          if (s !== undefined) {\n            startNodes[displayKey] = {\n              name: _nodeDataStr(s.id, s.data),\n              ...s,\n            } as DrawableGraphNode;\n          }\n          endNodes[displayKey] = {\n            name: _nodeDataStr(e.id, e.data),\n            ...e,\n          } as DrawableGraphNode;\n        } else {\n          // TODO: Remove when we stop supporting core 0.2.0\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const newNode = graph.addNode(node, displayKey, metadata);\n          startNodes[displayKey] = newNode;\n          endNodes[displayKey] = newNode;\n        }\n      } else {\n        // TODO: Remove when we stop supporting core 0.2.0\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const newNode = graph.addNode(node, displayKey, metadata);\n        startNodes[displayKey] = newNode;\n        endNodes[displayKey] = newNode;\n      }\n    }\n    const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n      if (a < b) {\n        return -1;\n      } else if (b > a) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const [start, end] of sortedEdges) {\n      addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n    }\n    for (const [start, branches] of Object.entries(this.builder.branches)) {\n      const defaultEnds: Record<string, string> = {\n        ...Object.fromEntries(\n          Object.keys(this.builder.nodes)\n            .filter((k) => k !== start)\n            .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])\n        ),\n        [END]: END,\n      };\n      for (const branch of Object.values(branches)) {\n        let ends;\n        if (branch.ends !== undefined) {\n          ends = branch.ends;\n        } else {\n          ends = defaultEnds;\n        }\n        for (const [label, end] of Object.entries(ends)) {\n          addEdge(\n            _escapeMermaidKeywords(start),\n            _escapeMermaidKeywords(end),\n            label,\n            true\n          );\n        }\n      }\n    }\n    for (const [key, node] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      if (node.ends !== undefined) {\n        for (const end of node.ends) {\n          addEdge(\n            _escapeMermaidKeywords(key),\n            _escapeMermaidKeywords(end),\n            undefined,\n            true\n          );\n        }\n      }\n    }\n    return graph;\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   *\n   * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.\n   */\n  override getGraph(\n    config?: RunnableConfig & { xray?: boolean | number }\n  ): DrawableGraph {\n    const xray = config?.xray;\n    const graph = new DrawableGraph();\n    const startNodes: Record<string, DrawableGraphNode> = {\n      [START]: graph.addNode(\n        {\n          schema: z.any(),\n        },\n        START\n      ),\n    };\n    const endNodes: Record<string, DrawableGraphNode> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let subgraphs: Record<string, CompiledGraph<any>> = {};\n    if (xray) {\n      subgraphs = Object.fromEntries(\n        gatherIteratorSync(this.getSubgraphs()).filter(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (x): x is [string, CompiledGraph<any>] => isCompiledGraph(x[1])\n        )\n      );\n    }\n\n    function addEdge(\n      start: string,\n      end: string,\n      label?: string,\n      conditional = false\n    ) {\n      if (end === END && endNodes[END] === undefined) {\n        endNodes[END] = graph.addNode({ schema: z.any() }, END);\n      }\n      return graph.addEdge(\n        startNodes[start],\n        endNodes[end],\n        label !== end ? label : undefined,\n        conditional\n      );\n    }\n\n    for (const [key, nodeSpec] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      const displayKey = _escapeMermaidKeywords(key);\n      const node = nodeSpec.runnable;\n      const metadata = nodeSpec.metadata ?? {};\n      if (\n        this.interruptBefore?.includes(key) &&\n        this.interruptAfter?.includes(key)\n      ) {\n        metadata.__interrupt = \"before,after\";\n      } else if (this.interruptBefore?.includes(key)) {\n        metadata.__interrupt = \"before\";\n      } else if (this.interruptAfter?.includes(key)) {\n        metadata.__interrupt = \"after\";\n      }\n      if (xray) {\n        const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n        const drawableSubgraph =\n          subgraphs[key] !== undefined\n            ? subgraphs[key].getGraph({\n                ...config,\n                xray: newXrayValue,\n              })\n            : node.getGraph(config);\n        drawableSubgraph.trimFirstNode();\n        drawableSubgraph.trimLastNode();\n        if (Object.keys(drawableSubgraph.nodes).length > 1) {\n          const [e, s] = graph.extend(drawableSubgraph, displayKey);\n          if (e === undefined) {\n            throw new Error(\n              `Could not extend subgraph \"${key}\" due to missing entrypoint.`\n            );\n          }\n\n          // TODO: Remove default name once we stop supporting core 0.2.0\n          // eslint-disable-next-line no-inner-declarations\n          function _isRunnableInterface(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            thing: any\n          ): thing is RunnableInterface {\n            return thing ? thing.lc_runnable : false;\n          }\n          // eslint-disable-next-line no-inner-declarations\n          function _nodeDataStr(\n            id: string | undefined,\n            data: RunnableInterface | RunnableIOSchema\n          ): string {\n            if (id !== undefined && !isUuid(id)) {\n              return id;\n            } else if (_isRunnableInterface(data)) {\n              try {\n                let dataStr = data.getName();\n                dataStr = dataStr.startsWith(\"Runnable\")\n                  ? dataStr.slice(\"Runnable\".length)\n                  : dataStr;\n                return dataStr;\n              } catch (error) {\n                return data.getName();\n              }\n            } else {\n              return data.name ?? \"UnknownSchema\";\n            }\n          }\n          // TODO: Remove casts when we stop supporting core 0.2.0\n          if (s !== undefined) {\n            startNodes[displayKey] = {\n              name: _nodeDataStr(s.id, s.data),\n              ...s,\n            } as DrawableGraphNode;\n          }\n          endNodes[displayKey] = {\n            name: _nodeDataStr(e.id, e.data),\n            ...e,\n          } as DrawableGraphNode;\n        } else {\n          // TODO: Remove when we stop supporting core 0.2.0\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const newNode = graph.addNode(node, displayKey, metadata);\n          startNodes[displayKey] = newNode;\n          endNodes[displayKey] = newNode;\n        }\n      } else {\n        // TODO: Remove when we stop supporting core 0.2.0\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const newNode = graph.addNode(node, displayKey, metadata);\n        startNodes[displayKey] = newNode;\n        endNodes[displayKey] = newNode;\n      }\n    }\n    const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n      if (a < b) {\n        return -1;\n      } else if (b > a) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const [start, end] of sortedEdges) {\n      addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n    }\n    for (const [start, branches] of Object.entries(this.builder.branches)) {\n      const defaultEnds: Record<string, string> = {\n        ...Object.fromEntries(\n          Object.keys(this.builder.nodes)\n            .filter((k) => k !== start)\n            .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])\n        ),\n        [END]: END,\n      };\n      for (const branch of Object.values(branches)) {\n        let ends;\n        if (branch.ends !== undefined) {\n          ends = branch.ends;\n        } else {\n          ends = defaultEnds;\n        }\n        for (const [label, end] of Object.entries(ends)) {\n          addEdge(\n            _escapeMermaidKeywords(start),\n            _escapeMermaidKeywords(end),\n            label,\n            true\n          );\n        }\n      }\n    }\n    return graph;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isCompiledGraph(x: unknown): x is CompiledGraph<any> {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (x as CompiledGraph<any>).attachNode === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (x as CompiledGraph<any>).attachEdge === \"function\"\n  );\n}\n\nfunction _escapeMermaidKeywords(key: string) {\n  if (key === \"subgraph\") {\n    return `\"${key}\"`;\n  }\n  return key;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Embeddings } from \"@langchain/core/embeddings\";\n\n/**\n * Error thrown when an invalid namespace is provided.\n */\nexport class InvalidNamespaceError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InvalidNamespaceError\";\n  }\n}\n\n/**\n * Validates the provided namespace.\n * @param namespace The namespace to validate.\n * @throws {InvalidNamespaceError} If the namespace is invalid.\n */\nfunction validateNamespace(namespace: string[]): void {\n  if (namespace.length === 0) {\n    throw new InvalidNamespaceError(\"Namespace cannot be empty.\");\n  }\n  for (const label of namespace) {\n    if (typeof label !== \"string\") {\n      throw new InvalidNamespaceError(\n        `Invalid namespace label '${label}' found in ${namespace}. Namespace labels ` +\n          `must be strings, but got ${typeof label}.`\n      );\n    }\n    if (label.includes(\".\")) {\n      throw new InvalidNamespaceError(\n        `Invalid namespace label '${label}' found in ${namespace}. Namespace labels cannot contain periods ('.').`\n      );\n    }\n    if (label === \"\") {\n      throw new InvalidNamespaceError(\n        `Namespace labels cannot be empty strings. Got ${label} in ${namespace}`\n      );\n    }\n  }\n  if (namespace[0] === \"langgraph\") {\n    throw new InvalidNamespaceError(\n      `Root label for namespace cannot be \"langgraph\". Got: ${namespace}`\n    );\n  }\n}\n\n/**\n * Represents a stored item with metadata.\n */\nexport interface Item {\n  /**\n   * The stored data as an object. Keys are filterable.\n   */\n  value: Record<string, any>;\n  /**\n   * Unique identifier within the namespace.\n   */\n  key: string;\n  /**\n   * Hierarchical path defining the collection in which this document resides.\n   * Represented as an array of strings, allowing for nested categorization.\n   * For example: [\"documents\", \"user123\"]\n   */\n  namespace: string[];\n  /**\n   * Timestamp of item creation.\n   */\n  createdAt: Date;\n  /**\n   * Timestamp of last update.\n   */\n  updatedAt: Date;\n}\n\n/**\n * Represents a search result item with relevance score.\n * Extends the base Item interface with an optional similarity score.\n */\nexport interface SearchItem extends Item {\n  /**\n   * Relevance/similarity score if from a ranked operation.\n   * Higher scores indicate better matches.\n   *\n   * This is typically a cosine similarity score between -1 and 1,\n   * where 1 indicates identical vectors and -1 indicates opposite vectors.\n   */\n  score?: number;\n}\n\n/**\n * Operation to retrieve an item by namespace and ID.\n */\nexport interface GetOperation {\n  /**\n   * Hierarchical path for the item.\n   *\n   * @example\n   * // Get a user profile\n   * namespace: [\"users\", \"profiles\"]\n   */\n  namespace: string[];\n\n  /**\n   * Unique identifier within the namespace.\n   * Together with namespace forms the complete path to the item.\n   *\n   * @example\n   * key: \"user123\"  // For a user profile\n   * key: \"doc456\"   // For a document\n   */\n  key: string;\n}\n\n/**\n * Operation to search for items within a namespace prefix.\n */\nexport interface SearchOperation {\n  /**\n   * Hierarchical path prefix to search within.\n   * Only items under this prefix will be searched.\n   *\n   * @example\n   * // Search all user documents\n   * namespacePrefix: [\"users\", \"documents\"]\n   *\n   * // Search everything\n   * namespacePrefix: []\n   */\n  namespacePrefix: string[];\n\n  /**\n   * Key-value pairs to filter results based on exact matches or comparison operators.\n   *\n   * Supports both exact matches and operator-based comparisons:\n   * - $eq: Equal to (same as direct value comparison)\n   * - $ne: Not equal to\n   * - $gt: Greater than\n   * - $gte: Greater than or equal to\n   * - $lt: Less than\n   * - $lte: Less than or equal to\n   *\n   * @example\n   * // Exact match\n   * filter: { status: \"active\" }\n   *\n   * // With operators\n   * filter: { score: { $gt: 4.99 } }\n   *\n   * // Multiple conditions\n   * filter: {\n   *   score: { $gte: 3.0 },\n   *   color: \"red\"\n   * }\n   */\n  filter?: Record<string, any>;\n\n  /**\n   * Maximum number of items to return.\n   * @default 10\n   */\n  limit?: number;\n\n  /**\n   * Number of items to skip before returning results.\n   * Useful for pagination.\n   * @default 0\n   */\n  offset?: number;\n\n  /**\n   * Natural language search query for semantic search.\n   * When provided, results will be ranked by relevance to this query\n   * using vector similarity search.\n   *\n   * @example\n   * // Find technical documentation about APIs\n   * query: \"technical documentation about REST APIs\"\n   *\n   * // Find recent ML papers\n   * query: \"machine learning papers from 2023\"\n   */\n  query?: string;\n}\n\n/**\n * Operation to store, update, or delete an item.\n */\nexport interface PutOperation {\n  /**\n   * Hierarchical path for the item.\n   * Acts as a folder-like structure to organize items.\n   * Each element represents one level in the hierarchy.\n   *\n   * @example\n   * // Root level documents\n   * namespace: [\"documents\"]\n   *\n   * // User-specific documents\n   * namespace: [\"documents\", \"user123\"]\n   *\n   * // Nested cache structure\n   * namespace: [\"cache\", \"docs\", \"v1\"]\n   */\n  namespace: string[];\n\n  /**\n   * Unique identifier for the document within its namespace.\n   * Together with namespace forms the complete path to the item.\n   *\n   * Example: If namespace is [\"documents\", \"user123\"] and key is \"report1\",\n   * the full path would effectively be \"documents/user123/report1\"\n   */\n  key: string;\n\n  /**\n   * Data to be stored, or null to delete the item.\n   * Must be a JSON-serializable object with string keys.\n   * Setting to null signals that the item should be deleted.\n   *\n   * @example\n   * {\n   *   field1: \"string value\",\n   *   field2: 123,\n   *   nested: { can: \"contain\", any: \"serializable data\" }\n   * }\n   */\n  value: Record<string, any> | null;\n\n  /**\n   * Controls how the item's fields are indexed for search operations.\n   *\n   * - undefined: Uses store's default indexing configuration\n   * - false: Disables indexing for this item\n   * - string[]: List of field paths to index\n   *\n   * Path syntax supports:\n   * - Nested fields: \"metadata.title\"\n   * - Array access: \"chapters[*].content\" (each indexed separately)\n   * - Specific indices: \"authors[0].name\"\n   *\n   * @example\n   * // Index specific fields\n   * index: [\"metadata.title\", \"chapters[*].content\"]\n   *\n   * // Disable indexing\n   * index: false\n   */\n  index?: false | string[];\n}\n\n/**\n * Operation to list and filter namespaces in the store.\n */\nexport interface ListNamespacesOperation {\n  matchConditions?: MatchCondition[];\n  maxDepth?: number;\n  limit: number;\n  offset: number;\n}\n\nexport type NameSpacePath = (string | \"*\")[];\n\nexport type NamespaceMatchType = \"prefix\" | \"suffix\";\n\nexport interface MatchCondition {\n  matchType: NamespaceMatchType;\n  path: NameSpacePath;\n}\n\nexport type Operation =\n  | GetOperation\n  | SearchOperation\n  | PutOperation\n  | ListNamespacesOperation;\n\nexport type OperationResults<Tuple extends readonly Operation[]> = {\n  [K in keyof Tuple]: Tuple[K] extends PutOperation\n    ? void\n    : Tuple[K] extends SearchOperation\n    ? SearchItem[]\n    : Tuple[K] extends GetOperation\n    ? Item | null\n    : Tuple[K] extends ListNamespacesOperation\n    ? string[][]\n    : never;\n};\n\n/**\n * Configuration for indexing documents for semantic search in the store.\n *\n * This configures how documents are embedded and indexed for vector similarity search.\n */\nexport interface IndexConfig {\n  /**\n   * Number of dimensions in the embedding vectors.\n   *\n   * Common embedding model dimensions:\n   * - OpenAI text-embedding-3-large: 256, 1024, or 3072\n   * - OpenAI text-embedding-3-small: 512 or 1536\n   * - OpenAI text-embedding-ada-002: 1536\n   * - Cohere embed-english-v3.0: 1024\n   * - Cohere embed-english-light-v3.0: 384\n   * - Cohere embed-multilingual-v3.0: 1024\n   * - Cohere embed-multilingual-light-v3.0: 384\n   */\n  dims: number;\n\n  /**\n   * The embeddings model to use for generating vectors.\n   * This should be a LangChain Embeddings implementation.\n   */\n  embeddings: Embeddings;\n\n  /**\n   * Fields to extract text from for embedding generation.\n   *\n   * Path syntax supports:\n   * - Simple field access: \"field\"\n   * - Nested fields: \"metadata.title\"\n   * - Array indexing:\n   *   - All elements: \"chapters[*].content\"\n   *   - Specific index: \"authors[0].name\"\n   *   - Last element: \"array[-1]\"\n   *\n   * @default [\"$\"] Embeds the entire document as one vector\n   */\n  fields?: string[];\n}\n\n/**\n * Utility function to get text at a specific JSON path\n */\nexport function getTextAtPath(obj: any, path: string): string[] {\n  const parts = path.split(\".\");\n  let current: any = obj;\n\n  for (const part of parts) {\n    if (part.includes(\"[\")) {\n      const [arrayName, indexStr] = part.split(\"[\");\n      const index = indexStr.replace(\"]\", \"\");\n\n      if (!current[arrayName]) return [];\n\n      if (index === \"*\") {\n        const results: string[] = [];\n        for (const item of current[arrayName]) {\n          if (typeof item === \"string\") results.push(item);\n        }\n        return results;\n      }\n\n      const idx = parseInt(index, 10);\n      if (Number.isNaN(idx)) return [];\n      current = current[arrayName][idx];\n    } else {\n      current = current[part];\n    }\n\n    if (current === undefined) return [];\n  }\n\n  return typeof current === \"string\" ? [current] : [];\n}\n\n/**\n * Tokenizes a JSON path into parts\n */\nexport function tokenizePath(path: string): string[] {\n  return path.split(\".\");\n}\n\n/**\n * Abstract base class for persistent key-value stores.\n *\n * Stores enable persistence and memory that can be shared across threads,\n * scoped to user IDs, assistant IDs, or other arbitrary namespaces.\n *\n * Features:\n * - Hierarchical namespaces for organization\n * - Key-value storage with metadata\n * - Vector similarity search (if configured)\n * - Filtering and pagination\n */\nexport abstract class BaseStore {\n  /**\n   * Execute multiple operations in a single batch.\n   * This is more efficient than executing operations individually.\n   *\n   * @param operations Array of operations to execute\n   * @returns Promise resolving to results matching the operations\n   */\n  abstract batch<Op extends Operation[]>(\n    operations: Op\n  ): Promise<OperationResults<Op>>;\n\n  /**\n   * Retrieve a single item by its namespace and key.\n   *\n   * @param namespace Hierarchical path for the item\n   * @param key Unique identifier within the namespace\n   * @returns Promise resolving to the item or null if not found\n   */\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    return (await this.batch<[GetOperation]>([{ namespace, key }]))[0];\n  }\n\n  /**\n   * Search for items within a namespace prefix.\n   * Supports both metadata filtering and vector similarity search.\n   *\n   * @param namespacePrefix Hierarchical path prefix to search within\n   * @param options Search options for filtering and pagination\n   * @returns Promise resolving to list of matching items with relevance scores\n   *\n   * @example\n   * // Search with filters\n   * await store.search([\"documents\"], {\n   *   filter: { type: \"report\", status: \"active\" },\n   *   limit: 5,\n   *   offset: 10\n   * });\n   *\n   * // Vector similarity search\n   * await store.search([\"users\", \"content\"], {\n   *   query: \"technical documentation about APIs\",\n   *   limit: 20\n   * });\n   */\n  async search(\n    namespacePrefix: string[],\n    options: {\n      filter?: Record<string, any>;\n      limit?: number;\n      offset?: number;\n      query?: string;\n    } = {}\n  ): Promise<SearchItem[]> {\n    const { filter, limit = 10, offset = 0, query } = options;\n    return (\n      await this.batch<[SearchOperation]>([\n        {\n          namespacePrefix,\n          filter,\n          limit,\n          offset,\n          query,\n        },\n      ])\n    )[0];\n  }\n\n  /**\n   * Store or update an item.\n   *\n   * @param namespace Hierarchical path for the item\n   * @param key Unique identifier within the namespace\n   * @param value Object containing the item's data\n   * @param index Optional indexing configuration\n   *\n   * @example\n   * // Simple storage\n   * await store.put([\"docs\"], \"report\", { title: \"Annual Report\" });\n   *\n   * // With specific field indexing\n   * await store.put(\n   *   [\"docs\"],\n   *   \"report\",\n   *   {\n   *     title: \"Q4 Report\",\n   *     chapters: [{ content: \"...\" }, { content: \"...\" }]\n   *   },\n   *   [\"title\", \"chapters[*].content\"]\n   * );\n   */\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, any>,\n    index?: false | string[]\n  ): Promise<void> {\n    validateNamespace(namespace);\n    await this.batch<[PutOperation]>([{ namespace, key, value, index }]);\n  }\n\n  /**\n   * Delete an item from the store.\n   *\n   * @param namespace Hierarchical path for the item\n   * @param key Unique identifier within the namespace\n   */\n  async delete(namespace: string[], key: string): Promise<void> {\n    await this.batch<[PutOperation]>([{ namespace, key, value: null }]);\n  }\n\n  /**\n   * List and filter namespaces in the store.\n   * Used to explore data organization and navigate the namespace hierarchy.\n   *\n   * @param options Options for listing namespaces\n   * @returns Promise resolving to list of namespace paths\n   *\n   * @example\n   * // List all namespaces under \"documents\"\n   * await store.listNamespaces({\n   *   prefix: [\"documents\"],\n   *   maxDepth: 2\n   * });\n   *\n   * // List namespaces ending with \"v1\"\n   * await store.listNamespaces({\n   *   suffix: [\"v1\"],\n   *   limit: 50\n   * });\n   */\n  async listNamespaces(\n    options: {\n      prefix?: string[];\n      suffix?: string[];\n      maxDepth?: number;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<string[][]> {\n    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;\n\n    const matchConditions: MatchCondition[] = [];\n    if (prefix) {\n      matchConditions.push({ matchType: \"prefix\", path: prefix });\n    }\n    if (suffix) {\n      matchConditions.push({ matchType: \"suffix\", path: suffix });\n    }\n\n    return (\n      await this.batch<[ListNamespacesOperation]>([\n        {\n          matchConditions: matchConditions.length ? matchConditions : undefined,\n          maxDepth,\n          limit,\n          offset,\n        },\n      ])\n    )[0];\n  }\n\n  /**\n   * Start the store. Override if initialization is needed.\n   */\n  start(): void | Promise<void> {}\n\n  /**\n   * Stop the store. Override if cleanup is needed.\n   */\n  stop(): void | Promise<void> {}\n}\n","import {\n  BaseCallbackHandler,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"@langchain/core/callbacks/base\";\nimport {\n  AIMessageChunk,\n  BaseMessage,\n  isBaseMessage,\n  isBaseMessageChunk,\n  isToolMessage,\n} from \"@langchain/core/messages\";\nimport { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  LLMResult,\n} from \"@langchain/core/outputs\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\n\nimport { TAG_HIDDEN, TAG_NOSTREAM } from \"../constants.js\";\nimport { StreamChunk } from \"./stream.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Meta = [string[], Record<string, any>];\n\nfunction isChatGenerationChunk(x: unknown): x is ChatGenerationChunk {\n  return isBaseMessage((x as ChatGenerationChunk)?.message);\n}\n\n/**\n * A callback handler that implements stream_mode=messages.\n * Collects messages from (1) chat model stream events and (2) node outputs.\n */\n// TODO: Make this import and explicitly implement the\n// CallbackHandlerPrefersStreaming interface once we drop support for core 0.2\nexport class StreamMessagesHandler extends BaseCallbackHandler {\n  name = \"StreamMessagesHandler\";\n\n  streamFn: (streamChunk: StreamChunk) => void;\n\n  metadatas: Record<string, Meta | undefined> = {};\n\n  seen: Record<string, BaseMessage> = {};\n\n  emittedChatModelRunIds: Record<string, boolean> = {};\n\n  stableMessageIdMap: Record<string, string> = {};\n\n  lc_prefer_streaming = true;\n\n  constructor(streamFn: (streamChunk: StreamChunk) => void) {\n    super();\n    this.streamFn = streamFn;\n  }\n\n  _emit(\n    meta: Meta,\n    message: BaseMessage,\n    runId: string | undefined,\n    dedupe = false\n  ) {\n    if (\n      dedupe &&\n      message.id !== undefined &&\n      this.seen[message.id] !== undefined\n    ) {\n      return;\n    }\n\n    let messageId = message.id;\n\n    if (runId != null) {\n      if (isToolMessage(message)) {\n        // Distinguish tool messages by tool call ID.\n        messageId ??= `run-${runId}-tool-${message.tool_call_id}`;\n      } else {\n        // For instance in ChatAnthropic, the first chunk has an message ID\n        // but the subsequent chunks do not. To avoid clients seeing two messages\n        // we rename the message ID if it's being auto-set to `run-${runId}`\n        // (see https://github.com/langchain-ai/langchainjs/pull/6646).\n        if (messageId == null || messageId === `run-${runId}`) {\n          messageId =\n            this.stableMessageIdMap[runId] ?? messageId ?? `run-${runId}`;\n        }\n\n        this.stableMessageIdMap[runId] ??= messageId;\n      }\n    }\n\n    if (messageId !== message.id) {\n      // eslint-disable-next-line no-param-reassign\n      message.id = messageId;\n\n      // eslint-disable-next-line no-param-reassign\n      message.lc_kwargs.id = messageId;\n    }\n\n    if (message.id != null) this.seen[message.id] = message;\n    this.streamFn([meta[0], \"messages\", [message, meta[1]]]);\n  }\n\n  handleChatModelStart(\n    _llm: Serialized,\n    _messages: BaseMessage[][],\n    runId: string,\n    _parentRunId?: string,\n    _extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ) {\n    if (\n      metadata &&\n      // Include legacy LangGraph SDK tag\n      (!tags || (!tags.includes(TAG_NOSTREAM) && !tags.includes(\"nostream\")))\n    ) {\n      this.metadatas[runId] = [\n        (metadata.langgraph_checkpoint_ns as string).split(\"|\"),\n        { tags, name, ...metadata },\n      ];\n    }\n  }\n\n  handleLLMNewToken(\n    token: string,\n    _idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ) {\n    const chunk = fields?.chunk;\n    this.emittedChatModelRunIds[runId] = true;\n    if (this.metadatas[runId] !== undefined) {\n      if (isChatGenerationChunk(chunk)) {\n        this._emit(this.metadatas[runId], chunk.message, runId);\n      } else {\n        this._emit(\n          this.metadatas[runId],\n          new AIMessageChunk({ content: token }),\n          runId\n        );\n      }\n    }\n  }\n\n  handleLLMEnd(output: LLMResult, runId: string) {\n    // Filter out runs that we do not have metadata for\n    if (this.metadatas[runId] === undefined) return;\n\n    // In JS, non-streaming runs do not call handleLLMNewToken at the model level\n    if (!this.emittedChatModelRunIds[runId]) {\n      const chatGeneration = output.generations?.[0]?.[0] as ChatGeneration;\n      if (isBaseMessage(chatGeneration?.message)) {\n        this._emit(this.metadatas[runId], chatGeneration?.message, runId, true);\n      }\n      delete this.emittedChatModelRunIds[runId];\n    }\n    delete this.metadatas[runId];\n    delete this.stableMessageIdMap[runId];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleLLMError(_err: any, runId: string) {\n    delete this.metadatas[runId];\n  }\n\n  handleChainStart(\n    _chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    _runType?: string,\n    name?: string\n  ) {\n    if (\n      metadata !== undefined &&\n      name === metadata.langgraph_node &&\n      (tags === undefined || !tags.includes(TAG_HIDDEN))\n    ) {\n      this.metadatas[runId] = [\n        (metadata.langgraph_checkpoint_ns as string).split(\"|\"),\n        { tags, name, ...metadata },\n      ];\n\n      if (typeof inputs === \"object\") {\n        for (const value of Object.values(inputs)) {\n          if (\n            (isBaseMessage(value) || isBaseMessageChunk(value)) &&\n            value.id !== undefined\n          ) {\n            this.seen[value.id] = value;\n          } else if (Array.isArray(value)) {\n            for (const item of value) {\n              if (\n                (isBaseMessage(item) || isBaseMessageChunk(item)) &&\n                item.id !== undefined\n              ) {\n                this.seen[item.id] = item;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  handleChainEnd(outputs: ChainValues, runId: string) {\n    const metadata = this.metadatas[runId];\n    delete this.metadatas[runId];\n    if (metadata !== undefined) {\n      if (isBaseMessage(outputs)) {\n        this._emit(metadata, outputs, runId, true);\n      } else if (Array.isArray(outputs)) {\n        for (const value of outputs) {\n          if (isBaseMessage(value)) {\n            this._emit(metadata, value, runId, true);\n          }\n        }\n      } else if (outputs != null && typeof outputs === \"object\") {\n        for (const value of Object.values(outputs)) {\n          if (isBaseMessage(value)) {\n            this._emit(metadata, value, runId, true);\n          } else if (Array.isArray(value)) {\n            for (const item of value) {\n              if (isBaseMessage(item)) {\n                this._emit(metadata, item, runId, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleChainError(_err: any, runId: string) {\n    delete this.metadatas[runId];\n  }\n}\n","import type { CSPair } from \"ansi-styles\";\nimport styles from \"ansi-styles\";\nimport { BaseTracer, type AgentRun, type Run } from \"./base.js\";\n\nfunction wrap(style: CSPair, text: string) {\n  return `${style.open}${text}${style.close}`;\n}\n\nfunction tryJsonStringify(obj: unknown, fallback: string) {\n  try {\n    return JSON.stringify(obj, null, 2);\n  } catch {\n    return fallback;\n  }\n}\n\nfunction formatKVMapItem(value: unknown) {\n  if (typeof value === \"string\") {\n    return value.trim();\n  }\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  return tryJsonStringify(value, value.toString());\n}\n\nfunction elapsed(run: Run): string {\n  if (!run.end_time) return \"\";\n  const elapsed = run.end_time - run.start_time;\n  if (elapsed < 1000) {\n    return `${elapsed}ms`;\n  }\n  return `${(elapsed / 1000).toFixed(2)}s`;\n}\n\nconst { color } = styles;\n\n/**\n * A tracer that logs all events to the console. It extends from the\n * `BaseTracer` class and overrides its methods to provide custom logging\n * functionality.\n * @example\n * ```typescript\n *\n * const llm = new ChatAnthropic({\n *   temperature: 0,\n *   tags: [\"example\", \"callbacks\", \"constructor\"],\n *   callbacks: [new ConsoleCallbackHandler()],\n * });\n *\n * ```\n */\nexport class ConsoleCallbackHandler extends BaseTracer {\n  name = \"console_callback_handler\" as const;\n\n  /**\n   * Method used to persist the run. In this case, it simply returns a\n   * resolved promise as there's no persistence logic.\n   * @param _run The run to persist.\n   * @returns A resolved promise.\n   */\n  protected persistRun(_run: Run) {\n    return Promise.resolve();\n  }\n\n  // utility methods\n\n  /**\n   * Method used to get all the parent runs of a given run.\n   * @param run The run whose parents are to be retrieved.\n   * @returns An array of parent runs.\n   */\n  getParents(run: Run) {\n    const parents: Run[] = [];\n    let currentRun = run;\n    while (currentRun.parent_run_id) {\n      const parent = this.runMap.get(currentRun.parent_run_id);\n      if (parent) {\n        parents.push(parent);\n        currentRun = parent;\n      } else {\n        break;\n      }\n    }\n    return parents;\n  }\n\n  /**\n   * Method used to get a string representation of the run's lineage, which\n   * is used in logging.\n   * @param run The run whose lineage is to be retrieved.\n   * @returns A string representation of the run's lineage.\n   */\n  getBreadcrumbs(run: Run) {\n    const parents = this.getParents(run).reverse();\n    const string = [...parents, run]\n      .map((parent, i, arr) => {\n        const name = `${parent.execution_order}:${parent.run_type}:${parent.name}`;\n        return i === arr.length - 1 ? wrap(styles.bold, name) : name;\n      })\n      .join(\" > \");\n    return wrap(color.grey, string);\n  }\n\n  // logging methods\n\n  /**\n   * Method used to log the start of a chain run.\n   * @param run The chain run that has started.\n   * @returns void\n   */\n  onChainStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[chain/start]\"\n      )} [${crumbs}] Entering Chain run with input: ${tryJsonStringify(\n        run.inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of a chain run.\n   * @param run The chain run that has ended.\n   * @returns void\n   */\n  onChainEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[chain/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Chain run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[outputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a chain run.\n   * @param run The chain run that has errored.\n   * @returns void\n   */\n  onChainError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[chain/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Chain run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the start of an LLM run.\n   * @param run The LLM run that has started.\n   * @returns void\n   */\n  onLLMStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    const inputs =\n      \"prompts\" in run.inputs\n        ? { prompts: (run.inputs.prompts as string[]).map((p) => p.trim()) }\n        : run.inputs;\n    console.log(\n      `${wrap(\n        color.green,\n        \"[llm/start]\"\n      )} [${crumbs}] Entering LLM run with input: ${tryJsonStringify(\n        inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of an LLM run.\n   * @param run The LLM run that has ended.\n   * @returns void\n   */\n  onLLMEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[llm/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting LLM run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[response]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of an LLM run.\n   * @param run The LLM run that has errored.\n   * @returns void\n   */\n  onLLMError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[llm/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] LLM run errored with error: ${tryJsonStringify(run.error, \"[error]\")}`\n    );\n  }\n\n  /**\n   * Method used to log the start of a tool run.\n   * @param run The tool run that has started.\n   * @returns void\n   */\n  onToolStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[tool/start]\"\n      )} [${crumbs}] Entering Tool run with input: \"${formatKVMapItem(\n        run.inputs.input\n      )}\"`\n    );\n  }\n\n  /**\n   * Method used to log the end of a tool run.\n   * @param run The tool run that has ended.\n   * @returns void\n   */\n  onToolEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n\n    console.log(\n      `${wrap(color.cyan, \"[tool/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Tool run with output: \"${formatKVMapItem(\n        run.outputs?.output\n      )}\"`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a tool run.\n   * @param run The tool run that has errored.\n   * @returns void\n   */\n  onToolError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[tool/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Tool run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the start of a retriever run.\n   * @param run The retriever run that has started.\n   * @returns void\n   */\n  onRetrieverStart(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.green,\n        \"[retriever/start]\"\n      )} [${crumbs}] Entering Retriever run with input: ${tryJsonStringify(\n        run.inputs,\n        \"[inputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the end of a retriever run.\n   * @param run The retriever run that has ended.\n   * @returns void\n   */\n  onRetrieverEnd(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.cyan, \"[retriever/end]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Exiting Retriever run with output: ${tryJsonStringify(\n        run.outputs,\n        \"[outputs]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log any errors of a retriever run.\n   * @param run The retriever run that has errored.\n   * @returns void\n   */\n  onRetrieverError(run: Run) {\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(color.red, \"[retriever/error]\")} [${crumbs}] [${elapsed(\n        run\n      )}] Retriever run errored with error: ${tryJsonStringify(\n        run.error,\n        \"[error]\"\n      )}`\n    );\n  }\n\n  /**\n   * Method used to log the action selected by the agent.\n   * @param run The run in which the agent action occurred.\n   * @returns void\n   */\n  onAgentAction(run: Run) {\n    const agentRun = run as AgentRun;\n    const crumbs = this.getBreadcrumbs(run);\n    console.log(\n      `${wrap(\n        color.blue,\n        \"[agent/action]\"\n      )} [${crumbs}] Agent selected action: ${tryJsonStringify(\n        agentRun.actions[agentRun.actions.length - 1],\n        \"[action]\"\n      )}`\n    );\n  }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport type {\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  checkValidTemplate,\n  parseTemplate,\n  renderTemplate,\n  type TemplateFormat,\n} from \"./template.js\";\nimport type { SerializedPromptTemplate } from \"./serde.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport { MessageContent, ContentBlock } from \"../messages/index.js\";\n\n/**\n * Inputs to create a {@link PromptTemplate}\n * @augments BasePromptTemplateInput\n */\nexport interface PromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any,\n  Format extends TemplateFormat = TemplateFormat\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt template\n   */\n  template: MessageContent;\n\n  /**\n   * The format of the prompt template. Options are \"f-string\" and \"mustache\"\n   */\n  templateFormat?: Format;\n\n  /**\n   * Whether or not to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n}\n\ntype NonAlphanumeric =\n  | \" \"\n  | \"\\t\"\n  | \"\\n\"\n  | \"\\r\"\n  | '\"'\n  | \"'\"\n  | \"{\"\n  | \"[\"\n  | \"(\"\n  | \"`\"\n  | \":\"\n  | \";\";\n\n/**\n * Recursive type to extract template parameters from a string.\n * @template T - The input string.\n * @template Result - The resulting array of extracted template parameters.\n */\ntype ExtractTemplateParamsRecursive<\n  T extends string,\n  Result extends string[] = []\n> = T extends `${string}{${infer Param}}${infer Rest}`\n  ? Param extends `${NonAlphanumeric}${string}`\n    ? ExtractTemplateParamsRecursive<Rest, Result> // for non-template variables that look like template variables e.g. see https://github.com/langchain-ai/langchainjs/blob/main/langchain/src/chains/query_constructor/prompt.ts\n    : ExtractTemplateParamsRecursive<Rest, [...Result, Param]>\n  : Result;\n\nexport type ParamsFromFString<T extends string> = {\n  [Key in\n    | ExtractTemplateParamsRecursive<T>[number]\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | (string & Record<never, never>)]: any;\n};\n\nexport type ExtractedFStringParams<\n  T extends string,\n  RunInput extends InputValues = Symbol\n> = RunInput extends Symbol ? ParamsFromFString<T> : RunInput;\n\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends BaseStringPromptTemplate<RunInput, PartialVariableName>\n  implements PromptTemplateInput<RunInput, PartialVariableName>\n{\n  static lc_name() {\n    return \"PromptTemplate\";\n  }\n\n  template: MessageContent;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n\n  constructor(input: PromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (\n      input.templateFormat === \"mustache\" &&\n      input.validateTemplate === undefined\n    ) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n\n    if (this.validateTemplate) {\n      if (this.templateFormat === \"mustache\") {\n        throw new Error(\"Mustache templates cannot be validated.\");\n      }\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.template,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"prompt\" {\n    return \"prompt\";\n  }\n\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    return renderTemplate(\n      this.template as string,\n      this.templateFormat,\n      allValues\n    );\n  }\n\n  /**\n   * Take examples in list format with prefix and suffix to create a prompt.\n   *\n   * Intended to be used a a way to dynamically create a prompt from examples.\n   *\n   * @param examples - List of examples to use in the prompt.\n   * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n   * @param inputVariables - A list of variable names the final prompt template will expect\n   * @param exampleSeparator - The separator to use in between examples\n   * @param prefix - String that should go before any examples. Generally includes examples.\n   *\n   * @returns The final prompt template generated.\n   */\n  static fromExamples(\n    examples: string[],\n    suffix: string,\n    inputVariables: string[],\n    exampleSeparator = \"\\n\\n\",\n    prefix = \"\"\n  ) {\n    const template = [prefix, ...examples, suffix].join(exampleSeparator);\n    return new PromptTemplate({\n      inputVariables,\n      template,\n    });\n  }\n\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"f-string\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string>,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"mustache\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<InputValues>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >\n  ): PromptTemplate<ExtractedFStringParams<T, RunInput> | InputValues> {\n    const { templateFormat = \"f-string\", ...rest } = options ?? {};\n    const names = new Set<string>();\n    parseTemplate(template, templateFormat).forEach((node) => {\n      if (node.type === \"variable\") {\n        names.add(node.name);\n      }\n    });\n\n    return new PromptTemplate({\n      // Rely on extracted types\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      inputVariables: [...names] as any[],\n      templateFormat,\n      template,\n      ...rest,\n    });\n  }\n\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of PromptTemplate with the partially applied values.\n   */\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new PromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  serialize(): SerializedPromptTemplate {\n    if (this.outputParser !== undefined) {\n      throw new Error(\n        \"Cannot serialize a prompt template with an output parser\"\n      );\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      template: this.template,\n      template_format: this.templateFormat,\n    };\n  }\n\n  static async deserialize(\n    data: SerializedPromptTemplate\n  ): Promise<PromptTemplate> {\n    if (!data.template) {\n      throw new Error(\"Prompt template must have a template\");\n    }\n    const res = new PromptTemplate({\n      inputVariables: data.input_variables,\n      template: data.template,\n      templateFormat: data.template_format,\n    });\n    return res;\n  }\n\n  // TODO(from file)\n}\n","import { Runnable } from \"../runnables/base.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { TypedPromptInputValues } from \"./base.js\";\nimport { parseTemplate, renderTemplate, TemplateFormat } from \"./template.js\";\n\nexport class DictPromptTemplate<\n  RunInput extends InputValues = InputValues,\n  RunOutput extends Record<string, unknown> = Record<string, unknown>\n> extends Runnable<TypedPromptInputValues<RunInput>, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"dict\"];\n\n  lc_serializable = true;\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat;\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  static lc_name() {\n    return \"DictPromptTemplate\";\n  }\n\n  constructor(fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }) {\n    const templateFormat = fields.templateFormat ?? \"f-string\";\n    const inputVariables = _getInputVariables(\n      fields.template,\n      templateFormat\n    ) as Array<Extract<keyof RunInput, string>>;\n    super({ inputVariables, ...fields });\n    this.template = fields.template;\n    this.templateFormat = templateFormat;\n    this.inputVariables = inputVariables;\n  }\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<RunOutput> {\n    return _insertInputVariables(\n      this.template,\n      values,\n      this.templateFormat\n    ) as RunOutput;\n  }\n\n  async invoke(\n    values: TypedPromptInputValues<InputValues>\n  ): Promise<RunOutput> {\n    return await this._callWithConfig(this.format.bind(this), values, {\n      runType: \"prompt\",\n    });\n  }\n}\n\nfunction _getInputVariables(\n  template: Record<string, unknown>,\n  templateFormat: TemplateFormat\n): Array<Extract<keyof InputValues, string>> {\n  const inputVariables: Array<Extract<keyof InputValues, string>> = [];\n  for (const v of Object.values(template)) {\n    if (typeof v === \"string\") {\n      parseTemplate(v, templateFormat).forEach((t) => {\n        if (t.type === \"variable\") {\n          inputVariables.push(t.name);\n        }\n      });\n    } else if (Array.isArray(v)) {\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          parseTemplate(x, templateFormat).forEach((t) => {\n            if (t.type === \"variable\") {\n              inputVariables.push(t.name);\n            }\n          });\n        } else if (typeof x === \"object\") {\n          inputVariables.push(..._getInputVariables(x, templateFormat));\n        }\n      }\n    } else if (typeof v === \"object\" && v !== null) {\n      inputVariables.push(\n        ..._getInputVariables(v as Record<string, unknown>, templateFormat)\n      );\n    }\n  }\n  return Array.from(new Set(inputVariables));\n}\n\nfunction _insertInputVariables(\n  template: Record<string, unknown>,\n  inputs: TypedPromptInputValues<InputValues>,\n  templateFormat: TemplateFormat\n): Record<string, unknown> {\n  const formatted: Record<string, unknown> = {};\n  for (const [k, v] of Object.entries(template)) {\n    if (typeof v === \"string\") {\n      formatted[k] = renderTemplate(v, templateFormat, inputs);\n    } else if (Array.isArray(v)) {\n      const formattedV: Array<unknown> = [];\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          formattedV.push(renderTemplate(x, templateFormat, inputs));\n        } else if (typeof x === \"object\") {\n          formattedV.push(_insertInputVariables(x, inputs, templateFormat));\n        }\n      }\n      formatted[k] = formattedV;\n    } else if (typeof v === \"object\" && v !== null) {\n      formatted[k] = _insertInputVariables(\n        v as Record<string, unknown>,\n        inputs,\n        templateFormat\n      );\n    } else {\n      formatted[k] = v;\n    }\n  }\n  return formatted;\n}\n","import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointTuple,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n  All,\n  BaseStore,\n  AsyncBatchedStore,\n  WRITES_IDX_MAP,\n  BaseCache,\n  CacheFullKey,\n  CacheNamespace,\n} from \"@langchain/langgraph-checkpoint\";\n\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n} from \"../channels/base.js\";\nimport type {\n  Call,\n  CallTaskPath,\n  Durability,\n  PregelExecutableTask,\n  PregelScratchpad,\n  StreamMode,\n} from \"./types.js\";\nimport {\n  isCommand,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_RESUMING,\n  CONFIG_KEY_STREAM,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  NULL_TASK_ID,\n  RESUME,\n  TAG_HIDDEN,\n  PUSH,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_CHECKPOINT_NS,\n  CHECKPOINT_NAMESPACE_END,\n  CONFIG_KEY_CHECKPOINT_ID,\n  CONFIG_KEY_RESUME_MAP,\n  START,\n} from \"../constants.js\";\nimport {\n  _applyWrites,\n  _prepareNextTasks,\n  _prepareSingleTask,\n  increment,\n  shouldInterrupt,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  prefixGenerator,\n} from \"../utils.js\";\nimport {\n  mapCommand,\n  mapInput,\n  mapOutputUpdates,\n  mapOutputValues,\n  readChannels,\n} from \"./io.js\";\nimport {\n  EmptyInputError,\n  GraphInterrupt,\n  isGraphInterrupt,\n} from \"../errors.js\";\nimport { getNewChannelVersions, patchConfigurable } from \"./utils/index.js\";\nimport {\n  mapDebugTasks,\n  mapDebugCheckpoint,\n  mapDebugTaskResults,\n  printStepTasks,\n} from \"./debug.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { IterableReadableWritableStream, StreamChunk } from \"./stream.js\";\nimport { isXXH3 } from \"../hash.js\";\n\nconst INPUT_DONE = Symbol.for(\"INPUT_DONE\");\nconst INPUT_RESUMING = Symbol.for(\"INPUT_RESUMING\");\nconst DEFAULT_LOOP_LIMIT = 25;\n\nexport type PregelLoopInitializeParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  channelSpecs: Record<string, BaseChannel>;\n  stream: IterableReadableWritableStream;\n  store?: BaseStore;\n  cache?: BaseCache<PendingWrite<string>[]>;\n  interruptAfter: string[] | All;\n  interruptBefore: string[] | All;\n  durability: Durability;\n  manager?: CallbackManagerForChainRun;\n  debug: boolean;\n  triggerToNodes: Record<string, string[]>;\n};\n\ntype PregelLoopParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  checkpoint: Checkpoint;\n  checkpointMetadata: CheckpointMetadata;\n  checkpointPreviousVersions: Record<string, string | number>;\n  checkpointPendingWrites: CheckpointPendingWrite[];\n  checkpointConfig: RunnableConfig;\n  channels: Record<string, BaseChannel>;\n  step: number;\n  stop: number;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  checkpointNamespace: string[];\n  skipDoneTasks: boolean;\n  isNested: boolean;\n  manager?: CallbackManagerForChainRun;\n  stream: IterableReadableWritableStream;\n  store?: AsyncBatchedStore;\n  cache?: BaseCache<PendingWrite<string>[]>;\n  prevCheckpointConfig: RunnableConfig | undefined;\n  interruptAfter: string[] | All;\n  interruptBefore: string[] | All;\n  durability: Durability;\n  debug: boolean;\n  triggerToNodes: Record<string, string[]>;\n};\n\nfunction createDuplexStream(...streams: IterableReadableWritableStream[]) {\n  return new IterableReadableWritableStream({\n    passthroughFn: (value: StreamChunk) => {\n      for (const stream of streams) {\n        if (stream.modes.has(value[1])) {\n          stream.push(value);\n        }\n      }\n    },\n    modes: new Set(streams.flatMap((s) => Array.from(s.modes))),\n  });\n}\n\nclass AsyncBatchedCache extends BaseCache<PendingWrite<string>[]> {\n  protected cache: BaseCache<PendingWrite<string>[]>;\n\n  private queue: Promise<unknown> = Promise.resolve();\n\n  constructor(cache: BaseCache<unknown>) {\n    super();\n    this.cache = cache as BaseCache<PendingWrite<string>[]>;\n  }\n\n  async get(keys: CacheFullKey[]) {\n    return this.enqueueOperation(\"get\", keys);\n  }\n\n  async set(\n    pairs: {\n      key: CacheFullKey;\n      value: PendingWrite<string>[];\n      ttl?: number;\n    }[]\n  ) {\n    return this.enqueueOperation(\"set\", pairs);\n  }\n\n  async clear(namespaces: CacheNamespace[]) {\n    return this.enqueueOperation(\"clear\", namespaces);\n  }\n\n  async stop() {\n    await this.queue;\n  }\n\n  private enqueueOperation<Type extends \"get\" | \"set\" | \"clear\">(\n    type: Type,\n    ...args: Parameters<(typeof this.cache)[Type]>\n  ) {\n    const newPromise = this.queue.then(() => {\n      // @ts-expect-error Tuple type warning\n      return this.cache[type](...args) as Promise<\n        ReturnType<(typeof this.cache)[Type]>\n      >;\n    });\n\n    this.queue = newPromise.then(\n      () => void 0,\n      () => void 0\n    );\n\n    return newPromise;\n  }\n}\n\nexport class PregelLoop {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected input?: any | Command;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output: any;\n\n  config: LangGraphRunnableConfig;\n\n  protected checkpointer?: BaseCheckpointSaver;\n\n  protected checkpointerGetNextVersion: (current: number | undefined) => number;\n\n  channels: Record<string, BaseChannel>;\n\n  protected checkpoint: Checkpoint;\n\n  protected checkpointIdSaved: string | undefined;\n\n  protected checkpointConfig: RunnableConfig;\n\n  checkpointMetadata: CheckpointMetadata;\n\n  protected checkpointNamespace: string[];\n\n  protected checkpointPendingWrites: CheckpointPendingWrite[] = [];\n\n  protected checkpointPreviousVersions: Record<string, string | number>;\n\n  step: number;\n\n  protected stop: number;\n\n  protected durability: Durability;\n\n  protected outputKeys: string | string[];\n\n  protected streamKeys: string | string[];\n\n  protected nodes: Record<string, PregelNode>;\n\n  protected skipDoneTasks: boolean;\n\n  protected prevCheckpointConfig: RunnableConfig | undefined;\n\n  protected updatedChannels: Set<string> | undefined;\n\n  status:\n    | \"pending\"\n    | \"done\"\n    | \"interrupt_before\"\n    | \"interrupt_after\"\n    | \"out_of_steps\" = \"pending\";\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tasks: Record<string, PregelExecutableTask<any, any>> = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  stream: IterableReadableWritableStream;\n\n  checkpointerPromises: Promise<unknown>[] = [];\n\n  isNested: boolean;\n\n  protected _checkpointerChainedPromise: Promise<unknown> = Promise.resolve();\n\n  store?: AsyncBatchedStore;\n\n  cache?: AsyncBatchedCache;\n\n  manager?: CallbackManagerForChainRun;\n\n  interruptAfter: string[] | All;\n\n  interruptBefore: string[] | All;\n\n  toInterrupt: PregelExecutableTask<string, string>[] = [];\n\n  debug: boolean = false;\n\n  triggerToNodes: Record<string, string[]>;\n\n  get isResuming() {\n    let hasChannelVersions = false;\n    if (START in this.checkpoint.channel_versions) {\n      // For common channels, we can short-circuit the check\n      hasChannelVersions = true;\n    } else {\n      for (const chan in this.checkpoint.channel_versions) {\n        if (\n          Object.prototype.hasOwnProperty.call(\n            this.checkpoint.channel_versions,\n            chan\n          )\n        ) {\n          hasChannelVersions = true;\n          break;\n        }\n      }\n    }\n\n    const configHasResumingFlag =\n      this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined;\n    const configIsResuming =\n      configHasResumingFlag && this.config.configurable?.[CONFIG_KEY_RESUMING];\n\n    const inputIsNullOrUndefined =\n      this.input === null || this.input === undefined;\n    const inputIsCommandResuming =\n      isCommand(this.input) && this.input.resume != null;\n    const inputIsResuming = this.input === INPUT_RESUMING;\n\n    const runIdMatchesPrevious =\n      !this.isNested &&\n      this.config.metadata?.run_id !== undefined &&\n      (this.checkpointMetadata as { run_id?: unknown })?.run_id !== undefined &&\n      this.config.metadata.run_id ===\n        (this.checkpointMetadata as { run_id?: unknown })?.run_id;\n\n    return (\n      hasChannelVersions &&\n      (configIsResuming ||\n        inputIsNullOrUndefined ||\n        inputIsCommandResuming ||\n        inputIsResuming ||\n        runIdMatchesPrevious)\n    );\n  }\n\n  constructor(params: PregelLoopParams) {\n    this.input = params.input;\n    this.checkpointer = params.checkpointer;\n    // TODO: if managed values no longer needs graph we can replace with\n    // managed_specs, channel_specs\n    if (this.checkpointer !== undefined) {\n      this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(\n        this.checkpointer\n      );\n    } else {\n      this.checkpointerGetNextVersion = increment;\n    }\n    this.checkpoint = params.checkpoint;\n    this.checkpointMetadata = params.checkpointMetadata;\n    this.checkpointPreviousVersions = params.checkpointPreviousVersions;\n    this.channels = params.channels;\n    this.checkpointPendingWrites = params.checkpointPendingWrites;\n    this.step = params.step;\n    this.stop = params.stop;\n    this.config = params.config;\n    this.checkpointConfig = params.checkpointConfig;\n    this.isNested = params.isNested;\n    this.manager = params.manager;\n    this.outputKeys = params.outputKeys;\n    this.streamKeys = params.streamKeys;\n    this.nodes = params.nodes;\n    this.skipDoneTasks = params.skipDoneTasks;\n    this.store = params.store;\n    this.cache = params.cache ? new AsyncBatchedCache(params.cache) : undefined;\n    this.stream = params.stream;\n    this.checkpointNamespace = params.checkpointNamespace;\n    this.prevCheckpointConfig = params.prevCheckpointConfig;\n    this.interruptAfter = params.interruptAfter;\n    this.interruptBefore = params.interruptBefore;\n    this.durability = params.durability;\n    this.debug = params.debug;\n    this.triggerToNodes = params.triggerToNodes;\n  }\n\n  static async initialize(params: PregelLoopInitializeParams) {\n    let { config, stream } = params;\n    if (\n      stream !== undefined &&\n      config.configurable?.[CONFIG_KEY_STREAM] !== undefined\n    ) {\n      stream = createDuplexStream(\n        stream,\n        config.configurable[CONFIG_KEY_STREAM]\n      );\n    }\n    const skipDoneTasks = config.configurable\n      ? !(\"checkpoint_id\" in config.configurable)\n      : true;\n\n    const scratchpad = config.configurable?.[CONFIG_KEY_SCRATCHPAD] as\n      | PregelScratchpad\n      | undefined;\n\n    if (config.configurable && scratchpad) {\n      if (scratchpad.subgraphCounter > 0) {\n        config = patchConfigurable(config, {\n          [CONFIG_KEY_CHECKPOINT_NS]: [\n            config.configurable[CONFIG_KEY_CHECKPOINT_NS],\n            scratchpad.subgraphCounter.toString(),\n          ].join(CHECKPOINT_NAMESPACE_SEPARATOR),\n        });\n      }\n\n      scratchpad.subgraphCounter += 1;\n    }\n\n    const isNested = CONFIG_KEY_READ in (config.configurable ?? {});\n    if (\n      !isNested &&\n      config.configurable?.checkpoint_ns !== undefined &&\n      config.configurable?.checkpoint_ns !== \"\"\n    ) {\n      config = patchConfigurable(config, {\n        checkpoint_ns: \"\",\n        checkpoint_id: undefined,\n      });\n    }\n    let checkpointConfig = config;\n    if (\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP]?.[\n        config.configurable?.checkpoint_ns\n      ]\n    ) {\n      checkpointConfig = patchConfigurable(config, {\n        checkpoint_id:\n          config.configurable[CONFIG_KEY_CHECKPOINT_MAP][\n            config.configurable?.checkpoint_ns\n          ],\n      });\n    }\n    const checkpointNamespace =\n      config.configurable?.checkpoint_ns?.split(\n        CHECKPOINT_NAMESPACE_SEPARATOR\n      ) ?? [];\n\n    const saved: CheckpointTuple = (await params.checkpointer?.getTuple(\n      checkpointConfig\n    )) ?? {\n      config,\n      checkpoint: emptyCheckpoint(),\n      metadata: { source: \"input\", step: -2, parents: {} },\n      pendingWrites: [],\n    };\n    checkpointConfig = {\n      ...config,\n      ...saved.config,\n      configurable: {\n        checkpoint_ns: \"\",\n        ...config.configurable,\n        ...saved.config.configurable,\n      },\n    };\n    const prevCheckpointConfig = saved.parentConfig;\n    const checkpoint = copyCheckpoint(saved.checkpoint);\n    const checkpointMetadata = { ...saved.metadata } as CheckpointMetadata;\n    const checkpointPendingWrites = saved.pendingWrites ?? [];\n\n    const channels = emptyChannels(params.channelSpecs, checkpoint);\n\n    const step = (checkpointMetadata.step ?? 0) + 1;\n    const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;\n    const checkpointPreviousVersions = { ...checkpoint.channel_versions };\n\n    const store = params.store\n      ? new AsyncBatchedStore(params.store)\n      : undefined;\n\n    if (store) {\n      // Start the store. This is a batch store, so it will run continuously\n      await store.start();\n    }\n    return new PregelLoop({\n      input: params.input,\n      config,\n      checkpointer: params.checkpointer,\n      checkpoint,\n      checkpointMetadata,\n      checkpointConfig,\n      prevCheckpointConfig,\n      checkpointNamespace,\n      channels,\n      isNested,\n      manager: params.manager,\n      skipDoneTasks,\n      step,\n      stop,\n      checkpointPreviousVersions,\n      checkpointPendingWrites,\n      outputKeys: params.outputKeys ?? [],\n      streamKeys: params.streamKeys ?? [],\n      nodes: params.nodes,\n      stream,\n      store,\n      cache: params.cache,\n      interruptAfter: params.interruptAfter,\n      interruptBefore: params.interruptBefore,\n      durability: params.durability,\n      debug: params.debug,\n      triggerToNodes: params.triggerToNodes,\n    });\n  }\n\n  protected _checkpointerPutAfterPrevious(input: {\n    config: RunnableConfig;\n    checkpoint: Checkpoint;\n    metadata: CheckpointMetadata;\n    newVersions: Record<string, string | number>;\n  }) {\n    this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(\n      () => {\n        return this.checkpointer?.put(\n          input.config,\n          input.checkpoint,\n          input.metadata,\n          input.newVersions\n        );\n      }\n    );\n    this.checkpointerPromises.push(this._checkpointerChainedPromise);\n  }\n\n  /**\n   * Put writes for a task, to be read by the next tick.\n   * @param taskId\n   * @param writes\n   */\n  putWrites(taskId: string, writes: PendingWrite<string>[]) {\n    let writesCopy = writes;\n    if (writesCopy.length === 0) return;\n\n    // deduplicate writes to special channels, last write wins\n    if (writesCopy.every(([key]) => key in WRITES_IDX_MAP)) {\n      writesCopy = Array.from(\n        new Map(writesCopy.map((w) => [w[0], w])).values()\n      );\n    }\n\n    // remove existing writes for this task\n    this.checkpointPendingWrites = this.checkpointPendingWrites.filter(\n      (w) => w[0] !== taskId\n    );\n\n    // save writes\n    for (const [c, v] of writesCopy) {\n      this.checkpointPendingWrites.push([taskId, c, v]);\n    }\n\n    const config = patchConfigurable(this.checkpointConfig, {\n      [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? \"\",\n      [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id,\n    });\n\n    if (this.durability !== \"exit\" && this.checkpointer != null) {\n      this.checkpointerPromises.push(\n        this.checkpointer.putWrites(config, writesCopy, taskId)\n      );\n    }\n\n    if (this.tasks) {\n      this._outputWrites(taskId, writesCopy);\n    }\n\n    if (!writes.length || !this.cache || !this.tasks) {\n      return;\n    }\n\n    // only cache tasks with a cache key\n    const task = this.tasks[taskId];\n    if (task == null || task.cache_key == null) {\n      return;\n    }\n\n    // only cache successful tasks\n    if (writes[0][0] === ERROR || writes[0][0] === INTERRUPT) {\n      return;\n    }\n\n    void this.cache.set([\n      {\n        key: [task.cache_key.ns, task.cache_key.key],\n        value: task.writes,\n        ttl: task.cache_key.ttl,\n      },\n    ]);\n  }\n\n  _outputWrites(taskId: string, writes: [string, unknown][], cached = false) {\n    const task = this.tasks[taskId];\n    if (task !== undefined) {\n      if (\n        task.config !== undefined &&\n        (task.config.tags ?? []).includes(TAG_HIDDEN)\n      ) {\n        return;\n      }\n\n      if (writes.length > 0) {\n        if (writes[0][0] === INTERRUPT) {\n          // in `algo.ts` we append a bool to the task path to indicate\n          // whether or not a call was present. If so, we don't emit the\n          // the interrupt as it'll be emitted by the parent.\n          if (task.path?.[0] === PUSH && task.path?.at(-1) === true) return;\n\n          const interruptWrites = writes\n            .filter((w) => w[0] === INTERRUPT)\n            .flatMap((w) => w[1] as string[]);\n\n          this._emit([\n            [\"updates\", { [INTERRUPT]: interruptWrites }],\n            [\"values\", { [INTERRUPT]: interruptWrites }],\n          ]);\n        } else if (writes[0][0] !== ERROR) {\n          this._emit(\n            gatherIteratorSync(\n              prefixGenerator(\n                mapOutputUpdates(this.outputKeys, [[task, writes]], cached),\n                \"updates\"\n              )\n            )\n          );\n        }\n      }\n      if (!cached) {\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapDebugTaskResults([[task, writes]], this.streamKeys),\n              \"tasks\"\n            )\n          )\n        );\n      }\n    }\n  }\n\n  async _matchCachedWrites() {\n    if (!this.cache) return [];\n\n    const matched: {\n      task: PregelExecutableTask<string, string>;\n      result: unknown;\n    }[] = [];\n\n    const serializeKey = ([ns, key]: CacheFullKey) => {\n      return `ns:${ns.join(\",\")}|key:${key}`;\n    };\n\n    const keys: CacheFullKey[] = [];\n    const keyMap: Record<string, PregelExecutableTask<string, string>> = {};\n\n    for (const task of Object.values(this.tasks)) {\n      if (task.cache_key != null && !task.writes.length) {\n        keys.push([task.cache_key.ns, task.cache_key.key]);\n        keyMap[serializeKey([task.cache_key.ns, task.cache_key.key])] = task;\n      }\n    }\n\n    if (keys.length === 0) return [];\n    const cache = await this.cache.get(keys);\n\n    for (const { key, value } of cache) {\n      const task = keyMap[serializeKey(key)];\n      if (task != null) {\n        // update the task with the cached writes\n        task.writes.push(...value);\n        matched.push({ task, result: value });\n      }\n    }\n\n    return matched;\n  }\n\n  /**\n   * Execute a single iteration of the Pregel loop.\n   * Returns true if more iterations are needed.\n   * @param params\n   */\n  async tick(params: { inputKeys?: string | string[] }): Promise<boolean> {\n    if (this.store && !this.store.isRunning) {\n      await this.store?.start();\n    }\n    const { inputKeys = [] } = params;\n    if (this.status !== \"pending\") {\n      throw new Error(\n        `Cannot tick when status is no longer \"pending\". Current status: \"${this.status}\"`\n      );\n    }\n    if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) {\n      await this._first(inputKeys);\n    } else if (this.toInterrupt.length > 0) {\n      this.status = \"interrupt_before\";\n      throw new GraphInterrupt();\n    } else if (\n      Object.values(this.tasks).every((task) => task.writes.length > 0)\n    ) {\n      // finish superstep\n      const writes = Object.values(this.tasks).flatMap((t) => t.writes);\n      // All tasks have finished\n      this.updatedChannels = _applyWrites(\n        this.checkpoint,\n        this.channels,\n        Object.values(this.tasks),\n        this.checkpointerGetNextVersion,\n        this.triggerToNodes\n      );\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, writes, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n      // clear pending writes\n      this.checkpointPendingWrites = [];\n      await this._putCheckpoint({ source: \"loop\" });\n      // after execution, check if we should interrupt\n      if (\n        shouldInterrupt(\n          this.checkpoint,\n          this.interruptAfter,\n          Object.values(this.tasks)\n        )\n      ) {\n        this.status = \"interrupt_after\";\n        throw new GraphInterrupt();\n      }\n\n      // unset resuming flag\n      if (this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined) {\n        delete this.config.configurable?.[CONFIG_KEY_RESUMING];\n      }\n    } else {\n      return false;\n    }\n    if (this.step > this.stop) {\n      this.status = \"out_of_steps\";\n      return false;\n    }\n\n    const nextTasks = _prepareNextTasks(\n      this.checkpoint,\n      this.checkpointPendingWrites,\n      this.nodes,\n      this.channels,\n      this.config,\n      true,\n      {\n        step: this.step,\n        checkpointer: this.checkpointer,\n        isResuming: this.isResuming,\n        manager: this.manager,\n        store: this.store,\n        stream: this.stream,\n        triggerToNodes: this.triggerToNodes,\n        updatedChannels: this.updatedChannels,\n      }\n    );\n    this.tasks = nextTasks;\n\n    // Produce debug output\n    if (this.checkpointer) {\n      this._emit(\n        await gatherIterator(\n          prefixGenerator(\n            mapDebugCheckpoint(\n              this.checkpointConfig,\n              this.channels,\n              this.streamKeys,\n              this.checkpointMetadata,\n              Object.values(this.tasks),\n              this.checkpointPendingWrites,\n              this.prevCheckpointConfig,\n              this.outputKeys\n            ),\n            \"checkpoints\"\n          )\n        )\n      );\n    }\n\n    if (Object.values(this.tasks).length === 0) {\n      this.status = \"done\";\n      return false;\n    }\n    // if there are pending writes from a previous loop, apply them\n    if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {\n      for (const [tid, k, v] of this.checkpointPendingWrites) {\n        if (k === ERROR || k === INTERRUPT || k === RESUME) {\n          continue;\n        }\n        const task = Object.values(this.tasks).find((t) => t.id === tid);\n        if (task) {\n          task.writes.push([k, v]);\n        }\n      }\n      for (const task of Object.values(this.tasks)) {\n        if (task.writes.length > 0) {\n          this._outputWrites(task.id, task.writes, true);\n        }\n      }\n    }\n    // if all tasks have finished, re-tick\n    if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n      return this.tick({ inputKeys });\n    }\n\n    // Before execution, check if we should interrupt\n    if (\n      shouldInterrupt(\n        this.checkpoint,\n        this.interruptBefore,\n        Object.values(this.tasks)\n      )\n    ) {\n      this.status = \"interrupt_before\";\n      throw new GraphInterrupt();\n    }\n\n    // Produce debug output\n    const debugOutput = await gatherIterator(\n      prefixGenerator(mapDebugTasks(Object.values(this.tasks)), \"tasks\")\n    );\n    this._emit(debugOutput);\n\n    return true;\n  }\n\n  async finishAndHandleError(error?: Error) {\n    // persist current checkpoint and writes\n    if (\n      this.durability === \"exit\" &&\n      // if it's a top graph\n      (!this.isNested ||\n        // or a nested graph with error or interrupt\n        typeof error !== \"undefined\" ||\n        // or a nested graph with checkpointer: true\n        this.checkpointNamespace.every(\n          (part) => !part.includes(CHECKPOINT_NAMESPACE_END)\n        ))\n    ) {\n      this._putCheckpoint(this.checkpointMetadata);\n      this._flushPendingWrites();\n    }\n\n    const suppress = this._suppressInterrupt(error);\n    if (suppress || error === undefined) {\n      this.output = readChannels(this.channels, this.outputKeys);\n    }\n    if (suppress) {\n      // emit one last \"values\" event, with pending writes applied\n      if (\n        this.tasks !== undefined &&\n        this.checkpointPendingWrites.length > 0 &&\n        Object.values(this.tasks).some((task) => task.writes.length > 0)\n      ) {\n        this.updatedChannels = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          Object.values(this.tasks),\n          this.checkpointerGetNextVersion,\n          this.triggerToNodes\n        );\n\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapOutputValues(\n                this.outputKeys,\n                Object.values(this.tasks).flatMap((t) => t.writes),\n                this.channels\n              ),\n              \"values\"\n            )\n          )\n        );\n      }\n\n      // Emit INTERRUPT event\n      if (isGraphInterrupt(error) && !error.interrupts.length) {\n        this._emit([\n          [\"updates\", { [INTERRUPT]: [] }],\n          [\"values\", { [INTERRUPT]: [] }],\n        ]);\n      }\n    }\n    return suppress;\n  }\n\n  async acceptPush(\n    task: PregelExecutableTask<string, string>,\n    writeIdx: number,\n    call?: Call\n  ): Promise<PregelExecutableTask<string, string> | void> {\n    if (\n      this.interruptAfter?.length > 0 &&\n      shouldInterrupt(this.checkpoint, this.interruptAfter, [task])\n    ) {\n      this.toInterrupt.push(task);\n      return;\n    }\n\n    const pushed = _prepareSingleTask(\n      [PUSH, task.path ?? [], writeIdx, task.id, call] as CallTaskPath,\n      this.checkpoint,\n      this.checkpointPendingWrites,\n      this.nodes,\n      this.channels,\n      task.config ?? {},\n      true,\n      {\n        step: this.step,\n        checkpointer: this.checkpointer,\n        manager: this.manager,\n        store: this.store,\n        stream: this.stream,\n      }\n    );\n\n    if (!pushed) return;\n    if (\n      this.interruptBefore?.length > 0 &&\n      shouldInterrupt(this.checkpoint, this.interruptBefore, [pushed])\n    ) {\n      this.toInterrupt.push(pushed);\n      return;\n    }\n\n    this._emit(\n      gatherIteratorSync(prefixGenerator(mapDebugTasks([pushed]), \"tasks\"))\n    );\n\n    if (this.debug) printStepTasks(this.step, [pushed]);\n    this.tasks[pushed.id] = pushed;\n    if (this.skipDoneTasks) this._matchWrites({ [pushed.id]: pushed });\n\n    const tasks = await this._matchCachedWrites();\n    for (const { task } of tasks) {\n      this._outputWrites(task.id, task.writes, true);\n    }\n\n    return pushed;\n  }\n\n  protected _suppressInterrupt(e?: Error): boolean {\n    return isGraphInterrupt(e) && !this.isNested;\n  }\n\n  protected async _first(inputKeys: string | string[]) {\n    /*\n     * Resuming from previous checkpoint requires\n     * - finding a previous checkpoint\n     * - receiving null input (outer graph) or RESUMING flag (subgraph)\n     */\n\n    const { configurable } = this.config;\n\n    // take resume value from parent\n    const scratchpad = configurable?.[\n      CONFIG_KEY_SCRATCHPAD\n    ] as PregelScratchpad;\n\n    if (scratchpad && scratchpad.nullResume !== undefined) {\n      this.putWrites(NULL_TASK_ID, [[RESUME, scratchpad.nullResume]]);\n    }\n\n    // map command to writes\n    if (isCommand(this.input)) {\n      const hasResume = this.input.resume != null;\n\n      if (\n        this.input.resume != null &&\n        typeof this.input.resume === \"object\" &&\n        Object.keys(this.input.resume).every(isXXH3)\n      ) {\n        this.config.configurable ??= {};\n        this.config.configurable[CONFIG_KEY_RESUME_MAP] = this.input.resume;\n      }\n\n      if (hasResume && this.checkpointer == null) {\n        throw new Error(\"Cannot use Command(resume=...) without checkpointer\");\n      }\n\n      const writes: { [key: string]: PendingWrite[] } = {};\n\n      // group writes by task id\n      for (const [tid, key, value] of mapCommand(\n        this.input,\n        this.checkpointPendingWrites\n      )) {\n        writes[tid] ??= [];\n        writes[tid].push([key, value]);\n      }\n      if (Object.keys(writes).length === 0) {\n        throw new EmptyInputError(\"Received empty Command input\");\n      }\n\n      // save writes\n      for (const [tid, ws] of Object.entries(writes)) {\n        this.putWrites(tid, ws);\n      }\n    }\n\n    // apply null writes\n    const nullWrites = (this.checkpointPendingWrites ?? [])\n      .filter((w) => w[0] === NULL_TASK_ID)\n      .map((w) => w.slice(1)) as PendingWrite<string>[];\n    if (nullWrites.length > 0) {\n      _applyWrites(\n        this.checkpoint,\n        this.channels,\n        [\n          {\n            name: INPUT,\n            writes: nullWrites,\n            triggers: [],\n          },\n        ],\n        this.checkpointerGetNextVersion,\n        this.triggerToNodes\n      );\n    }\n    const isCommandUpdateOrGoto =\n      isCommand(this.input) && nullWrites.length > 0;\n    if (this.isResuming || isCommandUpdateOrGoto) {\n      for (const channelName in this.channels) {\n        if (!Object.prototype.hasOwnProperty.call(this.channels, channelName))\n          continue;\n        if (this.checkpoint.channel_versions[channelName] !== undefined) {\n          const version = this.checkpoint.channel_versions[channelName];\n          this.checkpoint.versions_seen[INTERRUPT] = {\n            ...this.checkpoint.versions_seen[INTERRUPT],\n            [channelName]: version,\n          };\n        }\n      }\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, true, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n    }\n    if (this.isResuming) {\n      this.input = INPUT_RESUMING;\n    } else if (isCommandUpdateOrGoto) {\n      // we need to create a new checkpoint for Command(update=...) or Command(goto=...)\n      // in case the result of Command(goto=...) is an interrupt.\n      // If not done, the checkpoint containing the interrupt will be lost.\n      await this._putCheckpoint({ source: \"input\" });\n      this.input = INPUT_DONE;\n    } else {\n      // map inputs to channel updates\n      const inputWrites = await gatherIterator(mapInput(inputKeys, this.input));\n      if (inputWrites.length > 0) {\n        const discardTasks = _prepareNextTasks(\n          this.checkpoint,\n          this.checkpointPendingWrites,\n          this.nodes,\n          this.channels,\n          this.config,\n          true,\n          { step: this.step }\n        );\n        this.updatedChannels = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          (Object.values(discardTasks) as WritesProtocol[]).concat([\n            {\n              name: INPUT,\n              writes: inputWrites as PendingWrite[],\n              triggers: [],\n            },\n          ]),\n          this.checkpointerGetNextVersion,\n          this.triggerToNodes\n        );\n        // save input checkpoint\n        await this._putCheckpoint({ source: \"input\" });\n\n        this.input = INPUT_DONE;\n      } else if (!(CONFIG_KEY_RESUMING in (this.config.configurable ?? {}))) {\n        throw new EmptyInputError(\n          `Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`\n        );\n      } else {\n        // done with input\n        this.input = INPUT_DONE;\n      }\n    }\n    if (!this.isNested) {\n      this.config = patchConfigurable(this.config, {\n        [CONFIG_KEY_RESUMING]: this.isResuming,\n      });\n    }\n  }\n\n  protected _emit(values: [StreamMode, unknown][]) {\n    for (const [mode, payload] of values) {\n      if (this.stream.modes.has(mode)) {\n        this.stream.push([this.checkpointNamespace, mode, payload]);\n      }\n\n      // debug mode is a \"checkpoints\" or \"tasks\" wrapped in an object\n      // TODO: consider deprecating this in 1.x\n      if (\n        (mode === \"checkpoints\" || mode === \"tasks\") &&\n        this.stream.modes.has(\"debug\")\n      ) {\n        const step = mode === \"checkpoints\" ? this.step - 1 : this.step;\n        const timestamp = new Date().toISOString();\n        const type = (() => {\n          if (mode === \"checkpoints\") {\n            return \"checkpoint\";\n          } else if (\n            typeof payload === \"object\" &&\n            payload != null &&\n            \"result\" in payload\n          ) {\n            return \"task_result\";\n          } else {\n            return \"task\";\n          }\n        })();\n\n        this.stream.push([\n          this.checkpointNamespace,\n          \"debug\",\n          { step, type, timestamp, payload },\n        ]);\n      }\n    }\n  }\n\n  protected _putCheckpoint(\n    inputMetadata: Omit<CheckpointMetadata, \"step\" | \"parents\">\n  ) {\n    const exiting = this.checkpointMetadata === inputMetadata;\n\n    const doCheckpoint =\n      this.checkpointer != null && (this.durability !== \"exit\" || exiting);\n\n    const storeCheckpoint = (checkpoint: Checkpoint) => {\n      // store the previous checkpoint config for debug events\n      this.prevCheckpointConfig = this.checkpointConfig?.configurable\n        ?.checkpoint_id\n        ? this.checkpointConfig\n        : undefined;\n\n      // child graphs keep at most one checkpoint per parent checkpoint\n      // this is achieved by writing child checkpoints as progress is made\n      // (so that error recovery / resuming from interrupt don't lose work)\n      // but doing so always with an id equal to that of the parent checkpoint\n      this.checkpointConfig = patchConfigurable(this.checkpointConfig, {\n        [CONFIG_KEY_CHECKPOINT_NS]:\n          this.config.configurable?.checkpoint_ns ?? \"\",\n      });\n\n      const channelVersions = { ...this.checkpoint.channel_versions };\n      const newVersions = getNewChannelVersions(\n        this.checkpointPreviousVersions,\n        channelVersions\n      );\n      this.checkpointPreviousVersions = channelVersions;\n      // save it, without blocking\n      // if there's a previous checkpoint save in progress, wait for it\n      // ensuring checkpointers receive checkpoints in order\n      void this._checkpointerPutAfterPrevious({\n        config: { ...this.checkpointConfig },\n        checkpoint: copyCheckpoint(checkpoint),\n        metadata: { ...this.checkpointMetadata },\n        newVersions,\n      });\n      this.checkpointConfig = {\n        ...this.checkpointConfig,\n        configurable: {\n          ...this.checkpointConfig.configurable,\n          checkpoint_id: this.checkpoint.id,\n        },\n      };\n    };\n\n    if (!exiting) {\n      this.checkpointMetadata = {\n        ...inputMetadata,\n        step: this.step,\n        parents: this.config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] ?? {},\n      };\n    }\n\n    // create new checkpoint\n    this.checkpoint = createCheckpoint(\n      this.checkpoint,\n      doCheckpoint ? this.channels : undefined,\n      this.step,\n      exiting ? { id: this.checkpoint.id } : undefined\n    );\n\n    // Bail if no checkpointer\n    if (doCheckpoint) storeCheckpoint(this.checkpoint);\n\n    if (!exiting) {\n      // increment step\n      this.step += 1;\n    }\n  }\n\n  protected _flushPendingWrites() {\n    if (this.checkpointer == null) return;\n    if (this.checkpointPendingWrites.length === 0) return;\n\n    // patch config\n    const config = patchConfigurable(this.checkpointConfig, {\n      [CONFIG_KEY_CHECKPOINT_NS]: this.config.configurable?.checkpoint_ns ?? \"\",\n      [CONFIG_KEY_CHECKPOINT_ID]: this.checkpoint.id,\n    });\n\n    // group writes by task id\n    const byTask: Record<string, PendingWrite<string>[]> = {};\n    for (const [tid, key, value] of this.checkpointPendingWrites) {\n      byTask[tid] ??= [];\n      byTask[tid].push([key, value]);\n    }\n\n    // submit writes to checkpointer\n    for (const [tid, ws] of Object.entries(byTask)) {\n      this.checkpointerPromises.push(\n        this.checkpointer.putWrites(config, ws, tid)\n      );\n    }\n  }\n\n  protected _matchWrites(\n    tasks: Record<string, PregelExecutableTask<string, string>>\n  ) {\n    for (const [tid, k, v] of this.checkpointPendingWrites) {\n      if (k === ERROR || k === INTERRUPT || k === RESUME) {\n        continue;\n      }\n      const task = Object.values(tasks).find((t) => t.id === tid);\n      if (task) {\n        task.writes.push([k, v]);\n      }\n    }\n    for (const task of Object.values(tasks)) {\n      if (task.writes.length > 0) {\n        this._outputWrites(task.id, task.writes, true);\n      }\n    }\n  }\n}\n","import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type {\n  BaseLangChainParams,\n  ToolDefinition,\n} from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport {\n  Runnable,\n  RunnableToolLike,\n  type RunnableInterface,\n} from \"../runnables/base.js\";\nimport {\n  type DirectToolOutput,\n  type ToolCall,\n  type ToolMessage,\n} from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodType,\n  isInteropZodSchema,\n  type InteropZodObject,\n} from \"../utils/types/zod.js\";\n\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport type { BaseStore } from \"../stores.js\";\n\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolOutputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ContentAndArtifact = [MessageContent, any];\n\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> =\n  TOutput extends DirectToolOutput\n    ? TOutput\n    : TConfig extends { toolCall: { id: string } }\n    ? ToolMessage\n    : TConfig extends { toolCall: { id: undefined } }\n    ? TOutput\n    : TConfig extends { toolCall: { id?: string } }\n    ? TOutput | ToolMessage\n    : TInput extends ToolCall\n    ? ToolMessage\n    : TOutput;\n\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n  /**\n   * Whether to show full details in the thrown parsing errors.\n   *\n   * @default false\n   */\n  verboseParsingErrors?: boolean;\n  /**\n   * Metadata for the tool.\n   */\n  metadata?: Record<string, unknown>;\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n}\n\nexport type ToolRunnableConfig<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = Record<string, any>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ContextSchema = any\n> = RunnableConfig<ConfigurableFieldType> & {\n  toolCall?: ToolCall;\n  context?: ContextSchema;\n};\n\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams\n  extends Pick<StructuredToolInterface, \"name\" | \"schema\" | \"extras\"> {\n  /**\n   * An optional description of the tool to pass to the model.\n   */\n  description?: string;\n}\n\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType\n  ? InferInteropZodOutput<T>\n  : T extends JSONSchema\n  ? unknown\n  : never;\n\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType\n  ? InferInteropZodInput<T>\n  : T extends JSONSchema\n  ? unknown\n  : never;\n\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>\n> =\n  | (ToolInputSchemaOutputType<SchemaT> extends string ? string : never)\n  | SchemaInputT\n  | ToolCall;\n\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<\n  string | undefined,\n  z3.ZodTypeDef,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  any\n>;\n\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> =\n  StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<\n  SchemaT = ToolInputSchemaBase,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends RunnableInterface<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  > {\n  lc_namespace: string[];\n\n  /**\n   * A Zod schema representing the parameters of the tool.\n   */\n  schema: SchemaT;\n\n  /**\n   * Invokes the tool with the provided argument and configuration.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration for the tool call.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  invoke<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n\n  /**\n   * The name of the tool.\n   */\n  name: string;\n\n  /**\n   * A description of the tool.\n   */\n  description: string;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect: boolean;\n\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n}\n\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<\n  SchemaT = StringInputToolSchema,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    // TODO: shouldn't this be narrowed based on SchemaT?\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n  name: string;\n  description: string;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType>\n  extends BaseDynamicToolInput {\n  func: (\n    input: string,\n    runManager?: CallbackManagerForToolRun,\n    config?: ToolRunnableConfig\n  ) => Promise<ToolOutputT>;\n}\n\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends BaseDynamicToolInput {\n  /**\n   * Tool handler function - the function that will be called when the tool is invoked.\n   *\n   * @param input - The input to the tool.\n   * @param runManager - The run manager for the tool.\n   * @param config - The configuration for the tool.\n   * @returns The result of the tool.\n   */\n  func: (\n    input: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    config?: RunnableConfig\n  ) => Promise<ToolOutputT>;\n  schema: SchemaT;\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport function isStructuredTool(\n  tool?: StructuredToolInterface | ToolDefinition | JSONSchema\n): tool is StructuredToolInterface {\n  return (\n    tool !== undefined &&\n    Array.isArray((tool as StructuredToolInterface).lc_namespace)\n  );\n}\n\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike {\n  return (\n    tool !== undefined &&\n    Runnable.isRunnable(tool) &&\n    \"lc_name\" in tool.constructor &&\n    typeof tool.constructor.lc_name === \"function\" &&\n    tool.constructor.lc_name() === \"RunnableToolLike\"\n  );\n}\n\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport function isStructuredToolParams(\n  tool?: unknown\n): tool is StructuredToolParams {\n  return (\n    !!tool &&\n    typeof tool === \"object\" &&\n    \"name\" in tool &&\n    \"schema\" in tool &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (isInteropZodSchema(tool.schema as Record<string, any>) ||\n      (tool.schema != null &&\n        typeof tool.schema === \"object\" &&\n        \"type\" in tool.schema &&\n        typeof tool.schema.type === \"string\" &&\n        [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\"].includes(\n          tool.schema.type\n        )))\n  );\n}\n\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport function isLangChainTool(tool?: unknown): tool is StructuredToolParams {\n  return (\n    isStructuredToolParams(tool) ||\n    isRunnableToolLike(tool) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isStructuredTool(tool as any)\n  );\n}\n\n/**\n * Runtime context automatically injected into tools.\n *\n * When a tool function has a parameter named `tool_runtime` with type hint\n * `ToolRuntime`, the tool execution system will automatically inject an instance\n * containing:\n *\n * - `state`: The current graph state\n * - `toolCallId`: The ID of the current tool call\n * - `config`: `RunnableConfig` for the current execution\n * - `context`: Runtime context\n * - `store`: `BaseStore` instance for persistent storage\n * - `writer`: Stream writer for streaming output\n *\n * No `Annotated` wrapper is needed - just use `runtime: ToolRuntime`\n * as a parameter.\n *\n * @example\n * ```typescript\n * import { tool, ToolRuntime } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const stateSchema = z.object({\n *   messages: z.array(z.any()),\n *   userId: z.string().optional(),\n * });\n *\n * const greet = tool(\n *   async ({ name }, runtime) => {\n *     // Access state\n *     const messages = runtime.state.messages;\n *\n *     // Access tool_call_id\n *     console.log(`Tool call ID: ${runtime.toolCallId}`);\n *\n *     // Access config\n *     console.log(`Run ID: ${runtime.config.runId}`);\n *\n *     // Access runtime context\n *     const userId = runtime.context?.userId;\n *\n *     // Access store\n *     await runtime.store?.mset([[\"key\", \"value\"]]);\n *\n *     // Stream output\n *     runtime.writer?.(\"Processing...\");\n *\n *     return `Hello! User ID: ${runtime.state.userId || \"unknown\"} ${name}`;\n *   },\n *   {\n *     name: \"greet\",\n *     description: \"Use this to greet the user once you found their info.\",\n *     schema: z.object({ name: z.string() }),\n *     stateSchema,\n *   }\n * );\n * ```\n *\n * @template StateT - The type of the state schema (inferred from stateSchema)\n * @template ContextT - The type of the context schema (inferred from contextSchema)\n */\nexport type ToolRuntime<\n  TState = unknown,\n  TContext = unknown\n> = RunnableConfig & {\n  /**\n   * The current graph state.\n   */\n  state: TState extends InteropZodObject\n    ? InferInteropZodOutput<TState>\n    : TState extends Record<string, unknown>\n    ? TState\n    : unknown;\n  /**\n   * The ID of the current tool call.\n   */\n  toolCallId: string;\n  /**\n   * The current tool call.\n   */\n  toolCall?: ToolCall;\n  /**\n   * RunnableConfig for the current execution.\n   */\n  config: ToolRunnableConfig;\n  /**\n   * Runtime context (from langgraph `Runtime`).\n   */\n  context: TContext extends InteropZodObject\n    ? InferInteropZodOutput<TContext>\n    : TContext extends Record<string, unknown>\n    ? TContext\n    : unknown;\n  /**\n   * BaseStore instance for persistent storage (from langgraph `Runtime`).\n   */\n  store: BaseStore<string, unknown> | null;\n  /**\n   * Stream writer for streaming output (from langgraph `Runtime`).\n   */\n  writer: ((chunk: unknown) => void) | null;\n};\n","import PQueueMod from \"p-queue\";\nimport pRetry from \"p-retry\";\n\nimport { getAbortSignalError } from \"./signal.js\";\n\nconst STATUS_NO_RETRY = [\n  400, // Bad Request\n  401, // Unauthorized\n  402, // Payment Required\n  403, // Forbidden\n  404, // Not Found\n  405, // Method Not Allowed\n  406, // Not Acceptable\n  407, // Proxy Authentication Required\n  409, // Conflict\n];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst defaultFailedAttemptHandler = (error: any) => {\n  if (\n    error.message.startsWith(\"Cancel\") ||\n    error.message.startsWith(\"AbortError\") ||\n    error.name === \"AbortError\"\n  ) {\n    throw error;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.code === \"ECONNABORTED\") {\n    throw error;\n  }\n  const status =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (error as any)?.response?.status ?? (error as any)?.status;\n  if (status && STATUS_NO_RETRY.includes(+status)) {\n    throw error;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.error?.code === \"insufficient_quota\") {\n    const err = new Error(error?.message);\n    err.name = \"InsufficientQuotaError\";\n    throw err;\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type FailedAttemptHandler = (error: any) => any;\n\nexport interface AsyncCallerParams {\n  /**\n   * The maximum number of concurrent calls that can be made.\n   * Defaults to `Infinity`, which means no limit.\n   */\n  maxConcurrency?: number;\n  /**\n   * The maximum number of retries that can be made for a single call,\n   * with an exponential backoff between each attempt. Defaults to 6.\n   */\n  maxRetries?: number;\n  /**\n   * Custom handler to handle failed attempts. Takes the originally thrown\n   * error object as input, and should itself throw an error if the input\n   * error is not retryable.\n   */\n  onFailedAttempt?: FailedAttemptHandler;\n}\n\nexport interface AsyncCallerCallOptions {\n  signal?: AbortSignal;\n}\n\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */\nexport class AsyncCaller {\n  protected maxConcurrency: AsyncCallerParams[\"maxConcurrency\"];\n\n  protected maxRetries: AsyncCallerParams[\"maxRetries\"];\n\n  protected onFailedAttempt: AsyncCallerParams[\"onFailedAttempt\"];\n\n  private queue: typeof import(\"p-queue\")[\"default\"][\"prototype\"];\n\n  constructor(params: AsyncCallerParams) {\n    this.maxConcurrency = params.maxConcurrency ?? Infinity;\n    this.maxRetries = params.maxRetries ?? 6;\n    this.onFailedAttempt =\n      params.onFailedAttempt ?? defaultFailedAttemptHandler;\n\n    const PQueue = (\n      \"default\" in PQueueMod ? PQueueMod.default : PQueueMod\n    ) as typeof PQueueMod;\n    this.queue = new PQueue({ concurrency: this.maxConcurrency });\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async call<A extends any[], T extends (...args: A) => Promise<any>>(\n    callable: T,\n    ...args: Parameters<T>\n  ): Promise<Awaited<ReturnType<T>>> {\n    return this.queue.add(\n      () =>\n        pRetry(\n          () =>\n            callable(...args).catch((error) => {\n              // eslint-disable-next-line no-instanceof/no-instanceof\n              if (error instanceof Error) {\n                throw error;\n              } else {\n                throw new Error(error);\n              }\n            }),\n          {\n            onFailedAttempt: ({ error }) => this.onFailedAttempt?.(error),\n            retries: this.maxRetries,\n            randomize: true,\n            // If needed we can change some of the defaults here,\n            // but they're quite sensible.\n          }\n        ),\n      { throwOnTimeout: true }\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callWithOptions<A extends any[], T extends (...args: A) => Promise<any>>(\n    options: AsyncCallerCallOptions,\n    callable: T,\n    ...args: Parameters<T>\n  ): Promise<Awaited<ReturnType<T>>> {\n    // Note this doesn't cancel the underlying request,\n    // when available prefer to use the signal option of the underlying call\n    if (options.signal) {\n      let listener: (() => void) | undefined;\n      return Promise.race([\n        this.call<A, T>(callable, ...args),\n        new Promise<never>((_, reject) => {\n          listener = () => {\n            reject(getAbortSignalError(options.signal));\n          };\n          options.signal?.addEventListener(\"abort\", listener);\n        }),\n      ]).finally(() => {\n        if (options.signal && listener) {\n          options.signal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n    return this.call<A, T>(callable, ...args);\n  }\n\n  fetch(...args: Parameters<typeof fetch>): ReturnType<typeof fetch> {\n    return this.call(() =>\n      fetch(...args).then((res) => (res.ok ? res : Promise.reject(res)))\n    );\n  }\n}\n","import { CallbackManagerForLLMRun } from \"../../callbacks/manager.js\";\nimport { BaseLLMParams, LLM } from \"../../language_models/llms.js\";\nimport { GenerationChunk } from \"../../outputs.js\";\n\nexport class FakeLLM extends LLM {\n  response?: string;\n\n  thrownErrorString?: string;\n\n  constructor(\n    fields: { response?: string; thrownErrorString?: string } & BaseLLMParams\n  ) {\n    super(fields);\n    this.response = fields.response;\n    this.thrownErrorString = fields.thrownErrorString;\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  async _call(\n    prompt: string,\n    _options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    const response = this.response ?? prompt;\n    await runManager?.handleLLMNewToken(response);\n    return response;\n  }\n}\n\nexport class FakeStreamingLLM extends LLM {\n  sleep?: number = 50;\n\n  responses?: string[];\n\n  thrownErrorString?: string;\n\n  constructor(\n    fields: {\n      sleep?: number;\n      responses?: string[];\n      thrownErrorString?: string;\n    } & BaseLLMParams\n  ) {\n    super(fields);\n    this.sleep = fields.sleep ?? this.sleep;\n    this.responses = fields.responses;\n    this.thrownErrorString = fields.thrownErrorString;\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  async _call(prompt: string): Promise<string> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    const response = this.responses?.[0];\n    this.responses = this.responses?.slice(1);\n    return response ?? prompt;\n  }\n\n  async *_streamResponseChunks(\n    input: string,\n    _options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ) {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    const response = this.responses?.[0];\n    this.responses = this.responses?.slice(1);\n    for (const c of response ?? input) {\n      await new Promise((resolve) => setTimeout(resolve, this.sleep));\n      yield { text: c, generationInfo: {} } as GenerationChunk;\n      await runManager?.handleLLMNewToken(c);\n    }\n  }\n}\n","import { CallbackManagerForLLMRun } from \"../../callbacks/manager.js\";\nimport {\n  BaseChatModel,\n  BaseChatModelCallOptions,\n  BaseChatModelParams,\n} from \"../../language_models/chat_models.js\";\nimport { BaseLLMParams } from \"../../language_models/llms.js\";\nimport {\n  BaseMessage,\n  AIMessage,\n  AIMessageChunk,\n} from \"../../messages/index.js\";\nimport { type ChatResult, ChatGenerationChunk } from \"../../outputs.js\";\nimport { Runnable, RunnableLambda } from \"../../runnables/base.js\";\nimport { StructuredTool } from \"../../tools/index.js\";\nimport {\n  StructuredOutputMethodParams,\n  BaseLanguageModelInput,\n  StructuredOutputMethodOptions,\n} from \"../../language_models/base.js\";\n\nimport { toJsonSchema } from \"../json_schema.js\";\nimport { InteropZodType } from \"../types/zod.js\";\n\n/** Minimal shape actually needed by `bindTools` */\nexport interface ToolSpec {\n  name: string;\n  description?: string;\n  schema: InteropZodType | Record<string, unknown>; // Either a Zod schema *or* a plain JSON-Schema object\n}\n\n/**\n * Interface specific to the Fake Streaming Chat model.\n */\nexport interface FakeStreamingChatModelCallOptions\n  extends BaseChatModelCallOptions {}\n/**\n * Interface for the Constructor-field specific to the Fake Streaming Chat model (all optional because we fill in defaults).\n */\nexport interface FakeStreamingChatModelFields extends BaseChatModelParams {\n  /** Milliseconds to pause between fallback char-by-char chunks */\n  sleep?: number;\n\n  /** Full AI messages to fall back to when no `chunks` supplied */\n  responses?: BaseMessage[];\n\n  /** Exact chunks to emit (can include tool-call deltas) */\n  chunks?: AIMessageChunk[];\n\n  /** How tool specs are formatted in `bindTools` */\n  toolStyle?: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\";\n\n  /** Throw this error instead of streaming (useful in tests) */\n  thrownErrorString?: string;\n}\n\nexport class FakeChatModel extends BaseChatModel {\n  _combineLLMOutput() {\n    return [];\n  }\n\n  _llmType(): string {\n    return \"fake\";\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (options?.stop?.length) {\n      return {\n        generations: [\n          {\n            message: new AIMessage(options.stop[0]),\n            text: options.stop[0],\n          },\n        ],\n      };\n    }\n    const text = messages\n      .map((m) => {\n        if (typeof m.content === \"string\") {\n          return m.content;\n        }\n        return JSON.stringify(m.content, null, 2);\n      })\n      .join(\"\\n\");\n    await runManager?.handleLLMNewToken(text);\n    return {\n      generations: [\n        {\n          message: new AIMessage(text),\n          text,\n        },\n      ],\n      llmOutput: {},\n    };\n  }\n}\n\nexport class FakeStreamingChatModel extends BaseChatModel<FakeStreamingChatModelCallOptions> {\n  sleep = 50;\n\n  responses: BaseMessage[] = [];\n\n  chunks: AIMessageChunk[] = [];\n\n  toolStyle: \"openai\" | \"anthropic\" | \"bedrock\" | \"google\" = \"openai\";\n\n  thrownErrorString?: string;\n\n  private tools: (StructuredTool | ToolSpec)[] = [];\n\n  constructor({\n    sleep = 50,\n    responses = [],\n    chunks = [],\n    toolStyle = \"openai\",\n    thrownErrorString,\n    ...rest\n  }: FakeStreamingChatModelFields & BaseLLMParams) {\n    super(rest);\n    this.sleep = sleep;\n    this.responses = responses;\n    this.chunks = chunks;\n    this.toolStyle = toolStyle;\n    this.thrownErrorString = thrownErrorString;\n  }\n\n  _llmType() {\n    return \"fake\";\n  }\n\n  bindTools(tools: (StructuredTool | ToolSpec)[]) {\n    const merged = [...this.tools, ...tools];\n\n    const toolDicts = merged.map((t) => {\n      switch (this.toolStyle) {\n        case \"openai\":\n          return {\n            type: \"function\",\n            function: {\n              name: t.name,\n              description: t.description,\n              parameters: toJsonSchema(t.schema),\n            },\n          };\n        case \"anthropic\":\n          return {\n            name: t.name,\n            description: t.description,\n            input_schema: toJsonSchema(t.schema),\n          };\n        case \"bedrock\":\n          return {\n            toolSpec: {\n              name: t.name,\n              description: t.description,\n              inputSchema: toJsonSchema(t.schema),\n            },\n          };\n        case \"google\":\n          return {\n            name: t.name,\n            description: t.description,\n            parameters: toJsonSchema(t.schema),\n          };\n        default:\n          throw new Error(`Unsupported tool style: ${this.toolStyle}`);\n      }\n    });\n\n    const wrapped =\n      this.toolStyle === \"google\"\n        ? [{ functionDeclarations: toolDicts }]\n        : toolDicts;\n\n    /* creating a *new* instance  mirrors LangChain .bind semantics for type-safety and avoiding noise */\n    const next = new FakeStreamingChatModel({\n      sleep: this.sleep,\n      responses: this.responses,\n      chunks: this.chunks,\n      toolStyle: this.toolStyle,\n      thrownErrorString: this.thrownErrorString,\n    });\n    next.tools = merged;\n\n    return next.withConfig({ tools: wrapped } as BaseChatModelCallOptions);\n  }\n\n  async _generate(\n    messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n\n    const content = this.responses?.[0]?.content ?? messages[0].content ?? \"\";\n\n    const generation: ChatResult = {\n      generations: [\n        {\n          text: \"\",\n          message: new AIMessage({\n            content,\n            tool_calls: this.chunks?.[0]?.tool_calls,\n          }),\n        },\n      ],\n    };\n\n    return generation;\n  }\n\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    if (this.thrownErrorString) {\n      throw new Error(this.thrownErrorString);\n    }\n    if (this.chunks?.length) {\n      for (const msgChunk of this.chunks) {\n        const cg = new ChatGenerationChunk({\n          message: new AIMessageChunk({\n            content: msgChunk.content,\n            tool_calls: msgChunk.tool_calls,\n            additional_kwargs: msgChunk.additional_kwargs ?? {},\n          }),\n          text: msgChunk.content?.toString() ?? \"\",\n        });\n\n        yield cg;\n        await runManager?.handleLLMNewToken(\n          msgChunk.content as string,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          { chunk: cg }\n        );\n      }\n      return;\n    }\n\n    const fallback =\n      this.responses?.[0] ??\n      new AIMessage(\n        typeof _messages[0].content === \"string\" ? _messages[0].content : \"\"\n      );\n    const text = typeof fallback.content === \"string\" ? fallback.content : \"\";\n\n    for (const ch of text) {\n      await new Promise((r) => setTimeout(r, this.sleep));\n      const cg = new ChatGenerationChunk({\n        message: new AIMessageChunk({ content: ch }),\n        text: ch,\n      });\n      yield cg;\n      await runManager?.handleLLMNewToken(\n        ch,\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        { chunk: cg }\n      );\n    }\n  }\n}\n\n/**\n * Interface for the input parameters specific to the Fake List Chat model.\n */\nexport interface FakeChatInput extends BaseChatModelParams {\n  /** Responses to return */\n  responses: string[];\n\n  /** Time to sleep in milliseconds between responses */\n  sleep?: number;\n\n  emitCustomEvent?: boolean;\n}\n\nexport interface FakeListChatModelCallOptions extends BaseChatModelCallOptions {\n  thrownErrorString?: string;\n}\n\n/**\n * A fake Chat Model that returns a predefined list of responses. It can be used\n * for testing purposes.\n * @example\n * ```typescript\n * const chat = new FakeListChatModel({\n *   responses: [\"I'll callback later.\", \"You 'console' them!\"]\n * });\n *\n * const firstMessage = new HumanMessage(\"You want to hear a JavaScript joke?\");\n * const secondMessage = new HumanMessage(\"How do you cheer up a JavaScript developer?\");\n *\n * // Call the chat model with a message and log the response\n * const firstResponse = await chat.call([firstMessage]);\n * console.log({ firstResponse });\n *\n * const secondResponse = await chat.call([secondMessage]);\n * console.log({ secondResponse });\n * ```\n */\nexport class FakeListChatModel extends BaseChatModel<FakeListChatModelCallOptions> {\n  static lc_name() {\n    return \"FakeListChatModel\";\n  }\n\n  lc_serializable = true;\n\n  responses: string[];\n\n  i = 0;\n\n  sleep?: number;\n\n  emitCustomEvent = false;\n\n  constructor(params: FakeChatInput) {\n    super(params);\n    const { responses, sleep, emitCustomEvent } = params;\n    this.responses = responses;\n    this.sleep = sleep;\n    this.emitCustomEvent = emitCustomEvent ?? this.emitCustomEvent;\n  }\n\n  _combineLLMOutput() {\n    return [];\n  }\n\n  _llmType(): string {\n    return \"fake-list\";\n  }\n\n  async _generate(\n    _messages: BaseMessage[],\n    options?: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    await this._sleepIfRequested();\n    if (options?.thrownErrorString) {\n      throw new Error(options.thrownErrorString);\n    }\n    if (this.emitCustomEvent) {\n      await runManager?.handleCustomEvent(\"some_test_event\", {\n        someval: true,\n      });\n    }\n\n    if (options?.stop?.length) {\n      return {\n        generations: [this._formatGeneration(options.stop[0])],\n      };\n    } else {\n      const response = this._currentResponse();\n      this._incrementResponse();\n\n      return {\n        generations: [this._formatGeneration(response)],\n        llmOutput: {},\n      };\n    }\n  }\n\n  _formatGeneration(text: string) {\n    return {\n      message: new AIMessage(text),\n      text,\n    };\n  }\n\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    const response = this._currentResponse();\n    this._incrementResponse();\n    if (this.emitCustomEvent) {\n      await runManager?.handleCustomEvent(\"some_test_event\", {\n        someval: true,\n      });\n    }\n\n    for await (const text of response) {\n      await this._sleepIfRequested();\n      if (options?.thrownErrorString) {\n        throw new Error(options.thrownErrorString);\n      }\n      const chunk = this._createResponseChunk(text);\n      yield chunk;\n      // eslint-disable-next-line no-void\n      void runManager?.handleLLMNewToken(text);\n    }\n  }\n\n  async _sleepIfRequested() {\n    if (this.sleep !== undefined) {\n      await this._sleep();\n    }\n  }\n\n  async _sleep() {\n    return new Promise<void>((resolve) => {\n      setTimeout(() => resolve(), this.sleep);\n    });\n  }\n\n  _createResponseChunk(text: string): ChatGenerationChunk {\n    return new ChatGenerationChunk({\n      message: new AIMessageChunk({ content: text }),\n      text,\n    });\n  }\n\n  _currentResponse() {\n    return this.responses[this.i];\n  }\n\n  _incrementResponse() {\n    if (this.i < this.responses.length - 1) {\n      this.i += 1;\n    } else {\n      this.i = 0;\n    }\n  }\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    _params:\n      | StructuredOutputMethodParams<RunOutput, false>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    _params:\n      | StructuredOutputMethodParams<RunOutput, true>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    _params:\n      | StructuredOutputMethodParams<RunOutput, boolean>\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    _config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        { raw: BaseMessage; parsed: RunOutput }\n      > {\n    return RunnableLambda.from(async (input) => {\n      const message = await this.invoke(input);\n      if (message.tool_calls?.[0]?.args) {\n        return message.tool_calls[0].args as RunOutput;\n      }\n      if (typeof message.content === \"string\") {\n        return JSON.parse(message.content);\n      }\n      throw new Error(\"No structured output found\");\n    }) as Runnable;\n  }\n}\n","import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  _mergeLists,\n  BaseMessageFields,\n} from \"./base.js\";\nimport { getTranslator } from \"./block_translators/index.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport {\n  $InferMessageContent,\n  $InferMessageProperty,\n  MessageStructure,\n} from \"./message.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  defaultToolCallParser,\n} from \"./tool.js\";\nimport { collapseToolCallChunks, Constructor } from \"./utils.js\";\n\nexport interface AIMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"ai\"> {\n  tool_calls?: ToolCall[];\n  invalid_tool_calls?: InvalidToolCall[];\n  usage_metadata?: $InferMessageProperty<TStructure, \"ai\", \"usage_metadata\">;\n}\n\nexport class AIMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"ai\">\n  implements AIMessageFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  usage_metadata?: AIMessageFields<TStructure>[\"usage_metadata\"];\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n    };\n  }\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>\n  ) {\n    let initParams: AIMessageFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: {},\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (\n        !(rawToolCalls == null) &&\n        rawToolCalls.length > 0 &&\n        (toolCalls === undefined || toolCalls.length === 0)\n      ) {\n        console.warn(\n          [\n            \"New LangChain packages are available that more efficiently handle\",\n            \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n            \"message tool calls. e.g., `pnpm install @langchain/anthropic`,\",\n            \"pnpm install @langchain/openai`, etc.\",\n          ].join(\" \")\n        );\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [toolCalls, invalidToolCalls] =\n            defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls = toolCalls ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [];\n        initParams.invalid_tool_calls = [];\n      }\n\n      // Convert content to content blocks if output version is v1\n      if (\n        initParams.response_metadata !== undefined &&\n        \"output_version\" in initParams.response_metadata &&\n        initParams.response_metadata.output_version === \"v1\"\n      ) {\n        initParams.contentBlocks =\n          initParams.content as Array<ContentBlock.Standard>;\n        initParams.content = undefined;\n      }\n\n      if (initParams.contentBlocks !== undefined) {\n        // Add constructor tool calls as content blocks\n        initParams.contentBlocks.push(\n          ...initParams.tool_calls.map((toolCall) => ({\n            type: \"tool_call\" as const,\n            id: toolCall.id,\n            name: toolCall.name,\n            args: toolCall.args,\n          }))\n        );\n        // Add content block tool calls that aren't in the constructor tool calls\n        const missingToolCalls = initParams.contentBlocks\n          .filter<ContentBlock.Tools.ToolCall>(\n            (block): block is ContentBlock.Tools.ToolCall =>\n              block.type === \"tool_call\"\n          )\n          .filter(\n            (block) =>\n              !initParams.tool_calls?.some(\n                (toolCall) =>\n                  toolCall.id === block.id && toolCall.name === block.name\n              )\n          );\n        if (missingToolCalls.length > 0) {\n          initParams.tool_calls = missingToolCalls.map((block) => ({\n            type: \"tool_call\" as const,\n            id: block.id!,\n            name: block.name,\n            args: block.args as Record<string, unknown>,\n          }));\n        }\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls =\n        initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  static lc_name() {\n    return \"AIMessage\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      const missingToolCalls = this.tool_calls.filter(\n        (block) =>\n          !blocks.some((b) => b.id === block.id && b.name === block.name)\n      );\n      blocks.push(\n        ...missingToolCalls.map((block) => ({\n          ...block,\n          type: \"tool_call\" as const,\n          id: block.id,\n          name: block.name,\n          args: block.args,\n        }))\n      );\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is AIMessage {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n\n/**\n * @deprecated Use {@link AIMessage.isInstance} instead\n */\nexport function isAIMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is AIMessage<TStructure> {\n  return x._getType() === \"ai\";\n}\n\n/**\n * @deprecated Use {@link AIMessageChunk.isInstance} instead\n */\nexport function isAIMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is AIMessageChunk<TStructure> {\n  return x._getType() === \"ai\";\n}\n\nexport type AIMessageChunkFields<\n  TStructure extends MessageStructure = MessageStructure\n> = AIMessageFields<TStructure> & {\n  tool_call_chunks?: ToolCallChunk[];\n};\n\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessageChunk<TStructure, \"ai\">\n  implements AIMessage<TStructure>, AIMessageChunkFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  tool_call_chunks?: ToolCallChunk[] = [];\n\n  usage_metadata?: AIMessageChunkFields<TStructure>[\"usage_metadata\"];\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>\n  ) {\n    let initParams: AIMessageChunkFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n      };\n    } else if (\n      fields.tool_call_chunks === undefined ||\n      fields.tool_call_chunks.length === 0\n    ) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    } else {\n      initParams = {\n        ...fields,\n        ...collapseToolCallChunks(fields.tool_call_chunks ?? []),\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    this.tool_call_chunks =\n      initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls =\n      initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\",\n    };\n  }\n\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      if (typeof this.content !== \"string\") {\n        const contentToolCalls = this.content\n          .filter((block) => block.type === \"tool_call\")\n          .map((block) => block.id);\n        for (const toolCall of this.tool_calls) {\n          if (toolCall.id && !contentToolCalls.includes(toolCall.id)) {\n            blocks.push({\n              ...toolCall,\n              type: \"tool_call\",\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            });\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  concat(chunk: AIMessageChunk<TStructure>) {\n    const combinedFields: AIMessageChunkFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: mergeResponseMetadata(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      tool_call_chunks: [],\n      id: this.id ?? chunk.id,\n    };\n    if (\n      this.tool_call_chunks !== undefined ||\n      chunk.tool_call_chunks !== undefined\n    ) {\n      const rawToolCalls = _mergeLists(\n        this.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[],\n        chunk.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (\n      this.usage_metadata !== undefined ||\n      chunk.usage_metadata !== undefined\n    ) {\n      combinedFields.usage_metadata = mergeUsageMetadata(\n        this.usage_metadata,\n        chunk.usage_metadata\n      );\n    }\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls(combinedFields);\n  }\n\n  static isInstance(obj: unknown): obj is AIMessageChunk {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n","import type { Tiktoken, TiktokenModel } from \"js-tiktoken/lite\";\nimport type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\n\nimport { type BaseCache, InMemoryCache } from \"../caches/index.js\";\nimport {\n  type BasePromptValueInterface,\n  StringPromptValue,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport {\n  type BaseMessage,\n  type BaseMessageLike,\n  type MessageContent,\n} from \"../messages/base.js\";\nimport { coerceMessageLikeToMessage } from \"../messages/utils.js\";\nimport { type LLMResult } from \"../outputs.js\";\nimport { CallbackManager, Callbacks } from \"../callbacks/manager.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { encodingForModel } from \"../utils/tiktoken.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig } from \"../runnables/config.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n} from \"../utils/types/zod.js\";\nimport { ModelProfile } from \"./profile.js\";\n\n// https://www.npmjs.com/package/js-tiktoken\n\nexport const getModelNameForTiktoken = (modelName: string): TiktokenModel => {\n  if (modelName.startsWith(\"gpt-5\")) {\n    return \"gpt-5\" as TiktokenModel;\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-16k\")) {\n    return \"gpt-3.5-turbo-16k\";\n  }\n\n  if (modelName.startsWith(\"gpt-3.5-turbo-\")) {\n    return \"gpt-3.5-turbo\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-32k\")) {\n    return \"gpt-4-32k\";\n  }\n\n  if (modelName.startsWith(\"gpt-4-\")) {\n    return \"gpt-4\";\n  }\n\n  if (modelName.startsWith(\"gpt-4o\")) {\n    return \"gpt-4o\";\n  }\n\n  return modelName as TiktokenModel;\n};\n\nexport const getEmbeddingContextSize = (modelName?: string): number => {\n  switch (modelName) {\n    case \"text-embedding-ada-002\":\n      return 8191;\n    default:\n      return 2046;\n  }\n};\n\n/**\n * Get the context window size (max input tokens) for a given model.\n *\n * Context window sizes are sourced from official model documentation:\n * - OpenAI: https://platform.openai.com/docs/models\n * - Anthropic: https://docs.anthropic.com/claude/docs/models-overview\n * - Google: https://ai.google.dev/gemini/docs/models/gemini\n *\n * @param modelName - The name of the model\n * @returns The context window size in tokens\n */\nexport const getModelContextSize = (modelName: string): number => {\n  const normalizedName = getModelNameForTiktoken(modelName) as string;\n\n  switch (normalizedName) {\n    // GPT-5 series\n    case \"gpt-5\":\n    case \"gpt-5-turbo\":\n    case \"gpt-5-turbo-preview\":\n      return 400000;\n\n    // GPT-4o series\n    case \"gpt-4o\":\n    case \"gpt-4o-mini\":\n    case \"gpt-4o-2024-05-13\":\n    case \"gpt-4o-2024-08-06\":\n      return 128000;\n\n    // GPT-4 Turbo series\n    case \"gpt-4-turbo\":\n    case \"gpt-4-turbo-preview\":\n    case \"gpt-4-turbo-2024-04-09\":\n    case \"gpt-4-0125-preview\":\n    case \"gpt-4-1106-preview\":\n      return 128000;\n\n    // GPT-4 series\n    case \"gpt-4-32k\":\n    case \"gpt-4-32k-0314\":\n    case \"gpt-4-32k-0613\":\n      return 32768;\n    case \"gpt-4\":\n    case \"gpt-4-0314\":\n    case \"gpt-4-0613\":\n      return 8192;\n\n    // GPT-3.5 Turbo series\n    case \"gpt-3.5-turbo-16k\":\n    case \"gpt-3.5-turbo-16k-0613\":\n      return 16384;\n    case \"gpt-3.5-turbo\":\n    case \"gpt-3.5-turbo-0301\":\n    case \"gpt-3.5-turbo-0613\":\n    case \"gpt-3.5-turbo-1106\":\n    case \"gpt-3.5-turbo-0125\":\n      return 4096;\n\n    // Legacy GPT-3 models\n    case \"text-davinci-003\":\n    case \"text-davinci-002\":\n      return 4097;\n    case \"text-davinci-001\":\n      return 2049;\n    case \"text-curie-001\":\n    case \"text-babbage-001\":\n    case \"text-ada-001\":\n      return 2048;\n\n    // Code models\n    case \"code-davinci-002\":\n    case \"code-davinci-001\":\n      return 8000;\n    case \"code-cushman-001\":\n      return 2048;\n\n    // Claude models (Anthropic)\n    case \"claude-3-5-sonnet-20241022\":\n    case \"claude-3-5-sonnet-20240620\":\n    case \"claude-3-opus-20240229\":\n    case \"claude-3-sonnet-20240229\":\n    case \"claude-3-haiku-20240307\":\n    case \"claude-2.1\":\n      return 200000;\n    case \"claude-2.0\":\n    case \"claude-instant-1.2\":\n      return 100000;\n\n    // Gemini models (Google)\n    case \"gemini-1.5-pro\":\n    case \"gemini-1.5-pro-latest\":\n    case \"gemini-1.5-flash\":\n    case \"gemini-1.5-flash-latest\":\n      return 1000000; // 1M tokens\n    case \"gemini-pro\":\n    case \"gemini-pro-vision\":\n      return 32768;\n\n    default:\n      return 4097;\n  }\n};\n\n/**\n * Whether or not the input matches the OpenAI tool definition.\n * @param {unknown} tool The input to check.\n * @returns {boolean} Whether the input is an OpenAI tool definition.\n */\nexport function isOpenAITool(tool: unknown): tool is ToolDefinition {\n  if (typeof tool !== \"object\" || !tool) return false;\n  if (\n    \"type\" in tool &&\n    tool.type === \"function\" &&\n    \"function\" in tool &&\n    typeof tool.function === \"object\" &&\n    tool.function &&\n    \"name\" in tool.function &&\n    \"parameters\" in tool.function\n  ) {\n    return true;\n  }\n  return false;\n}\n\ninterface CalculateMaxTokenProps {\n  prompt: string;\n  modelName: TiktokenModel;\n}\n\nexport const calculateMaxTokens = async ({\n  prompt,\n  modelName,\n}: CalculateMaxTokenProps) => {\n  let numTokens;\n\n  try {\n    numTokens = (\n      await encodingForModel(getModelNameForTiktoken(modelName))\n    ).encode(prompt).length;\n  } catch {\n    console.warn(\n      \"Failed to calculate number of tokens, falling back to approximate count\"\n    );\n\n    // fallback to approximate calculation if tiktoken is not available\n    // each token is ~4 characters: https://help.openai.com/en/articles/4936856-what-are-tokens-and-how-to-count-them#\n    numTokens = Math.ceil(prompt.length / 4);\n  }\n\n  const maxTokens = getModelContextSize(modelName);\n  return maxTokens - numTokens;\n};\n\nconst getVerbosity = () => false;\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLangChainParams {\n  verbose?: boolean;\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Base class for language models, chains, tools.\n */\nexport abstract class BaseLangChain<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput, CallOptions>\n  implements BaseLangChainParams\n{\n  /**\n   * Whether to print out response text.\n   */\n  verbose: boolean;\n\n  callbacks?: Callbacks;\n\n  tags?: string[];\n\n  metadata?: Record<string, unknown>;\n\n  get lc_attributes(): { [key: string]: undefined } | undefined {\n    return {\n      callbacks: undefined,\n      verbose: undefined,\n    };\n  }\n\n  constructor(params: BaseLangChainParams) {\n    super(params);\n    this.verbose = params.verbose ?? getVerbosity();\n    this.callbacks = params.callbacks;\n    this.tags = params.tags ?? [];\n    this.metadata = params.metadata ?? {};\n  }\n}\n\n/**\n * Base interface for language model parameters.\n * A subclass of {@link BaseLanguageModel} should have a constructor that\n * takes in a parameter that extends this interface.\n */\nexport interface BaseLanguageModelParams\n  extends AsyncCallerParams,\n    BaseLangChainParams {\n  /**\n   * @deprecated Use `callbacks` instead\n   */\n  callbackManager?: CallbackManager;\n\n  cache?: BaseCache | boolean;\n}\n\nexport interface BaseLanguageModelTracingCallOptions {\n  /**\n   * Describes the format of structured outputs.\n   * This should be provided if an output is considered to be structured\n   */\n  ls_structured_output_format?: {\n    /**\n     * An object containing the method used for structured output (e.g., \"jsonMode\").\n     */\n    kwargs: { method: string };\n    /**\n     * The JSON schema describing the expected output structure.\n     */\n    schema?: JSONSchema;\n  };\n}\n\nexport interface BaseLanguageModelCallOptions\n  extends RunnableConfig,\n    BaseLanguageModelTracingCallOptions {\n  /**\n   * Stop tokens to use for this call.\n   * If not provided, the default stop tokens for the model will be used.\n   */\n  stop?: string[];\n}\n\nexport interface FunctionDefinition {\n  /**\n   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain\n   * underscores and dashes, with a maximum length of 64.\n   */\n  name: string;\n\n  /**\n   * The parameters the functions accepts, described as a JSON Schema object. See the\n   * [guide](https://platform.openai.com/docs/guides/gpt/function-calling) for\n   * examples, and the\n   * [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for\n   * documentation about the format.\n   *\n   * To describe a function that accepts no parameters, provide the value\n   * `{\"type\": \"object\", \"properties\": {}}`.\n   */\n  parameters: Record<string, unknown> | JSONSchema;\n\n  /**\n   * A description of what the function does, used by the model to choose when and\n   * how to call the function.\n   */\n  description?: string;\n}\n\nexport interface ToolDefinition {\n  type: \"function\";\n  function: FunctionDefinition;\n}\n\nexport type FunctionCallOption = {\n  name: string;\n};\n\nexport interface BaseFunctionCallOptions extends BaseLanguageModelCallOptions {\n  function_call?: FunctionCallOption;\n  functions?: FunctionDefinition[];\n}\n\nexport type BaseLanguageModelInput =\n  | BasePromptValueInterface\n  | string\n  | BaseMessageLike[];\n\nexport type StructuredOutputType = InferInteropZodOutput<InteropZodObject>;\n\nexport type StructuredOutputMethodOptions<IncludeRaw extends boolean = false> =\n  {\n    name?: string;\n    method?: \"functionCalling\" | \"jsonMode\" | \"jsonSchema\" | string;\n    includeRaw?: IncludeRaw;\n    /** Whether to use strict mode. Currently only supported by OpenAI models. */\n    strict?: boolean;\n  };\n\n/** @deprecated Use StructuredOutputMethodOptions instead */\nexport type StructuredOutputMethodParams<\n  RunOutput,\n  IncludeRaw extends boolean = false\n> = {\n  /** @deprecated Pass schema in as the first argument */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  schema: InteropZodType<RunOutput> | Record<string, any>;\n  name?: string;\n  method?: \"functionCalling\" | \"jsonMode\";\n  includeRaw?: IncludeRaw;\n};\n\nexport interface BaseLanguageModelInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions\n> extends RunnableInterface<BaseLanguageModelInput, RunOutput, CallOptions> {\n  get callKeys(): string[];\n\n  generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  _modelType(): string;\n\n  _llmType(): string;\n\n  getNumTokens(content: MessageContent): Promise<number>;\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any>;\n\n  serialize(): SerializedLLM;\n}\n\nexport type LanguageModelOutput = BaseMessage | string;\n\nexport type LanguageModelLike = Runnable<\n  BaseLanguageModelInput,\n  LanguageModelOutput\n>;\n\n/**\n * Base class for language models.\n */\nexport abstract class BaseLanguageModel<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends BaseLanguageModelCallOptions = BaseLanguageModelCallOptions\n  >\n  extends BaseLangChain<BaseLanguageModelInput, RunOutput, CallOptions>\n  implements\n    BaseLanguageModelParams,\n    BaseLanguageModelInterface<RunOutput, CallOptions>\n{\n  /**\n   * Keys that the language model accepts as call options.\n   */\n  get callKeys(): string[] {\n    return [\"stop\", \"timeout\", \"signal\", \"tags\", \"metadata\", \"callbacks\"];\n  }\n\n  /**\n   * The async caller should be used by subclasses to make any async calls,\n   * which will thus benefit from the concurrency and retry logic.\n   */\n  caller: AsyncCaller;\n\n  cache?: BaseCache;\n\n  constructor({\n    callbacks,\n    callbackManager,\n    ...params\n  }: BaseLanguageModelParams) {\n    const { cache, ...rest } = params;\n    super({\n      callbacks: callbacks ?? callbackManager,\n      ...rest,\n    });\n    if (typeof cache === \"object\") {\n      this.cache = cache;\n    } else if (cache) {\n      this.cache = InMemoryCache.global();\n    } else {\n      this.cache = undefined;\n    }\n    this.caller = new AsyncCaller(params ?? {});\n  }\n\n  abstract generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult>;\n\n  abstract _modelType(): string;\n\n  abstract _llmType(): string;\n\n  private _encoding?: Tiktoken;\n\n  /**\n   * Get the number of tokens in the content.\n   * @param content The content to get the number of tokens for.\n   * @returns The number of tokens in the content.\n   */\n  async getNumTokens(content: MessageContent) {\n    // Extract text content from MessageContent\n    let textContent: string;\n    if (typeof content === \"string\") {\n      textContent = content;\n    } else {\n      /**\n       * Content is an array of ContentBlock\n       *\n       * ToDo(@christian-bromann): This is a temporary fix to get the number of tokens for the content.\n       * We need to find a better way to do this.\n       * @see https://github.com/langchain-ai/langchainjs/pull/8341#pullrequestreview-2933713116\n       */\n      textContent = content\n        .map((item) => {\n          if (typeof item === \"string\") return item;\n          if (item.type === \"text\" && \"text\" in item) return item.text;\n          return \"\";\n        })\n        .join(\"\");\n    }\n\n    // fallback to approximate calculation if tiktoken is not available\n    let numTokens = Math.ceil(textContent.length / 4);\n\n    if (!this._encoding) {\n      try {\n        this._encoding = await encodingForModel(\n          \"modelName\" in this\n            ? getModelNameForTiktoken(this.modelName as string)\n            : \"gpt2\"\n        );\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    if (this._encoding) {\n      try {\n        numTokens = this._encoding.encode(textContent).length;\n      } catch (error) {\n        console.warn(\n          \"Failed to calculate number of tokens, falling back to approximate count\",\n          error\n        );\n      }\n    }\n\n    return numTokens;\n  }\n\n  protected static _convertInputToPromptValue(\n    input: BaseLanguageModelInput\n  ): BasePromptValueInterface {\n    if (typeof input === \"string\") {\n      return new StringPromptValue(input);\n    } else if (Array.isArray(input)) {\n      return new ChatPromptValue(input.map(coerceMessageLikeToMessage));\n    } else {\n      return input;\n    }\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Create a unique cache key for a specific call to a specific language model.\n   * @param callOptions Call options for the model\n   * @returns A unique cache key.\n   */\n  _getSerializedCacheKeyParametersForCall(\n    // TODO: Fix when we remove the RunnableLambda backwards compatibility shim.\n    { config, ...callOptions }: CallOptions & { config?: RunnableConfig }\n  ): string {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const params: Record<string, any> = {\n      ...this._identifyingParams(),\n      ...callOptions,\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n    const filteredEntries = Object.entries(params).filter(\n      ([_, value]) => value !== undefined\n    );\n    const serializedEntries = filteredEntries\n      .map(([key, value]) => `${key}:${JSON.stringify(value)}`)\n      .sort()\n      .join(\",\");\n    return serializedEntries;\n  }\n\n  /**\n   * @deprecated\n   * Return a json-like object representing this LLM.\n   */\n  serialize(): SerializedLLM {\n    return {\n      ...this._identifyingParams(),\n      _type: this._llmType(),\n      _model: this._modelType(),\n    };\n  }\n\n  /**\n   * @deprecated\n   * Load an LLM from a json-like object describing it.\n   */\n  static async deserialize(_data: SerializedLLM): Promise<BaseLanguageModel> {\n    throw new Error(\"Use .toJSON() instead\");\n  }\n\n  /**\n   * Return profiling information for the model.\n   *\n   * @returns {ModelProfile} An object describing the model's capabilities and constraints\n   */\n  get profile(): ModelProfile {\n    return {};\n  }\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  /**\n   * Model wrapper that returns outputs formatted to match the given schema.\n   *\n   * @template {BaseLanguageModelInput} RunInput The input type for the Runnable, expected to be the same input for the LLM.\n   * @template {Record<string, any>} RunOutput The output type for the Runnable, expected to be a Zod schema object for structured output validation.\n   *\n   * @param {InteropZodType<RunOutput>} schema The schema for the structured output. Either as a Zod schema or a valid JSON schema object.\n   *   If a Zod schema is passed, the returned attributes will be validated, whereas with JSON schema they will not be.\n   * @param {string} name The name of the function to call.\n   * @param {\"functionCalling\" | \"jsonMode\"} [method=functionCalling] The method to use for getting the structured output. Defaults to \"functionCalling\".\n   * @param {boolean | undefined} [includeRaw=false] Whether to include the raw output in the result. Defaults to false.\n   * @returns {Runnable<RunInput, RunOutput> | Runnable<RunInput, { raw: BaseMessage; parsed: RunOutput }>} A new runnable that calls the LLM with structured output.\n   */\n  withStructuredOutput?<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    schema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      >;\n}\n\n/**\n * Shared interface for token usage\n * return type from LLM calls.\n */\nexport interface TokenUsage {\n  completionTokens?: number;\n  promptTokens?: number;\n  totalTokens?: number;\n}\n","import { Command, CONFIG_KEY_RESUMING } from \"../constants.js\";\nimport { isGraphBubbleUp, isParentCommand } from \"../errors.js\";\nimport { PregelExecutableTask } from \"./types.js\";\nimport { getParentCheckpointNamespace } from \"./utils/config.js\";\nimport { patchConfigurable, type RetryPolicy } from \"./utils/index.js\";\n\nexport const DEFAULT_INITIAL_INTERVAL = 500;\nexport const DEFAULT_BACKOFF_FACTOR = 2;\nexport const DEFAULT_MAX_INTERVAL = 128000;\nexport const DEFAULT_MAX_RETRIES = 3;\n\nconst DEFAULT_STATUS_NO_RETRY = [\n  400, // Bad Request\n  401, // Unauthorized\n  402, // Payment Required\n  403, // Forbidden\n  404, // Not Found\n  405, // Method Not Allowed\n  406, // Not Acceptable\n  407, // Proxy Authentication Required\n  409, // Conflict\n];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst DEFAULT_RETRY_ON_HANDLER = (error: any) => {\n  if (\n    error.message.startsWith(\"Cancel\") ||\n    error.message.startsWith(\"AbortError\") ||\n    error.name === \"AbortError\"\n  ) {\n    return false;\n  }\n\n  // Thrown when interrupt is called without a checkpointer\n  if (error.name === \"GraphValueError\") {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.code === \"ECONNABORTED\") {\n    return false;\n  }\n\n  const status =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (error as any)?.response?.status ?? (error as any)?.status;\n  if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) {\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.error?.code === \"insufficient_quota\") {\n    return false;\n  }\n  return true;\n};\n\nexport type SettledPregelTask = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  task: PregelExecutableTask<any, any>;\n  error: Error;\n  signalAborted?: boolean;\n};\n\nexport async function _runWithRetry<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pregelTask: PregelExecutableTask<N, C>,\n  retryPolicy?: RetryPolicy,\n  configurable?: Record<string, unknown>,\n  signal?: AbortSignal\n): Promise<{\n  task: PregelExecutableTask<N, C>;\n  result: unknown;\n  error: Error | undefined;\n  signalAborted?: boolean;\n}> {\n  const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;\n  let interval =\n    resolvedRetryPolicy !== undefined\n      ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL\n      : 0;\n  let attempts = 0;\n  let error;\n  let result;\n\n  let { config } = pregelTask;\n  if (configurable) config = patchConfigurable(config, configurable);\n  config = { ...config, signal };\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    if (signal?.aborted) {\n      // no need to throw here - we'll throw from the runner, instead.\n      // there's just no point in retrying if the user has requested an abort.\n      break;\n    }\n    // Clear any writes from previous attempts\n    pregelTask.writes.splice(0, pregelTask.writes.length);\n    error = undefined;\n    try {\n      result = await pregelTask.proc.invoke(pregelTask.input, config);\n      break;\n    } catch (e: unknown) {\n      error = e;\n      (error as { pregelTaskId: string }).pregelTaskId = pregelTask.id;\n      if (isParentCommand(error)) {\n        const ns: string = config?.configurable?.checkpoint_ns;\n        const cmd = error.command;\n        if (cmd.graph === ns) {\n          // this command is for the current graph, handle it\n          for (const writer of pregelTask.writers) {\n            await writer.invoke(cmd, config);\n          }\n          error = undefined;\n          break;\n        } else if (cmd.graph === Command.PARENT) {\n          // this command is for the parent graph, assign it to the parent\n          const parentNs = getParentCheckpointNamespace(ns);\n          error.command = new Command({\n            ...error.command,\n            graph: parentNs,\n          });\n        }\n      }\n      if (isGraphBubbleUp(error)) {\n        break;\n      }\n      if (resolvedRetryPolicy === undefined) {\n        break;\n      }\n      attempts += 1;\n      // check if we should give up\n      if (\n        attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)\n      ) {\n        break;\n      }\n      const retryOn = resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER;\n      if (!retryOn(error)) {\n        break;\n      }\n      interval = Math.min(\n        resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL,\n        interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR)\n      );\n      const intervalWithJitter = resolvedRetryPolicy.jitter\n        ? Math.floor(interval + Math.random() * 1000)\n        : interval;\n      // sleep before retrying\n      // eslint-disable-next-line no-promise-executor-return\n      await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));\n      // log the retry\n      const errorName =\n        (error as Error).name ??\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ((error as Error).constructor as any).unminifiable_name ??\n        (error as Error).constructor.name;\n      if (resolvedRetryPolicy?.logWarning ?? true) {\n        console.log(\n          `Retrying task \"${String(pregelTask.name)}\" after ${interval.toFixed(\n            2\n          )}ms (attempt ${attempts}) after ${errorName}: ${error}`\n        );\n      }\n\n      // signal subgraphs to resume (if available)\n      config = patchConfigurable(config, { [CONFIG_KEY_RESUMING]: true });\n    }\n  }\n  return {\n    task: pregelTask,\n    result,\n    error: error as Error | undefined,\n    signalAborted: signal?.aborted,\n  };\n}\n","import { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  CheckpointMetadata,\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport {\n  ERROR,\n  Interrupt,\n  INTERRUPT,\n  RETURN,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport { EmptyChannelError } from \"../errors.js\";\nimport {\n  PregelExecutableTask,\n  PregelTaskDescription,\n  StateSnapshot,\n} from \"./types.js\";\nimport { readChannels } from \"./io.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\n\ntype ConsoleColors = {\n  start: string;\n  end: string;\n};\n\ntype ConsoleColorMap = {\n  [key: string]: ConsoleColors;\n};\n\nconst COLORS_MAP: ConsoleColorMap = {\n  blue: {\n    start: \"\\x1b[34m\",\n    end: \"\\x1b[0m\",\n  },\n  green: {\n    start: \"\\x1b[32m\",\n    end: \"\\x1b[0m\",\n  },\n  yellow: {\n    start: \"\\x1b[33;1m\",\n    end: \"\\x1b[0m\",\n  },\n};\n\n/**\n * Wrap some text in a color for printing to the console.\n */\nexport const wrap = (color: ConsoleColors, text: string): string =>\n  `${color.start}${text}${color.end}`;\n\nexport function printCheckpoint<Value>(\n  step: number,\n  channels: Record<string, BaseChannel<Value>>\n) {\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, \"[langgraph/checkpoint]\")}`,\n      `Finishing step ${step}. Channel values:\\n`,\n      `\\n${JSON.stringify(\n        Object.fromEntries(_readChannels<Value>(channels)),\n        null,\n        2\n      )}`,\n    ].join(\"\")\n  );\n}\n\nexport function* _readChannels<Value>(\n  channels: Record<string, BaseChannel<Value>>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): IterableIterator<[string, any]> {\n  for (const [name, channel] of Object.entries(channels)) {\n    try {\n      yield [name, channel.get()];\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.name === EmptyChannelError.unminifiable_name) {\n        // Skip the channel if it's empty\n        continue;\n      } else {\n        throw error; // Re-throw the error if it's not an EmptyChannelError\n      }\n    }\n  }\n}\n\nexport function* mapDebugTasks<N extends PropertyKey, C extends PropertyKey>(\n  tasks: readonly PregelExecutableTask<N, C>[]\n) {\n  for (const { id, name, input, config, triggers, writes } of tasks) {\n    if (config?.tags?.includes(TAG_HIDDEN)) continue;\n\n    const interrupts = writes\n      .filter(([writeId, n]) => {\n        return writeId === id && n === INTERRUPT;\n      })\n      .map(([, v]) => {\n        return v;\n      });\n    yield { id, name, input, triggers, interrupts };\n  }\n}\n\nfunction isMultipleChannelWrite(\n  value: unknown\n): value is { $writes: unknown[] } {\n  if (typeof value !== \"object\" || value === null) return false;\n  return \"$writes\" in value && Array.isArray(value.$writes);\n}\n\nfunction mapTaskResultWrites(writes: PendingWrite<unknown>[]) {\n  const result: Record<string, unknown> = {};\n\n  for (const [channel, value] of writes) {\n    const strChannel = String(channel);\n\n    if (strChannel in result) {\n      const channelWrites = isMultipleChannelWrite(result[strChannel])\n        ? result[strChannel].$writes\n        : [result[strChannel]];\n\n      channelWrites.push(value);\n      result[strChannel] = { $writes: channelWrites };\n    } else {\n      result[strChannel] = value;\n    }\n  }\n  return result;\n}\n\nexport function* mapDebugTaskResults<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  tasks: readonly [PregelExecutableTask<N, C>, PendingWrite<C>[]][],\n  streamChannels: PropertyKey | Array<PropertyKey>\n) {\n  for (const [{ id, name, config }, writes] of tasks) {\n    if (config?.tags?.includes(TAG_HIDDEN)) continue;\n    yield {\n      id,\n      name,\n      result: mapTaskResultWrites(\n        writes.filter(([channel]) => {\n          return Array.isArray(streamChannels)\n            ? streamChannels.includes(channel)\n            : channel === streamChannels;\n        })\n      ),\n      interrupts: writes.filter((w) => w[0] === INTERRUPT).map((w) => w[1]),\n    };\n  }\n}\n\ntype ChannelKey = string | number | symbol;\n\nexport function* mapDebugCheckpoint<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  config: RunnableConfig,\n  channels: Record<string, BaseChannel>,\n  streamChannels: string | string[],\n  metadata: CheckpointMetadata,\n  tasks: readonly PregelExecutableTask<N, C>[],\n  pendingWrites: CheckpointPendingWrite[],\n  parentConfig: RunnableConfig | undefined,\n  outputKeys: ChannelKey | ChannelKey[]\n) {\n  function formatConfig(config: RunnableConfig) {\n    // https://stackoverflow.com/a/78298178\n    type CamelToSnake<\n      T extends string,\n      A extends string = \"\"\n    > = T extends `${infer F}${infer R}`\n      ? CamelToSnake<\n          R,\n          `${A}${F extends Lowercase<F> ? F : `_${Lowercase<F>}`}`\n        >\n      : A;\n\n    // make sure the config is consistent with Python\n    const pyConfig: Partial<\n      Record<CamelToSnake<keyof RunnableConfig>, unknown>\n    > = {};\n\n    if (config.callbacks != null) pyConfig.callbacks = config.callbacks;\n    if (config.configurable != null)\n      pyConfig.configurable = config.configurable;\n    if (config.maxConcurrency != null)\n      pyConfig.max_concurrency = config.maxConcurrency;\n\n    if (config.metadata != null) pyConfig.metadata = config.metadata;\n    if (config.recursionLimit != null)\n      pyConfig.recursion_limit = config.recursionLimit;\n    if (config.runId != null) pyConfig.run_id = config.runId;\n    if (config.runName != null) pyConfig.run_name = config.runName;\n    if (config.tags != null) pyConfig.tags = config.tags;\n\n    return pyConfig;\n  }\n\n  const parentNs = config.configurable?.checkpoint_ns;\n  const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n\n  for (const task of tasks) {\n    const candidates = task.subgraphs?.length ? task.subgraphs : [task.proc];\n    if (!candidates.find(findSubgraphPregel)) continue;\n\n    let taskNs = `${task.name as string}:${task.id}`;\n    if (parentNs) taskNs = `${parentNs}|${taskNs}`;\n\n    taskStates[task.id] = {\n      configurable: {\n        thread_id: config.configurable?.thread_id,\n        checkpoint_ns: taskNs,\n      },\n    };\n  }\n\n  yield {\n    config: formatConfig(config),\n    values: readChannels(channels, streamChannels),\n    metadata,\n    next: tasks.map((task) => task.name),\n    tasks: tasksWithWrites(tasks, pendingWrites, taskStates, outputKeys),\n    parentConfig: parentConfig ? formatConfig(parentConfig) : undefined,\n  };\n}\n\nexport function tasksWithWrites<N extends PropertyKey, C extends PropertyKey>(\n  tasks: PregelTaskDescription[] | readonly PregelExecutableTask<N, C>[],\n  pendingWrites: CheckpointPendingWrite[],\n  states: Record<string, RunnableConfig | StateSnapshot> | undefined,\n  outputKeys: ChannelKey[] | ChannelKey\n): PregelTaskDescription[] {\n  return tasks.map((task): PregelTaskDescription => {\n    const error = pendingWrites.find(\n      ([id, n]) => id === task.id && n === ERROR\n    )?.[2];\n\n    const interrupts = pendingWrites\n      .filter(([id, n]) => id === task.id && n === INTERRUPT)\n      .map(([, , v]) => v) as Interrupt[];\n\n    const result = (() => {\n      if (error || interrupts.length || !pendingWrites.length) return undefined;\n\n      const idx = pendingWrites.findIndex(\n        ([tid, n]) => tid === task.id && n === RETURN\n      );\n\n      if (idx >= 0) return pendingWrites[idx][2];\n\n      if (typeof outputKeys === \"string\") {\n        return pendingWrites.find(\n          ([tid, n]) => tid === task.id && n === outputKeys\n        )?.[2];\n      }\n\n      if (Array.isArray(outputKeys)) {\n        const results = pendingWrites\n          .filter(([tid, n]) => tid === task.id && outputKeys.includes(n))\n          .map(([, n, v]) => [n, v] as PendingWrite<C>);\n\n        if (!results.length) return undefined;\n        return mapTaskResultWrites(results);\n      }\n\n      return undefined;\n    })();\n\n    if (error) {\n      return {\n        id: task.id,\n        name: task.name as string,\n        path: task.path,\n        error,\n        interrupts,\n        result,\n      };\n    }\n\n    const taskState = states?.[task.id];\n    return {\n      id: task.id,\n      name: task.name as string,\n      path: task.path,\n      interrupts,\n      ...(taskState !== undefined ? { state: taskState } : {}),\n      result,\n    };\n  });\n}\n\nexport function printStepCheckpoint(\n  step: number,\n  channels: Record<string, BaseChannel<unknown>>,\n  whitelist: string[]\n): void {\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,\n      `\\x1b[1m State at the end of step ${step}:\\x1b[0m\\n`,\n      JSON.stringify(readChannels(channels, whitelist), null, 2),\n    ].join(\"\")\n  );\n}\n\nexport function printStepTasks<N extends PropertyKey, C extends PropertyKey>(\n  step: number,\n  nextTasks: readonly PregelExecutableTask<N, C>[]\n): void {\n  const nTasks = nextTasks.length;\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,\n      `\\x1b[1m Starting step ${step} with ${nTasks} task${\n        nTasks === 1 ? \"\" : \"s\"\n      }:\\x1b[0m\\n`,\n      nextTasks\n        .map(\n          (task) =>\n            `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(\n              task.input,\n              null,\n              2\n            )}`\n        )\n        .join(\"\\n\"),\n    ].join(\"\")\n  );\n}\n\nexport function printStepWrites(\n  step: number,\n  writes: PendingWrite[],\n  whitelist: string[]\n): void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const byChannel: Record<string, any[]> = {};\n\n  for (const [channel, value] of writes) {\n    if (whitelist.includes(channel)) {\n      if (!byChannel[channel]) {\n        byChannel[channel] = [];\n      }\n      byChannel[channel].push(value);\n    }\n  }\n\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,\n      `\\x1b[1m Finished step ${step} with writes to ${\n        Object.keys(byChannel).length\n      } channel${Object.keys(byChannel).length !== 1 ? \"s\" : \"\"}:\\x1b[0m\\n`,\n      Object.entries(byChannel)\n        .map(\n          ([name, vals]) =>\n            `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals\n              .map((v) => JSON.stringify(v))\n              .join(\", \")}`\n        )\n        .join(\"\\n\"),\n    ].join(\"\")\n  );\n}\n","import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { SerializedConstructor } from \"../load/serializable.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { parsePartialJson } from \"../utils/json.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessageLike,\n  BaseMessage,\n  isBaseMessage,\n  StoredMessage,\n  StoredMessageV1,\n  BaseMessageFields,\n  _isMessageFieldWithRole,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageFields, ChatMessageChunk } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  ToolMessage,\n  ToolMessageFields,\n} from \"./tool.js\";\n\nexport type $Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n  [K in keyof T]: string extends K\n    ? never\n    : number extends K\n    ? never\n    : symbol extends K\n    ? never\n    : K;\n}[keyof T];\n\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n  ? true\n  : symbol extends keyof T\n  ? true\n  : false;\n\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true\n  ? [$KnownKeys<T>] extends [never]\n    ? true\n    : false\n  : false;\n\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> =\n  // If U is purely index-signature based, prefer U as a whole\n  $OnlyIndexSignatures<U> extends true\n    ? U\n    : // If T is purely index-signature based, prefer U as a whole (prevents leaking broad index signatures)\n    $OnlyIndexSignatures<T> extends true\n    ? U\n    : {\n        [K in keyof T | keyof U]: K extends keyof T\n          ? K extends keyof U\n            ? T[K] extends Record<string, unknown>\n              ? U[K] extends Record<string, unknown>\n                ? $MergeObjects<T[K], U[K]>\n                : U[K]\n              : U[K]\n            : T[K]\n          : K extends keyof U\n          ? U[K]\n          : never;\n      };\n\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<\n  A extends Record<Key, PropertyKey>,\n  B extends Record<Key, PropertyKey>,\n  Key extends PropertyKey = \"type\"\n> = {\n  // Create a mapped type over all possible discriminator values from both A and B\n  [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n    ? // If B doesn't have this discriminator value, use A's member\n      Extract<A, Record<Key, T>>\n    : // If B does have this discriminator value, merge A's and B's members (B takes precedence)\n    [Extract<A, Record<Key, T>>] extends [never]\n    ? Extract<B, Record<Key, T>>\n    : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n  // Index into the mapped type with all possible discriminator values\n  // This converts the mapped type back into a union\n}[A[Key] | B[Key]];\n\nexport type Constructor<T> = new (...args: unknown[]) => T;\n\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport const iife = <T>(fn: () => T) => fn();\n\nfunction _coerceToolCall(\n  toolCall: ToolCall | Record<string, unknown>\n): ToolCall {\n  if (_isToolCall(toolCall)) {\n    return toolCall;\n  } else if (\n    typeof toolCall.id === \"string\" &&\n    toolCall.type === \"function\" &&\n    typeof toolCall.function === \"object\" &&\n    toolCall.function !== null &&\n    \"arguments\" in toolCall.function &&\n    typeof toolCall.function.arguments === \"string\" &&\n    \"name\" in toolCall.function &&\n    typeof toolCall.function.name === \"string\"\n  ) {\n    // Handle OpenAI tool call format\n    return {\n      id: toolCall.id,\n      args: JSON.parse(toolCall.function.arguments),\n      name: toolCall.function.name,\n      type: \"tool_call\",\n    };\n  } else {\n    // TODO: Throw an error?\n    return toolCall as unknown as ToolCall;\n  }\n}\n\nfunction isSerializedConstructor(x: unknown): x is SerializedConstructor {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    (x as SerializedConstructor).lc === 1 &&\n    Array.isArray((x as SerializedConstructor).id) &&\n    (x as SerializedConstructor).kwargs != null &&\n    typeof (x as SerializedConstructor).kwargs === \"object\"\n  );\n}\n\nfunction _constructMessageFromParams(\n  params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor\n) {\n  let type: string;\n  let rest: BaseMessageFields & Record<string, unknown>;\n  // Support serialized messages\n  if (isSerializedConstructor(params)) {\n    const className = params.id.at(-1);\n    if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n      type = \"user\";\n    } else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n      type = \"assistant\";\n    } else if (\n      className === \"SystemMessage\" ||\n      className === \"SystemMessageChunk\"\n    ) {\n      type = \"system\";\n    } else if (\n      className === \"FunctionMessage\" ||\n      className === \"FunctionMessageChunk\"\n    ) {\n      type = \"function\";\n    } else if (\n      className === \"ToolMessage\" ||\n      className === \"ToolMessageChunk\"\n    ) {\n      type = \"tool\";\n    } else {\n      type = \"unknown\";\n    }\n    rest = params.kwargs as BaseMessageFields;\n  } else {\n    const { type: extractedType, ...otherParams } = params;\n    type = extractedType;\n    rest = otherParams;\n  }\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage(rest);\n  } else if (type === \"ai\" || type === \"assistant\") {\n    const { tool_calls: rawToolCalls, ...other } = rest;\n    if (!Array.isArray(rawToolCalls)) {\n      return new AIMessage(rest);\n    }\n    const tool_calls = rawToolCalls.map(_coerceToolCall);\n    return new AIMessage({ ...other, tool_calls });\n  } else if (type === \"system\") {\n    return new SystemMessage(rest);\n  } else if (type === \"developer\") {\n    return new SystemMessage({\n      ...rest,\n      additional_kwargs: {\n        ...rest.additional_kwargs,\n        __openai_role__: \"developer\",\n      },\n    });\n  } else if (type === \"tool\" && \"tool_call_id\" in rest) {\n    return new ToolMessage({\n      ...rest,\n      content: rest.content,\n      tool_call_id: rest.tool_call_id as string,\n      name: rest.name,\n    });\n  } else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n    return new RemoveMessage({ ...rest, id: rest.id });\n  } else {\n    const error = addLangChainErrorFields(\n      new Error(\n        `Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(\n          params,\n          null,\n          2\n        )}`\n      ),\n      \"MESSAGE_COERCION_FAILURE\"\n    );\n    throw error;\n  }\n}\n\nexport function coerceMessageLikeToMessage(\n  messageLike: BaseMessageLike\n): BaseMessage {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  if (Array.isArray(messageLike)) {\n    const [type, content] = messageLike;\n    return _constructMessageFromParams({ type, content });\n  } else if (_isMessageFieldWithRole(messageLike)) {\n    const { role: type, ...rest } = messageLike;\n    return _constructMessageFromParams({ ...rest, type });\n  } else {\n    return _constructMessageFromParams(messageLike);\n  }\n}\n\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(\n  messages: BaseMessage[],\n  humanPrefix = \"Human\",\n  aiPrefix = \"AI\"\n): string {\n  const string_messages: string[] = [];\n  for (const m of messages) {\n    let role: string;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = (m as ChatMessage).role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    const readableContent =\n      typeof m.content === \"string\"\n        ? m.content\n        : JSON.stringify(m.content, null, 2);\n    string_messages.push(`${role}: ${nameStr}${readableContent}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(\n  message: StoredMessage | StoredMessageV1\n): StoredMessage {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if ((message as StoredMessage).data !== undefined) {\n    return message as StoredMessage;\n  } else {\n    const v1Message = message as StoredMessageV1;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined,\n      },\n    };\n  }\n}\n\nexport function mapStoredMessageToChatMessage(message: StoredMessage) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data as FunctionMessageFields);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data as ToolMessageFields);\n    case \"generic\": {\n      if (storedMessage.data.role === undefined) {\n        throw new Error(\"Role must be defined for chat messages\");\n      }\n      return new ChatMessage(storedMessage.data as ChatMessageFields);\n    }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(\n  messages: StoredMessage[]\n): BaseMessage[] {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(\n  messages: BaseMessage[]\n): StoredMessage[] {\n  return messages.map((message) => message.toDict());\n}\n\nexport function convertToChunk(message: BaseMessage) {\n  const type = message._getType();\n  if (type === \"human\") {\n    return new HumanMessageChunk({ ...message });\n  } else if (type === \"ai\") {\n    let aiChunkFields: AIMessageChunkFields = {\n      ...message,\n    };\n    if (\"tool_calls\" in aiChunkFields) {\n      aiChunkFields = {\n        ...aiChunkFields,\n        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n          ...tc,\n          type: \"tool_call_chunk\",\n          index: undefined,\n          args: JSON.stringify(tc.args),\n        })),\n      };\n    }\n    return new AIMessageChunk({ ...aiChunkFields });\n  } else if (type === \"system\") {\n    return new SystemMessageChunk({ ...message });\n  } else if (type === \"function\") {\n    return new FunctionMessageChunk({ ...message });\n  } else if (ChatMessage.isInstance(message)) {\n    return new ChatMessageChunk({ ...message });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}\n\n/**\n * Collapses an array of tool call chunks into complete tool calls.\n *\n * This function groups tool call chunks by their id and/or index, then attempts to\n * parse and validate the accumulated arguments for each group. Successfully parsed\n * tool calls are returned as valid `ToolCall` objects, while malformed ones are\n * returned as `InvalidToolCall` objects.\n *\n * @param chunks - An array of `ToolCallChunk` objects to collapse\n * @returns An object containing:\n *   - `tool_call_chunks`: The original input chunks\n *   - `tool_calls`: An array of successfully parsed and validated tool calls\n *   - `invalid_tool_calls`: An array of tool calls that failed parsing or validation\n *\n * @remarks\n * Chunks are grouped using the following matching logic:\n * - If a chunk has both an id and index, it matches chunks with the same id and index\n * - If a chunk has only an id, it matches chunks with the same id\n * - If a chunk has only an index, it matches chunks with the same index\n *\n * For each group, the function:\n * 1. Concatenates all `args` strings from the chunks\n * 2. Attempts to parse the concatenated string as JSON\n * 3. Validates that the result is a non-null object with a valid id\n * 4. Creates either a `ToolCall` (if valid) or `InvalidToolCall` (if invalid)\n */\nexport function collapseToolCallChunks(chunks: ToolCallChunk[]): {\n  tool_call_chunks: ToolCallChunk[];\n  tool_calls: ToolCall[];\n  invalid_tool_calls: InvalidToolCall[];\n} {\n  const groupedToolCallChunks = chunks.reduce((acc, chunk) => {\n    const matchedChunkIndex = acc.findIndex(([match]) => {\n      // If chunk has an id and index, match if both are present\n      if (\n        \"id\" in chunk &&\n        chunk.id &&\n        \"index\" in chunk &&\n        chunk.index !== undefined\n      ) {\n        return chunk.id === match.id && chunk.index === match.index;\n      }\n      // If chunk has an id, we match on id\n      if (\"id\" in chunk && chunk.id) {\n        return chunk.id === match.id;\n      }\n      // If chunk has an index, we match on index\n      if (\"index\" in chunk && chunk.index !== undefined) {\n        return chunk.index === match.index;\n      }\n      return false;\n    });\n    if (matchedChunkIndex !== -1) {\n      acc[matchedChunkIndex].push(chunk);\n    } else {\n      acc.push([chunk]);\n    }\n    return acc;\n  }, [] as ToolCallChunk[][]);\n\n  const toolCalls: ToolCall[] = [];\n  const invalidToolCalls: InvalidToolCall[] = [];\n  for (const chunks of groupedToolCallChunks) {\n    let parsedArgs: Record<string, unknown> | null = null;\n    const name = chunks[0]?.name ?? \"\";\n    const joinedArgs = chunks\n      .map((c) => c.args || \"\")\n      .join(\"\")\n      .trim();\n    const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n    const id = chunks[0]?.id;\n    try {\n      parsedArgs = parsePartialJson(argsStr);\n      if (\n        !id ||\n        parsedArgs === null ||\n        typeof parsedArgs !== \"object\" ||\n        Array.isArray(parsedArgs)\n      ) {\n        throw new Error(\"Malformed tool call chunk args.\");\n      }\n      toolCalls.push({\n        name,\n        args: parsedArgs,\n        id,\n        type: \"tool_call\",\n      });\n    } catch {\n      invalidToolCalls.push({\n        name,\n        args: argsStr,\n        id,\n        error: \"Malformed args.\",\n        type: \"invalid_tool_call\",\n      });\n    }\n  }\n  return {\n    tool_call_chunks: chunks,\n    tool_calls: toolCalls,\n    invalid_tool_calls: invalidToolCalls,\n  };\n}\n","import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * Stores the last value received, can receive at most one value per step.\n *\n * Since `update` is only called once per step and value can only be of length 1,\n * LastValue always stores the last value of a single node. If multiple nodes attempt to\n * write to this channel in a single step, an error will be thrown.\n * @internal\n */\nexport class LastValue<Value> extends BaseChannel<Value, Value, Value> {\n  lc_graph_name = \"LastValue\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  fromCheckpoint(checkpoint?: Value) {\n    const empty = new LastValue<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = [checkpoint];\n    }\n\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n    if (values.length !== 1) {\n      throw new InvalidUpdateError(\n        \"LastValue can only receive one value per step.\",\n        { lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\" }\n      );\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0;\n  }\n}\n\n/**\n * Stores the last value received, but only made available after finish().\n * Once made available, clears the value.\n */\nexport class LastValueAfterFinish<Value> extends BaseChannel<\n  Value,\n  Value,\n  [Value, boolean]\n> {\n  lc_graph_name = \"LastValueAfterFinish\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  finished: boolean = false;\n\n  fromCheckpoint(checkpoint?: [Value, boolean]) {\n    const empty = new LastValueAfterFinish<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      const [value, finished] = checkpoint;\n      empty.value = [value];\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n\n    this.finished = false;\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0 || !this.finished) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): [Value, boolean] | undefined {\n    if (this.value.length === 0) return undefined;\n    return [this.value[0], this.finished];\n  }\n\n  consume(): boolean {\n    if (this.finished) {\n      this.finished = false;\n      this.value = [];\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && this.value.length > 0) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0 && this.finished;\n  }\n}\n","/**\n * Tokenize a JSON path into parts.\n * @example\n * tokenizePath(\"metadata.title\") // -> [\"metadata\", \"title\"]\n * tokenizePath(\"chapters[*].content\") // -> [\"chapters[*]\", \"content\"]\n */\nexport function tokenizePath(path: string): string[] {\n  if (!path) {\n    return [];\n  }\n\n  const tokens: string[] = [];\n  let current: string[] = [];\n  let i = 0;\n\n  while (i < path.length) {\n    const char = path[i];\n\n    if (char === \"[\") {\n      // Handle array index\n      if (current.length) {\n        tokens.push(current.join(\"\"));\n        current = [];\n      }\n      let bracketCount = 1;\n      const indexChars = [\"[\"];\n      i += 1;\n      while (i < path.length && bracketCount > 0) {\n        if (path[i] === \"[\") {\n          bracketCount += 1;\n        } else if (path[i] === \"]\") {\n          bracketCount -= 1;\n        }\n        indexChars.push(path[i]);\n        i += 1;\n      }\n      tokens.push(indexChars.join(\"\"));\n      continue;\n    } else if (char === \"{\") {\n      // Handle multi-field selection\n      if (current.length) {\n        tokens.push(current.join(\"\"));\n        current = [];\n      }\n      let braceCount = 1;\n      const fieldChars = [\"{\"];\n      i += 1;\n      while (i < path.length && braceCount > 0) {\n        if (path[i] === \"{\") {\n          braceCount += 1;\n        } else if (path[i] === \"}\") {\n          braceCount -= 1;\n        }\n        fieldChars.push(path[i]);\n        i += 1;\n      }\n      tokens.push(fieldChars.join(\"\"));\n      continue;\n    } else if (char === \".\") {\n      // Handle regular field\n      if (current.length) {\n        tokens.push(current.join(\"\"));\n        current = [];\n      }\n    } else {\n      current.push(char);\n    }\n    i += 1;\n  }\n\n  if (current.length) {\n    tokens.push(current.join(\"\"));\n  }\n\n  return tokens;\n}\n\n/**\n * Represents the supported filter operators\n */\ntype FilterOperators = {\n  $eq?: unknown;\n  $ne?: unknown;\n  $gt?: unknown;\n  $gte?: unknown;\n  $lt?: unknown;\n  $lte?: unknown;\n  $in?: unknown[];\n  $nin?: unknown[];\n};\n\n/**\n * Type guard to check if an object is a FilterOperators\n */\nfunction isFilterOperators(obj: unknown): obj is FilterOperators {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    Object.keys(obj).every(\n      (key) =>\n        key === \"$eq\" ||\n        key === \"$ne\" ||\n        key === \"$gt\" ||\n        key === \"$gte\" ||\n        key === \"$lt\" ||\n        key === \"$lte\" ||\n        key === \"$in\" ||\n        key === \"$nin\"\n    )\n  );\n}\n\n/**\n * Compare values for filtering, supporting operator-based comparisons.\n */\nexport function compareValues(\n  itemValue: unknown,\n  filterValue: unknown\n): boolean {\n  if (isFilterOperators(filterValue)) {\n    const operators = Object.keys(filterValue).filter((k) => k.startsWith(\"$\"));\n    return operators.every((op) => {\n      const value = filterValue[op as keyof FilterOperators];\n      switch (op) {\n        case \"$eq\":\n          return itemValue === value;\n        case \"$ne\":\n          return itemValue !== value;\n        case \"$gt\":\n          return Number(itemValue) > Number(value);\n        case \"$gte\":\n          return Number(itemValue) >= Number(value);\n        case \"$lt\":\n          return Number(itemValue) < Number(value);\n        case \"$lte\":\n          return Number(itemValue) <= Number(value);\n        case \"$in\":\n          return Array.isArray(value) ? value.includes(itemValue) : false;\n        case \"$nin\":\n          return Array.isArray(value) ? !value.includes(itemValue) : true;\n        default:\n          return false;\n      }\n    });\n  }\n\n  // If no operators, do a direct comparison\n  return itemValue === filterValue;\n}\n\n/**\n * Extract text from a value at a specific JSON path.\n *\n * Supports:\n * - Simple paths: \"field1.field2\"\n * - Array indexing: \"[0]\", \"[*]\", \"[-1]\"\n * - Wildcards: \"*\"\n * - Multi-field selection: \"{field1,field2}\"\n * - Nested paths in multi-field: \"{field1,nested.field2}\"\n */\nexport function getTextAtPath(obj: unknown, path: string[] | string): string[] {\n  if (!path || path === \"$\") {\n    return [JSON.stringify(obj, null, 2)];\n  }\n  const tokens = Array.isArray(path) ? path : tokenizePath(path);\n\n  function extractFromObj(\n    obj: unknown,\n    tokens: string[],\n    pos: number\n  ): string[] {\n    if (pos >= tokens.length) {\n      if (\n        typeof obj === \"string\" ||\n        typeof obj === \"number\" ||\n        typeof obj === \"boolean\"\n      ) {\n        return [String(obj)];\n      }\n      if (obj === null || obj === undefined) {\n        return [];\n      }\n      if (Array.isArray(obj) || typeof obj === \"object\") {\n        return [JSON.stringify(obj, null, 2)];\n      }\n      return [];\n    }\n\n    const token = tokens[pos];\n    const results: string[] = [];\n    if (pos === 0 && token === \"$\") {\n      results.push(JSON.stringify(obj, null, 2));\n    }\n\n    if (token.startsWith(\"[\") && token.endsWith(\"]\")) {\n      if (!Array.isArray(obj)) return [];\n\n      const index = token.slice(1, -1);\n      if (index === \"*\") {\n        for (const item of obj) {\n          results.push(...extractFromObj(item, tokens, pos + 1));\n        }\n      } else {\n        try {\n          let idx = parseInt(index, 10);\n          if (idx < 0) {\n            idx = obj.length + idx;\n          }\n          if (idx >= 0 && idx < obj.length) {\n            results.push(...extractFromObj(obj[idx], tokens, pos + 1));\n          }\n        } catch {\n          return [];\n        }\n      }\n    } else if (token.startsWith(\"{\") && token.endsWith(\"}\")) {\n      if (typeof obj !== \"object\" || obj === null) return [];\n\n      const fields = token\n        .slice(1, -1)\n        .split(\",\")\n        .map((f) => f.trim());\n      for (const field of fields) {\n        const nestedTokens = tokenizePath(field);\n        if (nestedTokens.length) {\n          let currentObj = obj as Record<string, unknown> | undefined;\n          for (const nestedToken of nestedTokens) {\n            if (\n              currentObj &&\n              typeof currentObj === \"object\" &&\n              nestedToken in currentObj\n            ) {\n              currentObj = currentObj[nestedToken] as Record<string, unknown>;\n            } else {\n              currentObj = undefined;\n              break;\n            }\n          }\n          if (currentObj !== undefined) {\n            if (\n              typeof currentObj === \"string\" ||\n              typeof currentObj === \"number\" ||\n              typeof currentObj === \"boolean\"\n            ) {\n              results.push(String(currentObj));\n            } else if (\n              Array.isArray(currentObj) ||\n              typeof currentObj === \"object\"\n            ) {\n              results.push(JSON.stringify(currentObj, null, 2));\n            }\n          }\n        }\n      }\n    } else if (token === \"*\") {\n      if (Array.isArray(obj)) {\n        for (const item of obj) {\n          results.push(...extractFromObj(item, tokens, pos + 1));\n        }\n      } else if (typeof obj === \"object\" && obj !== null) {\n        for (const value of Object.values(obj)) {\n          results.push(...extractFromObj(value, tokens, pos + 1));\n        }\n      }\n    } else {\n      if (typeof obj === \"object\" && obj !== null && token in obj) {\n        results.push(\n          ...extractFromObj(\n            (obj as Record<string, unknown>)[token],\n            tokens,\n            pos + 1\n          )\n        );\n      }\n    }\n\n    return results;\n  }\n\n  return extractFromObj(obj, tokens, 0);\n}\n\n/**\n * Calculate cosine similarity between two vectors.\n */\nexport function cosineSimilarity(vector1: number[], vector2: number[]): number {\n  if (vector1.length !== vector2.length) {\n    throw new Error(\"Vectors must have the same length\");\n  }\n\n  const dotProduct = vector1.reduce((acc, val, i) => acc + val * vector2[i], 0);\n  const magnitude1 = Math.sqrt(\n    vector1.reduce((acc, val) => acc + val * val, 0)\n  );\n  const magnitude2 = Math.sqrt(\n    vector2.reduce((acc, val) => acc + val * val, 0)\n  );\n\n  if (magnitude1 === 0 || magnitude2 === 0) return 0;\n  return dotProduct / (magnitude1 * magnitude2);\n}\n","// @ts-nocheck\n\n// Inlined because of ESM import issues\n\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2013-2021 Joachim Wester\n * MIT license\n */\ndeclare var require: any;\n\nimport {\n  PatchError,\n  _deepClone,\n  isInteger,\n  unescapePathComponent,\n  hasUndefined,\n} from \"./helpers.js\";\n\nexport const JsonPatchError = PatchError;\nexport const deepClone = _deepClone;\n\nexport type Operation =\n  | AddOperation<any>\n  | RemoveOperation\n  | ReplaceOperation<any>\n  | MoveOperation\n  | CopyOperation\n  | TestOperation<any>\n  | GetOperation<any>;\n\nexport interface Validator<T> {\n  (\n    operation: Operation,\n    index: number,\n    document: T,\n    existingPathFragment: string\n  ): void;\n}\n\nexport interface OperationResult<T> {\n  removed?: any;\n  test?: boolean;\n  newDocument: T;\n}\n\nexport interface BaseOperation {\n  path: string;\n}\n\nexport interface AddOperation<T> extends BaseOperation {\n  op: \"add\";\n  value: T;\n}\n\nexport interface RemoveOperation extends BaseOperation {\n  op: \"remove\";\n}\n\nexport interface ReplaceOperation<T> extends BaseOperation {\n  op: \"replace\";\n  value: T;\n}\n\nexport interface MoveOperation extends BaseOperation {\n  op: \"move\";\n  from: string;\n}\n\nexport interface CopyOperation extends BaseOperation {\n  op: \"copy\";\n  from: string;\n}\n\nexport interface TestOperation<T> extends BaseOperation {\n  op: \"test\";\n  value: T;\n}\n\nexport interface GetOperation<T> extends BaseOperation {\n  op: \"_get\";\n  value: T;\n}\nexport interface PatchResult<T> extends Array<OperationResult<T>> {\n  newDocument: T;\n}\n\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n\n/* The operations applicable to an object */\nconst objOps = {\n  add: function (obj, key, document) {\n    obj[key] = this.value;\n    return { newDocument: document };\n  },\n  remove: function (obj, key, document) {\n    var removed = obj[key];\n    delete obj[key];\n    return { newDocument: document, removed };\n  },\n  replace: function (obj, key, document) {\n    var removed = obj[key];\n    obj[key] = this.value;\n    return { newDocument: document, removed };\n  },\n  move: function (obj, key, document) {\n    /* in case move target overwrites an existing value,\n    return the removed value, this can be taxing performance-wise,\n    and is potentially unneeded */\n    let removed = getValueByPointer(document, this.path);\n\n    if (removed) {\n      removed = _deepClone(removed);\n    }\n\n    const originalValue = applyOperation(document, {\n      op: \"remove\",\n      path: this.from,\n    }).removed;\n\n    applyOperation(document, {\n      op: \"add\",\n      path: this.path,\n      value: originalValue,\n    });\n\n    return { newDocument: document, removed };\n  },\n  copy: function (obj, key, document) {\n    const valueToCopy = getValueByPointer(document, this.from);\n    // enforce copy by value so further operations don't affect source (see issue #177)\n    applyOperation(document, {\n      op: \"add\",\n      path: this.path,\n      value: _deepClone(valueToCopy),\n    });\n    return { newDocument: document };\n  },\n  test: function (obj, key, document) {\n    return { newDocument: document, test: _areEquals(obj[key], this.value) };\n  },\n  _get: function (obj, key, document) {\n    this.value = obj[key];\n    return { newDocument: document };\n  },\n};\n\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n  add: function (arr, i, document) {\n    if (isInteger(i)) {\n      arr.splice(i, 0, this.value);\n    } else {\n      // array props\n      arr[i] = this.value;\n    }\n    // this may be needed when using '-' in an array\n    return { newDocument: document, index: i };\n  },\n  remove: function (arr, i, document) {\n    var removedList = arr.splice(i, 1);\n    return { newDocument: document, removed: removedList[0] };\n  },\n  replace: function (arr, i, document) {\n    var removed = arr[i];\n    arr[i] = this.value;\n    return { newDocument: document, removed };\n  },\n  move: objOps.move,\n  copy: objOps.copy,\n  test: objOps.test,\n  _get: objOps._get,\n};\n\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nexport function getValueByPointer(document: any, pointer: string): any {\n  if (pointer == \"\") {\n    return document;\n  }\n  var getOriginalDestination = <GetOperation<any>>{ op: \"_get\", path: pointer };\n  applyOperation(document, getOriginalDestination);\n  return getOriginalDestination.value;\n}\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nexport function applyOperation<T>(\n  document: T,\n  operation: Operation,\n  validateOperation: boolean | Validator<T> = false,\n  mutateDocument: boolean = true,\n  banPrototypeModifications: boolean = true,\n  index: number = 0\n): OperationResult<T> {\n  if (validateOperation) {\n    if (typeof validateOperation == \"function\") {\n      validateOperation(operation, 0, document, operation.path);\n    } else {\n      validator(operation, 0);\n    }\n  }\n  /* ROOT OPERATIONS */\n  if (operation.path === \"\") {\n    let returnValue: OperationResult<T> = { newDocument: document };\n    if (operation.op === \"add\") {\n      returnValue.newDocument = operation.value;\n      return returnValue;\n    } else if (operation.op === \"replace\") {\n      returnValue.newDocument = operation.value;\n      returnValue.removed = document; //document we removed\n      return returnValue;\n    } else if (operation.op === \"move\" || operation.op === \"copy\") {\n      // it's a move or copy to root\n      returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n      if (operation.op === \"move\") {\n        // report removed item\n        returnValue.removed = document;\n      }\n      return returnValue;\n    } else if (operation.op === \"test\") {\n      returnValue.test = _areEquals(document, operation.value);\n      if (returnValue.test === false) {\n        throw new JsonPatchError(\n          \"Test operation failed\",\n          \"TEST_OPERATION_FAILED\",\n          index,\n          operation,\n          document\n        );\n      }\n      returnValue.newDocument = document;\n      return returnValue;\n    } else if (operation.op === \"remove\") {\n      // a remove on root\n      returnValue.removed = document;\n      returnValue.newDocument = null;\n      return returnValue;\n    } else if (operation.op === \"_get\") {\n      operation.value = document;\n      return returnValue;\n    } else {\n      /* bad operation */\n      if (validateOperation) {\n        throw new JsonPatchError(\n          \"Operation `op` property is not one of operations defined in RFC-6902\",\n          \"OPERATION_OP_INVALID\",\n          index,\n          operation,\n          document\n        );\n      } else {\n        return returnValue;\n      }\n    }\n  } /* END ROOT OPERATIONS */ else {\n    if (!mutateDocument) {\n      document = _deepClone(document);\n    }\n    const path = operation.path || \"\";\n    const keys = path.split(\"/\");\n    let obj = document;\n    let t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n    let len = keys.length;\n    let existingPathFragment = undefined;\n    let key: string | number;\n    let validateFunction;\n    if (typeof validateOperation == \"function\") {\n      validateFunction = validateOperation;\n    } else {\n      validateFunction = validator;\n    }\n    while (true) {\n      key = keys[t];\n      if (key && key.indexOf(\"~\") != -1) {\n        key = unescapePathComponent(key);\n      }\n\n      if (\n        banPrototypeModifications &&\n        (key == \"__proto__\" ||\n          (key == \"prototype\" && t > 0 && keys[t - 1] == \"constructor\"))\n      ) {\n        throw new TypeError(\n          \"JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README\"\n        );\n      }\n\n      if (validateOperation) {\n        if (existingPathFragment === undefined) {\n          if (obj[key] === undefined) {\n            existingPathFragment = keys.slice(0, t).join(\"/\");\n          } else if (t == len - 1) {\n            existingPathFragment = operation.path;\n          }\n          if (existingPathFragment !== undefined) {\n            validateFunction(operation, 0, document, existingPathFragment);\n          }\n        }\n      }\n      t++;\n      if (Array.isArray(obj)) {\n        if (key === \"-\") {\n          key = obj.length;\n        } else {\n          if (validateOperation && !isInteger(key)) {\n            throw new JsonPatchError(\n              \"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\",\n              \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\",\n              index,\n              operation,\n              document\n            );\n          } // only parse key when it's an integer for `arr.prop` to work\n          else if (isInteger(key)) {\n            key = ~~key;\n          }\n        }\n        if (t >= len) {\n          if (validateOperation && operation.op === \"add\" && key > obj.length) {\n            throw new JsonPatchError(\n              \"The specified index MUST NOT be greater than the number of elements in the array\",\n              \"OPERATION_VALUE_OUT_OF_BOUNDS\",\n              index,\n              operation,\n              document\n            );\n          }\n          const returnValue = arrOps[operation.op].call(\n            operation,\n            obj,\n            key,\n            document\n          ); // Apply patch\n          if (returnValue.test === false) {\n            throw new JsonPatchError(\n              \"Test operation failed\",\n              \"TEST_OPERATION_FAILED\",\n              index,\n              operation,\n              document\n            );\n          }\n          return returnValue;\n        }\n      } else {\n        if (t >= len) {\n          const returnValue = objOps[operation.op].call(\n            operation,\n            obj,\n            key,\n            document\n          ); // Apply patch\n          if (returnValue.test === false) {\n            throw new JsonPatchError(\n              \"Test operation failed\",\n              \"TEST_OPERATION_FAILED\",\n              index,\n              operation,\n              document\n            );\n          }\n          return returnValue;\n        }\n      }\n      obj = obj[key];\n      // If we have more keys in the path, but the next value isn't a non-null object,\n      // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n      if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n        throw new JsonPatchError(\n          \"Cannot perform operation at the desired path\",\n          \"OPERATION_PATH_UNRESOLVABLE\",\n          index,\n          operation,\n          document\n        );\n      }\n    }\n  }\n}\n\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nexport function applyPatch<T>(\n  document: T,\n  patch: ReadonlyArray<Operation>,\n  validateOperation?: boolean | Validator<T>,\n  mutateDocument: boolean = true,\n  banPrototypeModifications: boolean = true\n): PatchResult<T> {\n  if (validateOperation) {\n    if (!Array.isArray(patch)) {\n      throw new JsonPatchError(\n        \"Patch sequence must be an array\",\n        \"SEQUENCE_NOT_AN_ARRAY\"\n      );\n    }\n  }\n  if (!mutateDocument) {\n    document = _deepClone(document);\n  }\n  const results = new Array(patch.length) as PatchResult<T>;\n\n  for (let i = 0, length = patch.length; i < length; i++) {\n    // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n    results[i] = applyOperation(\n      document,\n      patch[i],\n      validateOperation,\n      true,\n      banPrototypeModifications,\n      i\n    );\n    document = results[i].newDocument; // in case root was replaced\n  }\n  results.newDocument = document;\n  return results;\n}\n\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nexport function applyReducer<T>(\n  document: T,\n  operation: Operation,\n  index: number\n): T {\n  const operationResult: OperationResult<T> = applyOperation(\n    document,\n    operation\n  );\n  if (operationResult.test === false) {\n    // failed test\n    throw new JsonPatchError(\n      \"Test operation failed\",\n      \"TEST_OPERATION_FAILED\",\n      index,\n      operation,\n      document\n    );\n  }\n  return operationResult.newDocument;\n}\n\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nexport function validator(\n  operation: Operation,\n  index: number,\n  document?: any,\n  existingPathFragment?: string\n): void {\n  if (\n    typeof operation !== \"object\" ||\n    operation === null ||\n    Array.isArray(operation)\n  ) {\n    throw new JsonPatchError(\n      \"Operation is not an object\",\n      \"OPERATION_NOT_AN_OBJECT\",\n      index,\n      operation,\n      document\n    );\n  } else if (!objOps[operation.op]) {\n    throw new JsonPatchError(\n      \"Operation `op` property is not one of operations defined in RFC-6902\",\n      \"OPERATION_OP_INVALID\",\n      index,\n      operation,\n      document\n    );\n  } else if (typeof operation.path !== \"string\") {\n    throw new JsonPatchError(\n      \"Operation `path` property is not a string\",\n      \"OPERATION_PATH_INVALID\",\n      index,\n      operation,\n      document\n    );\n  } else if (operation.path.indexOf(\"/\") !== 0 && operation.path.length > 0) {\n    // paths that aren't empty string should start with \"/\"\n    throw new JsonPatchError(\n      'Operation `path` property must start with \"/\"',\n      \"OPERATION_PATH_INVALID\",\n      index,\n      operation,\n      document\n    );\n  } else if (\n    (operation.op === \"move\" || operation.op === \"copy\") &&\n    typeof operation.from !== \"string\"\n  ) {\n    throw new JsonPatchError(\n      \"Operation `from` property is not present (applicable in `move` and `copy` operations)\",\n      \"OPERATION_FROM_REQUIRED\",\n      index,\n      operation,\n      document\n    );\n  } else if (\n    (operation.op === \"add\" ||\n      operation.op === \"replace\" ||\n      operation.op === \"test\") &&\n    operation.value === undefined\n  ) {\n    throw new JsonPatchError(\n      \"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\",\n      \"OPERATION_VALUE_REQUIRED\",\n      index,\n      operation,\n      document\n    );\n  } else if (\n    (operation.op === \"add\" ||\n      operation.op === \"replace\" ||\n      operation.op === \"test\") &&\n    hasUndefined(operation.value)\n  ) {\n    throw new JsonPatchError(\n      \"Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)\",\n      \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\",\n      index,\n      operation,\n      document\n    );\n  } else if (document) {\n    if (operation.op == \"add\") {\n      var pathLen = operation.path.split(\"/\").length;\n      var existingPathLen = existingPathFragment.split(\"/\").length;\n      if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n        throw new JsonPatchError(\n          \"Cannot perform an `add` operation at the desired path\",\n          \"OPERATION_PATH_CANNOT_ADD\",\n          index,\n          operation,\n          document\n        );\n      }\n    } else if (\n      operation.op === \"replace\" ||\n      operation.op === \"remove\" ||\n      <any>operation.op === \"_get\"\n    ) {\n      if (operation.path !== existingPathFragment) {\n        throw new JsonPatchError(\n          \"Cannot perform the operation at a path that does not exist\",\n          \"OPERATION_PATH_UNRESOLVABLE\",\n          index,\n          operation,\n          document\n        );\n      }\n    } else if (operation.op === \"move\" || operation.op === \"copy\") {\n      var existingValue: any = {\n        op: \"_get\",\n        path: operation.from,\n        value: undefined,\n      };\n      var error = validate([existingValue], document);\n      if (error && error.name === \"OPERATION_PATH_UNRESOLVABLE\") {\n        throw new JsonPatchError(\n          \"Cannot perform the operation from a path that does not exist\",\n          \"OPERATION_FROM_UNRESOLVABLE\",\n          index,\n          operation,\n          document\n        );\n      }\n    }\n  }\n}\n\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nexport function validate<T>(\n  sequence: ReadonlyArray<Operation>,\n  document?: T,\n  externalValidator?: Validator<T>\n): PatchError {\n  try {\n    if (!Array.isArray(sequence)) {\n      throw new JsonPatchError(\n        \"Patch sequence must be an array\",\n        \"SEQUENCE_NOT_AN_ARRAY\"\n      );\n    }\n    if (document) {\n      //clone document and sequence so that we can safely try applying operations\n      applyPatch(\n        _deepClone(document),\n        _deepClone(sequence),\n        externalValidator || true\n      );\n    } else {\n      externalValidator = externalValidator || validator;\n      for (var i = 0; i < sequence.length; i++) {\n        externalValidator(sequence[i], i, document, undefined);\n      }\n    }\n  } catch (e) {\n    if (e instanceof JsonPatchError) {\n      return e;\n    } else {\n      throw e;\n    }\n  }\n}\n\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n\n// Copyright (c) 2017 Evgeny Poberezkin\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nexport function _areEquals(a: any, b: any): boolean {\n  if (a === b) return true;\n\n  if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n    var arrA = Array.isArray(a),\n      arrB = Array.isArray(b),\n      i,\n      length,\n      key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0; ) if (!_areEquals(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var keys = Object.keys(a);\n    length = keys.length;\n\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0; ) if (!b.hasOwnProperty(keys[i])) return false;\n\n    for (i = length; i-- !== 0; ) {\n      key = keys[i];\n      if (!_areEquals(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a !== a && b !== b;\n}\n","import { z } from \"zod/v3\";\nimport pRetry from \"p-retry\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nimport {\n  type TraceableFunction,\n  isTraceableFunction,\n} from \"langsmith/singletons/traceable\";\nimport type {\n  RunnableInterface,\n  RunnableBatchOptions,\n  RunnableConfig,\n} from \"./types.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport {\n  LogStreamCallbackHandler,\n  LogStreamCallbackHandlerInput,\n  RunLog,\n  RunLogPatch,\n  isLogStreamHandler,\n} from \"../tracers/log_stream.js\";\nimport {\n  EventStreamCallbackHandler,\n  EventStreamCallbackHandlerInput,\n  StreamEvent,\n  StreamEventData,\n  isStreamEventsHandler,\n} from \"../tracers/event_stream.js\";\nimport { Serializable } from \"../load/serializable.js\";\nimport {\n  IterableReadableStream,\n  concat,\n  atee,\n  pipeGeneratorWithSetup,\n  AsyncGeneratorWithSetup,\n} from \"../utils/stream.js\";\nimport { raceWithSignal, getAbortSignalError } from \"../utils/signal.js\";\nimport {\n  DEFAULT_RECURSION_LIMIT,\n  ensureConfig,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  pickRunnableConfigKeys,\n} from \"./config.js\";\nimport { AsyncCaller } from \"../utils/async_caller.js\";\nimport { Run } from \"../tracers/base.js\";\nimport { RootListenersTracer } from \"../tracers/root_listener.js\";\nimport { _RootEventFilter, isRunnableInterface } from \"./utils.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { Graph } from \"./graph.js\";\nimport { convertToHttpEventStream } from \"./wrappers.js\";\nimport {\n  consumeAsyncIterableInContext,\n  consumeIteratorInContext,\n  isAsyncIterable,\n  isIterableIterator,\n  isIterator,\n} from \"./iter.js\";\nimport { _isToolCall, ToolInputParsingException } from \"../tools/utils.js\";\nimport { ToolCall } from \"../messages/tool.js\";\nimport {\n  getSchemaDescription,\n  InferInteropZodOutput,\n  interopParseAsync,\n  InteropZodType,\n  isSimpleStringZodSchema,\n} from \"../utils/types/zod.js\";\n\nexport { type RunnableInterface, RunnableBatchOptions };\n\nexport type RunnableFunc<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> = (\n  input: RunInput,\n  options:\n    | CallOptions\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | Record<string, any>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    | (Record<string, any> & CallOptions)\n) => RunOutput | Promise<RunOutput>;\n\nexport type RunnableMapLike<RunInput, RunOutput> = {\n  [K in keyof RunOutput]: RunnableLike<RunInput, RunOutput[K]>;\n};\n\nexport type RunnableLike<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends RunnableConfig = RunnableConfig\n> =\n  | RunnableInterface<RunInput, RunOutput, CallOptions>\n  | RunnableFunc<RunInput, RunOutput, CallOptions>\n  | RunnableMapLike<RunInput, RunOutput>;\n\nexport type RunnableRetryFailedAttemptHandler = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error: any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\n/**\n * A Runnable is a generic unit of work that can be invoked, batched, streamed, and/or\n * transformed.\n */\nexport abstract class Runnable<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput = any,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Serializable\n  implements RunnableInterface<RunInput, RunOutput, CallOptions>\n{\n  protected lc_runnable = true;\n\n  name?: string;\n\n  getName(suffix?: string): string {\n    const name =\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      this.name ?? (this.constructor as any).lc_name() ?? this.constructor.name;\n    return suffix ? `${name}${suffix}` : name;\n  }\n\n  abstract invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput>;\n\n  /**\n   * Add retry logic to an existing runnable.\n   * @param fields.stopAfterAttempt The number of attempts to retry.\n   * @param fields.onFailedAttempt A function that is called when a retry fails.\n   * @returns A new RunnableRetry that, when invoked, will retry according to the parameters.\n   */\n  withRetry(fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }): RunnableRetry<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this,\n      kwargs: {},\n      config: {},\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields,\n    });\n  }\n\n  /**\n   * Bind config to a Runnable, returning a new Runnable.\n   * @param config New configuration parameters to attach to the new runnable.\n   * @returns A new RunnableBinding with a config matching what's passed.\n   */\n  withConfig(\n    config: Partial<CallOptions>\n  ): Runnable<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding({\n      bound: this,\n      config,\n      kwargs: {},\n    });\n  }\n\n  /**\n   * Create a new runnable from the current one that will try invoking\n   * other passed fallback runnables if the initial invocation fails.\n   * @param fields.fallbacks Other runnables to call if the runnable errors.\n   * @returns A new RunnableWithFallbacks.\n   */\n  withFallbacks(\n    fields:\n      | {\n          fallbacks: Runnable<RunInput, RunOutput>[];\n        }\n      | Runnable<RunInput, RunOutput>[]\n  ): RunnableWithFallbacks<RunInput, RunOutput> {\n    const fallbacks = Array.isArray(fields) ? fields : fields.fallbacks;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableWithFallbacks<RunInput, RunOutput>({\n      runnable: this,\n      fallbacks,\n    });\n  }\n\n  protected _getOptionsList<O extends CallOptions & { runType?: string }>(\n    options: Partial<O> | Partial<O>[],\n    length = 0\n  ): Partial<O>[] {\n    if (Array.isArray(options) && options.length !== length) {\n      throw new Error(\n        `Passed \"options\" must be an array with the same length as the inputs, but got ${options.length} options for ${length} inputs`\n      );\n    }\n\n    if (Array.isArray(options)) {\n      return options.map(ensureConfig);\n    }\n    if (length > 1 && !Array.isArray(options) && options.runId) {\n      console.warn(\n        \"Provided runId will be used only for the first element of the batch.\"\n      );\n      const subsequent = Object.fromEntries(\n        Object.entries(options).filter(([key]) => key !== \"runId\")\n      );\n\n      return Array.from({ length }, (_, i) =>\n        ensureConfig(i === 0 ? options : subsequent)\n      ) as Partial<O>[];\n    }\n    return Array.from({ length }, () => ensureConfig(options));\n  }\n\n  /**\n   * Default implementation of batch, which calls invoke N times.\n   * Subclasses should override this method if they can batch more efficiently.\n   * @param inputs Array of inputs to each batch call.\n   * @param options Either a single call options object to apply to each batch call or an array for each call.\n   * @param batchOptions.returnExceptions Whether to return errors rather than throwing on the first one\n   * @returns An array of RunOutputs, or mixed RunOutputs and errors if batchOptions.returnExceptions is set\n   */\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      configList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const caller = new AsyncCaller({\n      maxConcurrency,\n      onFailedAttempt: (e) => {\n        throw e;\n      },\n    });\n    const batchCalls = inputs.map((input, i) =>\n      caller.call(async () => {\n        try {\n          const result = await this.invoke(input, configList[i]);\n          return result;\n        } catch (e) {\n          if (batchOptions?.returnExceptions) {\n            return e as Error;\n          }\n          throw e;\n        }\n      })\n    );\n    return Promise.all(batchCalls);\n  }\n\n  /**\n   * Default streaming implementation.\n   * Subclasses should override this method if they support streaming output.\n   * @param input\n   * @param options\n   */\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    yield this.invoke(input, options);\n  }\n\n  /**\n   * Stream output in chunks.\n   * @param input\n   * @param options\n   * @returns A readable stream that is also an iterable.\n   */\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    // Buffer the first streamed chunk to allow for initial errors\n    // to surface immediately.\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this._streamIterator(input, config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n\n  protected _separateRunnableConfigFromCallOptions(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, Omit<Partial<CallOptions>, keyof RunnableConfig>] {\n    let runnableConfig;\n    if (options === undefined) {\n      runnableConfig = ensureConfig(options);\n    } else {\n      runnableConfig = ensureConfig({\n        callbacks: options.callbacks,\n        tags: options.tags,\n        metadata: options.metadata,\n        runName: options.runName,\n        configurable: options.configurable,\n        recursionLimit: options.recursionLimit,\n        maxConcurrency: options.maxConcurrency,\n        runId: options.runId,\n        timeout: options.timeout,\n        signal: options.signal,\n      });\n    }\n    const callOptions = { ...(options as Partial<CallOptions>) };\n    delete callOptions.callbacks;\n    delete callOptions.tags;\n    delete callOptions.metadata;\n    delete callOptions.runName;\n    delete callOptions.configurable;\n    delete callOptions.recursionLimit;\n    delete callOptions.maxConcurrency;\n    delete callOptions.runId;\n    delete callOptions.timeout;\n    delete callOptions.signal;\n    return [runnableConfig, callOptions];\n  }\n\n  protected async _callWithConfig<T extends RunInput>(\n    func:\n      | ((input: T) => Promise<RunOutput>)\n      | ((\n          input: T,\n          config?: Partial<CallOptions>,\n          runManager?: CallbackManagerForChainRun\n        ) => Promise<RunOutput>),\n    input: T,\n    options?: Partial<CallOptions> & { runType?: string }\n  ) {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config.runId,\n      config?.runType,\n      undefined,\n      undefined,\n      config?.runName ?? this.getName()\n    );\n    delete config.runId;\n    let output;\n    try {\n      const promise = func.call(this, input, config, runManager);\n      output = await raceWithSignal(promise, options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n    return output;\n  }\n\n  /**\n   * Internal method that handles batching and configuration for a runnable\n   * It takes a function, input values, and optional configuration, and\n   * returns a promise that resolves to the output values.\n   * @param func The function to be executed for each input value.\n   * @param input The input values to be processed.\n   * @param config Optional configuration for the function execution.\n   * @returns A promise that resolves to the output values.\n   */\n  async _batchWithConfig<T extends RunInput>(\n    func: (\n      inputs: T[],\n      options?: Partial<CallOptions>[],\n      runManagers?: (CallbackManagerForChainRun | undefined)[],\n      batchOptions?: RunnableBatchOptions\n    ) => Promise<(RunOutput | Error)[]>,\n    inputs: T[],\n    options?:\n      | Partial<CallOptions & { runType?: string }>\n      | Partial<CallOptions & { runType?: string }>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      optionsList.map(getCallbackManagerForConfig)\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          optionsList[i].runId,\n          optionsList[i].runType,\n          undefined,\n          undefined,\n          optionsList[i].runName ?? this.getName()\n        );\n        delete optionsList[i].runId;\n        return handleStartRes;\n      })\n    );\n    let outputs: (RunOutput | Error)[];\n    try {\n      const promise = func.call(\n        this,\n        inputs,\n        optionsList,\n        runManagers,\n        batchOptions\n      );\n      outputs = await raceWithSignal(promise, optionsList?.[0]?.signal);\n    } catch (e) {\n      await Promise.all(\n        runManagers.map((runManager) => runManager?.handleChainError(e))\n      );\n      throw e;\n    }\n    await Promise.all(\n      runManagers.map((runManager) =>\n        runManager?.handleChainEnd(_coerceToDict(outputs, \"output\"))\n      )\n    );\n    return outputs;\n  }\n\n  /** @internal */\n  _concatOutputChunks<O>(first: O, second: O): O {\n    return concat(first, second);\n  }\n\n  /**\n   * Helper method to transform an Iterator of Input values into an Iterator of\n   * Output values, with callbacks.\n   * Use this to implement `stream()` or `transform()` in Runnable subclasses.\n   */\n  protected async *_transformStreamWithConfig<\n    I extends RunInput,\n    O extends RunOutput\n  >(\n    inputGenerator: AsyncGenerator<I>,\n    transformer: (\n      generator: AsyncGenerator<I>,\n      runManager?: CallbackManagerForChainRun,\n      options?: Partial<CallOptions>\n    ) => AsyncGenerator<O>,\n    options?: Partial<CallOptions> & { runType?: string }\n  ): AsyncGenerator<O> {\n    let finalInput: I | undefined;\n    let finalInputSupported = true;\n    let finalOutput: O | undefined;\n    let finalOutputSupported = true;\n\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const outerThis = this;\n    async function* wrapInputForTracing() {\n      for await (const chunk of inputGenerator) {\n        if (finalInputSupported) {\n          if (finalInput === undefined) {\n            finalInput = chunk;\n          } else {\n            try {\n              finalInput = outerThis._concatOutputChunks(\n                finalInput,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                chunk as any\n              );\n            } catch {\n              finalInput = undefined;\n              finalInputSupported = false;\n            }\n          }\n        }\n        yield chunk;\n      }\n    }\n\n    let runManager: CallbackManagerForChainRun | undefined;\n    try {\n      const pipe = await pipeGeneratorWithSetup(\n        transformer.bind(this),\n        wrapInputForTracing(),\n        async () =>\n          callbackManager_?.handleChainStart(\n            this.toJSON(),\n            { input: \"\" },\n            config.runId,\n            config.runType,\n            undefined,\n            undefined,\n            config.runName ?? this.getName()\n          ),\n        options?.signal,\n        config\n      );\n      delete config.runId;\n      runManager = pipe.setup;\n\n      const streamEventsHandler = runManager?.handlers.find(\n        isStreamEventsHandler\n      );\n      let iterator = pipe.output;\n      if (streamEventsHandler !== undefined && runManager !== undefined) {\n        iterator = streamEventsHandler.tapOutputIterable(\n          runManager.runId,\n          iterator\n        );\n      }\n\n      const streamLogHandler = runManager?.handlers.find(isLogStreamHandler);\n      if (streamLogHandler !== undefined && runManager !== undefined) {\n        iterator = streamLogHandler.tapOutputIterable(\n          runManager.runId,\n          iterator\n        );\n      }\n\n      for await (const chunk of iterator) {\n        yield chunk;\n        if (finalOutputSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              finalOutput = this._concatOutputChunks(\n                finalOutput,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                chunk as any\n              );\n            } catch {\n              finalOutput = undefined;\n              finalOutputSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e, undefined, undefined, undefined, {\n        inputs: _coerceToDict(finalInput, \"input\"),\n      });\n      throw e;\n    }\n    await runManager?.handleChainEnd(\n      finalOutput ?? {},\n      undefined,\n      undefined,\n      undefined,\n      { inputs: _coerceToDict(finalInput, \"input\") }\n    );\n  }\n\n  getGraph(_?: RunnableConfig): Graph {\n    const graph = new Graph();\n\n    // TODO: Add input schema for runnables\n    const inputNode = graph.addNode({\n      name: `${this.getName()}Input`,\n      schema: z.any(),\n    });\n\n    const runnableNode = graph.addNode(this);\n\n    // TODO: Add output schemas for runnables\n    const outputNode = graph.addNode({\n      name: `${this.getName()}Output`,\n      schema: z.any(),\n    });\n\n    graph.addEdge(inputNode, runnableNode);\n    graph.addEdge(runnableNode, outputNode);\n    return graph;\n  }\n\n  /**\n   * Create a new runnable sequence that runs each individual runnable in series,\n   * piping the output of one runnable into another runnable or runnable-like.\n   * @param coerceable A runnable, function, or object whose values are functions or runnables.\n   * @returns A new runnable sequence.\n   */\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<RunOutput, NewRunOutput>\n  ): Runnable<RunInput, Exclude<NewRunOutput, Error>> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableSequence({\n      first: this,\n      last: _coerceToRunnable(coerceable),\n    });\n  }\n\n  /**\n   * Pick keys from the dict output of this runnable. Returns a new runnable.\n   */\n  pick(keys: string | string[]): Runnable {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return this.pipe(new RunnablePick(keys) as Runnable);\n  }\n\n  /**\n   * Assigns new fields to the dict output of this runnable. Returns a new runnable.\n   */\n  assign(\n    mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>\n  ): Runnable {\n    return this.pipe(\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      new RunnableAssign(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        new RunnableMap<Record<string, unknown>>({ steps: mapping })\n      ) as Runnable\n    );\n  }\n\n  /**\n   * Default implementation of transform, which buffers input and then calls stream.\n   * Subclasses should override this method if they can start producing output while\n   * input is still being generated.\n   * @param generator\n   * @param options\n   */\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    let finalChunk;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        // This method should throw an error if gathering fails.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        finalChunk = this._concatOutputChunks(finalChunk, chunk as any);\n      }\n    }\n    yield* this._streamIterator(finalChunk, ensureConfig(options));\n  }\n\n  /**\n   * Stream all output from a runnable, as reported to the callback system.\n   * This includes all inner runs of LLMs, Retrievers, Tools, etc.\n   * Output is streamed as Log objects, which include a list of\n   * jsonpatch ops that describe how the state of the run has changed in each\n   * step, and the final state of the run.\n   * The jsonpatch ops can be applied in order to construct state.\n   * @param input\n   * @param options\n   * @param streamOptions\n   */\n  async *streamLog(\n    input: RunInput,\n    options?: Partial<CallOptions>,\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<RunLogPatch> {\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"original\",\n    });\n    const config = ensureConfig(options);\n    yield* this._streamLog(input, logStreamCallbackHandler, config);\n  }\n\n  protected async *_streamLog(\n    input: RunInput,\n    logStreamCallbackHandler: LogStreamCallbackHandler,\n    config: Partial<CallOptions>\n  ): AsyncGenerator<RunLogPatch> {\n    const { callbacks } = config;\n    if (callbacks === undefined) {\n      config.callbacks = [logStreamCallbackHandler];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat([logStreamCallbackHandler]);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(logStreamCallbackHandler, true);\n      config.callbacks = copiedCallbacks;\n    }\n    const runnableStreamPromise = this.stream(input, config);\n    async function consumeRunnableStream() {\n      try {\n        const runnableStream = await runnableStreamPromise;\n        for await (const chunk of runnableStream) {\n          const patch = new RunLogPatch({\n            ops: [\n              {\n                op: \"add\",\n                path: \"/streamed_output/-\",\n                value: chunk,\n              },\n            ],\n          });\n          await logStreamCallbackHandler.writer.write(patch);\n        }\n      } finally {\n        await logStreamCallbackHandler.writer.close();\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    try {\n      for await (const log of logStreamCallbackHandler) {\n        yield log;\n      }\n    } finally {\n      await runnableStreamConsumePromise;\n    }\n  }\n\n  /**\n   * Generate a stream of events emitted by the internal steps of the runnable.\n   *\n   * Use to create an iterator over StreamEvents that provide real-time information\n   * about the progress of the runnable, including StreamEvents from intermediate\n   * results.\n   *\n   * A StreamEvent is a dictionary with the following schema:\n   *\n   * - `event`: string - Event names are of the format: on_[runnable_type]_(start|stream|end).\n   * - `name`: string - The name of the runnable that generated the event.\n   * - `run_id`: string - Randomly generated ID associated with the given execution of\n   *   the runnable that emitted the event. A child runnable that gets invoked as part of the execution of a\n   *   parent runnable is assigned its own unique ID.\n   * - `tags`: string[] - The tags of the runnable that generated the event.\n   * - `metadata`: Record<string, any> - The metadata of the runnable that generated the event.\n   * - `data`: Record<string, any>\n   *\n   * Below is a table that illustrates some events that might be emitted by various\n   * chains. Metadata fields have been omitted from the table for brevity.\n   * Chain definitions have been included after the table.\n   *\n   * **ATTENTION** This reference table is for the V2 version of the schema.\n   *\n   * ```md\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | event                | input                       | output/chunk                             |\n   * +======================+=============================+==========================================+\n   * | on_chat_model_start  | {\"messages\": BaseMessage[]} |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chat_model_stream |                             | AIMessageChunk(\"hello\")                  |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chat_model_end    | {\"messages\": BaseMessage[]} | AIMessageChunk(\"hello world\")            |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_start         | {'input': 'hello'}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_stream        |                             | 'Hello'                                  |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_llm_end           | 'Hello human!'              |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_start       |                             |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_stream      |                             | \"hello world!\"                           |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_chain_end         | [Document(...)]             | \"hello world!, goodbye world!\"           |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_tool_start        | {\"x\": 1, \"y\": \"2\"}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_tool_end          |                             | {\"x\": 1, \"y\": \"2\"}                       |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_retriever_start   | {\"query\": \"hello\"}          |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_retriever_end     | {\"query\": \"hello\"}          | [Document(...), ..]                      |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_prompt_start      | {\"question\": \"hello\"}       |                                          |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * | on_prompt_end        | {\"question\": \"hello\"}       | ChatPromptValue(messages: BaseMessage[]) |\n   * +----------------------+-----------------------------+------------------------------------------+\n   * ```\n   *\n   * The \"on_chain_*\" events are the default for Runnables that don't fit one of the above categories.\n   *\n   * In addition to the standard events above, users can also dispatch custom events.\n   *\n   * Custom events will be only be surfaced with in the `v2` version of the API!\n   *\n   * A custom event has following format:\n   *\n   * ```md\n   * +-----------+------+------------------------------------------------------------+\n   * | Attribute | Type | Description                                                |\n   * +===========+======+============================================================+\n   * | name      | str  | A user defined name for the event.                         |\n   * +-----------+------+------------------------------------------------------------+\n   * | data      | Any  | The data associated with the event. This can be anything.  |\n   * +-----------+------+------------------------------------------------------------+\n   * ```\n   *\n   * Here's an example:\n   *\n   * ```ts\n   * import { RunnableLambda } from \"@langchain/core/runnables\";\n   * import { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch\";\n   * // Use this import for web environments that don't support \"async_hooks\"\n   * // and manually pass config to child runs.\n   * // import { dispatchCustomEvent } from \"@langchain/core/callbacks/dispatch/web\";\n   *\n   * const slowThing = RunnableLambda.from(async (someInput: string) => {\n   *   // Placeholder for some slow operation\n   *   await new Promise((resolve) => setTimeout(resolve, 100));\n   *   await dispatchCustomEvent(\"progress_event\", {\n   *    message: \"Finished step 1 of 2\",\n   *  });\n   *  await new Promise((resolve) => setTimeout(resolve, 100));\n   *  return \"Done\";\n   * });\n   *\n   * const eventStream = await slowThing.streamEvents(\"hello world\", {\n   *   version: \"v2\",\n   * });\n   *\n   * for await (const event of eventStream) {\n   *  if (event.event === \"on_custom_event\") {\n   *    console.log(event);\n   *  }\n   * }\n   * ```\n   */\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    let stream;\n    if (options.version === \"v1\") {\n      stream = this._streamEventsV1(input, options, streamOptions);\n    } else if (options.version === \"v2\") {\n      stream = this._streamEventsV2(input, options, streamOptions);\n    } else {\n      throw new Error(\n        `Only versions \"v1\" and \"v2\" of the schema are currently supported.`\n      );\n    }\n    if (options.encoding === \"text/event-stream\") {\n      return convertToHttpEventStream(stream);\n    } else {\n      return IterableReadableStream.fromAsyncGenerator(stream);\n    }\n  }\n\n  private async *_streamEventsV2(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<StreamEvent> {\n    const eventStreamer = new EventStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n    });\n    const config = ensureConfig(options);\n    const runId = config.runId ?? uuidv4();\n    config.runId = runId;\n    const callbacks = config.callbacks;\n    if (callbacks === undefined) {\n      config.callbacks = [eventStreamer];\n    } else if (Array.isArray(callbacks)) {\n      config.callbacks = callbacks.concat(eventStreamer);\n    } else {\n      const copiedCallbacks = callbacks.copy();\n      copiedCallbacks.addHandler(eventStreamer, true);\n      config.callbacks = copiedCallbacks;\n    }\n    const abortController = new AbortController();\n    // Call the runnable in streaming mode,\n    // add each chunk to the output stream\n    const outerThis = this;\n    async function consumeRunnableStream() {\n      let signal;\n      let listener: (() => void) | null = null;\n\n      try {\n        if (options?.signal) {\n          if (\"any\" in AbortSignal) {\n            // Use native AbortSignal.any() if available (Node 19+)\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signal = (AbortSignal as any).any([\n              abortController.signal,\n              options.signal,\n            ]);\n          } else {\n            // Fallback for Node 18 and below - just use the provided signal\n            signal = options.signal;\n            // Ensure we still abort our controller when the parent signal aborts\n\n            listener = () => {\n              abortController.abort();\n            };\n\n            options.signal.addEventListener(\"abort\", listener, { once: true });\n          }\n        } else {\n          signal = abortController.signal;\n        }\n        const runnableStream = await outerThis.stream(input, {\n          ...config,\n          signal,\n        });\n        const tappedStream = eventStreamer.tapOutputIterable(\n          runId,\n          runnableStream\n        );\n        for await (const _ of tappedStream) {\n          // Just iterate so that the callback handler picks up events\n          if (abortController.signal.aborted) break;\n        }\n      } finally {\n        await eventStreamer.finish();\n\n        if (signal && listener) {\n          signal.removeEventListener(\"abort\", listener);\n        }\n      }\n    }\n    const runnableStreamConsumePromise = consumeRunnableStream();\n    let firstEventSent = false;\n    let firstEventRunId;\n    try {\n      for await (const event of eventStreamer) {\n        // This is a work-around an issue where the inputs into the\n        // chain are not available until the entire input is consumed.\n        // As a temporary solution, we'll modify the input to be the input\n        // that was passed into the chain.\n        if (!firstEventSent) {\n          event.data.input = input;\n          firstEventSent = true;\n          firstEventRunId = event.run_id;\n          yield event;\n          continue;\n        }\n        if (event.run_id === firstEventRunId && event.event.endsWith(\"_end\")) {\n          // If it's the end event corresponding to the root runnable\n          // we dont include the input in the event since it's guaranteed\n          // to be included in the first event.\n          if (event.data?.input) {\n            delete event.data.input;\n          }\n        }\n        yield event;\n      }\n    } finally {\n      abortController.abort();\n      await runnableStreamConsumePromise;\n    }\n  }\n\n  private async *_streamEventsV1(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): AsyncGenerator<StreamEvent> {\n    let runLog;\n    let hasEncounteredStartEvent = false;\n    const config = ensureConfig(options);\n    const rootTags = config.tags ?? [];\n    const rootMetadata = config.metadata ?? {};\n    const rootName = config.runName ?? this.getName();\n    const logStreamCallbackHandler = new LogStreamCallbackHandler({\n      ...streamOptions,\n      autoClose: false,\n      _schemaFormat: \"streaming_events\",\n    });\n    const rootEventFilter = new _RootEventFilter({\n      ...streamOptions,\n    });\n    const logStream = this._streamLog(input, logStreamCallbackHandler, config);\n    for await (const log of logStream) {\n      if (!runLog) {\n        runLog = RunLog.fromRunLogPatch(log);\n      } else {\n        runLog = runLog.concat(log);\n      }\n      if (runLog.state === undefined) {\n        throw new Error(\n          `Internal error: \"streamEvents\" state is missing. Please open a bug report.`\n        );\n      }\n      // Yield the start event for the root runnable if it hasn't been seen.\n      // The root run is never filtered out\n      if (!hasEncounteredStartEvent) {\n        hasEncounteredStartEvent = true;\n        const state = { ...runLog.state };\n        const event: StreamEvent = {\n          run_id: state.id,\n          event: `on_${state.type}_start`,\n          name: rootName,\n          tags: rootTags,\n          metadata: rootMetadata,\n          data: {\n            input,\n          },\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n      const paths = log.ops\n        .filter((op) => op.path.startsWith(\"/logs/\"))\n        .map((op) => op.path.split(\"/\")[2]);\n      const dedupedPaths = [...new Set(paths)];\n      for (const path of dedupedPaths) {\n        let eventType;\n        let data: StreamEventData = {};\n        const logEntry = runLog.state.logs[path];\n        if (logEntry.end_time === undefined) {\n          if (logEntry.streamed_output.length > 0) {\n            eventType = \"stream\";\n          } else {\n            eventType = \"start\";\n          }\n        } else {\n          eventType = \"end\";\n        }\n        if (eventType === \"start\") {\n          // Include the inputs with the start event if they are available.\n          // Usually they will NOT be available for components that operate\n          // on streams, since those components stream the input and\n          // don't know its final value until the end of the stream.\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n        } else if (eventType === \"end\") {\n          if (logEntry.inputs !== undefined) {\n            data.input = logEntry.inputs;\n          }\n          data.output = logEntry.final_output;\n        } else if (eventType === \"stream\") {\n          const chunkCount = logEntry.streamed_output.length;\n          if (chunkCount !== 1) {\n            throw new Error(\n              `Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${logEntry.name}\"`\n            );\n          }\n          data = { chunk: logEntry.streamed_output[0] };\n          // Clean up the stream, we don't need it anymore.\n          // And this avoids duplicates as well!\n          logEntry.streamed_output = [];\n        }\n        yield {\n          event: `on_${logEntry.type}_${eventType}`,\n          name: logEntry.name,\n          run_id: logEntry.id,\n          tags: logEntry.tags,\n          metadata: logEntry.metadata,\n          data,\n        };\n      }\n      // Finally, we take care of the streaming output from the root chain\n      // if there is any.\n      const { state } = runLog;\n      if (state.streamed_output.length > 0) {\n        const chunkCount = state.streamed_output.length;\n        if (chunkCount !== 1) {\n          throw new Error(\n            `Expected exactly one chunk of streamed output, got ${chunkCount} instead. Encountered in: \"${state.name}\"`\n          );\n        }\n        const data = { chunk: state.streamed_output[0] };\n        // Clean up the stream, we don't need it anymore.\n        state.streamed_output = [];\n        const event = {\n          event: `on_${state.type}_stream`,\n          run_id: state.id,\n          tags: rootTags,\n          metadata: rootMetadata,\n          name: rootName,\n          data,\n        };\n        if (rootEventFilter.includeEvent(event, state.type)) {\n          yield event;\n        }\n      }\n    }\n    const state = runLog?.state;\n    if (state !== undefined) {\n      // Finally, yield the end event for the root runnable.\n      const event = {\n        event: `on_${state.type}_end`,\n        name: rootName,\n        run_id: state.id,\n        tags: rootTags,\n        metadata: rootMetadata,\n        data: {\n          output: state.final_output,\n        },\n      };\n      if (rootEventFilter.includeEvent(event, state.type)) yield event;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnable(thing: any): thing is Runnable {\n    return isRunnableInterface(thing);\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n  }): Runnable<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableBinding<RunInput, RunOutput, CallOptions>({\n      bound: this,\n      config: {},\n      configFactories: [\n        (config) => ({\n          callbacks: [\n            new RootListenersTracer({\n              config,\n              onStart,\n              onEnd,\n              onError,\n            }),\n          ],\n        }),\n      ],\n    });\n  }\n\n  /**\n   * Convert a runnable to a tool. Return a new instance of `RunnableToolLike`\n   * which contains the runnable, name, description and schema.\n   *\n   * @template {T extends RunInput = RunInput} RunInput - The input type of the runnable. Should be the same as the `RunInput` type of the runnable.\n   *\n   * @param fields\n   * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n   * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n   * @param {z.ZodType<T>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n   * @returns {RunnableToolLike<z.ZodType<T>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n   */\n  asTool<T extends RunInput = RunInput>(fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<T>;\n  }): RunnableToolLike<InteropZodType<T | ToolCall>, RunOutput> {\n    return convertRunnableToTool<T, RunOutput>(this, fields);\n  }\n}\n\nexport type RunnableBindingArgs<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> = {\n  bound: Runnable<RunInput, RunOutput, CallOptions>;\n  /** @deprecated Use {@link config} instead. */\n  kwargs?: Partial<CallOptions>;\n  config: RunnableConfig;\n  configFactories?: Array<\n    (config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>\n  >;\n};\n\n/**\n * Wraps a runnable and applies partial config upon invocation.\n *\n * @example\n * ```typescript\n * import {\n *   type RunnableConfig,\n *   RunnableLambda,\n * } from \"@langchain/core/runnables\";\n *\n * const enhanceProfile = (\n *   profile: Record<string, any>,\n *   config?: RunnableConfig\n * ) => {\n *   if (config?.configurable?.role) {\n *     return { ...profile, role: config.configurable.role };\n *   }\n *   return profile;\n * };\n *\n * const runnable = RunnableLambda.from(enhanceProfile);\n *\n * // Bind configuration to the runnable to set the user's role dynamically\n * const adminRunnable = runnable.withConfig({ configurable: { role: \"Admin\" } });\n * const userRunnable = runnable.withConfig({ configurable: { role: \"User\" } });\n *\n * const result1 = await adminRunnable.invoke({\n *   name: \"Alice\",\n *   email: \"alice@example.com\"\n * });\n *\n * // { name: \"Alice\", email: \"alice@example.com\", role: \"Admin\" }\n *\n * const result2 = await userRunnable.invoke({\n *   name: \"Bob\",\n *   email: \"bob@example.com\"\n * });\n *\n * // { name: \"Bob\", email: \"bob@example.com\", role: \"User\" }\n * ```\n */\nexport class RunnableBinding<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableBinding\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  bound: Runnable<RunInput, RunOutput, CallOptions>;\n\n  config: RunnableConfig;\n\n  kwargs?: Partial<CallOptions>;\n\n  configFactories?: Array<\n    (config: RunnableConfig) => RunnableConfig | Promise<RunnableConfig>\n  >;\n\n  constructor(fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>) {\n    super(fields);\n    this.bound = fields.bound;\n    this.kwargs = fields.kwargs;\n    this.config = fields.config;\n    this.configFactories = fields.configFactories;\n  }\n\n  getName(suffix?: string | undefined): string {\n    return this.bound.getName(suffix);\n  }\n\n  async _mergeConfig(\n    ...options: (Partial<CallOptions> | RunnableConfig | undefined)[]\n  ): Promise<Partial<CallOptions>> {\n    const config = mergeConfigs(this.config, ...options);\n    return mergeConfigs(\n      config,\n      ...(this.configFactories\n        ? await Promise.all(\n            this.configFactories.map(\n              async (configFactory) => await configFactory(config)\n            )\n          )\n        : [])\n    );\n  }\n\n  withConfig(\n    config: Partial<CallOptions>\n  ): Runnable<RunInput, RunOutput, CallOptions> {\n    return new (this.constructor as {\n      new (\n        fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>\n      ): RunnableBinding<RunInput, RunOutput, CallOptions>;\n    })({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: { ...this.config, ...config },\n    });\n  }\n\n  withRetry(fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }): RunnableRetry<RunInput, RunOutput, CallOptions> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunnableRetry({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      maxAttemptNumber: fields?.stopAfterAttempt,\n      ...fields,\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this.bound.invoke(\n      input,\n      await this._mergeConfig(options, this.kwargs)\n    );\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const mergedOptions = Array.isArray(options)\n      ? await Promise.all(\n          options.map(async (individualOption) =>\n            this._mergeConfig(ensureConfig(individualOption), this.kwargs)\n          )\n        )\n      : await this._mergeConfig(ensureConfig(options), this.kwargs);\n    return this.bound.batch(inputs, mergedOptions, batchOptions);\n  }\n\n  /** @internal */\n  override _concatOutputChunks<O>(first: O, second: O): O {\n    return this.bound._concatOutputChunks(first, second);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<CallOptions> | undefined\n  ) {\n    yield* this.bound._streamIterator(\n      input,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions> | undefined\n  ): Promise<IterableReadableStream<RunOutput>> {\n    return this.bound.stream(\n      input,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    yield* this.bound.transform(\n      generator,\n      await this._mergeConfig(ensureConfig(options), this.kwargs)\n    );\n  }\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & { version: \"v1\" | \"v2\" },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<Uint8Array>;\n\n  streamEvents(\n    input: RunInput,\n    options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    },\n    streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const outerThis = this;\n    const generator = async function* () {\n      yield* outerThis.bound.streamEvents(\n        input,\n        {\n          ...(await outerThis._mergeConfig(\n            ensureConfig(options),\n            outerThis.kwargs\n          )),\n          version: options.version,\n        },\n        streamOptions\n      );\n    };\n    return IterableReadableStream.fromAsyncGenerator(generator());\n  }\n\n  static isRunnableBinding(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    thing: any\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): thing is RunnableBinding<any, any, any> {\n    return thing.bound && Runnable.isRunnable(thing.bound);\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n  }): Runnable<RunInput, RunOutput, CallOptions> {\n    return new RunnableBinding<RunInput, RunOutput, CallOptions>({\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      configFactories: [\n        (config) => ({\n          callbacks: [\n            new RootListenersTracer({\n              config,\n              onStart,\n              onEnd,\n              onError,\n            }),\n          ],\n        }),\n      ],\n    });\n  }\n}\n\n/**\n * A runnable that delegates calls to another runnable\n * with each element of the input sequence.\n * @example\n * ```typescript\n * import { RunnableEach, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const toUpperCase = (input: string): string => input.toUpperCase();\n * const addGreeting = (input: string): string => `Hello, ${input}!`;\n *\n * const upperCaseLambda = RunnableLambda.from(toUpperCase);\n * const greetingLambda = RunnableLambda.from(addGreeting);\n *\n * const chain = new RunnableEach({\n *   bound: upperCaseLambda.pipe(greetingLambda),\n * });\n *\n * const result = await chain.invoke([\"alice\", \"bob\", \"carol\"])\n *\n * // [\"Hello, ALICE!\", \"Hello, BOB!\", \"Hello, CAROL!\"]\n * ```\n */\nexport class RunnableEach<\n  RunInputItem,\n  RunOutputItem,\n  CallOptions extends RunnableConfig\n> extends Runnable<RunInputItem[], RunOutputItem[], CallOptions> {\n  static lc_name() {\n    return \"RunnableEach\";\n  }\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n\n  constructor(fields: {\n    bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n  }) {\n    super(fields);\n    this.bound = fields.bound;\n  }\n\n  /**\n   * Invokes the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(\n    inputs: RunInputItem[],\n    config?: Partial<CallOptions>\n  ): Promise<RunOutputItem[]> {\n    return this._callWithConfig(this._invoke.bind(this), inputs, config);\n  }\n\n  /**\n   * A helper method that is used to invoke the runnable with the specified input and configuration.\n   * @param input The input to invoke the runnable with.\n   * @param config The configuration to invoke the runnable with.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  protected async _invoke(\n    inputs: RunInputItem[],\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutputItem[]> {\n    return this.bound.batch(\n      inputs,\n      patchConfig(config, { callbacks: runManager?.getChild() })\n    );\n  }\n\n  /**\n   * Bind lifecycle listeners to a Runnable, returning a new Runnable.\n   * The Run object contains information about the run, including its id,\n   * type, input, output, error, startTime, endTime, and any tags or metadata\n   * added to the run.\n   *\n   * @param {Object} params - The object containing the callback functions.\n   * @param {(run: Run) => void} params.onStart - Called before the runnable starts running, with the Run object.\n   * @param {(run: Run) => void} params.onEnd - Called after the runnable finishes running, with the Run object.\n   * @param {(run: Run) => void} params.onError - Called if the runnable throws an error, with the Run object.\n   */\n  withListeners({\n    onStart,\n    onEnd,\n    onError,\n  }: {\n    onStart?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onEnd?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    onError?: (run: Run, config?: RunnableConfig) => void | Promise<void>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }): Runnable<any, any, CallOptions> {\n    return new RunnableEach<RunInputItem, RunOutputItem, CallOptions>({\n      bound: this.bound.withListeners({ onStart, onEnd, onError }),\n    });\n  }\n}\n\n/**\n * Base class for runnables that can be retried a\n * specified number of times.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableRetry,\n * } from \"@langchain/core/runnables\";\n *\n * // Simulate an API call that fails\n * const simulateApiCall = (input: string): string => {\n *   console.log(`Attempting API call with input: ${input}`);\n *   throw new Error(\"API call failed due to network issue\");\n * };\n *\n * const apiCallLambda = RunnableLambda.from(simulateApiCall);\n *\n * // Apply retry logic using the .withRetry() method\n * const apiCallWithRetry = apiCallLambda.withRetry({ stopAfterAttempt: 3 });\n *\n * // Alternatively, create a RunnableRetry instance manually\n * const manualRetry = new RunnableRetry({\n *   bound: apiCallLambda,\n *   maxAttemptNumber: 3,\n *   config: {},\n * });\n *\n * // Example invocation using the .withRetry() method\n * const res = await apiCallWithRetry\n *   .invoke(\"Request 1\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n *\n * // Example invocation using the manual retry instance\n * const res2 = await manualRetry\n *   .invoke(\"Request 2\")\n *   .catch((error) => {\n *     console.error(\"Failed after multiple retries:\", error.message);\n *   });\n * ```\n */\nexport class RunnableRetry<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends RunnableBinding<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableRetry\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected maxAttemptNumber = 3;\n\n  onFailedAttempt: RunnableRetryFailedAttemptHandler = () => {\n    // empty\n  };\n\n  constructor(\n    fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {\n      maxAttemptNumber?: number;\n      onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n    }\n  ) {\n    super(fields);\n    this.maxAttemptNumber = fields.maxAttemptNumber ?? this.maxAttemptNumber;\n    this.onFailedAttempt = fields.onFailedAttempt ?? this.onFailedAttempt;\n  }\n\n  _patchConfigForRetry(\n    attempt: number,\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ): Partial<CallOptions> {\n    const tag = attempt > 1 ? `retry:attempt:${attempt}` : undefined;\n    return patchConfig(config, { callbacks: runManager?.getChild(tag) });\n  }\n\n  protected async _invoke(\n    input: RunInput,\n    config?: CallOptions,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    return pRetry(\n      (attemptNumber: number) =>\n        super.invoke(\n          input,\n          this._patchConfigForRetry(attemptNumber, config, runManager)\n        ),\n      {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        onFailedAttempt: ({ error }: { error: any }) =>\n          this.onFailedAttempt(error, input),\n        retries: Math.max(this.maxAttemptNumber - 1, 0),\n        randomize: true,\n      }\n    );\n  }\n\n  /**\n   * Method that invokes the runnable with the specified input, run manager,\n   * and config. It handles the retry logic by catching any errors and\n   * recursively invoking itself with the updated config for the next retry\n   * attempt.\n   * @param input The input for the runnable.\n   * @param runManager The run manager for the runnable.\n   * @param config The config for the runnable.\n   * @returns A promise that resolves to the output of the runnable.\n   */\n  async invoke(input: RunInput, config?: CallOptions): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke.bind(this), input, config);\n  }\n\n  async _batch<ReturnExceptions extends boolean = false>(\n    inputs: RunInput[],\n    configs?: RunnableConfig[],\n    runManagers?: (CallbackManagerForChainRun | undefined)[],\n    batchOptions?: RunnableBatchOptions\n  ) {\n    const resultsMap: Record<string, RunOutput | Error> = {};\n    try {\n      await pRetry(\n        async (attemptNumber: number) => {\n          const remainingIndexes = inputs\n            .map((_, i) => i)\n            .filter(\n              (i) =>\n                resultsMap[i.toString()] === undefined ||\n                // eslint-disable-next-line no-instanceof/no-instanceof\n                resultsMap[i.toString()] instanceof Error\n            );\n          const remainingInputs = remainingIndexes.map((i) => inputs[i]);\n          const patchedConfigs = remainingIndexes.map((i) =>\n            this._patchConfigForRetry(\n              attemptNumber,\n              configs?.[i] as CallOptions,\n              runManagers?.[i]\n            )\n          );\n          const results = await super.batch(remainingInputs, patchedConfigs, {\n            ...batchOptions,\n            returnExceptions: true,\n          });\n          let firstException;\n          for (let i = 0; i < results.length; i += 1) {\n            const result = results[i];\n            const resultMapIndex = remainingIndexes[i];\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (result instanceof Error) {\n              if (firstException === undefined) {\n                firstException = result;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                (firstException as any).input = remainingInputs[i];\n              }\n            }\n            resultsMap[resultMapIndex.toString()] = result;\n          }\n          if (firstException) {\n            throw firstException;\n          }\n          return results;\n        },\n        {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          onFailedAttempt: ({ error }: { error: any }) =>\n            this.onFailedAttempt(error, error.input),\n          retries: Math.max(this.maxAttemptNumber - 1, 0),\n          randomize: true,\n        }\n      );\n    } catch (e) {\n      if (batchOptions?.returnExceptions !== true) {\n        throw e;\n      }\n    }\n    return Object.keys(resultsMap)\n      .sort((a, b) => parseInt(a, 10) - parseInt(b, 10))\n      .map(\n        (key) => resultsMap[parseInt(key, 10)]\n      ) as ReturnExceptions extends false ? RunOutput[] : (RunOutput | Error)[];\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<CallOptions> | Partial<CallOptions>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    return this._batchWithConfig(\n      this._batch.bind(this),\n      inputs,\n      options,\n      batchOptions\n    );\n  }\n}\n\nexport type RunnableSequenceFields<RunInput, RunOutput> = {\n  first: Runnable<RunInput>;\n  middle?: Runnable[];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  last: Runnable<any, RunOutput>;\n  name?: string;\n  omitSequenceTags?: boolean;\n};\n\n/**\n * A sequence of runnables, where the output of each is the input of the next.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n * const chain = RunnableSequence.from([promptTemplate, new ChatOpenAI({ model: \"gpt-4o-mini\" })]);\n * const result = await chain.invoke({ topic: \"bears\" });\n * ```\n */\nexport class RunnableSequence<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RunnableSequence\";\n  }\n\n  protected first: Runnable<RunInput>;\n\n  protected middle: Runnable[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected last: Runnable<any, RunOutput>;\n\n  omitSequenceTags = false;\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  constructor(fields: RunnableSequenceFields<RunInput, RunOutput>) {\n    super(fields);\n    this.first = fields.first;\n    this.middle = fields.middle ?? this.middle;\n    this.last = fields.last;\n    this.name = fields.name;\n    this.omitSequenceTags = fields.omitSequenceTags ?? this.omitSequenceTags;\n  }\n\n  get steps() {\n    return [this.first, ...this.middle, this.last];\n  }\n\n  async invoke(input: RunInput, options?: RunnableConfig): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    delete config.runId;\n    let nextStepInput = input;\n    let finalOutput: RunOutput;\n    try {\n      const initialSteps = [this.first, ...this.middle];\n      for (let i = 0; i < initialSteps.length; i += 1) {\n        const step = initialSteps[i];\n        const promise = step.invoke(\n          nextStepInput,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            ),\n          })\n        );\n        nextStepInput = await raceWithSignal(promise, options?.signal);\n      }\n      // TypeScript can't detect that the last output of the sequence returns RunOutput, so call it out of the loop here\n      if (options?.signal?.aborted) {\n        throw getAbortSignalError(options.signal);\n      }\n      finalOutput = await this.last.invoke(\n        nextStepInput,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\n            this.omitSequenceTags ? undefined : `seq:step:${this.steps.length}`\n          ),\n        })\n      );\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n    return finalOutput;\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      configList.map(getCallbackManagerForConfig)\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          configList[i].runId,\n          undefined,\n          undefined,\n          undefined,\n          configList[i].runName\n        );\n        delete configList[i].runId;\n        return handleStartRes;\n      })\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let nextStepInputs: any = inputs;\n    try {\n      for (let i = 0; i < this.steps.length; i += 1) {\n        const step = this.steps[i];\n        const promise = step.batch(\n          nextStepInputs,\n          runManagers.map((runManager, j) => {\n            const childRunManager = runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            );\n            return patchConfig(configList[j], { callbacks: childRunManager });\n          }),\n          batchOptions\n        );\n        nextStepInputs = await raceWithSignal(promise, configList[0]?.signal);\n      }\n    } catch (e) {\n      await Promise.all(\n        runManagers.map((runManager) => runManager?.handleChainError(e))\n      );\n      throw e;\n    }\n    await Promise.all(\n      runManagers.map((runManager) =>\n        runManager?.handleChainEnd(_coerceToDict(nextStepInputs, \"output\"))\n      )\n    );\n    return nextStepInputs;\n  }\n\n  /** @internal */\n  override _concatOutputChunks<O>(first: O, second: O): O {\n    return this.last._concatOutputChunks(first, second);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: RunnableConfig\n  ): AsyncGenerator<RunOutput> {\n    const callbackManager_ = await getCallbackManagerForConfig(options);\n    const { runId, ...otherOptions } = options ?? {};\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherOptions?.runName\n    );\n    const steps = [this.first, ...this.middle, this.last];\n    let concatSupported = true;\n    let finalOutput;\n    async function* inputGenerator() {\n      yield input;\n    }\n    try {\n      let finalGenerator = steps[0].transform(\n        inputGenerator(),\n        patchConfig(otherOptions, {\n          callbacks: runManager?.getChild(\n            this.omitSequenceTags ? undefined : `seq:step:1`\n          ),\n        })\n      );\n      for (let i = 1; i < steps.length; i += 1) {\n        const step = steps[i];\n        finalGenerator = await step.transform(\n          finalGenerator,\n          patchConfig(otherOptions, {\n            callbacks: runManager?.getChild(\n              this.omitSequenceTags ? undefined : `seq:step:${i + 1}`\n            ),\n          })\n        );\n      }\n      for await (const chunk of finalGenerator) {\n        options?.signal?.throwIfAborted();\n        yield chunk;\n        if (concatSupported) {\n          if (finalOutput === undefined) {\n            finalOutput = chunk;\n          } else {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              finalOutput = this._concatOutputChunks(finalOutput, chunk as any);\n            } catch {\n              finalOutput = undefined;\n              concatSupported = false;\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(finalOutput, \"output\"));\n  }\n\n  getGraph(config?: RunnableConfig): Graph {\n    const graph = new Graph();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let currentLastNode: any = null;\n\n    this.steps.forEach((step, index) => {\n      const stepGraph = step.getGraph(config);\n\n      if (index !== 0) {\n        stepGraph.trimFirstNode();\n      }\n\n      if (index !== this.steps.length - 1) {\n        stepGraph.trimLastNode();\n      }\n\n      graph.extend(stepGraph);\n\n      const stepFirstNode = stepGraph.firstNode();\n      if (!stepFirstNode) {\n        throw new Error(`Runnable ${step} has no first node`);\n      }\n\n      if (currentLastNode) {\n        graph.addEdge(currentLastNode, stepFirstNode);\n      }\n\n      currentLastNode = stepGraph.lastNode();\n    });\n\n    return graph;\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike<RunOutput, NewRunOutput>\n  ): RunnableSequence<RunInput, Exclude<NewRunOutput, Error>> {\n    if (RunnableSequence.isRunnableSequence(coerceable)) {\n      return new RunnableSequence({\n        first: this.first,\n        middle: this.middle.concat([\n          this.last,\n          coerceable.first,\n          ...coerceable.middle,\n        ]),\n        last: coerceable.last,\n        name: this.name ?? coerceable.name,\n      });\n    } else {\n      return new RunnableSequence({\n        first: this.first,\n        middle: [...this.middle, this.last],\n        last: _coerceToRunnable(coerceable),\n        name: this.name,\n      });\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static isRunnableSequence(thing: any): thing is RunnableSequence {\n    return Array.isArray(thing.middle) && Runnable.isRunnable(thing);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    [first, ...runnables]: [\n      RunnableLike<RunInput>,\n      ...RunnableLike[],\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      RunnableLike<any, RunOutput>\n    ],\n    nameOrFields?:\n      | string\n      | Omit<\n          RunnableSequenceFields<RunInput, RunOutput>,\n          \"first\" | \"middle\" | \"last\"\n        >\n  ) {\n    let extra: Record<string, unknown> = {};\n    if (typeof nameOrFields === \"string\") {\n      extra.name = nameOrFields;\n    } else if (nameOrFields !== undefined) {\n      extra = nameOrFields;\n    }\n    return new RunnableSequence<RunInput, Exclude<RunOutput, Error>>({\n      ...extra,\n      first: _coerceToRunnable(first),\n      middle: runnables.slice(0, -1).map(_coerceToRunnable),\n      last: _coerceToRunnable(runnables[runnables.length - 1]),\n    });\n  }\n}\n\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * const mapChain = RunnableMap.from({\n *   joke: PromptTemplate.fromTemplate(\"Tell me a joke about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n *   poem: PromptTemplate.fromTemplate(\"write a 2-line poem about {topic}\").pipe(\n *     new ChatAnthropic({}),\n *   ),\n * });\n * const result = await mapChain.invoke({ topic: \"bear\" });\n * ```\n */\nexport class RunnableMap<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput extends Record<string, any> = Record<string, any>\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RunnableMap\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  protected steps: Record<string, Runnable<RunInput>>;\n\n  public getStepsKeys(): string[] {\n    return Object.keys(this.steps);\n  }\n\n  constructor(fields: { steps: RunnableMapLike<RunInput, RunOutput> }) {\n    super(fields);\n    this.steps = {};\n    for (const [key, value] of Object.entries(fields.steps)) {\n      this.steps[key] = _coerceToRunnable(value);\n    }\n  }\n\n  static from<\n    RunInput,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    steps: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableMap<RunInput, RunOutput> {\n    return new RunnableMap<RunInput, RunOutput>({ steps });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      {\n        input,\n      },\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    delete config.runId;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const output: Record<string, any> = {};\n    try {\n      const promises = Object.entries(this.steps).map(\n        async ([key, runnable]) => {\n          output[key] = await runnable.invoke(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`map:key:${key}`),\n            })\n          );\n        }\n      );\n      await raceWithSignal(Promise.all(promises), options?.signal);\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(output);\n    return output as RunOutput;\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    // shallow copy steps to ignore changes while iterating\n    const steps = { ...this.steps };\n    // each step gets a copy of the input iterator\n    const inputCopies = atee(generator, Object.keys(steps).length);\n    // start the first iteration of each output iterator\n    const tasks = new Map(\n      Object.entries(steps).map(([key, runnable], i) => {\n        const gen = runnable.transform(\n          inputCopies[i],\n          patchConfig(options, {\n            callbacks: runManager?.getChild(`map:key:${key}`),\n          })\n        );\n        return [key, gen.next().then((result) => ({ key, gen, result }))];\n      })\n    );\n    // yield chunks as they become available,\n    // starting new iterations as needed,\n    // until all iterators are done\n    while (tasks.size) {\n      const promise = Promise.race(tasks.values());\n      const { key, result, gen } = await raceWithSignal(\n        promise,\n        options?.signal\n      );\n      tasks.delete(key);\n      if (!result.done) {\n        yield { [key]: result.value } as unknown as RunOutput;\n        tasks.set(\n          key,\n          gen.next().then((result) => ({ key, gen, result }))\n        );\n      }\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyTraceableFunction = TraceableFunction<(...any: any[]) => any>;\n\n/**\n * A runnable that wraps a traced LangSmith function.\n */\nexport class RunnableTraceable<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  lc_serializable = false;\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: AnyTraceableFunction;\n\n  constructor(fields: { func: AnyTraceableFunction }) {\n    super(fields);\n\n    if (!isTraceableFunction(fields.func)) {\n      throw new Error(\n        \"RunnableTraceable requires a function that is wrapped in traceable higher-order function\"\n      );\n    }\n\n    this.func = fields.func;\n  }\n\n  async invoke(input: RunInput, options?: Partial<RunnableConfig>) {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const callbacks = await getCallbackManagerForConfig(config);\n    const promise = this.func(\n      patchConfig(config, { callbacks }),\n      input\n    ) as Promise<RunOutput>;\n\n    return raceWithSignal(promise, config?.signal);\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    const [config] = this._getOptionsList(options ?? {}, 1);\n    const result = await this.invoke(input, options);\n\n    if (isAsyncIterable(result)) {\n      for await (const item of result) {\n        config?.signal?.throwIfAborted();\n        yield item as RunOutput;\n      }\n      return;\n    }\n\n    if (isIterator(result)) {\n      while (true) {\n        config?.signal?.throwIfAborted();\n        const state: IteratorResult<unknown> = result.next();\n        if (state.done) break;\n        yield state.value as RunOutput;\n      }\n      return;\n    }\n\n    yield result;\n  }\n\n  static from(func: AnyTraceableFunction) {\n    return new RunnableTraceable({ func });\n  }\n}\n\nfunction assertNonTraceableFunction<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n>(\n  func:\n    | RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    | TraceableFunction<\n        RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      >\n): asserts func is RunnableFunc<\n  RunInput,\n  RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n  CallOptions\n> {\n  if (isTraceableFunction(func)) {\n    throw new Error(\n      \"RunnableLambda requires a function that is not wrapped in traceable higher-order function. This shouldn't happen.\"\n    );\n  }\n}\n\n/**\n * A runnable that wraps an arbitrary function that takes a single argument.\n * @example\n * ```typescript\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const add = (input: { x: number; y: number }) => input.x + input.y;\n *\n * const multiply = (input: { value: number; multiplier: number }) =>\n *   input.value * input.multiplier;\n *\n * // Create runnables for the functions\n * const addLambda = RunnableLambda.from(add);\n * const multiplyLambda = RunnableLambda.from(multiply);\n *\n * // Chain the lambdas for a mathematical operation\n * const chainedLambda = addLambda.pipe((result) =>\n *   multiplyLambda.invoke({ value: result, multiplier: 2 })\n * );\n *\n * // Example invocation of the chainedLambda\n * const result = await chainedLambda.invoke({ x: 2, y: 3 });\n *\n * // Will log \"10\" (since (2 + 3) * 2 = 10)\n * ```\n */\nexport class RunnableLambda<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  static lc_name() {\n    return \"RunnableLambda\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  protected func: RunnableFunc<\n    RunInput,\n    RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n    CallOptions\n  >;\n\n  constructor(fields: {\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >;\n  }) {\n    if (isTraceableFunction(fields.func)) {\n      // eslint-disable-next-line no-constructor-return\n      return RunnableTraceable.from(fields.func) as unknown as RunnableLambda<\n        RunInput,\n        RunOutput,\n        CallOptions\n      >;\n    }\n\n    super(fields);\n\n    assertNonTraceableFunction(fields.func);\n    this.func = fields.func;\n  }\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func: RunnableFunc<\n      RunInput,\n      RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n      CallOptions\n    >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions>;\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func: TraceableFunction<\n      RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions>;\n\n  static from<\n    RunInput,\n    RunOutput,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >(\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >\n  ): RunnableLambda<RunInput, RunOutput, CallOptions> {\n    return new RunnableLambda({\n      func,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<CallOptions>,\n    runManager?: CallbackManagerForChainRun\n  ) {\n    return new Promise<RunOutput>((resolve, reject) => {\n      const childConfig = patchConfig(config, {\n        callbacks: runManager?.getChild(),\n        recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n      });\n      // eslint-disable-next-line no-void\n      void AsyncLocalStorageProviderSingleton.runWithConfig(\n        pickRunnableConfigKeys(childConfig),\n        async () => {\n          try {\n            let output = await this.func(input, {\n              ...childConfig,\n            });\n            if (output && Runnable.isRunnable(output)) {\n              if (config?.recursionLimit === 0) {\n                throw new Error(\"Recursion limit reached.\");\n              }\n              output = await output.invoke(input, {\n                ...childConfig,\n                recursionLimit:\n                  (childConfig.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n              });\n            } else if (isAsyncIterable(output)) {\n              let finalOutput: RunOutput | undefined;\n              for await (const chunk of consumeAsyncIterableInContext(\n                childConfig,\n                output\n              )) {\n                config?.signal?.throwIfAborted();\n                if (finalOutput === undefined) {\n                  finalOutput = chunk as RunOutput;\n                } else {\n                  // Make a best effort to gather, for any type that supports concat.\n                  try {\n                    finalOutput = this._concatOutputChunks(\n                      finalOutput,\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      chunk as any\n                    );\n                  } catch {\n                    finalOutput = chunk as RunOutput;\n                  }\n                }\n              }\n              output = finalOutput as typeof output;\n            } else if (isIterableIterator(output)) {\n              let finalOutput: RunOutput | undefined;\n              for (const chunk of consumeIteratorInContext(\n                childConfig,\n                output\n              )) {\n                config?.signal?.throwIfAborted();\n                if (finalOutput === undefined) {\n                  finalOutput = chunk as RunOutput;\n                } else {\n                  // Make a best effort to gather, for any type that supports concat.\n                  try {\n                    finalOutput = this._concatOutputChunks(\n                      finalOutput,\n                      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                      chunk as any\n                    );\n                  } catch {\n                    finalOutput = chunk as RunOutput;\n                  }\n                }\n              }\n              output = finalOutput as typeof output;\n            }\n            resolve(output);\n          } catch (e) {\n            reject(e);\n          }\n        }\n      );\n    });\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke.bind(this), input, options);\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    config?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    let finalChunk: RunInput | undefined;\n    for await (const chunk of generator) {\n      if (finalChunk === undefined) {\n        finalChunk = chunk;\n      } else {\n        // Make a best effort to gather, for any type that supports concat.\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          finalChunk = this._concatOutputChunks(finalChunk, chunk as any);\n        } catch {\n          finalChunk = chunk;\n        }\n      }\n    }\n    const childConfig = patchConfig(config, {\n      callbacks: runManager?.getChild(),\n      recursionLimit: (config?.recursionLimit ?? DEFAULT_RECURSION_LIMIT) - 1,\n    });\n    const output = await new Promise<RunOutput | Runnable>(\n      (resolve, reject) => {\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              const res = await this.func(finalChunk as RunInput, {\n                ...childConfig,\n                config: childConfig,\n              });\n              resolve(res);\n            } catch (e) {\n              reject(e);\n            }\n          }\n        );\n      }\n    );\n    if (output && Runnable.isRunnable(output)) {\n      if (config?.recursionLimit === 0) {\n        throw new Error(\"Recursion limit reached.\");\n      }\n      const stream = await output.stream(finalChunk as RunInput, childConfig);\n      for await (const chunk of stream) {\n        yield chunk;\n      }\n    } else if (isAsyncIterable(output)) {\n      for await (const chunk of consumeAsyncIterableInContext(\n        childConfig,\n        output\n      )) {\n        config?.signal?.throwIfAborted();\n        yield chunk as RunOutput;\n      }\n    } else if (isIterableIterator(output)) {\n      for (const chunk of consumeIteratorInContext(childConfig, output)) {\n        config?.signal?.throwIfAborted();\n        yield chunk as RunOutput;\n      }\n    } else {\n      yield output;\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<CallOptions>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\n/**\n * A runnable that runs a mapping of runnables in parallel,\n * and returns a mapping of their outputs.\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const addYears = (age: number): number => age + 5;\n * const yearsToFifty = (age: number): number => 50 - age;\n * const yearsToHundred = (age: number): number => 100 - age;\n *\n * const addYearsLambda = RunnableLambda.from(addYears);\n * const milestoneFiftyLambda = RunnableLambda.from(yearsToFifty);\n * const milestoneHundredLambda = RunnableLambda.from(yearsToHundred);\n *\n * // Pipe will coerce objects into RunnableParallel by default, but we\n * // explicitly instantiate one here to demonstrate\n * const sequence = addYearsLambda.pipe(\n *   RunnableParallel.from({\n *     years_to_fifty: milestoneFiftyLambda,\n *     years_to_hundred: milestoneHundredLambda,\n *   })\n * );\n *\n * // Invoke the sequence with a single age input\n * const res = await sequence.invoke(25);\n *\n * // { years_to_fifty: 20, years_to_hundred: 70 }\n * ```\n */\nexport class RunnableParallel<RunInput> extends RunnableMap<RunInput> {}\n\n/**\n * A Runnable that can fallback to other Runnables if it fails.\n * External APIs (e.g., APIs for a language model) may at times experience\n * degraded performance or even downtime.\n *\n * In these cases, it can be useful to have a fallback Runnable that can be\n * used in place of the original Runnable (e.g., fallback to another LLM provider).\n *\n * Fallbacks can be defined at the level of a single Runnable, or at the level\n * of a chain of Runnables. Fallbacks are tried in order until one succeeds or\n * all fail.\n *\n * While you can instantiate a `RunnableWithFallbacks` directly, it is usually\n * more convenient to use the `withFallbacks` method on an existing Runnable.\n *\n * When streaming, fallbacks will only be called on failures during the initial\n * stream creation. Errors that occur after a stream starts will not fallback\n * to the next Runnable.\n *\n * @example\n * ```typescript\n * import {\n *   RunnableLambda,\n *   RunnableWithFallbacks,\n * } from \"@langchain/core/runnables\";\n *\n * const primaryOperation = (input: string): string => {\n *   if (input !== \"safe\") {\n *     throw new Error(\"Primary operation failed due to unsafe input\");\n *   }\n *   return `Processed: ${input}`;\n * };\n *\n * // Define a fallback operation that processes the input differently\n * const fallbackOperation = (input: string): string =>\n *   `Fallback processed: ${input}`;\n *\n * const primaryRunnable = RunnableLambda.from(primaryOperation);\n * const fallbackRunnable = RunnableLambda.from(fallbackOperation);\n *\n * // Apply the fallback logic using the .withFallbacks() method\n * const runnableWithFallback = primaryRunnable.withFallbacks([fallbackRunnable]);\n *\n * // Alternatively, create a RunnableWithFallbacks instance manually\n * const manualFallbackChain = new RunnableWithFallbacks({\n *   runnable: primaryRunnable,\n *   fallbacks: [fallbackRunnable],\n * });\n *\n * // Example invocation using .withFallbacks()\n * const res = await runnableWithFallback\n *   .invoke(\"unsafe input\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Fallback processed: unsafe input\"\n *\n * // Example invocation using manual instantiation\n * const res = await manualFallbackChain\n *   .invoke(\"safe\")\n *   .catch((error) => {\n *     console.error(\"Failed after all attempts:\", error.message);\n *   });\n *\n * // \"Processed: safe\"\n * ```\n */\nexport class RunnableWithFallbacks<RunInput, RunOutput> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableWithFallbacks\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnable: Runnable<RunInput, RunOutput>;\n\n  fallbacks: Runnable<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    runnable: Runnable<RunInput, RunOutput>;\n    fallbacks: Runnable<RunInput, RunOutput>[];\n  }) {\n    super(fields);\n    this.runnable = fields.runnable;\n    this.fallbacks = fields.fallbacks;\n  }\n\n  *runnables() {\n    yield this.runnable;\n    for (const fallback of this.fallbacks) {\n      yield fallback;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const { runId, ...otherConfigFields } = config;\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherConfigFields?.runName\n    );\n    const childConfig = patchConfig(otherConfigFields, {\n      callbacks: runManager?.getChild(),\n    });\n    const res = await AsyncLocalStorageProviderSingleton.runWithConfig(\n      childConfig,\n      async () => {\n        let firstError;\n        for (const runnable of this.runnables()) {\n          config?.signal?.throwIfAborted();\n          try {\n            const output = await runnable.invoke(input, childConfig);\n            await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n            return output;\n          } catch (e) {\n            if (firstError === undefined) {\n              firstError = e;\n            }\n          }\n        }\n        if (firstError === undefined) {\n          throw new Error(\"No error stored at end of fallback.\");\n        }\n        await runManager?.handleChainError(firstError);\n        throw firstError;\n      }\n    );\n    return res;\n  }\n\n  async *_streamIterator(\n    input: RunInput,\n    options?: Partial<RunnableConfig> | undefined\n  ): AsyncGenerator<RunOutput> {\n    const config = ensureConfig(options);\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const { runId, ...otherConfigFields } = config;\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      otherConfigFields?.runName\n    );\n    let firstError;\n    let stream;\n    for (const runnable of this.runnables()) {\n      config?.signal?.throwIfAborted();\n      const childConfig = patchConfig(otherConfigFields, {\n        callbacks: runManager?.getChild(),\n      });\n      try {\n        const originalStream = await runnable.stream(input, childConfig);\n        stream = consumeAsyncIterableInContext(childConfig, originalStream);\n        break;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (stream === undefined) {\n      const error =\n        firstError ?? new Error(\"No error stored at end of fallback.\");\n      await runManager?.handleChainError(error);\n      throw error;\n    }\n    let output;\n    try {\n      for await (const chunk of stream) {\n        yield chunk;\n        try {\n          output =\n            output === undefined\n              ? output\n              : this._concatOutputChunks(output, chunk);\n        } catch {\n          output = undefined;\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(_coerceToDict(output, \"output\"));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    if (batchOptions?.returnExceptions) {\n      throw new Error(\"Not implemented.\");\n    }\n    const configList = this._getOptionsList(options ?? {}, inputs.length);\n    const callbackManagers = await Promise.all(\n      configList.map((config) => getCallbackManagerForConfig(config))\n    );\n    const runManagers = await Promise.all(\n      callbackManagers.map(async (callbackManager, i) => {\n        const handleStartRes = await callbackManager?.handleChainStart(\n          this.toJSON(),\n          _coerceToDict(inputs[i], \"input\"),\n          configList[i].runId,\n          undefined,\n          undefined,\n          undefined,\n          configList[i].runName\n        );\n        delete configList[i].runId;\n        return handleStartRes;\n      })\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let firstError: any;\n    for (const runnable of this.runnables()) {\n      configList[0].signal?.throwIfAborted();\n      try {\n        const outputs = await runnable.batch(\n          inputs,\n          runManagers.map((runManager, j) =>\n            patchConfig(configList[j], {\n              callbacks: runManager?.getChild(),\n            })\n          ),\n          batchOptions\n        );\n        await Promise.all(\n          runManagers.map((runManager, i) =>\n            runManager?.handleChainEnd(_coerceToDict(outputs[i], \"output\"))\n          )\n        );\n        return outputs;\n      } catch (e) {\n        if (firstError === undefined) {\n          firstError = e;\n        }\n      }\n    }\n    if (!firstError) {\n      throw new Error(\"No error stored at end of fallbacks.\");\n    }\n    await Promise.all(\n      runManagers.map((runManager) => runManager?.handleChainError(firstError))\n    );\n    throw firstError;\n  }\n}\n\n// TODO: Figure out why the compiler needs help eliminating Error as a RunOutput type\nexport function _coerceToRunnable<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig = RunnableConfig\n>(\n  coerceable: RunnableLike<RunInput, RunOutput, CallOptions>\n): Runnable<RunInput, Exclude<RunOutput, Error>, CallOptions> {\n  if (typeof coerceable === \"function\") {\n    return new RunnableLambda({ func: coerceable }) as Runnable<\n      RunInput,\n      Exclude<RunOutput, Error>,\n      CallOptions\n    >;\n  } else if (Runnable.isRunnable(coerceable)) {\n    return coerceable as Runnable<\n      RunInput,\n      Exclude<RunOutput, Error>,\n      CallOptions\n    >;\n  } else if (!Array.isArray(coerceable) && typeof coerceable === \"object\") {\n    const runnables: Record<string, Runnable<RunInput>> = {};\n    for (const [key, value] of Object.entries(coerceable)) {\n      runnables[key] = _coerceToRunnable(value as RunnableLike);\n    }\n    return new RunnableMap({\n      steps: runnables,\n    }) as unknown as Runnable<RunInput, Exclude<RunOutput, Error>, CallOptions>;\n  } else {\n    throw new Error(\n      `Expected a Runnable, function or object.\\nInstead got an unsupported type.`\n    );\n  }\n}\n\nexport interface RunnableAssignFields<RunInput> {\n  mapper: RunnableMap<RunInput>;\n}\n\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * @example\n * ```typescript\n * import {\n *   RunnableAssign,\n *   RunnableLambda,\n *   RunnableParallel,\n * } from \"@langchain/core/runnables\";\n *\n * const calculateAge = (x: { birthYear: number }): { age: number } => {\n *   const currentYear = new Date().getFullYear();\n *   return { age: currentYear - x.birthYear };\n * };\n *\n * const createGreeting = (x: { name: string }): { greeting: string } => {\n *   return { greeting: `Hello, ${x.name}!` };\n * };\n *\n * const mapper = RunnableParallel.from({\n *   age_step: RunnableLambda.from(calculateAge),\n *   greeting_step: RunnableLambda.from(createGreeting),\n * });\n *\n * const runnableAssign = new RunnableAssign({ mapper });\n *\n * const res = await runnableAssign.invoke({ name: \"Alice\", birthYear: 1990 });\n *\n * // { name: \"Alice\", birthYear: 1990, age_step: { age: 34 }, greeting_step: { greeting: \"Hello, Alice!\" } }\n * ```\n */\nexport class RunnableAssign<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends Record<string, any> = Record<string, any>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements RunnableAssignFields<RunInput>\n{\n  static lc_name() {\n    return \"RunnableAssign\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  mapper: RunnableMap<RunInput>;\n\n  constructor(fields: RunnableMap<RunInput> | RunnableAssignFields<RunInput>) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (fields instanceof RunnableMap) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { mapper: fields };\n    }\n    super(fields);\n    this.mapper = fields.mapper;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    const mapperResult = await this.mapper.invoke(input, options);\n\n    return {\n      ...input,\n      ...mapperResult,\n    } as RunOutput;\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>,\n    runManager?: CallbackManagerForChainRun,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    // collect mapper keys\n    const mapperKeys = this.mapper.getStepsKeys();\n    // create two input gens, one for the mapper, one for the input\n    const [forPassthrough, forMapper] = atee(generator);\n    // create mapper output gen\n    const mapperOutput = this.mapper.transform(\n      forMapper,\n      patchConfig(options, { callbacks: runManager?.getChild() })\n    );\n    // start the mapper\n    const firstMapperChunkPromise = mapperOutput.next();\n    // yield the passthrough\n    for await (const chunk of forPassthrough) {\n      if (typeof chunk !== \"object\" || Array.isArray(chunk)) {\n        throw new Error(\n          `RunnableAssign can only be used with objects as input, got ${typeof chunk}`\n        );\n      }\n      const filtered = Object.fromEntries(\n        Object.entries(chunk).filter(([key]) => !mapperKeys.includes(key))\n      );\n      if (Object.keys(filtered).length > 0) {\n        yield filtered as unknown as RunOutput;\n      }\n    }\n    // yield the mapper output\n    yield (await firstMapperChunkPromise).value;\n    for await (const chunk of mapperOutput) {\n      yield chunk as unknown as RunOutput;\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\nexport interface RunnablePickFields {\n  keys: string | string[];\n}\n\n/**\n * A runnable that assigns key-value pairs to inputs of type `Record<string, unknown>`.\n * Useful for streaming, can be automatically created and chained by calling `runnable.pick();`.\n * @example\n * ```typescript\n * import { RunnablePick } from \"@langchain/core/runnables\";\n *\n * const inputData = {\n *   name: \"John\",\n *   age: 30,\n *   city: \"New York\",\n *   country: \"USA\",\n *   email: \"john.doe@example.com\",\n *   phone: \"+1234567890\",\n * };\n *\n * const basicInfoRunnable = new RunnablePick([\"name\", \"city\"]);\n *\n * // Example invocation\n * const res = await basicInfoRunnable.invoke(inputData);\n *\n * // { name: 'John', city: 'New York' }\n * ```\n */\nexport class RunnablePick<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends Record<string, any> = Record<string, any>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> | any = Record<string, any> | any,\n    CallOptions extends RunnableConfig = RunnableConfig\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements RunnablePickFields\n{\n  static lc_name() {\n    return \"RunnablePick\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  keys: string | string[];\n\n  constructor(fields: string | string[] | RunnablePickFields) {\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { keys: fields };\n    }\n    super(fields);\n    this.keys = fields.keys;\n  }\n\n  async _pick(input: RunInput): Promise<RunOutput> {\n    if (typeof this.keys === \"string\") {\n      return input[this.keys];\n    } else {\n      const picked = this.keys\n        .map((key) => [key, input[key]])\n        .filter((v) => v[1] !== undefined);\n      return picked.length === 0\n        ? (undefined as RunOutput)\n        : Object.fromEntries(picked);\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<CallOptions>\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._pick.bind(this), input, options);\n  }\n\n  async *_transform(\n    generator: AsyncGenerator<RunInput>\n  ): AsyncGenerator<RunOutput> {\n    for await (const chunk of generator) {\n      const picked = await this._pick(chunk);\n      if (picked !== undefined) {\n        yield picked;\n      }\n    }\n  }\n\n  transform(\n    generator: AsyncGenerator<RunInput>,\n    options?: Partial<RunnableConfig>\n  ): AsyncGenerator<RunOutput> {\n    return this._transformStreamWithConfig(\n      generator,\n      this._transform.bind(this),\n      options\n    );\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    async function* generator() {\n      yield input;\n    }\n    const config = ensureConfig(options);\n    const wrappedGenerator = new AsyncGeneratorWithSetup({\n      generator: this.transform(generator(), config),\n      config,\n    });\n    await wrappedGenerator.setup;\n    return IterableReadableStream.fromAsyncGenerator(wrappedGenerator);\n  }\n}\n\nexport interface RunnableToolLikeArgs<\n  RunInput extends InteropZodType = InteropZodType,\n  RunOutput = unknown\n> extends Omit<\n    RunnableBindingArgs<InferInteropZodOutput<RunInput>, RunOutput>,\n    \"config\"\n  > {\n  name: string;\n\n  description?: string;\n\n  schema: RunInput;\n\n  config?: RunnableConfig;\n}\n\nexport class RunnableToolLike<\n  RunInput extends InteropZodType = InteropZodType,\n  RunOutput = unknown\n> extends RunnableBinding<InferInteropZodOutput<RunInput>, RunOutput> {\n  name: string;\n\n  description?: string;\n\n  schema: RunInput;\n\n  constructor(fields: RunnableToolLikeArgs<RunInput, RunOutput>) {\n    const sequence = RunnableSequence.from([\n      RunnableLambda.from<\n        InferInteropZodOutput<RunInput> | ToolCall,\n        InferInteropZodOutput<RunInput>\n      >(async (input) => {\n        let toolInput: InferInteropZodOutput<RunInput>;\n\n        if (_isToolCall(input)) {\n          try {\n            toolInput = await interopParseAsync(this.schema, input.args);\n          } catch {\n            throw new ToolInputParsingException(\n              `Received tool input did not match expected schema`,\n              JSON.stringify(input.args)\n            );\n          }\n        } else {\n          toolInput = input;\n        }\n        return toolInput;\n      }).withConfig({ runName: `${fields.name}:parse_input` }),\n      fields.bound,\n    ]).withConfig({ runName: fields.name });\n\n    super({\n      bound: sequence,\n      config: fields.config ?? {},\n    });\n\n    this.name = fields.name;\n    this.description = fields.description;\n    this.schema = fields.schema;\n  }\n\n  static lc_name() {\n    return \"RunnableToolLike\";\n  }\n}\n\n/**\n * Given a runnable and a Zod schema, convert the runnable to a tool.\n *\n * @template RunInput The input type for the runnable.\n * @template RunOutput The output type for the runnable.\n *\n * @param {Runnable<RunInput, RunOutput>} runnable The runnable to convert to a tool.\n * @param fields\n * @param {string | undefined} [fields.name] The name of the tool. If not provided, it will default to the name of the runnable.\n * @param {string | undefined} [fields.description] The description of the tool. Falls back to the description on the Zod schema if not provided, or undefined if neither are provided.\n * @param {InteropZodType<RunInput>} [fields.schema] The Zod schema for the input of the tool. Infers the Zod type from the input type of the runnable.\n * @returns {RunnableToolLike<InteropZodType<RunInput>, RunOutput>} An instance of `RunnableToolLike` which is a runnable that can be used as a tool.\n */\nexport function convertRunnableToTool<RunInput, RunOutput>(\n  runnable: Runnable<RunInput, RunOutput>,\n  fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<RunInput>;\n  }\n): RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput> {\n  const name = fields.name ?? runnable.getName();\n  const description = fields.description ?? getSchemaDescription(fields.schema);\n\n  if (isSimpleStringZodSchema(fields.schema)) {\n    return new RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput>(\n      {\n        name,\n        description,\n        schema: z\n          .object({ input: z.string() })\n          .transform((input) => input.input) as InteropZodType,\n        bound: runnable,\n      }\n    );\n  }\n\n  return new RunnableToolLike<InteropZodType<RunInput | ToolCall>, RunOutput>({\n    name,\n    description,\n    schema: fields.schema,\n    bound: runnable,\n  });\n}\n","import { KVMap, BaseRun } from \"langsmith/schemas\";\nimport { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\n\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { LLMResult } from \"../outputs.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"../callbacks/base.js\";\nimport type { Document } from \"../documents/document.js\";\nimport { getRuntimeEnvironment } from \"../utils/env.js\";\n\nexport type RunType = string;\n\n// TODO: Remove this type and just use the base LangSmith Run type.\nexport interface Run extends BaseRun {\n  // some optional fields are always present here\n  id: string;\n  start_time: number;\n  end_time?: number;\n  execution_order: number;\n  // some additional fields that don't exist in sdk runs\n  child_runs: this[];\n  child_execution_order: number;\n  events: Array<{\n    name: string;\n    time: string;\n    kwargs?: Record<string, unknown>;\n  }>;\n  trace_id?: string;\n  dotted_order?: string;\n  /** @internal */\n  _serialized_start_time?: string;\n}\n\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree?: RunTree): Run | undefined => {\n  if (!runTree) {\n    return undefined;\n  }\n  // Important that we return the raw run tree object since the reference\n  // is mutated in other places.\n  // TODO: Remove places where this is being done.\n\n  runTree.events = runTree.events ?? [];\n  runTree.child_runs = runTree.child_runs ?? [];\n  // TODO: Remove this cast and just use the LangSmith RunTree type.\n  return runTree as unknown as Run;\n};\n\nfunction convertRunToRunTree(run?: Run, parentRun?: Run): RunTree | undefined {\n  if (!run) {\n    return undefined;\n  }\n  return new RunTree({\n    ...run,\n    start_time: run._serialized_start_time ?? run.start_time,\n    parent_run: convertRunToRunTree(parentRun),\n    child_runs: run.child_runs\n      .map((r) => convertRunToRunTree(r))\n      .filter((r): r is RunTree => r !== undefined),\n    extra: {\n      ...run.extra,\n      runtime: getRuntimeEnvironment(),\n    },\n    tracingEnabled: false,\n  });\n}\n\nexport interface AgentRun extends Run {\n  actions: AgentAction[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value: any, defaultKey: string) {\n  return value && !Array.isArray(value) && typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport function isBaseTracer(x: BaseCallbackHandler): x is BaseTracer {\n  return typeof (x as BaseTracer)._addRunToRunMap === \"function\";\n}\n\nexport abstract class BaseTracer extends BaseCallbackHandler {\n  /** @deprecated Use `runTreeMap` instead. */\n  protected runMap: Map<string, Run> = new Map();\n\n  protected runTreeMap: Map<string, RunTree> = new Map();\n\n  protected usesRunTreeMap = false;\n\n  constructor(_fields?: BaseCallbackHandlerInput) {\n    super(...arguments);\n  }\n\n  copy(): this {\n    return this;\n  }\n\n  protected getRunById(runId?: string): Run | undefined {\n    if (runId === undefined) {\n      return undefined;\n    }\n    return this.usesRunTreeMap\n      ? convertRunTreeToRun(this.runTreeMap.get(runId))\n      : this.runMap.get(runId);\n  }\n\n  protected stringifyError(error: unknown) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n    }\n\n    if (typeof error === \"string\") {\n      return error;\n    }\n\n    return `${error}`;\n  }\n\n  protected abstract persistRun(run: Run): Promise<void>;\n\n  protected _addChildRun(parentRun: Run, childRun: Run) {\n    parentRun.child_runs.push(childRun);\n  }\n\n  _addRunToRunMap(run: Run) {\n    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } =\n      convertToDottedOrderFormat(\n        new Date(run.start_time).getTime(),\n        run.id,\n        run.execution_order\n      );\n    const storedRun = { ...run };\n    const parentRun = this.getRunById(storedRun.parent_run_id);\n    if (storedRun.parent_run_id !== undefined) {\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(\n          parentRun.child_execution_order,\n          storedRun.child_execution_order\n        );\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [\n            parentRun.dotted_order,\n            currentDottedOrder,\n          ].join(\".\");\n          storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n      storedRun._serialized_start_time = microsecondPrecisionDatestring;\n    }\n    if (this.usesRunTreeMap) {\n      const runTree = convertRunToRunTree(storedRun, parentRun);\n      if (runTree !== undefined) {\n        this.runTreeMap.set(storedRun.id, runTree);\n      }\n    } else {\n      this.runMap.set(storedRun.id, storedRun);\n    }\n    return storedRun;\n  }\n\n  protected async _endTrace(run: Run): Promise<void> {\n    const parentRun =\n      run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(\n        parentRun.child_execution_order,\n        run.child_execution_order\n      );\n    } else {\n      await this.persistRun(run);\n    }\n    await this.onRunUpdate?.(run);\n    if (this.usesRunTreeMap) {\n      this.runTreeMap.delete(run.id);\n    } else {\n      this.runMap.delete(run.id);\n    }\n  }\n\n  protected _getExecutionOrder(parentRunId: string | undefined): number {\n    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n\n    return parentRun.child_execution_order + 1;\n  }\n\n  /**\n   * Create and add a run to the run map for LLM start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { prompts },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForLLMStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chat model start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { messages },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChatModelStart(\n        llm,\n        messages,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleLLMError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chain start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType ?? \"chain\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChainStart(\n        chain,\n        inputs,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        runType,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onChainStart?.(run);\n    return run;\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleChainError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for tool start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { input },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForToolStart(\n        tool,\n        input,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onToolStart?.(run);\n    return run;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { output };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleToolError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleAgentAction(action: AgentAction, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    const agentRun = run as AgentRun;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentAction?.(run as AgentRun);\n  }\n\n  async handleAgentEnd(action: AgentFinish, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentEnd?.(run);\n  }\n\n  /**\n   * Create and add a run to the run map for retriever start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { query },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForRetrieverStart(\n        retriever,\n        query,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onRetrieverStart?.(run);\n    return run;\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, unknown>>[],\n    runId: string\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { documents };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleRetrieverError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleText(text: string, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: { text },\n    });\n    await this.onText?.(run);\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\n        `Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`\n      );\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: { token, idx, chunk: fields?.chunk },\n    });\n    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n    return run;\n  }\n\n  // custom event handlers\n\n  onRunCreate?(run: Run): void | Promise<void>;\n\n  onRunUpdate?(run: Run): void | Promise<void>;\n\n  onLLMStart?(run: Run): void | Promise<void>;\n\n  onLLMEnd?(run: Run): void | Promise<void>;\n\n  onLLMError?(run: Run): void | Promise<void>;\n\n  onChainStart?(run: Run): void | Promise<void>;\n\n  onChainEnd?(run: Run): void | Promise<void>;\n\n  onChainError?(run: Run): void | Promise<void>;\n\n  onToolStart?(run: Run): void | Promise<void>;\n\n  onToolEnd?(run: Run): void | Promise<void>;\n\n  onToolError?(run: Run): void | Promise<void>;\n\n  onAgentAction?(run: Run): void | Promise<void>;\n\n  onAgentEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverStart?(run: Run): void | Promise<void>;\n\n  onRetrieverEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverError?(run: Run): void | Promise<void>;\n\n  onText?(run: Run): void | Promise<void>;\n\n  onLLMNewToken?(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): void | Promise<void>;\n}\n","import {\n  StructuredToolInterface,\n  StructuredToolParams,\n  isLangChainTool,\n} from \"../tools/types.js\";\nimport { FunctionDefinition, ToolDefinition } from \"../language_models/base.js\";\nimport { RunnableToolLike } from \"../runnables/base.js\";\nimport { toJsonSchema } from \"./json_schema.js\";\n\n// These utility functions were moved to a more appropriate location,\n// but we still export them here for backwards compatibility.\nexport {\n  isStructuredTool,\n  isStructuredToolParams,\n  isRunnableToolLike,\n  isLangChainTool,\n} from \"../tools/types.js\";\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a format\n * that is compatible with OpenAI function calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | RunnableToolLike} tool The tool to convert to an OpenAI function.\n * @returns {FunctionDefinition} The inputted tool in OpenAI function format.\n */\nexport function convertToOpenAIFunction(\n  tool: StructuredToolInterface | RunnableToolLike | StructuredToolParams,\n  fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number\n): FunctionDefinition {\n  // @TODO 0.3.0 Remove the `number` typing\n  const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n\n  return {\n    name: tool.name,\n    description: tool.description,\n    parameters: toJsonSchema(tool.schema),\n    // Do not include the `strict` field if it is `undefined`.\n    ...(fieldsCopy?.strict !== undefined ? { strict: fieldsCopy.strict } : {}),\n  };\n}\n\n/**\n * Formats a `StructuredTool` or `RunnableToolLike` instance into a\n * format that is compatible with OpenAI tool calling. If `StructuredTool` or\n * `RunnableToolLike` has a zod schema, the output will be converted into a\n * JSON schema, which is then used as the parameters for the OpenAI tool.\n *\n * @param {StructuredToolInterface | Record<string, any> | RunnableToolLike} tool The tool to convert to an OpenAI tool.\n * @returns {ToolDefinition} The inputted tool in OpenAI tool format.\n */\nexport function convertToOpenAITool(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tool: StructuredToolInterface | Record<string, any> | RunnableToolLike,\n  fields?:\n    | {\n        /**\n         * If `true`, model output is guaranteed to exactly match the JSON Schema\n         * provided in the function definition.\n         */\n        strict?: boolean;\n      }\n    | number\n): ToolDefinition {\n  // @TODO 0.3.0 Remove the `number` typing\n  const fieldsCopy = typeof fields === \"number\" ? undefined : fields;\n\n  let toolDef: ToolDefinition | undefined;\n  if (isLangChainTool(tool)) {\n    toolDef = {\n      type: \"function\",\n      function: convertToOpenAIFunction(tool),\n    };\n  } else {\n    toolDef = tool as ToolDefinition;\n  }\n\n  if (fieldsCopy?.strict !== undefined) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (toolDef.function as any).strict = fieldsCopy.strict;\n  }\n\n  return toolDef;\n}\n","import { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { mapStoredMessageToChatMessage } from \"../messages/utils.js\";\nimport { type StoredGeneration } from \"../messages/base.js\";\n\nexport const defaultHashKeyEncoder: HashKeyEncoder = (...strings) =>\n  sha256(strings.join(\"_\"));\n\nexport function deserializeStoredGeneration(\n  storedGeneration: StoredGeneration\n) {\n  if (storedGeneration.message !== undefined) {\n    return {\n      text: storedGeneration.text,\n      message: mapStoredMessageToChatMessage(storedGeneration.message),\n    };\n  } else {\n    return { text: storedGeneration.text };\n  }\n}\n\nexport function serializeGeneration(generation: Generation) {\n  const serializedValue: StoredGeneration = {\n    text: generation.text,\n  };\n  if ((generation as ChatGeneration).message !== undefined) {\n    serializedValue.message = (generation as ChatGeneration).message.toDict();\n  }\n  return serializedValue;\n}\n\n/**\n * Base class for all caches. All caches should extend this class.\n */\nexport abstract class BaseCache<T = Generation[]> {\n  protected keyEncoder: HashKeyEncoder = defaultHashKeyEncoder;\n\n  /**\n   * Sets a custom key encoder function for the cache.\n   * This function should take a prompt and an LLM key and return a string\n   * that will be used as the cache key.\n   * @param keyEncoderFn The custom key encoder function.\n   */\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  abstract lookup(prompt: string, llmKey: string): Promise<T | null>;\n\n  abstract update(prompt: string, llmKey: string, value: T): Promise<void>;\n}\n\nconst GLOBAL_MAP = new Map();\n\n/**\n * A cache for storing LLM generations that stores data in memory.\n */\nexport class InMemoryCache<T = Generation[]> extends BaseCache<T> {\n  private cache: Map<string, T>;\n\n  constructor(map?: Map<string, T>) {\n    super();\n    this.cache = map ?? new Map();\n  }\n\n  /**\n   * Retrieves data from the cache using a prompt and an LLM key. If the\n   * data is not found, it returns null.\n   * @param prompt The prompt used to find the data.\n   * @param llmKey The LLM key used to find the data.\n   * @returns The data corresponding to the prompt and LLM key, or null if not found.\n   */\n  lookup(prompt: string, llmKey: string): Promise<T | null> {\n    return Promise.resolve(\n      this.cache.get(this.keyEncoder(prompt, llmKey)) ?? null\n    );\n  }\n\n  /**\n   * Updates the cache with new data using a prompt and an LLM key.\n   * @param prompt The prompt used to store the data.\n   * @param llmKey The LLM key used to store the data.\n   * @param value The data to be stored.\n   */\n  async update(prompt: string, llmKey: string, value: T): Promise<void> {\n    this.cache.set(this.keyEncoder(prompt, llmKey), value);\n  }\n\n  /**\n   * Returns a global instance of InMemoryCache using a predefined global\n   * map as the initial cache.\n   * @returns A global instance of InMemoryCache.\n   */\n  static global(): InMemoryCache {\n    return new InMemoryCache(GLOBAL_MAP);\n  }\n}\n","import { VectorStore } from \"../vectorstores.js\";\n\n/**\n * Represents logical AND operator.\n */\nexport type AND = \"and\";\n/**\n * Represents logical OR operator.\n */\nexport type OR = \"or\";\n/**\n * Represents logical NOT operator.\n */\nexport type NOT = \"not\";\n\n/**\n * Represents a logical operator which can be AND, OR, or NOT.\n */\nexport type Operator = AND | OR | NOT;\n\n/**\n * Represents equality comparison operator.\n */\nexport type EQ = \"eq\";\n/**\n * Represents inequality comparison operator.\n */\nexport type NE = \"ne\";\n/**\n * Represents less than comparison operator.\n */\nexport type LT = \"lt\";\n/**\n * Represents greater than comparison operator.\n */\nexport type GT = \"gt\";\n/**\n * Represents less than or equal to comparison operator.\n */\nexport type LTE = \"lte\";\n/**\n * Represents greater than or equal to comparison operator.\n */\nexport type GTE = \"gte\";\n\n/**\n * Represents a comparison operator which can be EQ, NE, LT, GT, LTE, or\n * GTE.\n */\nexport type Comparator = EQ | NE | LT | GT | LTE | GTE;\n\nexport const Operators: { [key: string]: Operator } = {\n  and: \"and\",\n  or: \"or\",\n  not: \"not\",\n};\n\nexport const Comparators: { [key: string]: Comparator } = {\n  eq: \"eq\",\n  ne: \"ne\",\n  lt: \"lt\",\n  gt: \"gt\",\n  lte: \"lte\",\n  gte: \"gte\",\n};\n\n/**\n * Represents the result of visiting an operation or comparison\n * expression.\n */\nexport type VisitorResult = VisitorOperationResult | VisitorComparisonResult;\n\n/**\n * Represents the result of visiting an operation expression.\n */\nexport type VisitorOperationResult = {\n  [operator: string]: VisitorResult[];\n};\n\n/**\n * Represents the result of visiting a comparison expression.\n */\nexport type VisitorComparisonResult = {\n  [attr: string]: {\n    [comparator: string]: string | number | boolean;\n  };\n};\n\n/**\n * Represents the result of visiting a structured query expression.\n */\nexport type VisitorStructuredQueryResult = {\n  filter?: VisitorComparisonResult | VisitorOperationResult;\n};\n\n/**\n * Abstract class for visiting expressions. Subclasses must implement\n * visitOperation, visitComparison, and visitStructuredQuery methods.\n */\nexport abstract class Visitor<T extends VectorStore = VectorStore> {\n  declare VisitOperationOutput: object;\n\n  declare VisitComparisonOutput: object;\n\n  declare VisitStructuredQueryOutput: { filter?: T[\"FilterType\"] };\n\n  abstract allowedOperators: Operator[];\n\n  abstract allowedComparators: Comparator[];\n\n  abstract visitOperation(operation: Operation): this[\"VisitOperationOutput\"];\n\n  abstract visitComparison(\n    comparison: Comparison\n  ): this[\"VisitComparisonOutput\"];\n\n  abstract visitStructuredQuery(\n    structuredQuery: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"];\n}\n\n/**\n * Abstract class representing an expression. Subclasses must implement\n * the exprName property and the accept method.\n */\nexport abstract class Expression {\n  abstract exprName: \"Operation\" | \"Comparison\" | \"StructuredQuery\";\n\n  accept(visitor: Visitor) {\n    if (this.exprName === \"Operation\") {\n      return visitor.visitOperation(this as unknown as Operation);\n    } else if (this.exprName === \"Comparison\") {\n      return visitor.visitComparison(this as unknown as Comparison);\n    } else if (this.exprName === \"StructuredQuery\") {\n      return visitor.visitStructuredQuery(this as unknown as StructuredQuery);\n    } else {\n      throw new Error(\"Unknown Expression type\");\n    }\n  }\n}\n\n/**\n * Abstract class representing a filter directive. It extends the\n * Expression class.\n */\nexport abstract class FilterDirective extends Expression {}\n\n/**\n * Class representing a comparison filter directive. It extends the\n * FilterDirective class.\n */\nexport class Comparison<ValueTypes = string | number> extends FilterDirective {\n  exprName = \"Comparison\" as const;\n\n  constructor(\n    public comparator: Comparator,\n    public attribute: string,\n    public value: ValueTypes\n  ) {\n    super();\n  }\n}\n\n/**\n * Class representing an operation filter directive. It extends the\n * FilterDirective class.\n */\nexport class Operation extends FilterDirective {\n  exprName = \"Operation\" as const;\n\n  constructor(public operator: Operator, public args?: FilterDirective[]) {\n    super();\n  }\n}\n\n/**\n * Class representing a structured query expression. It extends the\n * Expression class.\n */\nexport class StructuredQuery extends Expression {\n  exprName = \"StructuredQuery\" as const;\n\n  constructor(public query: string, public filter?: FilterDirective) {\n    super();\n  }\n}\n","import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * Stores the value received in the step immediately preceding, clears after.\n */\nexport class EphemeralValue<Value> extends BaseChannel<Value, Value, Value> {\n  lc_graph_name = \"EphemeralValue\";\n\n  guard: boolean;\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  constructor(guard: boolean = true) {\n    super();\n    this.guard = guard;\n  }\n\n  fromCheckpoint(checkpoint?: Value) {\n    const empty = new EphemeralValue<Value>(this.guard);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = [checkpoint];\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      const updated = this.value.length > 0;\n      // If there are no updates for this specific channel at the end of the step, wipe it.\n      this.value = [];\n      return updated;\n    }\n    if (values.length !== 1 && this.guard) {\n      throw new InvalidUpdateError(\n        \"EphemeralValue can only receive one value per step.\"\n      );\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0;\n  }\n}\n","import { ZodIntersectionDef } from \"zod/v3\";\nimport { parseDef } from \"../parseDef.js\";\nimport { JsonSchema7Type } from \"../parseTypes.js\";\nimport { Refs } from \"../Refs.js\";\nimport { JsonSchema7StringType } from \"./string.js\";\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType\n): type is JsonSchema7AllOfType => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  let unevaluatedProperties:\n    | Pick<JsonSchema7AllOfType, \"unevaluatedProperties\">\n    | undefined =\n    refs.target === \"jsonSchema2019-09\"\n      ? { unevaluatedProperties: false }\n      : undefined;\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if (\n        \"additionalProperties\" in schema &&\n        schema.additionalProperties === false\n      ) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length\n    ? {\n        allOf: mergedAllOf,\n        ...unevaluatedProperties,\n      }\n    : undefined;\n}\n","import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  type BaseMessageFields,\n} from \"./base.js\";\nimport type { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface HumanMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"human\"> {}\n\n/**\n * Represents a human message in a conversation.\n */\nexport class HumanMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"human\"> {\n  static lc_name() {\n    return \"HumanMessage\";\n  }\n\n  readonly type = \"human\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  static isInstance(obj: unknown): obj is HumanMessage {\n    return super.isInstance(obj) && obj.type === \"human\";\n  }\n}\n\n/**\n * Represents a chunk of a human message, which can be concatenated with\n * other human message chunks.\n */\nexport class HumanMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"human\"> {\n  static lc_name() {\n    return \"HumanMessageChunk\";\n  }\n\n  readonly type = \"human\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"human\">\n      | HumanMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  concat(chunk: HumanMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is HumanMessageChunk {\n    return super.isInstance(obj) && obj.type === \"human\";\n  }\n}\n\n/**\n * @deprecated Use {@link HumanMessage.isInstance} instead\n */\nexport function isHumanMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is HumanMessage<TStructure> {\n  return x.getType() === \"human\";\n}\n\n/**\n * @deprecated Use {@link HumanMessageChunk.isInstance} instead\n */\nexport function isHumanMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is HumanMessageChunk<TStructure> {\n  return x.getType() === \"human\";\n}\n","import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../../chat_history.js\";\nimport { BaseMessage, AIMessage, HumanMessage } from \"../../messages/index.js\";\nimport { BaseTracer, Run } from \"../../tracers/base.js\";\n\nexport class FakeChatMessageHistory extends BaseChatMessageHistory {\n  lc_namespace = [\"langchain_core\", \"message\", \"fake\"];\n\n  messages: Array<BaseMessage> = [];\n\n  constructor() {\n    super();\n  }\n\n  async getMessages(): Promise<BaseMessage[]> {\n    return this.messages;\n  }\n\n  async addMessage(message: BaseMessage): Promise<void> {\n    this.messages.push(message);\n  }\n\n  async addUserMessage(message: string): Promise<void> {\n    this.messages.push(new HumanMessage(message));\n  }\n\n  async addAIMessage(message: string): Promise<void> {\n    this.messages.push(new AIMessage(message));\n  }\n\n  async clear(): Promise<void> {\n    this.messages = [];\n  }\n}\n\nexport class FakeListChatMessageHistory extends BaseListChatMessageHistory {\n  lc_namespace = [\"langchain_core\", \"message\", \"fake\"];\n\n  messages: Array<BaseMessage> = [];\n\n  constructor() {\n    super();\n  }\n\n  async addMessage(message: BaseMessage): Promise<void> {\n    this.messages.push(message);\n  }\n\n  async getMessages(): Promise<BaseMessage[]> {\n    return this.messages;\n  }\n}\n\nexport class FakeTracer extends BaseTracer {\n  name = \"fake_tracer\";\n\n  runs: Run[] = [];\n\n  constructor() {\n    super();\n  }\n\n  protected persistRun(run: Run): Promise<void> {\n    this.runs.push(run);\n    return Promise.resolve();\n  }\n}\n","import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage, HumanMessage, AIMessage } from \"./messages/index.js\";\n\n// TODO: Combine into one class for 0.2\n\n/**\n * Base class for all chat message histories. All chat message histories\n * should extend this class.\n */\nexport abstract class BaseChatMessageHistory extends Serializable {\n  public abstract getMessages(): Promise<BaseMessage[]>;\n\n  public abstract addMessage(message: BaseMessage): Promise<void>;\n\n  public abstract addUserMessage(message: string): Promise<void>;\n\n  public abstract addAIMessage(message: string): Promise<void>;\n\n  /**\n   * Add a list of messages.\n   *\n   * Implementations should override this method to handle bulk addition of messages\n   * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n   *\n   * @param messages - A list of BaseMessage objects to store.\n   */\n  public async addMessages(messages: BaseMessage[]): Promise<void> {\n    for (const message of messages) {\n      await this.addMessage(message);\n    }\n  }\n\n  public abstract clear(): Promise<void>;\n}\n\n/**\n * Base class for all list chat message histories. All list chat message\n * histories should extend this class.\n */\nexport abstract class BaseListChatMessageHistory extends Serializable {\n  /** Returns a list of messages stored in the store. */\n  public abstract getMessages(): Promise<BaseMessage[]>;\n\n  /**\n   * Add a message object to the store.\n   */\n  public abstract addMessage(message: BaseMessage): Promise<void>;\n\n  /**\n   * This is a convenience method for adding a human message string to the store.\n   * Please note that this is a convenience method. Code should favor the\n   * bulk addMessages interface instead to save on round-trips to the underlying\n   * persistence layer.\n   * This method may be deprecated in a future release.\n   */\n  public addUserMessage(message: string): Promise<void> {\n    return this.addMessage(new HumanMessage(message));\n  }\n\n  /**\n   * This is a convenience method for adding an AI message string to the store.\n   * Please note that this is a convenience method. Code should favor the bulk\n   * addMessages interface instead to save on round-trips to the underlying\n   * persistence layer.\n   * This method may be deprecated in a future release.\n   */\n  public addAIMessage(message: string): Promise<void> {\n    return this.addMessage(new AIMessage(message));\n  }\n\n  /**\n   * Add a list of messages.\n   *\n   * Implementations should override this method to handle bulk addition of messages\n   * in an efficient manner to avoid unnecessary round-trips to the underlying store.\n   *\n   * @param messages - A list of BaseMessage objects to store.\n   */\n  public async addMessages(messages: BaseMessage[]): Promise<void> {\n    for (const message of messages) {\n      await this.addMessage(message);\n    }\n  }\n\n  /**\n   * Remove all messages from the store.\n   */\n  public clear(): Promise<void> {\n    throw new Error(\"Not implemented.\");\n  }\n}\n\n/**\n * Class for storing chat message history in-memory. It extends the\n * BaseListChatMessageHistory class and provides methods to get, add, and\n * clear messages.\n */\nexport class InMemoryChatMessageHistory extends BaseListChatMessageHistory {\n  lc_namespace = [\"langchain\", \"stores\", \"message\", \"in_memory\"];\n\n  private messages: BaseMessage[] = [];\n\n  constructor(messages?: BaseMessage[]) {\n    super(...arguments);\n    this.messages = messages ?? [];\n  }\n\n  /**\n   * Method to get all the messages stored in the ChatMessageHistory\n   * instance.\n   * @returns Array of stored BaseMessage instances.\n   */\n  async getMessages(): Promise<BaseMessage[]> {\n    return this.messages;\n  }\n\n  /**\n   * Method to add a new message to the ChatMessageHistory instance.\n   * @param message The BaseMessage instance to add.\n   * @returns A promise that resolves when the message has been added.\n   */\n  async addMessage(message: BaseMessage) {\n    this.messages.push(message);\n  }\n\n  /**\n   * Method to clear all the messages from the ChatMessageHistory instance.\n   * @returns A promise that resolves when all messages have been cleared.\n   */\n  async clear() {\n    this.messages = [];\n  }\n}\n","import { cosine } from \"./ml-distance/similarities.js\";\nimport { innerProduct as innerProductDistance } from \"./ml-distance/distances.js\";\nimport { euclidean } from \"./ml-distance-euclidean/euclidean.js\";\n\ntype VectorFunction = (xVector: number[], yVector: number[]) => number;\n\n/**\n * Apply a row-wise function between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n * @param {VectorFunction} func - The function to apply.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the result of applying the function between the corresponding rows of X and Y.\n */\n\nexport function matrixFunc(\n  X: number[][],\n  Y: number[][],\n  func: VectorFunction\n): number[][] {\n  if (\n    X.length === 0 ||\n    X[0].length === 0 ||\n    Y.length === 0 ||\n    Y[0].length === 0\n  ) {\n    return [[]];\n  }\n\n  if (X[0].length !== Y[0].length) {\n    throw new Error(\n      `Number of columns in X and Y must be the same. X has shape ${[\n        X.length,\n        X[0].length,\n      ]} and Y has shape ${[Y.length, Y[0].length]}.`\n    );\n  }\n\n  return X.map((xVector) =>\n    Y.map((yVector) => func(xVector, yVector)).map((similarity) =>\n      Number.isNaN(similarity) ? 0 : similarity\n    )\n  );\n}\n\nexport function normalize(M: number[][], similarity = false): number[][] {\n  const max = matrixMaxVal(M);\n  return M.map((row) =>\n    row.map((val) => (similarity ? 1 - val / max : val / max))\n  );\n}\n\n/**\n * This function calculates the row-wise cosine similarity between two matrices with the same number of columns.\n *\n * @param {number[][]} X - The first matrix.\n * @param {number[][]} Y - The second matrix.\n *\n * @throws {Error} If the number of columns in X and Y are not the same.\n *\n * @returns {number[][] | [[]]} A matrix where each row represents the cosine similarity values between the corresponding rows of X and Y.\n */\nexport function cosineSimilarity(X: number[][], Y: number[][]): number[][] {\n  return matrixFunc(X, Y, cosine);\n}\n\nexport function innerProduct(X: number[][], Y: number[][]): number[][] {\n  return matrixFunc(X, Y, innerProductDistance);\n}\n\nexport function euclideanDistance(X: number[][], Y: number[][]): number[][] {\n  return matrixFunc(X, Y, euclidean);\n}\n\n/**\n * This function implements the Maximal Marginal Relevance algorithm\n * to select a set of embeddings that maximizes the diversity and relevance to a query embedding.\n *\n * @param {number[]|number[][]} queryEmbedding - The query embedding.\n * @param {number[][]} embeddingList - The list of embeddings to select from.\n * @param {number} [lambda=0.5] - The trade-off parameter between relevance and diversity.\n * @param {number} [k=4] - The maximum number of embeddings to select.\n *\n * @returns {number[]} The indexes of the selected embeddings in the embeddingList.\n */\nexport function maximalMarginalRelevance(\n  queryEmbedding: number[] | number[][],\n  embeddingList: number[][],\n  lambda = 0.5,\n  k = 4\n): number[] {\n  if (Math.min(k, embeddingList.length) <= 0) {\n    return [];\n  }\n\n  const queryEmbeddingExpanded = (\n    Array.isArray(queryEmbedding[0]) ? queryEmbedding : [queryEmbedding]\n  ) as number[][];\n\n  const similarityToQuery = cosineSimilarity(\n    queryEmbeddingExpanded,\n    embeddingList\n  )[0];\n  const mostSimilarEmbeddingIndex = argMax(similarityToQuery).maxIndex;\n\n  const selectedEmbeddings = [embeddingList[mostSimilarEmbeddingIndex]];\n  const selectedEmbeddingsIndexes = [mostSimilarEmbeddingIndex];\n\n  while (selectedEmbeddingsIndexes.length < Math.min(k, embeddingList.length)) {\n    let bestScore = -Infinity;\n    let bestIndex = -1;\n\n    const similarityToSelected = cosineSimilarity(\n      embeddingList,\n      selectedEmbeddings\n    );\n\n    similarityToQuery.forEach((queryScore, queryScoreIndex) => {\n      if (selectedEmbeddingsIndexes.includes(queryScoreIndex)) {\n        return;\n      }\n      const maxSimilarityToSelected = Math.max(\n        ...similarityToSelected[queryScoreIndex]\n      );\n      const score =\n        lambda * queryScore - (1 - lambda) * maxSimilarityToSelected;\n\n      if (score > bestScore) {\n        bestScore = score;\n        bestIndex = queryScoreIndex;\n      }\n    });\n    selectedEmbeddings.push(embeddingList[bestIndex]);\n    selectedEmbeddingsIndexes.push(bestIndex);\n  }\n\n  return selectedEmbeddingsIndexes;\n}\n\ntype MaxInfo = {\n  maxIndex: number;\n  maxValue: number;\n};\n\n/**\n * Finds the index of the maximum value in the given array.\n * @param {number[]} array - The input array.\n *\n * @returns {number} The index of the maximum value in the array. If the array is empty, returns -1.\n */\nfunction argMax(array: number[]): MaxInfo {\n  if (array.length === 0) {\n    return {\n      maxIndex: -1,\n      maxValue: NaN,\n    };\n  }\n\n  let maxValue = array[0];\n  let maxIndex = 0;\n\n  for (let i = 1; i < array.length; i += 1) {\n    if (array[i] > maxValue) {\n      maxIndex = i;\n      maxValue = array[i];\n    }\n  }\n  return { maxIndex, maxValue };\n}\n\nfunction matrixMaxVal(arrays: number[][]): number {\n  return arrays.reduce(\n    (acc, array) => Math.max(acc, argMax(array).maxValue),\n    0\n  );\n}\n","import {\n  applyPatch,\n  type Operation as JSONPatchOperation,\n} from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer, type Run } from \"./base.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  CallbackHandlerPrefersStreaming,\n  HandleLLMNewTokenCallbackFields,\n} from \"../callbacks/base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ChatGenerationChunk, GenerationChunk } from \"../outputs.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport type { StreamEvent, StreamEventData } from \"./event_stream.js\";\n\nexport type { StreamEvent, StreamEventData };\n\n/**\n * Interface that represents the structure of a log entry in the\n * `LogStreamCallbackHandler`.\n */\nexport type LogEntry = {\n  /** ID of the sub-run. */\n  id: string;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n  /** List of tags for the run. */\n  tags: string[];\n  /** Key-value pairs of metadata for the run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata: Record<string, any>;\n  /** ISO-8601 timestamp of when the run started. */\n  start_time: string;\n  /** List of general output chunks streamed by this run. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** List of LLM tokens streamed by this run, if applicable. */\n  streamed_output_str: string[];\n  /** Inputs to this run. Not available currently via streamLog. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputs?: any;\n  /** Final output of this run. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /** ISO-8601 timestamp of when the run ended. Only available after the run has finished. */\n  end_time?: string;\n};\n\nexport type RunState = {\n  /** ID of the sub-run. */\n  id: string;\n  /** List of output chunks streamed by Runnable.stream() */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  streamed_output: any[];\n  /** Final output of the run, usually the result of aggregating streamed_output. Only available after the run has finished successfully. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  final_output?: any;\n  /**\n   * List of sub-runs contained in this run, if any, in the order they were started.\n   * If filters were supplied, this list will contain only the runs that matched the filters.\n   */\n  logs: Record<string, LogEntry>;\n  /** Name of the object being run. */\n  name: string;\n  /** Type of the object being run, eg. prompt, chain, llm, etc. */\n  type: string;\n};\n\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n  ops: JSONPatchOperation[];\n\n  constructor(fields: { ops?: JSONPatchOperation[] }) {\n    this.ops = fields.ops ?? [];\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch({}, ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport class RunLog extends RunLogPatch {\n  state: RunState;\n\n  constructor(fields: { ops?: JSONPatchOperation[]; state: RunState }) {\n    super(fields);\n    this.state = fields.state;\n  }\n\n  concat(other: RunLogPatch) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch(this.state, other.ops);\n    return new RunLog({ ops, state: states[states.length - 1].newDocument });\n  }\n\n  static fromRunLogPatch(patch: RunLogPatch) {\n    const states = applyPatch({}, patch.ops);\n    return new RunLog({\n      ops: patch.ops,\n      state: states[states.length - 1].newDocument as RunState,\n    });\n  }\n}\n\nexport type SchemaFormat = \"original\" | \"streaming_events\";\n\nexport interface LogStreamCallbackHandlerInput\n  extends BaseCallbackHandlerInput {\n  autoClose?: boolean;\n  includeNames?: string[];\n  includeTypes?: string[];\n  includeTags?: string[];\n  excludeNames?: string[];\n  excludeTypes?: string[];\n  excludeTags?: string[];\n  _schemaFormat?: SchemaFormat;\n}\n\nexport const isLogStreamHandler = (\n  handler: BaseCallbackHandler\n): handler is LogStreamCallbackHandler => handler.name === \"log_stream_tracer\";\n\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run: Run, schemaFormat: SchemaFormat) {\n  if (schemaFormat === \"original\") {\n    throw new Error(\n      \"Do not assign inputs with original schema drop the key for now. \" +\n        \"When inputs are added to streamLog they should be added with \" +\n        \"standardized schema for streaming events.\"\n    );\n  }\n\n  const { inputs } = run;\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return inputs;\n  }\n\n  if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n    return undefined;\n  }\n\n  // new style chains\n  // These nest an additional 'input' key inside the 'inputs' to make sure\n  // the input is always a dict. We need to unpack and user the inner value.\n  // We should try to fix this in Runnables and callbacks/tracers\n  // Runnables should be using a null type here not a placeholder\n  // dict.\n  return inputs.input;\n}\n\nasync function _getStandardizedOutputs(run: Run, schemaFormat: SchemaFormat) {\n  const { outputs } = run;\n  if (schemaFormat === \"original\") {\n    // Return the old schema, without standardizing anything\n    return outputs;\n  }\n\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return outputs;\n  }\n\n  // TODO: Remove this hacky check\n  if (\n    outputs !== undefined &&\n    Object.keys(outputs).length === 1 &&\n    outputs?.output !== undefined\n  ) {\n    return outputs.output;\n  }\n\n  return outputs;\n}\n\nfunction isChatGenerationChunk(\n  x?: ChatGenerationChunk | GenerationChunk\n): x is ChatGenerationChunk {\n  return x !== undefined && (x as ChatGenerationChunk).message !== undefined;\n}\n\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler\n  extends BaseTracer\n  implements CallbackHandlerPrefersStreaming\n{\n  protected autoClose = true;\n\n  protected includeNames?: string[];\n\n  protected includeTypes?: string[];\n\n  protected includeTags?: string[];\n\n  protected excludeNames?: string[];\n\n  protected excludeTypes?: string[];\n\n  protected excludeTags?: string[];\n\n  protected _schemaFormat: SchemaFormat = \"original\";\n\n  protected rootId?: string;\n\n  private keyMapByRunId: Record<string, string> = {};\n\n  private counterMapByRunName: Record<string, number> = {};\n\n  protected transformStream: TransformStream;\n\n  public writer: WritableStreamDefaultWriter;\n\n  public receiveStream: IterableReadableStream<RunLogPatch>;\n\n  name = \"log_stream_tracer\";\n\n  lc_prefer_streaming = true;\n\n  constructor(fields?: LogStreamCallbackHandlerInput) {\n    super({ _awaitHandler: true, ...fields });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(\n      this.transformStream.readable\n    );\n  }\n\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n\n  _includeRun(run: Run): boolean {\n    if (run.id === this.rootId) {\n      return false;\n    }\n    const runTags = run.tags ?? [];\n    let include =\n      this.includeNames === undefined &&\n      this.includeTags === undefined &&\n      this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.run_type);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include ||\n        runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.run_type);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n\n  async *tapOutputIterable<T>(\n    runId: string,\n    output: AsyncGenerator<T>\n  ): AsyncGenerator<T> {\n    // Tap an output async iterator to stream its values to the log.\n    for await (const chunk of output) {\n      // root run is handled in .streamLog()\n      if (runId !== this.rootId) {\n        // if we can't find the run silently ignore\n        // eg. because this run wasn't included in the log\n        const key = this.keyMapByRunId[runId];\n        if (key) {\n          await this.writer.write(\n            new RunLogPatch({\n              ops: [\n                {\n                  op: \"add\",\n                  path: `/logs/${key}/streamed_output/-`,\n                  value: chunk,\n                },\n              ],\n            })\n          );\n        }\n      }\n      yield chunk;\n    }\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    if (this.rootId === undefined) {\n      this.rootId = run.id;\n      await this.writer.write(\n        new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"\",\n              value: {\n                id: run.id,\n                name: run.name,\n                type: run.run_type,\n                streamed_output: [],\n                final_output: undefined,\n                logs: {},\n              },\n            },\n          ],\n        })\n      );\n    }\n\n    if (!this._includeRun(run)) {\n      return;\n    }\n\n    if (this.counterMapByRunName[run.name] === undefined) {\n      this.counterMapByRunName[run.name] = 0;\n    }\n    this.counterMapByRunName[run.name] += 1;\n    const count = this.counterMapByRunName[run.name];\n    this.keyMapByRunId[run.id] =\n      count === 1 ? run.name : `${run.name}:${count}`;\n\n    const logEntry: LogEntry = {\n      id: run.id,\n      name: run.name,\n      type: run.run_type,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      start_time: new Date(run.start_time).toISOString(),\n      streamed_output: [],\n      streamed_output_str: [],\n      final_output: undefined,\n      end_time: undefined,\n    };\n\n    if (this._schemaFormat === \"streaming_events\") {\n      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n    }\n\n    await this.writer.write(\n      new RunLogPatch({\n        ops: [\n          {\n            op: \"add\",\n            path: `/logs/${this.keyMapByRunId[run.id]}`,\n            value: logEntry,\n          },\n        ],\n      })\n    );\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    try {\n      const runName = this.keyMapByRunId[run.id];\n      if (runName === undefined) {\n        return;\n      }\n      const ops: JSONPatchOperation[] = [];\n      if (this._schemaFormat === \"streaming_events\") {\n        ops.push({\n          op: \"replace\",\n          path: `/logs/${runName}/inputs`,\n          value: await _getStandardizedInputs(run, this._schemaFormat),\n        });\n      }\n      ops.push({\n        op: \"add\",\n        path: `/logs/${runName}/final_output`,\n        value: await _getStandardizedOutputs(run, this._schemaFormat),\n      });\n      if (run.end_time !== undefined) {\n        ops.push({\n          op: \"add\",\n          path: `/logs/${runName}/end_time`,\n          value: new Date(run.end_time).toISOString(),\n        });\n      }\n      const patch = new RunLogPatch({ ops });\n      await this.writer.write(patch);\n    } finally {\n      if (run.id === this.rootId) {\n        const patch = new RunLogPatch({\n          ops: [\n            {\n              op: \"replace\",\n              path: \"/final_output\",\n              value: await _getStandardizedOutputs(run, this._schemaFormat),\n            },\n          ],\n        });\n        await this.writer.write(patch);\n        if (this.autoClose) {\n          await this.writer.close();\n        }\n      }\n    }\n  }\n\n  async onLLMNewToken(\n    run: Run,\n    token: string,\n    kwargs?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    const runName = this.keyMapByRunId[run.id];\n    if (runName === undefined) {\n      return;\n    }\n    // TODO: Remove hack\n    const isChatModel = run.inputs.messages !== undefined;\n    let streamedOutputValue;\n    if (isChatModel) {\n      if (isChatGenerationChunk(kwargs?.chunk)) {\n        streamedOutputValue = kwargs?.chunk;\n      } else {\n        streamedOutputValue = new AIMessageChunk({\n          id: `run-${run.id}`,\n          content: token,\n        });\n      }\n    } else {\n      streamedOutputValue = token;\n    }\n    const patch = new RunLogPatch({\n      ops: [\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output_str/-`,\n          value: token,\n        },\n        {\n          op: \"add\",\n          path: `/logs/${runName}/streamed_output/-`,\n          value: streamedOutputValue,\n        },\n      ],\n    });\n    await this.writer.write(patch);\n  }\n}\n","import { v4 as uuidv4 } from \"uuid\";\nimport { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport { LLMResult } from \"../outputs.js\";\nimport {\n  BaseCallbackHandler,\n  CallbackHandlerMethods,\n  HandleLLMNewTokenCallbackFields,\n  isBaseCallbackHandler,\n  NewTokenIndices,\n} from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { type BaseMessage } from \"../messages/base.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport {\n  getContextVariable,\n  _getConfigureHooks,\n} from \"../singletons/async_local_storage/context.js\";\n\ntype BaseCallbackManagerMethods = {\n  [K in keyof CallbackHandlerMethods]?: (\n    ...args: Parameters<Required<CallbackHandlerMethods>[K]>\n  ) => Promise<unknown>;\n};\n\nexport interface CallbackManagerOptions {\n  verbose?: boolean;\n  tracing?: boolean;\n}\n\nexport type Callbacks =\n  | CallbackManager\n  | (BaseCallbackHandler | CallbackHandlerMethods)[];\n\nexport interface BaseCallbackConfig {\n  /**\n   * Name for the tracer run for this call. Defaults to the name of the class.\n   */\n  runName?: string;\n\n  /**\n   * Tags for this call and any sub-calls (eg. a Chain calling an LLM).\n   * You can use these to filter calls.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Keys should be strings, values should be JSON-serializable.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Callbacks for this call and any sub-calls (eg. a Chain calling an LLM).\n   * Tags are passed to all callbacks, metadata is passed to handle*Start callbacks.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Unique identifier for the tracer run for this call. If not provided, a new UUID\n   * will be generated.\n   */\n  runId?: string;\n}\n\nexport function parseCallbackConfigArg(\n  arg: Callbacks | BaseCallbackConfig | undefined\n): BaseCallbackConfig {\n  if (!arg) {\n    return {};\n  } else if (Array.isArray(arg) || \"name\" in arg) {\n    return { callbacks: arg };\n  } else {\n    return arg;\n  }\n}\n\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport abstract class BaseCallbackManager {\n  abstract addHandler(handler: BaseCallbackHandler): void;\n\n  abstract removeHandler(handler: BaseCallbackHandler): void;\n\n  abstract setHandlers(handlers: BaseCallbackHandler[]): void;\n\n  setHandler(handler: BaseCallbackHandler): void {\n    return this.setHandlers([handler]);\n  }\n}\n\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n  constructor(\n    public readonly runId: string,\n    public readonly handlers: BaseCallbackHandler[],\n    protected readonly inheritableHandlers: BaseCallbackHandler[],\n    protected readonly tags: string[],\n    protected readonly inheritableTags: string[],\n    protected readonly metadata: Record<string, unknown>,\n    protected readonly inheritableMetadata: Record<string, unknown>,\n    protected readonly _parentRunId?: string\n  ) {}\n\n  get parentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleText(text: string): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleText?.(\n              text,\n              this.runId,\n              this._parentRunId,\n              this.tags\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleText: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleCustomEvent(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    _runId?: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          try {\n            await handler.handleCustomEvent?.(\n              eventName,\n              data,\n              this.runId,\n              this.tags,\n              this.metadata\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleRetrieverEnd(documents: DocumentInterface[]): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverEnd?.(\n                documents,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetriever`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleRetrieverError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreRetriever) {\n            try {\n              await handler.handleRetrieverError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (error) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForLLMRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  async handleLLMNewToken(\n    token: string,\n    idx?: NewTokenIndices,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMNewToken?.(\n                token,\n                idx ?? { prompt: 0, completion: 0 },\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                fields\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreLLM) {\n            try {\n              await handler.handleLLMEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                extraParams\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForChainRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleChainError(\n    err: Error | unknown,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleChainEnd(\n    output: ChainValues,\n    _runId?: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreChain) {\n            try {\n              await handler.handleChainEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags,\n                kwargs\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentAction(action: AgentAction): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentAction?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  async handleAgentEnd(action: AgentFinish): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleAgentEnd?.(\n                action,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\nexport class CallbackManagerForToolRun\n  extends BaseRunManager\n  implements BaseCallbackManagerMethods\n{\n  getChild(tag?: string): CallbackManager {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n\n  async handleToolError(err: Error | unknown): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolError?.(\n                err,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolError: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any): Promise<void> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreAgent) {\n            try {\n              await handler.handleToolEnd?.(\n                output,\n                this.runId,\n                this._parentRunId,\n                this.tags\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n}\n\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ model: \"gpt-4o-mini\", temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager\n  extends BaseCallbackManager\n  implements BaseCallbackManagerMethods\n{\n  handlers: BaseCallbackHandler[] = [];\n\n  inheritableHandlers: BaseCallbackHandler[] = [];\n\n  tags: string[] = [];\n\n  inheritableTags: string[] = [];\n\n  metadata: Record<string, unknown> = {};\n\n  inheritableMetadata: Record<string, unknown> = {};\n\n  name = \"callback_manager\";\n\n  public _parentRunId?: string;\n\n  constructor(\n    parentRunId?: string,\n    options?: {\n      handlers?: BaseCallbackHandler[];\n      inheritableHandlers?: BaseCallbackHandler[];\n      tags?: string[];\n      inheritableTags?: string[];\n      metadata?: Record<string, unknown>;\n      inheritableMetadata?: Record<string, unknown>;\n    }\n  ) {\n    super();\n    this.handlers = options?.handlers ?? this.handlers;\n    this.inheritableHandlers =\n      options?.inheritableHandlers ?? this.inheritableHandlers;\n    this.tags = options?.tags ?? this.tags;\n    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n    this.metadata = options?.metadata ?? this.metadata;\n    this.inheritableMetadata =\n      options?.inheritableMetadata ?? this.inheritableMetadata;\n    this._parentRunId = parentRunId;\n  }\n\n  /**\n   * Gets the parent run ID, if any.\n   *\n   * @returns The parent run ID.\n   */\n  getParentRunId() {\n    return this._parentRunId;\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      prompts.map(async (prompt, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForLLMStart(\n                llm,\n                [prompt],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                await handler.handleLLMStart?.(\n                  llm,\n                  [prompt],\n                  runId_,\n                  this._parentRunId,\n                  extraParams,\n                  this.tags,\n                  this.metadata,\n                  runName\n                );\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string | undefined = undefined,\n    _parentRunId: string | undefined = undefined,\n    extraParams: Record<string, unknown> | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForLLMRun[]> {\n    return Promise.all(\n      messages.map(async (messageGroup, idx) => {\n        // Can't have duplicate runs with the same run ID (if provided)\n        const runId_ = idx === 0 && runId ? runId : uuidv4();\n\n        await Promise.all(\n          this.handlers.map((handler) => {\n            if (handler.ignoreLLM) {\n              return;\n            }\n            if (isBaseTracer(handler)) {\n              // Create and add run to the run map.\n              // We do this synchronously to avoid race conditions\n              // when callbacks are backgrounded.\n              handler._createRunForChatModelStart(\n                llm,\n                [messageGroup],\n                runId_,\n                this._parentRunId,\n                extraParams,\n                this.tags,\n                this.metadata,\n                runName\n              );\n            }\n            return consumeCallback(async () => {\n              try {\n                if (handler.handleChatModelStart) {\n                  await handler.handleChatModelStart?.(\n                    llm,\n                    [messageGroup],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                } else if (handler.handleLLMStart) {\n                  const messageString = getBufferString(messageGroup);\n                  await handler.handleLLMStart?.(\n                    llm,\n                    [messageString],\n                    runId_,\n                    this._parentRunId,\n                    extraParams,\n                    this.tags,\n                    this.metadata,\n                    runName\n                  );\n                }\n              } catch (err) {\n                const logFunction = handler.raiseError\n                  ? console.error\n                  : console.warn;\n                logFunction(\n                  `Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`\n                );\n                if (handler.raiseError) {\n                  throw err;\n                }\n              }\n            }, handler.awaitHandlers);\n          })\n        );\n\n        return new CallbackManagerForLLMRun(\n          runId_,\n          this.handlers,\n          this.inheritableHandlers,\n          this.tags,\n          this.inheritableTags,\n          this.metadata,\n          this.inheritableMetadata,\n          this._parentRunId\n        );\n      })\n    );\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId = uuidv4(),\n    runType: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForChainRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreChain) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForChainStart(\n            chain,\n            inputs,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runType,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleChainStart?.(\n              chain,\n              inputs,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runType,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleChainStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForChainRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForToolRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreAgent) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForToolStart(\n            tool,\n            input,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleToolStart?.(\n              tool,\n              input,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleToolStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForToolRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string = uuidv4(),\n    _parentRunId: string | undefined = undefined,\n    _tags: string[] | undefined = undefined,\n    _metadata: Record<string, unknown> | undefined = undefined,\n    runName: string | undefined = undefined\n  ): Promise<CallbackManagerForRetrieverRun> {\n    await Promise.all(\n      this.handlers.map((handler) => {\n        if (handler.ignoreRetriever) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForRetrieverStart(\n            retriever,\n            query,\n            runId,\n            this._parentRunId,\n            this.tags,\n            this.metadata,\n            runName\n          );\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleRetrieverStart?.(\n              retriever,\n              query,\n              runId,\n              this._parentRunId,\n              this.tags,\n              this.metadata,\n              runName\n            );\n          } catch (err) {\n            const logFunction = handler.raiseError\n              ? console.error\n              : console.warn;\n            logFunction(\n              `Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`\n            );\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      })\n    );\n    return new CallbackManagerForRetrieverRun(\n      runId,\n      this.handlers,\n      this.inheritableHandlers,\n      this.tags,\n      this.inheritableTags,\n      this.metadata,\n      this.inheritableMetadata,\n      this._parentRunId\n    );\n  }\n\n  async handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    _tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> {\n    await Promise.all(\n      this.handlers.map((handler) =>\n        consumeCallback(async () => {\n          if (!handler.ignoreCustomEvent) {\n            try {\n              await handler.handleCustomEvent?.(\n                eventName,\n                data,\n                runId,\n                this.tags,\n                this.metadata\n              );\n            } catch (err) {\n              const logFunction = handler.raiseError\n                ? console.error\n                : console.warn;\n              logFunction(\n                `Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`\n              );\n              if (handler.raiseError) {\n                throw err;\n              }\n            }\n          }\n        }, handler.awaitHandlers)\n      )\n    );\n  }\n\n  addHandler(handler: BaseCallbackHandler, inherit = true): void {\n    this.handlers.push(handler);\n    if (inherit) {\n      this.inheritableHandlers.push(handler);\n    }\n  }\n\n  removeHandler(handler: BaseCallbackHandler): void {\n    this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n    this.inheritableHandlers = this.inheritableHandlers.filter(\n      (_handler) => _handler !== handler\n    );\n  }\n\n  setHandlers(handlers: BaseCallbackHandler[], inherit = true): void {\n    this.handlers = [];\n    this.inheritableHandlers = [];\n    for (const handler of handlers) {\n      this.addHandler(handler, inherit);\n    }\n  }\n\n  addTags(tags: string[], inherit = true): void {\n    this.removeTags(tags); // Remove duplicates\n    this.tags.push(...tags);\n    if (inherit) {\n      this.inheritableTags.push(...tags);\n    }\n  }\n\n  removeTags(tags: string[]): void {\n    this.tags = this.tags.filter((tag) => !tags.includes(tag));\n    this.inheritableTags = this.inheritableTags.filter(\n      (tag) => !tags.includes(tag)\n    );\n  }\n\n  addMetadata(metadata: Record<string, unknown>, inherit = true): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    if (inherit) {\n      this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n    }\n  }\n\n  removeMetadata(metadata: Record<string, unknown>): void {\n    for (const key of Object.keys(metadata)) {\n      delete this.metadata[key];\n      delete this.inheritableMetadata[key];\n    }\n  }\n\n  copy(\n    additionalHandlers: BaseCallbackHandler[] = [],\n    inherit = true\n  ): CallbackManager {\n    const manager = new CallbackManager(this._parentRunId);\n    for (const handler of this.handlers) {\n      const inheritable = this.inheritableHandlers.includes(handler);\n      manager.addHandler(handler, inheritable);\n    }\n    for (const tag of this.tags) {\n      const inheritable = this.inheritableTags.includes(tag);\n      manager.addTags([tag], inheritable);\n    }\n    for (const key of Object.keys(this.metadata)) {\n      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n      manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n    }\n    for (const handler of additionalHandlers) {\n      if (\n        // Prevent multiple copies of console_callback_handler\n        manager.handlers\n          .filter((h) => h.name === \"console_callback_handler\")\n          .some((h) => h.name === handler.name)\n      ) {\n        continue;\n      }\n      manager.addHandler(handler, inherit);\n    }\n    return manager;\n  }\n\n  static fromHandlers(handlers: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuidv4();\n\n      constructor() {\n        super();\n        Object.assign(this, handlers);\n      }\n    }\n\n    const manager = new this();\n    manager.addHandler(new Handler());\n    return manager;\n  }\n\n  static configure(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ): CallbackManager | undefined {\n    return this._configureSync(\n      inheritableHandlers,\n      localHandlers,\n      inheritableTags,\n      localTags,\n      inheritableMetadata,\n      localMetadata,\n      options\n    );\n  }\n\n  // TODO: Deprecate async method in favor of this one.\n  static _configureSync(\n    inheritableHandlers?: Callbacks,\n    localHandlers?: Callbacks,\n    inheritableTags?: string[],\n    localTags?: string[],\n    inheritableMetadata?: Record<string, unknown>,\n    localMetadata?: Record<string, unknown>,\n    options?: CallbackManagerOptions\n  ) {\n    let callbackManager: CallbackManager | undefined;\n    if (inheritableHandlers || localHandlers) {\n      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n        callbackManager = new CallbackManager();\n        callbackManager.setHandlers(\n          inheritableHandlers?.map(ensureHandler) ?? [],\n          true\n        );\n      } else {\n        callbackManager = inheritableHandlers;\n      }\n\n      callbackManager = callbackManager.copy(\n        Array.isArray(localHandlers)\n          ? localHandlers.map(ensureHandler)\n          : localHandlers?.handlers,\n        false\n      );\n    }\n\n    const verboseEnabled =\n      getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n      options?.verbose;\n\n    const tracingV2Enabled =\n      LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n      isTracingEnabled();\n\n    const tracingEnabled =\n      tracingV2Enabled ||\n      (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n    if (verboseEnabled || tracingEnabled) {\n      if (!callbackManager) {\n        callbackManager = new CallbackManager();\n      }\n      if (\n        verboseEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === ConsoleCallbackHandler.prototype.name\n        )\n      ) {\n        const consoleHandler = new ConsoleCallbackHandler();\n        callbackManager.addHandler(consoleHandler, true);\n      }\n      if (\n        tracingEnabled &&\n        !callbackManager.handlers.some(\n          (handler) => handler.name === \"langchain_tracer\"\n        )\n      ) {\n        if (tracingV2Enabled) {\n          const tracerV2 = new LangChainTracer();\n          callbackManager.addHandler(tracerV2, true);\n        }\n      }\n      if (tracingV2Enabled) {\n        // handoff between langchain and langsmith/traceable\n        // override the parent run ID\n        const implicitRunTree = LangChainTracer.getTraceableRunTree();\n        if (implicitRunTree && callbackManager._parentRunId === undefined) {\n          callbackManager._parentRunId = implicitRunTree.id;\n          const tracerV2 = callbackManager.handlers.find(\n            (handler) => handler.name === \"langchain_tracer\"\n          ) as LangChainTracer | undefined;\n          tracerV2?.updateFromRunTree(implicitRunTree);\n        }\n      }\n    }\n\n    for (const {\n      contextVar,\n      inheritable = true,\n      handlerClass,\n      envVar,\n    } of _getConfigureHooks()) {\n      const createIfNotInContext =\n        envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n      let handler: BaseCallbackHandler | undefined;\n      const contextVarValue =\n        contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n        handler = contextVarValue;\n      } else if (createIfNotInContext) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handler = new (handlerClass as any)({});\n      }\n      if (handler !== undefined) {\n        if (!callbackManager) {\n          callbackManager = new CallbackManager();\n        }\n\n        if (!callbackManager.handlers.some((h) => h.name === handler!.name)) {\n          callbackManager.addHandler(handler, inheritable);\n        }\n      }\n    }\n\n    if (inheritableTags || localTags) {\n      if (callbackManager) {\n        callbackManager.addTags(inheritableTags ?? []);\n        callbackManager.addTags(localTags ?? [], false);\n      }\n    }\n    if (inheritableMetadata || localMetadata) {\n      if (callbackManager) {\n        callbackManager.addMetadata(inheritableMetadata ?? {});\n        callbackManager.addMetadata(localMetadata ?? {}, false);\n      }\n    }\n\n    return callbackManager;\n  }\n}\n\nexport function ensureHandler(\n  handler: BaseCallbackHandler | CallbackHandlerMethods\n): BaseCallbackHandler {\n  if (\"name\" in handler) {\n    return handler;\n  }\n\n  return BaseCallbackHandler.fromMethods(handler);\n}\n","import type { ZodType as ZodTypeV3 } from \"zod/v3\";\nimport type { $ZodType as ZodTypeV4 } from \"zod/v4/core\";\nimport {\n  AIMessage,\n  type BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  AIMessageChunk,\n  isAIMessageChunk,\n  isBaseMessage,\n  isAIMessage,\n  MessageOutputVersion,\n} from \"../messages/index.js\";\nimport {\n  convertToOpenAIImageBlock,\n  isURLContentBlock,\n  isBase64ContentBlock,\n} from \"../messages/content/data.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  LLMResult,\n  RUN_KEY,\n  type ChatGeneration,\n  ChatGenerationChunk,\n  type ChatResult,\n  type Generation,\n} from \"../outputs.js\";\nimport {\n  BaseLanguageModel,\n  type StructuredOutputMethodOptions,\n  type ToolDefinition,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport {\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport {\n  StructuredToolInterface,\n  StructuredToolParams,\n} from \"../tools/index.js\";\nimport {\n  Runnable,\n  RunnableLambda,\n  RunnableSequence,\n  RunnableToolLike,\n} from \"../runnables/base.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { RunnablePassthrough } from \"../runnables/passthrough.js\";\nimport {\n  getSchemaDescription,\n  InteropZodType,\n  isInteropZodSchema,\n} from \"../utils/types/zod.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\nimport { toJsonSchema } from \"../utils/json_schema.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { castStandardMessageContent, iife } from \"./utils.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ToolChoice = string | Record<string, any> | \"auto\" | \"any\";\n\n/**\n * Represents a serialized chat model.\n */\nexport type SerializedChatModel = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n// todo?\n/**\n * Represents a serialized large language model.\n */\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\n/**\n * Represents the parameters for a base chat model.\n */\nexport type BaseChatModelParams = BaseLanguageModelParams & {\n  /**\n   * Whether to disable streaming.\n   *\n   * If streaming is bypassed, then `stream()` will defer to\n   * `invoke()`.\n   *\n   * - If true, will always bypass streaming case.\n   * - If false (default), will always use streaming case if available.\n   */\n  disableStreaming?: boolean;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\n/**\n * Represents the call options for a base chat model.\n */\nexport type BaseChatModelCallOptions = BaseLanguageModelCallOptions & {\n  /**\n   * Specifies how the chat model should use tools.\n   * @default undefined\n   *\n   * Possible values:\n   * - \"auto\": The model may choose to use any of the provided tools, or none.\n   * - \"any\": The model must use one of the provided tools.\n   * - \"none\": The model must not use any tools.\n   * - A string (not \"auto\", \"any\", or \"none\"): The name of a specific tool the model must use.\n   * - An object: A custom schema specifying tool choice parameters. Specific to the provider.\n   *\n   * Note: Not all providers support tool_choice. An error will be thrown\n   * if used with an unsupported model.\n   */\n  tool_choice?: ToolChoice;\n  /**\n   * Version of `AIMessage` output format to store in message content.\n   *\n   * `AIMessage.contentBlocks` will lazily parse the contents of `content` into a\n   * standard format. This flag can be used to additionally store the standard format\n   * as the message content, e.g., for serialization purposes.\n   *\n   * - \"v0\": provider-specific format in content (can lazily parse with `.contentBlocks`)\n   * - \"v1\": standardized format in content (consistent with `.contentBlocks`)\n   *\n   * You can also set `LC_OUTPUT_VERSION` as an environment variable to \"v1\" to\n   * enable this by default.\n   *\n   * @default \"v0\"\n   */\n  outputVersion?: MessageOutputVersion;\n};\n\nfunction _formatForTracing(messages: BaseMessage[]): BaseMessage[] {\n  const messagesToTrace: BaseMessage[] = [];\n  for (const message of messages) {\n    let messageToTrace = message;\n    if (Array.isArray(message.content)) {\n      for (let idx = 0; idx < message.content.length; idx++) {\n        const block = message.content[idx];\n        if (isURLContentBlock(block) || isBase64ContentBlock(block)) {\n          if (messageToTrace === message) {\n            // Also shallow-copy content\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            messageToTrace = new (message.constructor as any)({\n              ...messageToTrace,\n              content: [\n                ...message.content.slice(0, idx),\n                convertToOpenAIImageBlock(block),\n                ...message.content.slice(idx + 1),\n              ],\n            });\n          }\n        }\n      }\n    }\n    messagesToTrace.push(messageToTrace);\n  }\n  return messagesToTrace;\n}\n\nexport type LangSmithParams = {\n  ls_provider?: string;\n  ls_model_name?: string;\n  ls_model_type: \"chat\";\n  ls_temperature?: number;\n  ls_max_tokens?: number;\n  ls_stop?: Array<string>;\n};\n\nexport type BindToolsInput =\n  | StructuredToolInterface\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  | Record<string, any>\n  | ToolDefinition\n  | RunnableToolLike\n  | StructuredToolParams;\n\n/**\n * Base class for chat models. It extends the BaseLanguageModel class and\n * provides methods for generating chat based on input messages.\n */\nexport abstract class BaseChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions,\n  // TODO: Fix the parameter order on the next minor version.\n  OutputMessageType extends BaseMessageChunk = AIMessageChunk\n> extends BaseLanguageModel<OutputMessageType, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"chat_models\", this._llmType()];\n\n  disableStreaming = false;\n\n  outputVersion?: MessageOutputVersion;\n\n  get callKeys(): string[] {\n    return [...super.callKeys, \"outputVersion\"];\n  }\n\n  constructor(fields: BaseChatModelParams) {\n    super(fields);\n    this.outputVersion = iife(() => {\n      const outputVersion =\n        fields.outputVersion ?? getEnvironmentVariable(\"LC_OUTPUT_VERSION\");\n      if (outputVersion && [\"v0\", \"v1\"].includes(outputVersion)) {\n        return outputVersion as \"v0\" | \"v1\";\n      }\n      return \"v0\";\n    });\n  }\n\n  _combineLLMOutput?(\n    ...llmOutputs: LLMResult[\"llmOutput\"][]\n  ): LLMResult[\"llmOutput\"];\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  /**\n   * Bind tool-like objects to this chat model.\n   *\n   * @param tools A list of tool definitions to bind to this chat model.\n   * Can be a structured tool, an OpenAI formatted tool, or an object\n   * matching the provider's specific tool schema.\n   * @param kwargs Any additional parameters to bind.\n   */\n  bindTools?(\n    tools: BindToolsInput[],\n    kwargs?: Partial<CallOptions>\n  ): Runnable<BaseLanguageModelInput, OutputMessageType, CallOptions>;\n\n  /**\n   * Invokes the chat model with a single input.\n   * @param input The input for the language model.\n   * @param options The call options.\n   * @returns A Promise that resolves to a BaseMessageChunk.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<OutputMessageType> {\n    const promptValue = BaseChatModel._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    const chatGeneration = result.generations[0][0] as ChatGeneration;\n    // TODO: Remove cast after figuring out inheritance\n    return chatGeneration.message as OutputMessageType;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _messages: BaseMessage[],\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<ChatGenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<OutputMessageType> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks ===\n        BaseChatModel.prototype._streamResponseChunks ||\n      this.disableStreaming\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseChatModel._convertInputToPromptValue(input);\n      const messages = prompt.toChatMessages();\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n\n      const inheritableMetadata = {\n        ...runnableConfig.metadata,\n        ...this.getLsParams(callOptions),\n      };\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const outputVersion = callOptions.outputVersion ?? this.outputVersion;\n      const runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        [_formatForTracing(messages)],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generationChunk: ChatGenerationChunk | undefined;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let llmOutput: Record<string, any> | undefined;\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          messages,\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          chunk.message.response_metadata = {\n            ...chunk.generationInfo,\n            ...chunk.message.response_metadata,\n          };\n          if (outputVersion === \"v1\") {\n            yield castStandardMessageContent(\n              chunk.message\n            ) as OutputMessageType;\n          } else {\n            yield chunk.message as OutputMessageType;\n          }\n          if (!generationChunk) {\n            generationChunk = chunk;\n          } else {\n            generationChunk = generationChunk.concat(chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            // TODO: Remove cast after figuring out inheritance\n            generations: [[generationChunk as ChatGeneration]],\n            llmOutput,\n          })\n        )\n      );\n    }\n  }\n\n  getLsParams(options: this[\"ParsedCallOptions\"]): LangSmithParams {\n    const providerName = this.getName().startsWith(\"Chat\")\n      ? this.getName().replace(\"Chat\", \"\")\n      : this.getName();\n\n    return {\n      ls_model_type: \"chat\",\n      ls_stop: options.stop,\n      ls_provider: providerName,\n    };\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    messages: BaseMessageLike[][],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: RunnableConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === baseMessages.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const inheritableMetadata = {\n        ...handledOptions.metadata,\n        ...this.getLsParams(parsedOptions),\n      };\n      // create callback manager and start run\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        inheritableMetadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: 1,\n      };\n      runManagers = await callbackManager_?.handleChatModelStart(\n        this.toJSON(),\n        baseMessages.map(_formatForTracing),\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions.runName\n      );\n    }\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: ChatGeneration[][] = [];\n    const llmOutputs: LLMResult[\"llmOutput\"][] = [];\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    if (\n      hasStreamingHandler &&\n      !this.disableStreaming &&\n      baseMessages.length === 1 &&\n      this._streamResponseChunks !==\n        BaseChatModel.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          baseMessages[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let llmOutput: Record<string, any> | undefined;\n        for await (const chunk of stream) {\n          if (chunk.message.id == null) {\n            const runId = runManagers?.at(0)?.runId;\n            if (runId != null) chunk.message._updateId(`run-${runId}`);\n          }\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n          if (\n            isAIMessageChunk(chunk.message) &&\n            chunk.message.usage_metadata !== undefined\n          ) {\n            llmOutput = {\n              tokenUsage: {\n                promptTokens: chunk.message.usage_metadata.input_tokens,\n                completionTokens: chunk.message.usage_metadata.output_tokens,\n                totalTokens: chunk.message.usage_metadata.total_tokens,\n              },\n            };\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        generations.push([aggregated]);\n        await runManagers?.[0].handleLLMEnd({\n          generations,\n          llmOutput,\n        });\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      // generate results\n      const results = await Promise.allSettled(\n        baseMessages.map(async (messageList, i) => {\n          const generateResults = await this._generate(\n            messageList,\n            { ...parsedOptions, promptIndex: i },\n            runManagers?.[i]\n          );\n          if (outputVersion === \"v1\") {\n            for (const generation of generateResults.generations) {\n              generation.message = castStandardMessageContent(\n                generation.message\n              );\n            }\n          }\n          return generateResults;\n        })\n      );\n      // handle results\n      await Promise.all(\n        results.map(async (pResult, i) => {\n          if (pResult.status === \"fulfilled\") {\n            const result = pResult.value;\n            for (const generation of result.generations) {\n              if (generation.message.id == null) {\n                const runId = runManagers?.at(0)?.runId;\n                if (runId != null) generation.message._updateId(`run-${runId}`);\n              }\n              generation.message.response_metadata = {\n                ...generation.generationInfo,\n                ...generation.message.response_metadata,\n              };\n            }\n            if (result.generations.length === 1) {\n              result.generations[0].message.response_metadata = {\n                ...result.llmOutput,\n                ...result.generations[0].message.response_metadata,\n              };\n            }\n            generations[i] = result.generations;\n            llmOutputs[i] = result.llmOutput;\n            return runManagers?.[i]?.handleLLMEnd({\n              generations: [result.generations],\n              llmOutput: result.llmOutput,\n            });\n          } else {\n            // status === \"rejected\"\n            await runManagers?.[i]?.handleLLMError(pResult.reason);\n            return Promise.reject(pResult.reason);\n          }\n        })\n      );\n    }\n    // create combined output\n    const output: LLMResult = {\n      generations,\n      llmOutput: llmOutputs.length\n        ? this._combineLLMOutput?.(...llmOutputs)\n        : undefined,\n    };\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    messages,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n  }: {\n    messages: BaseMessageLike[][];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const inheritableMetadata = {\n      ...handledOptions.metadata,\n      ...this.getLsParams(parsedOptions),\n    };\n    // create callback manager and start run\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      inheritableMetadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: 1,\n    };\n    const runManagers = await callbackManager_?.handleChatModelStart(\n      this.toJSON(),\n      baseMessages.map(_formatForTracing),\n      handledOptions.runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      baseMessages.map(async (baseMessage, index) => {\n        // Join all content into one string for the prompt index\n        const prompt =\n          BaseChatModel._convertInputToPromptValue(baseMessage).toString();\n        const result = await cache.lookup(prompt, llmStringKey);\n\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const outputVersion = parsedOptions.outputVersion ?? this.outputVersion;\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            if (\n              \"message\" in result &&\n              isBaseMessage(result.message) &&\n              isAIMessage(result.message)\n            ) {\n              result.message.usage_metadata = {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n              };\n              if (outputVersion === \"v1\") {\n                result.message = castStandardMessageContent(result.message);\n              }\n            }\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Generates chat based on the input messages.\n   * @param messages An array of arrays of BaseMessage instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generate(\n    messages: BaseMessageLike[][],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    // parse call options\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const baseMessages = messages.map((messageList) =>\n      messageList.map(coerceMessageLikeToMessage)\n    );\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(baseMessages, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        messages: baseMessages,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => baseMessages[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          // Join all content into one string for the prompt index\n          const prompt = BaseChatModel._convertInputToPromptValue(\n            baseMessages[promptIndex]\n          ).toString();\n          return cache.update(prompt, llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _modelType(): string {\n    return \"base_chat_model\" as const;\n  }\n\n  abstract _llmType(): string;\n\n  /**\n   * Generates a prompt based on the input prompt values.\n   * @param promptValues An array of BasePromptValue instances.\n   * @param options The call options or an array of stop sequences.\n   * @param callbacks The callbacks for the language model.\n   * @returns A Promise that resolves to an LLMResult.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const promptMessages: BaseMessage[][] = promptValues.map((promptValue) =>\n      promptValue.toChatMessages()\n    );\n    return this.generate(promptMessages, options, callbacks);\n  }\n\n  abstract _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV4<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<false>\n  ): Runnable<BaseLanguageModelInput, RunOutput>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | ZodTypeV3<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<true>\n  ): Runnable<BaseLanguageModelInput, { raw: BaseMessage; parsed: RunOutput }>;\n\n  withStructuredOutput<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunOutput extends Record<string, any> = Record<string, any>\n  >(\n    outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>,\n    config?: StructuredOutputMethodOptions<boolean>\n  ):\n    | Runnable<BaseLanguageModelInput, RunOutput>\n    | Runnable<\n        BaseLanguageModelInput,\n        {\n          raw: BaseMessage;\n          parsed: RunOutput;\n        }\n      > {\n    if (typeof this.bindTools !== \"function\") {\n      throw new Error(\n        `Chat model must implement \".bindTools()\" to use withStructuredOutput.`\n      );\n    }\n    if (config?.strict) {\n      throw new Error(\n        `\"strict\" mode is not supported for this model by default.`\n      );\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const schema: Record<string, any> | InteropZodType<RunOutput> =\n      outputSchema;\n    const name = config?.name;\n    const description =\n      getSchemaDescription(schema) ?? \"A function available to call.\";\n    const method = config?.method;\n    const includeRaw = config?.includeRaw;\n    if (method === \"jsonMode\") {\n      throw new Error(\n        `Base withStructuredOutput implementation only supports \"functionCalling\" as a method.`\n      );\n    }\n\n    let functionName = name ?? \"extract\";\n    let tools: ToolDefinition[];\n    if (isInteropZodSchema(schema)) {\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: toJsonSchema(schema),\n          },\n        },\n      ];\n    } else {\n      if (\"name\" in schema) {\n        functionName = schema.name;\n      }\n      tools = [\n        {\n          type: \"function\",\n          function: {\n            name: functionName,\n            description,\n            parameters: schema,\n          },\n        },\n      ];\n    }\n\n    const llm = this.bindTools(tools);\n    const outputParser = RunnableLambda.from<OutputMessageType, RunOutput>(\n      (input: BaseMessageChunk): RunOutput => {\n        if (!AIMessageChunk.isInstance(input)) {\n          throw new Error(\"Input is not an AIMessageChunk.\");\n        }\n        if (!input.tool_calls || input.tool_calls.length === 0) {\n          throw new Error(\"No tool calls found in the response.\");\n        }\n        const toolCall = input.tool_calls.find(\n          (tc) => tc.name === functionName\n        );\n        if (!toolCall) {\n          throw new Error(`No tool call found with name ${functionName}.`);\n        }\n        return toolCall.args as RunOutput;\n      }\n    );\n\n    if (!includeRaw) {\n      return llm.pipe(outputParser).withConfig({\n        runName: \"StructuredOutput\",\n      }) as Runnable<BaseLanguageModelInput, RunOutput>;\n    }\n\n    const parserAssign = RunnablePassthrough.assign({\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      parsed: (input: any, config) => outputParser.invoke(input.raw, config),\n    });\n    const parserNone = RunnablePassthrough.assign({\n      parsed: () => null,\n    });\n    const parsedWithFallback = parserAssign.withFallbacks({\n      fallbacks: [parserNone],\n    });\n    return RunnableSequence.from<\n      BaseLanguageModelInput,\n      { raw: BaseMessage; parsed: RunOutput }\n    >([\n      {\n        raw: llm,\n      },\n      parsedWithFallback,\n    ]).withConfig({\n      runName: \"StructuredOutputRunnable\",\n    });\n  }\n}\n\n/**\n * An abstract class that extends BaseChatModel and provides a simple\n * implementation of _generate.\n */\nexport abstract class SimpleChatModel<\n  CallOptions extends BaseChatModelCallOptions = BaseChatModelCallOptions\n> extends BaseChatModel<CallOptions> {\n  abstract _call(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    messages: BaseMessage[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<ChatResult> {\n    const text = await this._call(messages, options, runManager);\n    const message = new AIMessage(text);\n    if (typeof message.content !== \"string\") {\n      throw new Error(\n        \"Cannot generate with a simple chat model when output is not a string.\"\n      );\n    }\n    return {\n      generations: [\n        {\n          text: message.content,\n          message,\n        },\n      ],\n    };\n  }\n}\n","import {\n  parseBase64DataUrl,\n  isBase64ContentBlock,\n  isIDContentBlock,\n  isURLContentBlock,\n} from \"../content/data.js\";\nimport type { ContentBlock } from \"../content/index.js\";\nimport { _isContentBlock, _isObject, _isString } from \"./utils.js\";\n\nexport function convertToV1FromDataContentBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (isURLContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type,\n      url: block.url,\n      metadata: block.metadata,\n    };\n  }\n  if (isBase64ContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type ?? \"application/octet-stream\",\n      data: block.data,\n      metadata: block.metadata,\n    };\n  }\n  if (isIDContentBlock(block)) {\n    return {\n      type: block.type,\n      mimeType: block.mime_type,\n      fileId: block.id,\n      metadata: block.metadata,\n    };\n  }\n  return block as ContentBlock.Standard;\n}\n\nexport function convertToV1FromDataContent(\n  content: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  return content.map(convertToV1FromDataContentBlock);\n}\n\nexport function isOpenAIDataBlock(block: ContentBlock): boolean {\n  if (_isContentBlock(block, \"image_url\") && _isObject(block.image_url)) {\n    return true;\n  }\n  if (_isContentBlock(block, \"input_audio\") && _isObject(block.input_audio)) {\n    return true;\n  }\n  if (_isContentBlock(block, \"file\") && _isObject(block.file)) {\n    return true;\n  }\n  return false;\n}\n\nexport function convertToV1FromOpenAIDataBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (\n    _isContentBlock(block, \"image_url\") &&\n    _isObject(block.image_url) &&\n    _isString(block.image_url.url)\n  ) {\n    const parsed = parseBase64DataUrl({ dataUrl: block.image_url.url });\n    if (parsed) {\n      return {\n        type: \"image\",\n        mimeType: parsed.mime_type,\n        data: parsed.data,\n      };\n    } else {\n      return {\n        type: \"image\",\n        url: block.image_url.url,\n      };\n    }\n  } else if (\n    _isContentBlock(block, \"input_audio\") &&\n    _isObject(block.input_audio) &&\n    _isString(block.input_audio.data) &&\n    _isString(block.input_audio.format)\n  ) {\n    return {\n      type: \"audio\",\n      data: block.input_audio.data,\n      mimeType: `audio/${block.input_audio.format}`,\n    };\n  } else if (\n    _isContentBlock(block, \"file\") &&\n    _isObject(block.file) &&\n    _isString(block.file.data)\n  ) {\n    const parsed = parseBase64DataUrl({ dataUrl: block.file.data });\n    if (parsed) {\n      return {\n        type: \"file\",\n        data: parsed.data,\n        mimeType: parsed.mime_type,\n      };\n    } else if (_isString(block.file.file_id)) {\n      return {\n        type: \"file\",\n        fileId: block.file.file_id,\n      };\n    }\n  }\n  return block as ContentBlock.Standard;\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { RunTree } from \"langsmith\";\nimport {\n  AsyncLocalStorageInterface,\n  getGlobalAsyncLocalStorageInstance,\n  setGlobalAsyncLocalStorageInstance,\n  _CONTEXT_VARIABLES_KEY,\n} from \"./globals.js\";\nimport { CallbackManager } from \"../../callbacks/manager.js\";\nimport { LangChainTracer } from \"../../tracers/tracer_langchain.js\";\n\nexport class MockAsyncLocalStorage implements AsyncLocalStorageInterface {\n  getStore(): any {\n    return undefined;\n  }\n\n  run<T>(_store: any, callback: () => T): T {\n    return callback();\n  }\n\n  enterWith(_store: any) {\n    return undefined;\n  }\n}\n\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\n\nconst LC_CHILD_KEY = Symbol.for(\"lc:child_config\");\n\nclass AsyncLocalStorageProvider {\n  getInstance(): AsyncLocalStorageInterface {\n    return getGlobalAsyncLocalStorageInstance() ?? mockAsyncLocalStorage;\n  }\n\n  getRunnableConfig() {\n    const storage = this.getInstance();\n    // this has the runnable config\n    // which means that we should also have an instance of a LangChainTracer\n    // with the run map prepopulated\n    return storage.getStore()?.extra?.[LC_CHILD_KEY];\n  }\n\n  runWithConfig<T>(\n    config: any,\n    callback: () => T,\n    avoidCreatingRootRunTree?: boolean\n  ): T {\n    const callbackManager = CallbackManager._configureSync(\n      config?.callbacks,\n      undefined,\n      config?.tags,\n      undefined,\n      config?.metadata\n    );\n    const storage = this.getInstance();\n    const previousValue = storage.getStore();\n    const parentRunId = callbackManager?.getParentRunId();\n\n    const langChainTracer = callbackManager?.handlers?.find(\n      (handler) => handler?.name === \"langchain_tracer\"\n    ) as LangChainTracer | undefined;\n\n    let runTree;\n    if (langChainTracer && parentRunId) {\n      runTree = langChainTracer.getRunTreeWithTracingConfig(parentRunId);\n    } else if (!avoidCreatingRootRunTree) {\n      runTree = new RunTree({\n        name: \"<runnable_lambda>\",\n        tracingEnabled: false,\n      });\n    }\n\n    if (runTree) {\n      runTree.extra = { ...runTree.extra, [LC_CHILD_KEY]: config };\n    }\n\n    if (\n      previousValue !== undefined &&\n      previousValue[_CONTEXT_VARIABLES_KEY] !== undefined\n    ) {\n      if (runTree === undefined) {\n        runTree = {};\n      }\n      (runTree as any)[_CONTEXT_VARIABLES_KEY] =\n        previousValue[_CONTEXT_VARIABLES_KEY];\n    }\n\n    return storage.run(runTree, callback);\n  }\n\n  initializeGlobalInstance(instance: AsyncLocalStorageInterface) {\n    if (getGlobalAsyncLocalStorageInstance() === undefined) {\n      setGlobalAsyncLocalStorageInstance(instance);\n    }\n  }\n}\n\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\n\nexport { AsyncLocalStorageProviderSingleton, type AsyncLocalStorageInterface };\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport PQueueMod from \"p-queue\";\nimport { getGlobalAsyncLocalStorageInstance } from \"./async_local_storage/globals.js\";\nimport { getDefaultLangChainClientSingleton } from \"./tracer.js\";\n\nlet queue: (typeof PQueueMod)[\"prototype\"];\n\n/**\n * Creates a queue using the p-queue library. The queue is configured to\n * auto-start and has a concurrency of 1, meaning it will process tasks\n * one at a time.\n */\nfunction createQueue() {\n  const PQueue: any = \"default\" in PQueueMod ? PQueueMod.default : PQueueMod;\n  return new PQueue({\n    autoStart: true,\n    concurrency: 1,\n  });\n}\n\nexport function getQueue() {\n  if (typeof queue === \"undefined\") {\n    queue = createQueue();\n  }\n  return queue;\n}\n\n/**\n * Consume a promise, either adding it to the queue or waiting for it to resolve\n * @param promiseFn Promise to consume\n * @param wait Whether to wait for the promise to resolve or resolve immediately\n */\nexport async function consumeCallback<T>(\n  promiseFn: () => Promise<T> | T | void,\n  wait: boolean\n): Promise<void> {\n  if (wait === true) {\n    // Clear config since callbacks are not part of the root run\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n    if (asyncLocalStorageInstance !== undefined) {\n      await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n    } else {\n      await promiseFn();\n    }\n  } else {\n    queue = getQueue();\n    // eslint-disable-next-line no-void\n    void queue.add(async () => {\n      const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n      if (asyncLocalStorageInstance !== undefined) {\n        await asyncLocalStorageInstance.run(undefined, async () => promiseFn());\n      } else {\n        await promiseFn();\n      }\n    });\n  }\n}\n\n/**\n * Waits for all promises in the queue to resolve. If the queue is\n * undefined, it immediately resolves a promise.\n */\nexport async function awaitAllCallbacks(): Promise<void> {\n  const defaultClient = getDefaultLangChainClientSingleton();\n  await Promise.allSettled([\n    typeof queue !== \"undefined\" ? queue.onIdle() : Promise.resolve(),\n    defaultClient.awaitPendingTraceBatches(),\n  ]);\n}\n","import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport { KNOWN_BLOCK_TYPES } from \"../content/tools.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport {\n  _isArray,\n  _isBytesArray,\n  _isContentBlock,\n  _isNumber,\n  _isObject,\n  _isString,\n  iife,\n} from \"./utils.js\";\n\n// see `/libs/providers/langchain-aws/src/utils/compat.ts:convertFileFormatToMimeType`\nfunction convertFileFormatToMimeType(format: string): string {\n  switch (format) {\n    // DocumentBlock\n    case \"csv\":\n      return \"text/csv\";\n    case \"doc\":\n      return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n    case \"docx\":\n      return \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n    case \"html\":\n      return \"text/html\";\n    case \"md\":\n      return \"text/markdown\";\n    case \"pdf\":\n      return \"application/pdf\";\n    case \"txt\":\n      return \"text/plain\";\n    case \"xls\":\n      return \"application/vnd.ms-excel\";\n    case \"xlsx\":\n      return \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n    // ImageBlock\n    case \"gif\":\n      return \"image/gif\";\n    case \"jpeg\":\n      return \"image/jpeg\";\n    case \"jpg\":\n      return \"image/jpeg\";\n    case \"png\":\n      return \"image/png\";\n    case \"webp\":\n      return \"image/webp\";\n    // VideoBlock\n    case \"flv\":\n      return \"video/flv\";\n    case \"mkv\":\n      return \"video/mkv\";\n    case \"mov\":\n      return \"video/mov\";\n    case \"mp4\":\n      return \"video/mp4\";\n    case \"mpeg\":\n      return \"video/mpeg\";\n    case \"mpg\":\n      return \"video/mpg\";\n    case \"three_gp\":\n      return \"video/three_gp\";\n    case \"webm\":\n      return \"video/webm\";\n    case \"wmv\":\n      return \"video/wmv\";\n    default:\n      return \"application/octet-stream\";\n  }\n}\n\nfunction convertConverseDocumentBlock(\n  block: ContentBlock\n): ContentBlock.Standard {\n  if (_isObject(block.document) && _isObject(block.document.source)) {\n    const format =\n      _isObject(block.document) && _isString(block.document.format)\n        ? block.document.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.document.source)) {\n      if (\n        _isObject(block.document.source.s3Location) &&\n        _isString(block.document.source.s3Location.uri)\n      ) {\n        return {\n          type: \"file\",\n          mimeType,\n          fileId: block.document.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.document.source.bytes)) {\n        return {\n          type: \"file\",\n          mimeType,\n          data: block.document.source.bytes,\n        };\n      }\n      if (_isString(block.document.source.text)) {\n        return {\n          type: \"file\",\n          mimeType,\n          data: Buffer.from(block.document.source.text).toString(\"base64\"),\n        };\n      }\n      if (_isArray(block.document.source.content)) {\n        const data = block.document.source.content.reduce(\n          (acc: string, item) => {\n            if (_isObject(item) && _isString(item.text)) {\n              return acc + item.text;\n            }\n            return acc;\n          },\n          \"\"\n        );\n        return {\n          type: \"file\",\n          mimeType,\n          data,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nfunction convertConverseImageBlock(block: ContentBlock): ContentBlock.Standard {\n  if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n    const format =\n      _isObject(block.image) && _isString(block.image.format)\n        ? block.image.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.image.source)) {\n      if (\n        _isObject(block.image.source.s3Location) &&\n        _isString(block.image.source.s3Location.uri)\n      ) {\n        return {\n          type: \"image\",\n          mimeType,\n          fileId: block.image.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.image.source.bytes)) {\n        return {\n          type: \"image\",\n          mimeType,\n          data: block.image.source.bytes,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nfunction convertConverseVideoBlock(block: ContentBlock): ContentBlock.Standard {\n  if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n    const format =\n      _isObject(block.video) && _isString(block.video.format)\n        ? block.video.format\n        : \"\";\n    const mimeType = convertFileFormatToMimeType(format);\n\n    if (_isObject(block.video.source)) {\n      if (\n        _isObject(block.video.source.s3Location) &&\n        _isString(block.video.source.s3Location.uri)\n      ) {\n        return {\n          type: \"video\",\n          mimeType,\n          fileId: block.video.source.s3Location.uri,\n        };\n      }\n      if (_isBytesArray(block.video.source.bytes)) {\n        return {\n          type: \"video\",\n          mimeType,\n          data: block.video.source.bytes,\n        };\n      }\n    }\n  }\n  return { type: \"non_standard\", value: block };\n}\n\nexport function convertToV1FromChatBedrockConverseInput(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    const blocks = content.map((block) => {\n      if (_isContentBlock(block, \"non_standard\") && \"value\" in block) {\n        return block.value as ContentBlock;\n      }\n      return block;\n    });\n    for (const block of blocks) {\n      if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (\n        _isContentBlock(block, \"document\") &&\n        _isObject(block.document)\n      ) {\n        yield convertConverseDocumentBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n        yield convertConverseImageBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n        yield convertConverseVideoBlock(block);\n        continue;\n      }\n      if (KNOWN_BLOCK_TYPES.includes(block.type)) {\n        yield block as ContentBlock.Standard;\n      } else {\n        yield { type: \"non_standard\", value: block };\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nfunction convertToV1FromChatBedrockConverseMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  // see `/libs/providers/langchain-aws/src/utils/message_outputs.ts:convertConverseMessageToLangChainMessage`\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"cache_point\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (\n        _isContentBlock(block, \"citations_content\") &&\n        _isObject(block.citationsContent)\n      ) {\n        const text = _isArray(block.citationsContent.content)\n          ? block.citationsContent.content.reduce((acc: string, item) => {\n              if (_isObject(item) && _isString(item.text)) {\n                return acc + item.text;\n              }\n              return acc;\n            }, \"\")\n          : \"\";\n        const annotations = _isArray(block.citationsContent.citations)\n          ? block.citationsContent.citations.reduce(\n              (acc: Array<ContentBlock.Citation>, item) => {\n                if (_isObject(item)) {\n                  const citedText = _isArray(item.sourceContent)\n                    ? item.sourceContent.reduce((acc: string, item) => {\n                        if (_isObject(item) && _isString(item.text)) {\n                          return acc + item.text;\n                        }\n                        return acc;\n                      }, \"\")\n                    : \"\";\n                  const properties = iife(() => {\n                    if (_isObject(item.location)) {\n                      const location =\n                        item.location.documentChar ||\n                        item.location.documentPage ||\n                        item.location.documentChunk;\n                      if (_isObject(location)) {\n                        return {\n                          source: _isNumber(location.documentIndex)\n                            ? location.documentIndex.toString()\n                            : undefined,\n                          startIndex: _isNumber(location.start)\n                            ? location.start\n                            : undefined,\n                          endIndex: _isNumber(location.end)\n                            ? location.end\n                            : undefined,\n                        };\n                      }\n                    }\n                    return {};\n                  });\n                  acc.push({ type: \"citation\", citedText, ...properties });\n                }\n                return acc;\n              },\n              []\n            )\n          : [];\n        yield { type: \"text\", text, annotations };\n        continue;\n      } else if (\n        _isContentBlock(block, \"document\") &&\n        _isObject(block.document)\n      ) {\n        yield convertConverseDocumentBlock(block);\n        continue;\n      } else if (_isContentBlock(block, \"guard_content\")) {\n        yield {\n          type: \"non_standard\",\n          value: block,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"image\") && _isObject(block.image)) {\n        yield convertConverseImageBlock(block);\n        continue;\n      } else if (\n        _isContentBlock(block, \"reasoning_content\") &&\n        _isString(block.reasoningText)\n      ) {\n        yield {\n          type: \"reasoning\",\n          reasoning: block.reasoningText,\n        };\n        continue;\n      } else if (_isContentBlock(block, \"text\") && _isString(block.text)) {\n        yield { type: \"text\", text: block.text };\n        continue;\n      } else if (_isContentBlock(block, \"tool_result\")) {\n        yield { type: \"non_standard\", value: block };\n        continue;\n      } else if (_isContentBlock(block, \"tool_call\")) {\n        // no-op - filtered to tools\n        continue;\n      } else if (_isContentBlock(block, \"video\") && _isObject(block.video)) {\n        yield convertConverseVideoBlock(block);\n        continue;\n      }\n      yield { type: \"non_standard\", value: block };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatBedrockConverseTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromChatBedrockConverseMessage,\n  translateContentChunk: convertToV1FromChatBedrockConverseMessage,\n};\n","import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n} from \"./base.js\";\nimport { MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface FunctionMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"function\"> {\n  name: string;\n}\n\n/**\n * Represents a function message in a conversation.\n */\nexport class FunctionMessage<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessage<TStructure, \"function\">\n  implements FunctionMessageFields<TStructure>\n{\n  static lc_name() {\n    return \"FunctionMessage\";\n  }\n\n  readonly type = \"function\" as const;\n\n  name: string;\n\n  constructor(fields: FunctionMessageFields<TStructure>) {\n    super(fields);\n    this.name = fields.name;\n  }\n}\n\n/**\n * Represents a chunk of a function message, which can be concatenated\n * with other function message chunks.\n */\nexport class FunctionMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"function\"> {\n  static lc_name() {\n    return \"FunctionMessageChunk\";\n  }\n\n  readonly type = \"function\" as const;\n\n  concat(chunk: FunctionMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      name: this.name ?? \"\",\n      id: this.id ?? chunk.id,\n    });\n  }\n}\n\nexport function isFunctionMessage(x: BaseMessage): x is FunctionMessage {\n  return x._getType() === \"function\";\n}\n\nexport function isFunctionMessageChunk(\n  x: BaseMessageChunk\n): x is FunctionMessageChunk {\n  return x._getType() === \"function\";\n}\n","/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the input values for a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InputValues = Record<string, any>;\n\n/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the output values from a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type OutputValues = Record<string, any>;\n\n/**\n * Type alias for a record where the keys are strings and the values can\n * be any type. This is used to represent the memory variables in a Chain.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type MemoryVariables = Record<string, any>;\n\n/**\n * Abstract base class for memory in LangChain's Chains. Memory refers to\n * the state in Chains. It can be used to store information about past\n * executions of a Chain and inject that information into the inputs of\n * future executions of the Chain.\n */\nexport abstract class BaseMemory {\n  abstract get memoryKeys(): string[];\n\n  /**\n   * Abstract method that should take an object of input values and return a\n   * Promise that resolves with an object of memory variables. The\n   * implementation of this method should load the memory variables from the\n   * provided input values.\n   * @param values An object of input values.\n   * @returns Promise that resolves with an object of memory variables.\n   */\n  abstract loadMemoryVariables(values: InputValues): Promise<MemoryVariables>;\n\n  /**\n   * Abstract method that should take two objects, one of input values and\n   * one of output values, and return a Promise that resolves when the\n   * context has been saved. The implementation of this method should save\n   * the context based on the provided input and output values.\n   * @param inputValues An object of input values.\n   * @param outputValues An object of output values.\n   * @returns Promise that resolves when the context has been saved.\n   */\n  abstract saveContext(\n    inputValues: InputValues,\n    outputValues: OutputValues\n  ): Promise<void>;\n}\n\nconst getValue = (values: InputValues | OutputValues, key?: string) => {\n  if (key !== undefined) {\n    return values[key];\n  }\n  const keys = Object.keys(values);\n  if (keys.length === 1) {\n    return values[keys[0]];\n  }\n};\n\n/**\n * This function is used by memory classes to select the input value\n * to use for the memory. If there is only one input value, it is used.\n * If there are multiple input values, the inputKey must be specified.\n */\nexport const getInputValue = (inputValues: InputValues, inputKey?: string) => {\n  const value = getValue(inputValues, inputKey);\n  if (!value) {\n    const keys = Object.keys(inputValues);\n    throw new Error(\n      `input values have ${keys.length} keys, you must specify an input key or pass only 1 key as input`\n    );\n  }\n  return value;\n};\n\n/**\n * This function is used by memory classes to select the output value\n * to use for the memory. If there is only one output value, it is used.\n * If there are multiple output values, the outputKey must be specified.\n * If no outputKey is specified, an error is thrown.\n */\nexport const getOutputValue = (\n  outputValues: OutputValues,\n  outputKey?: string\n) => {\n  const value = getValue(outputValues, outputKey);\n  if (!value && value !== \"\") {\n    const keys = Object.keys(outputValues);\n    throw new Error(\n      `output values have ${keys.length} keys, you must specify an output key or pass only 1 key as output`\n    );\n  }\n  return value;\n};\n\n/**\n * Function used by memory classes to get the key of the prompt input,\n * excluding any keys that are memory variables or the \"stop\" key. If\n * there is not exactly one prompt input key, an error is thrown.\n */\nexport function getPromptInputKey(\n  inputs: Record<string, unknown>,\n  memoryVariables: string[]\n): string {\n  const promptInputKeys = Object.keys(inputs).filter(\n    (key) => !memoryVariables.includes(key) && key !== \"stop\"\n  );\n  if (promptInputKeys.length !== 1) {\n    throw new Error(\n      `One input key expected, but got ${promptInputKeys.length}`\n    );\n  }\n  return promptInputKeys[0];\n}\n","import { BaseRun, Run } from \"langsmith/schemas\";\nimport { BaseTracer } from \"./base.js\";\n\n/**\n * A callback handler that collects traced runs and makes it easy to fetch the traced run object from calls through any langchain object.\n * For instance, it makes it easy to fetch the run ID and then do things with that, such as log feedback.\n */\nexport class RunCollectorCallbackHandler extends BaseTracer {\n  /** The name of the callback handler. */\n  name = \"run_collector\";\n\n  /** The ID of the example. */\n  exampleId?: string;\n\n  /** An array of traced runs. */\n  tracedRuns: Run[];\n\n  /**\n   * Creates a new instance of the RunCollectorCallbackHandler class.\n   * @param exampleId The ID of the example.\n   */\n  constructor({ exampleId }: { exampleId?: string } = {}) {\n    super({ _awaitHandler: true });\n    this.exampleId = exampleId;\n    this.tracedRuns = [];\n  }\n\n  /**\n   * Persists the given run object.\n   * @param run The run object to persist.\n   */\n  protected async persistRun(run: BaseRun): Promise<void> {\n    const run_ = { ...run } as Run;\n    run_.reference_example_id = this.exampleId;\n    this.tracedRuns.push(run_);\n  }\n}\n","import type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport {\n  type LLMResult,\n  RUN_KEY,\n  type Generation,\n  GenerationChunk,\n} from \"../outputs.js\";\nimport {\n  type BaseCallbackConfig,\n  CallbackManager,\n  type CallbackManagerForLLMRun,\n  type Callbacks,\n} from \"../callbacks/manager.js\";\nimport {\n  BaseLanguageModel,\n  type BaseLanguageModelCallOptions,\n  type BaseLanguageModelInput,\n  type BaseLanguageModelParams,\n} from \"./base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BaseCache } from \"../caches/index.js\";\nimport { concat } from \"../utils/stream.js\";\nimport { callbackHandlerPrefersStreaming } from \"../callbacks/base.js\";\n\nexport type SerializedLLM = {\n  _model: string;\n  _type: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n} & Record<string, any>;\n\nexport interface BaseLLMParams extends BaseLanguageModelParams {}\n\nexport interface BaseLLMCallOptions extends BaseLanguageModelCallOptions {}\n\n/**\n * LLM Wrapper. Takes in a prompt (or prompts) and returns a string.\n */\nexport abstract class BaseLLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions\n> extends BaseLanguageModel<string, CallOptions> {\n  // Backwards compatibility since fields have been moved to RunnableConfig\n  declare ParsedCallOptions: Omit<\n    CallOptions,\n    Exclude<keyof RunnableConfig, \"signal\" | \"timeout\" | \"maxConcurrency\">\n  >;\n\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"llms\", this._llmType()];\n\n  /**\n   * This method takes an input and options, and returns a string. It\n   * converts the input to a prompt value and generates a result based on\n   * the prompt.\n   * @param input Input for the LLM.\n   * @param options Options for the LLM call.\n   * @returns A string result based on the prompt.\n   */\n  async invoke(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): Promise<string> {\n    const promptValue = BaseLLM._convertInputToPromptValue(input);\n    const result = await this.generatePrompt(\n      [promptValue],\n      options,\n      options?.callbacks\n    );\n    return result.generations[0][0].text;\n  }\n\n  // eslint-disable-next-line require-yield\n  async *_streamResponseChunks(\n    _input: string,\n    _options: this[\"ParsedCallOptions\"],\n    _runManager?: CallbackManagerForLLMRun\n  ): AsyncGenerator<GenerationChunk> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  protected _separateRunnableConfigFromCallOptionsCompat(\n    options?: Partial<CallOptions>\n  ): [RunnableConfig, this[\"ParsedCallOptions\"]] {\n    // For backwards compat, keep `signal` in both runnableConfig and callOptions\n    const [runnableConfig, callOptions] =\n      super._separateRunnableConfigFromCallOptions(options);\n    (callOptions as this[\"ParsedCallOptions\"]).signal = runnableConfig.signal;\n    return [runnableConfig, callOptions as this[\"ParsedCallOptions\"]];\n  }\n\n  async *_streamIterator(\n    input: BaseLanguageModelInput,\n    options?: CallOptions\n  ): AsyncGenerator<string> {\n    // Subclass check required to avoid double callbacks with default implementation\n    if (\n      this._streamResponseChunks === BaseLLM.prototype._streamResponseChunks\n    ) {\n      yield this.invoke(input, options);\n    } else {\n      const prompt = BaseLLM._convertInputToPromptValue(input);\n      const [runnableConfig, callOptions] =\n        this._separateRunnableConfigFromCallOptionsCompat(options);\n      const callbackManager_ = await CallbackManager.configure(\n        runnableConfig.callbacks,\n        this.callbacks,\n        runnableConfig.tags,\n        this.tags,\n        runnableConfig.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: callOptions,\n        invocation_params: this?.invocationParams(callOptions),\n        batch_size: 1,\n      };\n      const runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        [prompt.toString()],\n        runnableConfig.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        runnableConfig.runName\n      );\n      let generation = new GenerationChunk({\n        text: \"\",\n      });\n      try {\n        for await (const chunk of this._streamResponseChunks(\n          prompt.toString(),\n          callOptions,\n          runManagers?.[0]\n        )) {\n          if (!generation) {\n            generation = chunk;\n          } else {\n            generation = generation.concat(chunk);\n          }\n          if (typeof chunk.text === \"string\") {\n            yield chunk.text;\n          }\n        }\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n      await Promise.all(\n        (runManagers ?? []).map((runManager) =>\n          runManager?.handleLLMEnd({\n            generations: [[generation]],\n          })\n        )\n      );\n    }\n  }\n\n  /**\n   * This method takes prompt values, options, and callbacks, and generates\n   * a result based on the prompts.\n   * @param promptValues Prompt values for the LLM.\n   * @param options Options for the LLM call.\n   * @param callbacks Callbacks for the LLM call.\n   * @returns An LLMResult based on the prompts.\n   */\n  async generatePrompt(\n    promptValues: BasePromptValueInterface[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    const prompts: string[] = promptValues.map((promptValue) =>\n      promptValue.toString()\n    );\n    return this.generate(prompts, options, callbacks);\n  }\n\n  /**\n   * Run the LLM on the given prompts and input.\n   */\n  abstract _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult>;\n\n  /**\n   * Get the parameters used to invoke the model\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  invocationParams(_options?: this[\"ParsedCallOptions\"]): any {\n    return {};\n  }\n\n  _flattenLLMResult(llmResult: LLMResult): LLMResult[] {\n    const llmResults: LLMResult[] = [];\n\n    for (let i = 0; i < llmResult.generations.length; i += 1) {\n      const genList = llmResult.generations[i];\n\n      if (i === 0) {\n        llmResults.push({\n          generations: [genList],\n          llmOutput: llmResult.llmOutput,\n        });\n      } else {\n        const llmOutput = llmResult.llmOutput\n          ? { ...llmResult.llmOutput, tokenUsage: {} }\n          : undefined;\n\n        llmResults.push({\n          generations: [genList],\n          llmOutput,\n        });\n      }\n    }\n\n    return llmResults;\n  }\n\n  /** @ignore */\n  async _generateUncached(\n    prompts: string[],\n    parsedOptions: this[\"ParsedCallOptions\"],\n    handledOptions: BaseCallbackConfig,\n    startedRunManagers?: CallbackManagerForLLMRun[]\n  ): Promise<LLMResult> {\n    let runManagers: CallbackManagerForLLMRun[] | undefined;\n    if (\n      startedRunManagers !== undefined &&\n      startedRunManagers.length === prompts.length\n    ) {\n      runManagers = startedRunManagers;\n    } else {\n      const callbackManager_ = await CallbackManager.configure(\n        handledOptions.callbacks,\n        this.callbacks,\n        handledOptions.tags,\n        this.tags,\n        handledOptions.metadata,\n        this.metadata,\n        { verbose: this.verbose }\n      );\n      const extra = {\n        options: parsedOptions,\n        invocation_params: this?.invocationParams(parsedOptions),\n        batch_size: prompts.length,\n      };\n      runManagers = await callbackManager_?.handleLLMStart(\n        this.toJSON(),\n        prompts,\n        handledOptions.runId,\n        undefined,\n        extra,\n        undefined,\n        undefined,\n        handledOptions?.runName\n      );\n    }\n    // Even if stream is not explicitly called, check if model is implicitly\n    // called from streamEvents() or streamLog() to get all streamed events.\n    // Bail out if _streamResponseChunks not overridden\n    const hasStreamingHandler = !!runManagers?.[0].handlers.find(\n      callbackHandlerPrefersStreaming\n    );\n    let output: LLMResult;\n    if (\n      hasStreamingHandler &&\n      prompts.length === 1 &&\n      this._streamResponseChunks !== BaseLLM.prototype._streamResponseChunks\n    ) {\n      try {\n        const stream = await this._streamResponseChunks(\n          prompts[0],\n          parsedOptions,\n          runManagers?.[0]\n        );\n        let aggregated;\n        for await (const chunk of stream) {\n          if (aggregated === undefined) {\n            aggregated = chunk;\n          } else {\n            aggregated = concat(aggregated, chunk);\n          }\n        }\n        if (aggregated === undefined) {\n          throw new Error(\"Received empty response from chat model call.\");\n        }\n        output = { generations: [[aggregated]], llmOutput: {} };\n        await runManagers?.[0].handleLLMEnd(output);\n      } catch (e) {\n        await runManagers?.[0].handleLLMError(e);\n        throw e;\n      }\n    } else {\n      try {\n        output = await this._generate(prompts, parsedOptions, runManagers?.[0]);\n      } catch (err) {\n        await Promise.all(\n          (runManagers ?? []).map((runManager) =>\n            runManager?.handleLLMError(err)\n          )\n        );\n        throw err;\n      }\n\n      const flattenedOutputs: LLMResult[] = this._flattenLLMResult(output);\n      await Promise.all(\n        (runManagers ?? []).map((runManager, i) =>\n          runManager?.handleLLMEnd(flattenedOutputs[i])\n        )\n      );\n    }\n    const runIds = runManagers?.map((manager) => manager.runId) || undefined;\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runIds ? { runIds } : undefined,\n      configurable: true,\n    });\n    return output;\n  }\n\n  async _generateCached({\n    prompts,\n    cache,\n    llmStringKey,\n    parsedOptions,\n    handledOptions,\n    runId,\n  }: {\n    prompts: string[];\n    cache: BaseCache<Generation[]>;\n    llmStringKey: string;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parsedOptions: any;\n    handledOptions: RunnableConfig;\n    runId?: string;\n  }): Promise<\n    LLMResult & {\n      missingPromptIndices: number[];\n      startedRunManagers?: CallbackManagerForLLMRun[];\n    }\n  > {\n    const callbackManager_ = await CallbackManager.configure(\n      handledOptions.callbacks,\n      this.callbacks,\n      handledOptions.tags,\n      this.tags,\n      handledOptions.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const extra = {\n      options: parsedOptions,\n      invocation_params: this?.invocationParams(parsedOptions),\n      batch_size: prompts.length,\n    };\n    const runManagers = await callbackManager_?.handleLLMStart(\n      this.toJSON(),\n      prompts,\n      runId,\n      undefined,\n      extra,\n      undefined,\n      undefined,\n      handledOptions?.runName\n    );\n\n    // generate results\n    const missingPromptIndices: number[] = [];\n    const results = await Promise.allSettled(\n      prompts.map(async (prompt, index) => {\n        const result = await cache.lookup(prompt, llmStringKey);\n        if (result == null) {\n          missingPromptIndices.push(index);\n        }\n        return result;\n      })\n    );\n\n    // Map run managers to the results before filtering out null results\n    // Null results are just absent from the cache.\n    const cachedResults = results\n      .map((result, index) => ({ result, runManager: runManagers?.[index] }))\n      .filter(\n        ({ result }) =>\n          (result.status === \"fulfilled\" && result.value != null) ||\n          result.status === \"rejected\"\n      );\n\n    // Handle results and call run managers\n    const generations: Generation[][] = [];\n    await Promise.all(\n      cachedResults.map(async ({ result: promiseResult, runManager }, i) => {\n        if (promiseResult.status === \"fulfilled\") {\n          const result = promiseResult.value as Generation[];\n          generations[i] = result.map((result) => {\n            result.generationInfo = {\n              ...result.generationInfo,\n              tokenUsage: {},\n            };\n            return result;\n          });\n          if (result.length) {\n            await runManager?.handleLLMNewToken(result[0].text);\n          }\n          return runManager?.handleLLMEnd(\n            {\n              generations: [result],\n            },\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n        } else {\n          // status === \"rejected\"\n          await runManager?.handleLLMError(\n            promiseResult.reason,\n            undefined,\n            undefined,\n            undefined,\n            {\n              cached: true,\n            }\n          );\n          return Promise.reject(promiseResult.reason);\n        }\n      })\n    );\n\n    const output = {\n      generations,\n      missingPromptIndices,\n      startedRunManagers: runManagers,\n    };\n\n    // This defines RUN_KEY as a non-enumerable property on the output object\n    // so that it is not serialized when the output is stringified, and so that\n    // it isnt included when listing the keys of the output object.\n    Object.defineProperty(output, RUN_KEY, {\n      value: runManagers\n        ? { runIds: runManagers?.map((manager) => manager.runId) }\n        : undefined,\n      configurable: true,\n    });\n\n    return output;\n  }\n\n  /**\n   * Run the LLM on the given prompts and input, handling caching.\n   */\n  async generate(\n    prompts: string[],\n    options?: string[] | CallOptions,\n    callbacks?: Callbacks\n  ): Promise<LLMResult> {\n    if (!Array.isArray(prompts)) {\n      throw new Error(\"Argument 'prompts' is expected to be a string[]\");\n    }\n\n    let parsedOptions: CallOptions | undefined;\n    if (Array.isArray(options)) {\n      parsedOptions = { stop: options } as CallOptions;\n    } else {\n      parsedOptions = options;\n    }\n\n    const [runnableConfig, callOptions] =\n      this._separateRunnableConfigFromCallOptionsCompat(parsedOptions);\n    runnableConfig.callbacks = runnableConfig.callbacks ?? callbacks;\n\n    if (!this.cache) {\n      return this._generateUncached(prompts, callOptions, runnableConfig);\n    }\n\n    const { cache } = this;\n    const llmStringKey = this._getSerializedCacheKeyParametersForCall(\n      callOptions as CallOptions\n    );\n    const { generations, missingPromptIndices, startedRunManagers } =\n      await this._generateCached({\n        prompts,\n        cache,\n        llmStringKey,\n        parsedOptions: callOptions,\n        handledOptions: runnableConfig,\n        runId: runnableConfig.runId,\n      });\n\n    let llmOutput = {};\n    if (missingPromptIndices.length > 0) {\n      const results = await this._generateUncached(\n        missingPromptIndices.map((i) => prompts[i]),\n        callOptions,\n        runnableConfig,\n        startedRunManagers !== undefined\n          ? missingPromptIndices.map((i) => startedRunManagers?.[i])\n          : undefined\n      );\n      await Promise.all(\n        results.generations.map(async (generation, index) => {\n          const promptIndex = missingPromptIndices[index];\n          generations[promptIndex] = generation;\n          return cache.update(prompts[promptIndex], llmStringKey, generation);\n        })\n      );\n      llmOutput = results.llmOutput ?? {};\n    }\n\n    return { generations, llmOutput } as LLMResult;\n  }\n\n  /**\n   * Get the identifying parameters of the LLM.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _identifyingParams(): Record<string, any> {\n    return {};\n  }\n\n  /**\n   * Return the string type key uniquely identifying this class of LLM.\n   */\n  abstract _llmType(): string;\n\n  _modelType(): string {\n    return \"base_llm\" as const;\n  }\n}\n\n/**\n * LLM class that provides a simpler interface to subclass than {@link BaseLLM}.\n *\n * Requires only implementing a simpler {@link _call} method instead of {@link _generate}.\n *\n * @augments BaseLLM\n */\nexport abstract class LLM<\n  CallOptions extends BaseLLMCallOptions = BaseLLMCallOptions\n> extends BaseLLM<CallOptions> {\n  /**\n   * Run the LLM on the given prompt and input.\n   */\n  abstract _call(\n    prompt: string,\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<string>;\n\n  async _generate(\n    prompts: string[],\n    options: this[\"ParsedCallOptions\"],\n    runManager?: CallbackManagerForLLMRun\n  ): Promise<LLMResult> {\n    const generations: Generation[][] = await Promise.all(\n      prompts.map((prompt, promptIndex) =>\n        this._call(prompt, { ...options, promptIndex }, runManager).then(\n          (text) => [{ text }]\n        )\n      )\n    );\n    return { generations };\n  }\n}\n","import { v5 as uuidv5 } from \"uuid\";\nimport { VectorStore } from \"../vectorstores.js\";\nimport { RecordManagerInterface, UUIDV5_NAMESPACE } from \"./record_manager.js\";\nimport { sha256, type HashKeyEncoder } from \"../utils/hash.js\";\nimport { DocumentInterface, Document } from \"../documents/document.js\";\nimport { BaseDocumentLoader } from \"../document_loaders/base.js\";\n\ntype Metadata = Record<string, unknown>;\n\ntype IndexingResult = {\n  numAdded: number;\n  numDeleted: number;\n  numUpdated: number;\n  numSkipped: number;\n};\n\ntype StringOrDocFunc = string | ((doc: DocumentInterface) => string);\n\nexport interface HashedDocumentInterface extends DocumentInterface {\n  uid: string;\n  hash_?: string;\n  contentHash?: string;\n  metadataHash?: string;\n  pageContent: string;\n  metadata: Metadata;\n  calculateHashes(): void;\n  toDocument(): DocumentInterface;\n}\n\ninterface HashedDocumentArgs {\n  pageContent: string;\n  metadata: Metadata;\n  uid: string;\n}\n\n/**\n * HashedDocument is a Document with hashes calculated.\n * Hashes are calculated based on page content and metadata.\n * It is used for indexing.\n */\nexport class _HashedDocument implements HashedDocumentInterface {\n  uid: string;\n\n  hash_?: string;\n\n  contentHash?: string;\n\n  metadataHash?: string;\n\n  pageContent: string;\n\n  metadata: Metadata;\n\n  private keyEncoder: HashKeyEncoder = sha256;\n\n  constructor(fields: HashedDocumentArgs) {\n    this.uid = fields.uid;\n    this.pageContent = fields.pageContent;\n    this.metadata = fields.metadata;\n  }\n\n  makeDefaultKeyEncoder(keyEncoderFn: HashKeyEncoder): void {\n    this.keyEncoder = keyEncoderFn;\n  }\n\n  calculateHashes(): void {\n    const forbiddenKeys = [\"hash_\", \"content_hash\", \"metadata_hash\"];\n\n    for (const key of forbiddenKeys) {\n      if (key in this.metadata) {\n        throw new Error(\n          `Metadata cannot contain key ${key} as it is reserved for internal use. Restricted keys: [${forbiddenKeys.join(\n            \", \"\n          )}]`\n        );\n      }\n    }\n\n    const contentHash = this._hashStringToUUID(this.pageContent);\n\n    try {\n      const metadataHash = this._hashNestedDictToUUID(this.metadata);\n      this.contentHash = contentHash;\n      this.metadataHash = metadataHash;\n    } catch (e) {\n      throw new Error(\n        `Failed to hash metadata: ${e}. Please use a dict that can be serialized using json.`\n      );\n    }\n\n    this.hash_ = this._hashStringToUUID(this.contentHash + this.metadataHash);\n\n    if (!this.uid) {\n      this.uid = this.hash_;\n    }\n  }\n\n  toDocument(): DocumentInterface {\n    return new Document({\n      pageContent: this.pageContent,\n      metadata: this.metadata,\n    });\n  }\n\n  static fromDocument(\n    document: DocumentInterface,\n    uid?: string\n  ): _HashedDocument {\n    const doc = new this({\n      pageContent: document.pageContent,\n      metadata: document.metadata,\n      uid: uid || (document as DocumentInterface & { uid: string }).uid,\n    });\n    doc.calculateHashes();\n    return doc;\n  }\n\n  private _hashStringToUUID(inputString: string): string {\n    const hash_value = this.keyEncoder(inputString);\n    return uuidv5(hash_value, UUIDV5_NAMESPACE);\n  }\n\n  private _hashNestedDictToUUID(data: Record<string, unknown>): string {\n    const serialized_data = JSON.stringify(data, Object.keys(data).sort());\n    const hash_value = this.keyEncoder(serialized_data);\n    return uuidv5(hash_value, UUIDV5_NAMESPACE);\n  }\n}\n\nexport type CleanupMode = \"full\" | \"incremental\";\n\nexport type IndexOptions = {\n  /**\n   * The number of documents to index in one batch.\n   */\n  batchSize?: number;\n  /**\n   * The cleanup mode to use. Can be \"full\", \"incremental\" or undefined.\n   * - **Incremental**: Cleans up all documents that haven't been updated AND\n   *   that are associated with source ids that were seen\n   *   during indexing.\n   *   Clean up is done continuously during indexing helping\n   *   to minimize the probability of users seeing duplicated\n   *   content.\n   * - **Full**: Delete all documents that haven to been returned by the loader.\n   *   Clean up runs after all documents have been indexed.\n   *   This means that users may see duplicated content during indexing.\n   * - **undefined**: Do not delete any documents.\n   */\n  cleanup?: CleanupMode;\n  /**\n   * Optional key that helps identify the original source of the document.\n   * Must either be a string representing the key of the source in the metadata\n   * or a function that takes a document and returns a string representing the source.\n   * **Required when cleanup is incremental**.\n   */\n  sourceIdKey?: StringOrDocFunc;\n  /**\n   * Batch size to use when cleaning up documents.\n   */\n  cleanupBatchSize?: number;\n  /**\n   * Force update documents even if they are present in the\n   * record manager. Useful if you are re-indexing with updated embeddings.\n   */\n  forceUpdate?: boolean;\n};\n\nexport function _batch<T>(size: number, iterable: T[]): T[][] {\n  const batches: T[][] = [];\n  let currentBatch: T[] = [];\n\n  iterable.forEach((item) => {\n    currentBatch.push(item);\n\n    if (currentBatch.length >= size) {\n      batches.push(currentBatch);\n      currentBatch = [];\n    }\n  });\n\n  if (currentBatch.length > 0) {\n    batches.push(currentBatch);\n  }\n\n  return batches;\n}\n\nexport function _deduplicateInOrder(\n  hashedDocuments: HashedDocumentInterface[]\n): HashedDocumentInterface[] {\n  const seen = new Set<string>();\n  const deduplicated: HashedDocumentInterface[] = [];\n\n  for (const hashedDoc of hashedDocuments) {\n    if (!hashedDoc.hash_) {\n      throw new Error(\"Hashed document does not have a hash\");\n    }\n\n    if (!seen.has(hashedDoc.hash_)) {\n      seen.add(hashedDoc.hash_);\n      deduplicated.push(hashedDoc);\n    }\n  }\n  return deduplicated;\n}\n\nexport function _getSourceIdAssigner(\n  sourceIdKey: StringOrDocFunc | null\n): (doc: DocumentInterface) => string | null {\n  if (sourceIdKey === null) {\n    return (_doc: DocumentInterface) => null;\n  } else if (typeof sourceIdKey === \"string\") {\n    return (doc: DocumentInterface) => doc.metadata[sourceIdKey];\n  } else if (typeof sourceIdKey === \"function\") {\n    return sourceIdKey;\n  } else {\n    throw new Error(\n      `sourceIdKey should be null, a string or a function, got ${typeof sourceIdKey}`\n    );\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const _isBaseDocumentLoader = (arg: any): arg is BaseDocumentLoader => {\n  if (\n    \"load\" in arg &&\n    typeof arg.load === \"function\" &&\n    \"loadAndSplit\" in arg &&\n    typeof arg.loadAndSplit === \"function\"\n  ) {\n    return true;\n  }\n  return false;\n};\n\ninterface IndexArgs {\n  docsSource: BaseDocumentLoader | DocumentInterface[];\n  recordManager: RecordManagerInterface;\n  vectorStore: VectorStore;\n  options?: IndexOptions;\n}\n\n/**\n * Index data from the doc source into the vector store.\n *\n * Indexing functionality uses a manager to keep track of which documents\n * are in the vector store.\n *\n * This allows us to keep track of which documents were updated, and which\n * documents were deleted, which documents should be skipped.\n *\n * For the time being, documents are indexed using their hashes, and users\n *  are not able to specify the uid of the document.\n *\n * @param {IndexArgs} args\n * @param {BaseDocumentLoader | DocumentInterface[]} args.docsSource The source of documents to index. Can be a DocumentLoader or a list of Documents.\n * @param {RecordManagerInterface} args.recordManager The record manager to use for keeping track of indexed documents.\n * @param {VectorStore} args.vectorStore The vector store to use for storing the documents.\n * @param {IndexOptions | undefined} args.options Options for indexing.\n * @returns {Promise<IndexingResult>}\n */\nexport async function index(args: IndexArgs): Promise<IndexingResult> {\n  const { docsSource, recordManager, vectorStore, options } = args;\n  const {\n    batchSize = 100,\n    cleanup,\n    sourceIdKey,\n    cleanupBatchSize = 1000,\n    forceUpdate = false,\n  } = options ?? {};\n\n  if (cleanup === \"incremental\" && !sourceIdKey) {\n    throw new Error(\n      \"sourceIdKey is required when cleanup mode is incremental. Please provide through 'options.sourceIdKey'.\"\n    );\n  }\n\n  const docs = _isBaseDocumentLoader(docsSource)\n    ? await docsSource.load()\n    : docsSource;\n\n  const sourceIdAssigner = _getSourceIdAssigner(sourceIdKey ?? null);\n\n  const indexStartDt = await recordManager.getTime();\n  let numAdded = 0;\n  let numDeleted = 0;\n  let numUpdated = 0;\n  let numSkipped = 0;\n\n  const batches = _batch<DocumentInterface>(batchSize ?? 100, docs);\n\n  for (const batch of batches) {\n    const hashedDocs = _deduplicateInOrder(\n      batch.map((doc) => _HashedDocument.fromDocument(doc))\n    );\n\n    const sourceIds = hashedDocs.map((doc) => sourceIdAssigner(doc));\n\n    if (cleanup === \"incremental\") {\n      hashedDocs.forEach((_hashedDoc, index) => {\n        const source = sourceIds[index];\n        if (source === null) {\n          throw new Error(\n            \"sourceIdKey must be provided when cleanup is incremental\"\n          );\n        }\n      });\n    }\n\n    const batchExists = await recordManager.exists(\n      hashedDocs.map((doc) => doc.uid)\n    );\n\n    const uids: string[] = [];\n    const docsToIndex: DocumentInterface[] = [];\n    const docsToUpdate: string[] = [];\n    const seenDocs = new Set<string>();\n    hashedDocs.forEach((hashedDoc, i) => {\n      const docExists = batchExists[i];\n      if (docExists) {\n        if (forceUpdate) {\n          seenDocs.add(hashedDoc.uid);\n        } else {\n          docsToUpdate.push(hashedDoc.uid);\n          return;\n        }\n      }\n      uids.push(hashedDoc.uid);\n      docsToIndex.push(hashedDoc.toDocument());\n    });\n\n    if (docsToUpdate.length > 0) {\n      await recordManager.update(docsToUpdate, { timeAtLeast: indexStartDt });\n      numSkipped += docsToUpdate.length;\n    }\n\n    if (docsToIndex.length > 0) {\n      await vectorStore.addDocuments(docsToIndex, { ids: uids });\n      numAdded += docsToIndex.length - seenDocs.size;\n      numUpdated += seenDocs.size;\n    }\n\n    await recordManager.update(\n      hashedDocs.map((doc) => doc.uid),\n      { timeAtLeast: indexStartDt, groupIds: sourceIds }\n    );\n\n    if (cleanup === \"incremental\") {\n      sourceIds.forEach((sourceId) => {\n        if (!sourceId) throw new Error(\"Source id cannot be null\");\n      });\n      const uidsToDelete = await recordManager.listKeys({\n        before: indexStartDt,\n        groupIds: sourceIds,\n      });\n\n      if (uidsToDelete.length > 0) {\n        await vectorStore.delete({ ids: uidsToDelete });\n        await recordManager.deleteKeys(uidsToDelete);\n        numDeleted += uidsToDelete.length;\n      }\n    }\n  }\n\n  if (cleanup === \"full\") {\n    let uidsToDelete = await recordManager.listKeys({\n      before: indexStartDt,\n      limit: cleanupBatchSize,\n    });\n    while (uidsToDelete.length > 0) {\n      await vectorStore.delete({ ids: uidsToDelete });\n      await recordManager.deleteKeys(uidsToDelete);\n      numDeleted += uidsToDelete.length;\n      uidsToDelete = await recordManager.listKeys({\n        before: indexStartDt,\n        limit: cleanupBatchSize,\n      });\n    }\n  }\n\n  return {\n    numAdded,\n    numDeleted,\n    numUpdated,\n    numSkipped,\n  };\n}\n","import { MessageContent, ContentBlock } from \"../messages/index.js\";\nimport { ImagePromptValue, ImageContent } from \"../prompt_values.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport {\n  BasePromptTemplate,\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  TemplateFormat,\n  checkValidTemplate,\n  renderTemplate,\n} from \"./template.js\";\n\n/**\n * Inputs to create a {@link ImagePromptTemplate}\n * @augments BasePromptTemplateInput\n */\nexport interface ImagePromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt template\n   */\n  template: Record<string, unknown>;\n\n  /**\n   * The format of the prompt template. Options are 'f-string'\n   *\n   * @defaultValue 'f-string'\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n}\n\n/**\n * An image prompt template for a multimodal model.\n */\nexport class ImagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplate<RunInput, ImagePromptValue, PartialVariableName> {\n  static lc_name() {\n    return \"ImagePromptTemplate\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompts\", \"image\"];\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  /**\n   * Additional fields which should be included inside\n   * the message content array if using a complex message\n   * content.\n   */\n  additionalContentFields?: ContentBlock;\n\n  constructor(input: ImagePromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    this.template = input.template;\n    this.templateFormat = input.templateFormat ?? this.templateFormat;\n    this.validateTemplate = input.validateTemplate ?? this.validateTemplate;\n    this.additionalContentFields = input.additionalContentFields;\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        [\n          { type: \"image_url\", image_url: this.template },\n        ] as unknown as MessageContent,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"prompt\" {\n    return \"prompt\";\n  }\n\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of ImagePromptTemplate with the partially applied values.\n   */\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new ImagePromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format<FormatOutput = ImageContent>(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<FormatOutput> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const formatted: Record<string, any> = {};\n    for (const [key, value] of Object.entries(this.template)) {\n      if (typeof value === \"string\") {\n        formatted[key] = renderTemplate(value, this.templateFormat, values);\n      } else {\n        formatted[key] = value;\n      }\n    }\n    const url = values.url || formatted.url;\n    const detail = values.detail || formatted.detail;\n    if (!url) {\n      throw new Error(\"Must provide either an image URL.\");\n    }\n    if (typeof url !== \"string\") {\n      throw new Error(\"url must be a string.\");\n    }\n    const output: ImageContent = { url };\n    if (detail) {\n      output.detail = detail;\n    }\n    return output as FormatOutput;\n  }\n\n  /**\n   * Formats the prompt given the input values and returns a formatted\n   * prompt value.\n   * @param values The input values to format the prompt.\n   * @returns A Promise that resolves to a formatted prompt value.\n   */\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<ImagePromptValue> {\n    const formattedPrompt = await this.format(values);\n    return new ImagePromptValue(formattedPrompt);\n  }\n}\n","import { Optional } from \"../../types/type-utils.js\";\nimport { Generation, ChatGeneration } from \"../../outputs.js\";\nimport { BaseLLMOutputParser } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { JsonSchema7ObjectType } from \"../../utils/json_schema.js\";\nimport {\n  compare,\n  type Operation as JSONPatchOperation,\n} from \"../../utils/json_patch.js\";\n\n/**\n * Represents optional parameters for a function in a JSON Schema.\n */\nexport type FunctionParameters = Optional<\n  JsonSchema7ObjectType,\n  \"additionalProperties\"\n>;\n\n/**\n * Class for parsing the output of an LLM. Can be configured to return\n * only the arguments of the function call in the output.\n */\nexport class OutputFunctionsParser extends BaseLLMOutputParser<string> {\n  static lc_name() {\n    return \"OutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  argsOnly = true;\n\n  constructor(config?: { argsOnly?: boolean }) {\n    super();\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n  }\n\n  /**\n   * Parses the output and returns a string representation of the function\n   * call or its arguments.\n   * @param generations The output of the LLM to parse.\n   * @returns A string representation of the function call or its arguments.\n   */\n  async parseResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<string> {\n    if (\"message\" in generations[0]) {\n      const gen = generations[0] as ChatGeneration;\n      const functionCall = gen.message.additional_kwargs.function_call;\n      if (!functionCall) {\n        throw new Error(\n          `No function_call in message ${JSON.stringify(generations)}`\n        );\n      }\n      if (!functionCall.arguments) {\n        throw new Error(\n          `No arguments in function_call ${JSON.stringify(generations)}`\n        );\n      }\n      if (this.argsOnly) {\n        return functionCall.arguments;\n      }\n      return JSON.stringify(functionCall);\n    } else {\n      throw new Error(\n        `No message in generations ${JSON.stringify(generations)}`\n      );\n    }\n  }\n}\n\n/**\n * Class for parsing the output of an LLM into a JSON object. Uses an\n * instance of `OutputFunctionsParser` to parse the output.\n */\nexport class JsonOutputFunctionsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Output extends Record<string, any> = Record<string, any>\n> extends BaseCumulativeTransformOutputParser<Output> {\n  static lc_name() {\n    return \"JsonOutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  outputParser: OutputFunctionsParser;\n\n  argsOnly = true;\n\n  constructor(\n    config?: { argsOnly?: boolean } & BaseCumulativeTransformOutputParserInput\n  ) {\n    super(config);\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n    this.outputParser = new OutputFunctionsParser(config);\n  }\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): JSONPatchOperation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    const ops = compare(prev ?? {}, next);\n    return ops;\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[]\n  ): Promise<Output | undefined> {\n    const generation = generations[0];\n    if (!generation.message) {\n      return undefined;\n    }\n    const { message } = generation;\n    const functionCall = message.additional_kwargs.function_call;\n    if (!functionCall) {\n      return undefined;\n    }\n    if (this.argsOnly) {\n      return parsePartialJson(functionCall.arguments);\n    }\n\n    return {\n      ...functionCall,\n      arguments: parsePartialJson(functionCall.arguments),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } as Record<string, any> as Output;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parseResult(\n    generations: Generation[] | ChatGeneration[]\n  ): Promise<Output> {\n    const result = await this.outputParser.parseResult(generations);\n    if (!result) {\n      throw new Error(\n        `No result from \"OutputFunctionsParser\" ${JSON.stringify(generations)}`\n      );\n    }\n    return this.parse(result);\n  }\n\n  async parse(text: string): Promise<Output> {\n    const parsedResult = JSON.parse(text);\n    if (this.argsOnly) {\n      return parsedResult;\n    }\n    parsedResult.arguments = JSON.parse(parsedResult.arguments);\n    return parsedResult;\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n}\n\n/**\n * Class for parsing the output of an LLM into a JSON object and returning\n * a specific attribute. Uses an instance of `JsonOutputFunctionsParser`\n * to parse the output.\n */\nexport class JsonKeyOutputFunctionsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>\n> extends BaseLLMOutputParser<T> {\n  static lc_name() {\n    return \"JsonKeyOutputFunctionsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_functions\"];\n\n  lc_serializable = true;\n\n  outputParser = new JsonOutputFunctionsParser();\n\n  attrName: string;\n\n  get lc_aliases() {\n    return {\n      attrName: \"key_name\",\n    };\n  }\n\n  constructor(fields: { attrName: string }) {\n    super(fields);\n    this.attrName = fields.attrName;\n  }\n\n  /**\n   * Parses the output and returns a specific attribute of the parsed JSON\n   * object.\n   * @param generations The output of the LLM to parse.\n   * @returns The value of a specific attribute of the parsed JSON object.\n   */\n  async parseResult(generations: Generation[] | ChatGeneration[]): Promise<T> {\n    const result = await this.outputParser.parseResult(generations);\n    return result[this.attrName as keyof typeof result] as T;\n  }\n}\n","import { VectorStore } from \"../vectorstores.js\";\nimport {\n  Comparator,\n  Comparators,\n  Comparison,\n  Operation,\n  Operator,\n  Operators,\n  StructuredQuery,\n  Visitor,\n  VisitorComparisonResult,\n  VisitorOperationResult,\n  VisitorResult,\n  VisitorStructuredQueryResult,\n} from \"./ir.js\";\nimport { isFilterEmpty, castValue } from \"./utils.js\";\n\n/**\n * Options object for the BasicTranslator class. Specifies the allowed\n * operators and comparators.\n */\nexport type TranslatorOpts = {\n  allowedOperators: Operator[];\n  allowedComparators: Comparator[];\n};\n\n/**\n * Abstract class that provides a blueprint for creating specific\n * translator classes. Defines two abstract methods: formatFunction and\n * mergeFilters.\n */\nexport abstract class BaseTranslator<\n  T extends VectorStore = VectorStore\n> extends Visitor<T> {\n  /**\n   * Formats a given function (either an operator or a comparator) into a\n   * string.\n   * @param func The function to format.\n   * @returns Formatted string representation of the function.\n   */\n  abstract formatFunction(func: Operator | Comparator): string;\n\n  /**\n   * Merges two filters into one, using a specified merge type.\n   * @param defaultFilter The default filter.\n   * @param generatedFilter The generated filter.\n   * @param mergeType The type of merge to perform. Can be 'and', 'or', or 'replace'.\n   * @param forceDefaultFilter If true, the default filter will be used even if the generated filter is not empty.\n   * @returns The merged filter, or undefined if both filters are empty.\n   */\n  abstract mergeFilters(\n    defaultFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    generatedFilter: this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined,\n    mergeType?: \"and\" | \"or\" | \"replace\",\n    forceDefaultFilter?: boolean\n  ): this[\"VisitStructuredQueryOutput\"][\"filter\"] | undefined;\n}\n\n/**\n * Class that extends the BaseTranslator class and provides concrete\n * implementations for the abstract methods. Also declares three types:\n * VisitOperationOutput, VisitComparisonOutput, and\n * VisitStructuredQueryOutput, which are used as the return types for the\n * visitOperation, visitComparison, and visitStructuredQuery methods\n * respectively.\n */\nexport class BasicTranslator<\n  T extends VectorStore = VectorStore\n> extends BaseTranslator<T> {\n  declare VisitOperationOutput: VisitorOperationResult;\n\n  declare VisitComparisonOutput: VisitorComparisonResult;\n\n  declare VisitStructuredQueryOutput: VisitorStructuredQueryResult;\n\n  allowedOperators: Operator[];\n\n  allowedComparators: Comparator[];\n\n  constructor(opts?: TranslatorOpts) {\n    super();\n    this.allowedOperators = opts?.allowedOperators ?? [\n      Operators.and,\n      Operators.or,\n    ];\n    this.allowedComparators = opts?.allowedComparators ?? [\n      Comparators.eq,\n      Comparators.ne,\n      Comparators.gt,\n      Comparators.gte,\n      Comparators.lt,\n      Comparators.lte,\n    ];\n  }\n\n  formatFunction(func: Operator | Comparator): string {\n    if (func in Comparators) {\n      if (\n        this.allowedComparators.length > 0 &&\n        this.allowedComparators.indexOf(func as Comparator) === -1\n      ) {\n        throw new Error(\n          `Comparator ${func} not allowed. Allowed comparators: ${this.allowedComparators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else if (func in Operators) {\n      if (\n        this.allowedOperators.length > 0 &&\n        this.allowedOperators.indexOf(func as Operator) === -1\n      ) {\n        throw new Error(\n          `Operator ${func} not allowed. Allowed operators: ${this.allowedOperators.join(\n            \", \"\n          )}`\n        );\n      }\n    } else {\n      throw new Error(\"Unknown comparator or operator\");\n    }\n    return `$${func}`;\n  }\n\n  /**\n   * Visits an operation and returns a result.\n   * @param operation The operation to visit.\n   * @returns The result of visiting the operation.\n   */\n  visitOperation(operation: Operation): this[\"VisitOperationOutput\"] {\n    const args = operation.args?.map((arg) =>\n      arg.accept(this)\n    ) as VisitorResult[];\n    return {\n      [this.formatFunction(operation.operator)]: args,\n    };\n  }\n\n  /**\n   * Visits a comparison and returns a result.\n   * @param comparison The comparison to visit.\n   * @returns The result of visiting the comparison.\n   */\n  visitComparison(comparison: Comparison): this[\"VisitComparisonOutput\"] {\n    return {\n      [comparison.attribute]: {\n        [this.formatFunction(comparison.comparator)]: castValue(\n          comparison.value\n        ),\n      },\n    };\n  }\n\n  /**\n   * Visits a structured query and returns a result.\n   * @param query The structured query to visit.\n   * @returns The result of visiting the structured query.\n   */\n  visitStructuredQuery(\n    query: StructuredQuery\n  ): this[\"VisitStructuredQueryOutput\"] {\n    let nextArg = {};\n    if (query.filter) {\n      nextArg = {\n        filter: query.filter.accept(this),\n      };\n    }\n    return nextArg;\n  }\n\n  mergeFilters(\n    defaultFilter: VisitorStructuredQueryResult[\"filter\"] | undefined,\n    generatedFilter: VisitorStructuredQueryResult[\"filter\"] | undefined,\n    mergeType = \"and\",\n    forceDefaultFilter = false\n  ): VisitorStructuredQueryResult[\"filter\"] | undefined {\n    if (isFilterEmpty(defaultFilter) && isFilterEmpty(generatedFilter)) {\n      return undefined;\n    }\n    if (isFilterEmpty(defaultFilter) || mergeType === \"replace\") {\n      if (isFilterEmpty(generatedFilter)) {\n        return undefined;\n      }\n      return generatedFilter;\n    }\n    if (isFilterEmpty(generatedFilter)) {\n      if (forceDefaultFilter) {\n        return defaultFilter;\n      }\n      if (mergeType === \"and\") {\n        return undefined;\n      }\n      return defaultFilter;\n    }\n    if (mergeType === \"and\") {\n      return {\n        $and: [defaultFilter, generatedFilter],\n      };\n    } else if (mergeType === \"or\") {\n      return {\n        $or: [defaultFilter, generatedFilter],\n      };\n    } else {\n      throw new Error(\"Unknown merge type\");\n    }\n  }\n}\n","import { ZodFirstPartyTypeKind } from \"zod/v3\";\nimport { parseAnyDef } from \"./parsers/any.js\";\nimport { parseArrayDef } from \"./parsers/array.js\";\nimport { parseBigintDef } from \"./parsers/bigint.js\";\nimport { parseBooleanDef } from \"./parsers/boolean.js\";\nimport { parseBrandedDef } from \"./parsers/branded.js\";\nimport { parseCatchDef } from \"./parsers/catch.js\";\nimport { parseDateDef } from \"./parsers/date.js\";\nimport { parseDefaultDef } from \"./parsers/default.js\";\nimport { parseEffectsDef } from \"./parsers/effects.js\";\nimport { parseEnumDef } from \"./parsers/enum.js\";\nimport { parseIntersectionDef } from \"./parsers/intersection.js\";\nimport { parseLiteralDef } from \"./parsers/literal.js\";\nimport { parseMapDef } from \"./parsers/map.js\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.js\";\nimport { parseNeverDef } from \"./parsers/never.js\";\nimport { parseNullDef } from \"./parsers/null.js\";\nimport { parseNullableDef } from \"./parsers/nullable.js\";\nimport { parseNumberDef } from \"./parsers/number.js\";\nimport { parseObjectDef } from \"./parsers/object.js\";\nimport { parseOptionalDef } from \"./parsers/optional.js\";\nimport { parsePipelineDef } from \"./parsers/pipeline.js\";\nimport { parsePromiseDef } from \"./parsers/promise.js\";\nimport { parseRecordDef } from \"./parsers/record.js\";\nimport { parseSetDef } from \"./parsers/set.js\";\nimport { parseStringDef } from \"./parsers/string.js\";\nimport { parseTupleDef } from \"./parsers/tuple.js\";\nimport { parseUndefinedDef } from \"./parsers/undefined.js\";\nimport { parseUnionDef } from \"./parsers/union.js\";\nimport { parseUnknownDef } from \"./parsers/unknown.js\";\nimport { Refs } from \"./Refs.js\";\nimport { parseReadonlyDef } from \"./parsers/readonly.js\";\nimport { JsonSchema7Type } from \"./parseTypes.js\";\n\nexport type InnerDefGetter = () => any;\n\nexport const selectParser = (\n  def: any,\n  typeName: ZodFirstPartyTypeKind,\n  refs: Refs\n): JsonSchema7Type | undefined | InnerDefGetter => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef(refs);\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef(refs);\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => (def as any).getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef(refs);\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef(refs);\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef(refs);\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return undefined;\n    default:\n      /* c8 ignore next */\n      return ((_: never) => undefined)(typeName);\n  }\n};\n","import type { Embeddings } from \"../embeddings.js\";\nimport type {\n  VectorStoreInterface,\n  VectorStoreRetrieverInterface,\n  VectorStore,\n} from \"../vectorstores.js\";\nimport type { Example } from \"../prompts/base.js\";\nimport { Document } from \"../documents/document.js\";\nimport { BaseExampleSelector } from \"./base.js\";\n\nfunction sortedValues<T>(values: Record<string, T>): T[] {\n  return Object.keys(values)\n    .sort()\n    .map((key) => values[key]);\n}\n\n/**\n * Interface for the input data of the SemanticSimilarityExampleSelector\n * class.\n */\nexport type SemanticSimilarityExampleSelectorInput<\n  V extends VectorStoreInterface = VectorStoreInterface\n> =\n  | {\n      vectorStore: V;\n      k?: number;\n      filter?: V[\"FilterType\"];\n      exampleKeys?: string[];\n      inputKeys?: string[];\n      vectorStoreRetriever?: never;\n    }\n  | {\n      vectorStoreRetriever: VectorStoreRetrieverInterface<V>;\n      exampleKeys?: string[];\n      inputKeys?: string[];\n      vectorStore?: never;\n      k?: never;\n      filter?: never;\n    };\n\n/**\n * Class that selects examples based on semantic similarity. It extends\n * the BaseExampleSelector class.\n * @example\n * ```typescript\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt: PromptTemplate.fromTemplate(\n *     \"Input: {input}\\nOutput: {output}\",\n *   ),\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n * ```\n */\nexport class SemanticSimilarityExampleSelector<\n  V extends VectorStoreInterface = VectorStoreInterface\n> extends BaseExampleSelector {\n  vectorStoreRetriever: VectorStoreRetrieverInterface<V>;\n\n  exampleKeys?: string[];\n\n  inputKeys?: string[];\n\n  constructor(data: SemanticSimilarityExampleSelectorInput<V>) {\n    super(data);\n    this.exampleKeys = data.exampleKeys;\n    this.inputKeys = data.inputKeys;\n    if (data.vectorStore !== undefined) {\n      this.vectorStoreRetriever = data.vectorStore.asRetriever({\n        k: data.k ?? 4,\n        filter: data.filter,\n      });\n    } else if (data.vectorStoreRetriever) {\n      this.vectorStoreRetriever = data.vectorStoreRetriever;\n    } else {\n      throw new Error(\n        `You must specify one of \"vectorStore\" and \"vectorStoreRetriever\".`\n      );\n    }\n  }\n\n  /**\n   * Method that adds a new example to the vectorStore. The example is\n   * converted to a string and added to the vectorStore as a document.\n   * @param example The example to be added to the vectorStore.\n   * @returns Promise that resolves when the example has been added to the vectorStore.\n   */\n  async addExample(example: Example): Promise<void> {\n    const inputKeys = this.inputKeys ?? Object.keys(example);\n    const stringExample = sortedValues(\n      inputKeys.reduce(\n        (acc, key) => ({ ...acc, [key]: example[key] }),\n        {} as Example\n      )\n    ).join(\" \");\n\n    await this.vectorStoreRetriever.addDocuments([\n      new Document({\n        pageContent: stringExample,\n        metadata: example,\n      }),\n    ]);\n  }\n\n  /**\n   * Method that selects which examples to use based on semantic similarity.\n   * It performs a similarity search in the vectorStore using the input\n   * variables and returns the examples with the highest similarity.\n   * @param inputVariables The input variables used for the similarity search.\n   * @returns Promise that resolves with an array of the selected examples.\n   */\n  async selectExamples<T>(\n    inputVariables: Record<string, T>\n  ): Promise<Example[]> {\n    const inputKeys = this.inputKeys ?? Object.keys(inputVariables);\n    const query = sortedValues(\n      inputKeys.reduce(\n        (acc, key) => ({ ...acc, [key]: inputVariables[key] }),\n        {} as Record<string, T>\n      )\n    ).join(\" \");\n\n    const exampleDocs = await this.vectorStoreRetriever.invoke(query);\n\n    const examples = exampleDocs.map((doc) => doc.metadata);\n    if (this.exampleKeys) {\n      // If example keys are provided, filter examples to those keys.\n      return examples.map((example) =>\n        (this.exampleKeys as string[]).reduce(\n          (acc, key) => ({ ...acc, [key]: example[key] }),\n          {}\n        )\n      );\n    }\n    return examples;\n  }\n\n  /**\n   * Static method that creates a new instance of\n   * SemanticSimilarityExampleSelector. It takes a list of examples, an\n   * instance of Embeddings, a VectorStore class, and an options object as\n   * parameters. It converts the examples to strings, creates a VectorStore\n   * from the strings and the embeddings, and returns a new\n   * SemanticSimilarityExampleSelector with the created VectorStore and the\n   * options provided.\n   * @param examples The list of examples to be used.\n   * @param embeddings The instance of Embeddings to be used.\n   * @param vectorStoreCls The VectorStore class to be used.\n   * @param options The options object for the SemanticSimilarityExampleSelector.\n   * @returns Promise that resolves with a new instance of SemanticSimilarityExampleSelector.\n   */\n  static async fromExamples<C extends typeof VectorStore>(\n    examples: Record<string, string>[],\n    embeddings: Embeddings,\n    vectorStoreCls: C,\n    options: {\n      k?: number;\n      inputKeys?: string[];\n    } & Parameters<C[\"fromTexts\"]>[3] = {}\n  ): Promise<SemanticSimilarityExampleSelector> {\n    const inputKeys = options.inputKeys ?? null;\n    const stringExamples = examples.map((example) =>\n      sortedValues(\n        inputKeys\n          ? inputKeys.reduce(\n              (acc, key) => ({ ...acc, [key]: example[key] }),\n              {} as Record<string, string>\n            )\n          : example\n      ).join(\" \")\n    );\n\n    const vectorStore = await vectorStoreCls.fromTexts(\n      stringExamples,\n      examples, // metadatas\n      embeddings,\n      options\n    );\n\n    return new SemanticSimilarityExampleSelector({\n      vectorStore,\n      k: options.k ?? 4,\n      exampleKeys: options.exampleKeys,\n      inputKeys: options.inputKeys,\n    });\n  }\n}\n","import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\nimport { areSetsEqual } from \"./named_barrier_value.js\";\n\nexport interface WaitForNames<Value> {\n  __names: Value[];\n}\n\nfunction isWaitForNames<Value>(\n  v: WaitForNames<Value> | Value\n): v is WaitForNames<Value> {\n  return (v as WaitForNames<Value>).__names !== undefined;\n}\n\n/**\n * A channel that switches between two states\n *\n * - in the \"priming\" state it can't be read from.\n *     - if it receives a WaitForNames update, it switches to the \"waiting\" state.\n * - in the \"waiting\" state it collects named values until all are received.\n *     - once all named values are received, it can be read once, and it switches\n *       back to the \"priming\" state.\n */\nexport class DynamicBarrierValue<Value> extends BaseChannel<\n  void,\n  Value | WaitForNames<Value>,\n  [Value[] | undefined, Value[]]\n> {\n  lc_graph_name = \"DynamicBarrierValue\";\n\n  names?: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  constructor() {\n    super();\n    this.names = undefined;\n    this.seen = new Set<Value>();\n  }\n\n  fromCheckpoint(checkpoint?: [Value[] | undefined, Value[]]) {\n    const empty = new DynamicBarrierValue<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      empty.names = new Set(checkpoint[0]);\n      empty.seen = new Set(checkpoint[1]);\n    }\n    return empty as this;\n  }\n\n  update(values: (Value | WaitForNames<Value>)[]): boolean {\n    const waitForNames = values.filter(isWaitForNames);\n    if (waitForNames.length > 0) {\n      if (waitForNames.length > 1) {\n        throw new InvalidUpdateError(\n          \"Received multiple WaitForNames updates in the same step.\"\n        );\n      }\n      this.names = new Set(waitForNames[0].__names);\n      return true;\n    } else if (this.names !== undefined) {\n      let updated = false;\n      for (const value of values) {\n        if (isWaitForNames(value)) {\n          throw new Error(\n            \"Assertion Error: Received unexpected WaitForNames instance.\"\n          );\n        }\n        if (this.names.has(value) && !this.seen.has(value)) {\n          this.seen.add(value);\n          updated = true;\n        }\n      }\n      return updated;\n    }\n    return false;\n  }\n\n  consume(): boolean {\n    if (this.seen && this.names && areSetsEqual(this.seen, this.names)) {\n      this.seen = new Set<Value>();\n      this.names = undefined;\n      return true;\n    }\n    return false;\n  }\n\n  // If we have not yet seen all the node names we want to wait for,\n  // throw an error to prevent continuing.\n  get(): void {\n    if (!this.names || !areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): [Value[] | undefined, Value[]] {\n    return [this.names ? [...this.names] : undefined, [...this.seen]];\n  }\n\n  isAvailable(): boolean {\n    return !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n\n/**\n * A channel that switches between two states with an additional finished flag\n *\n * - in the \"priming\" state it can't be read from.\n *     - if it receives a WaitForNames update, it switches to the \"waiting\" state.\n * - in the \"waiting\" state it collects named values until all are received.\n *     - once all named values are received, and the finished flag is set, it can be read once, and it switches\n *       back to the \"priming\" state.\n * @internal\n */\nexport class DynamicBarrierValueAfterFinish<Value> extends BaseChannel<\n  void,\n  Value | WaitForNames<Value>,\n  [Value[] | undefined, Value[], boolean]\n> {\n  lc_graph_name = \"DynamicBarrierValueAfterFinish\";\n\n  names?: Set<Value>; // Names of nodes that we want to wait for.\n\n  seen: Set<Value>;\n\n  finished: boolean;\n\n  constructor() {\n    super();\n    this.names = undefined;\n    this.seen = new Set<Value>();\n    this.finished = false;\n  }\n\n  fromCheckpoint(checkpoint?: [Value[] | undefined, Value[], boolean]) {\n    const empty = new DynamicBarrierValueAfterFinish<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      const [names, seen, finished] = checkpoint;\n      empty.names = names ? new Set(names) : undefined;\n      empty.seen = new Set(seen);\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: (Value | WaitForNames<Value>)[]): boolean {\n    const waitForNames = values.filter(isWaitForNames);\n    if (waitForNames.length > 0) {\n      if (waitForNames.length > 1) {\n        throw new InvalidUpdateError(\n          \"Received multiple WaitForNames updates in the same step.\"\n        );\n      }\n      this.names = new Set(waitForNames[0].__names);\n      return true;\n    } else if (this.names !== undefined) {\n      let updated = false;\n      for (const value of values) {\n        if (isWaitForNames(value)) {\n          throw new Error(\n            \"Assertion Error: Received unexpected WaitForNames instance.\"\n          );\n        }\n        if (this.names.has(value) && !this.seen.has(value)) {\n          this.seen.add(value);\n          updated = true;\n        }\n      }\n      return updated;\n    }\n    return false;\n  }\n\n  consume(): boolean {\n    if (\n      this.finished &&\n      this.seen &&\n      this.names &&\n      areSetsEqual(this.seen, this.names)\n    ) {\n      this.seen = new Set<Value>();\n      this.names = undefined;\n      this.finished = false;\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && this.names && areSetsEqual(this.names, this.seen)) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  get(): void {\n    if (!this.finished || !this.names || !areSetsEqual(this.names, this.seen)) {\n      throw new EmptyChannelError();\n    }\n    return undefined;\n  }\n\n  checkpoint(): [Value[] | undefined, Value[], boolean] {\n    return [\n      this.names ? [...this.names] : undefined,\n      [...this.seen],\n      this.finished,\n    ];\n  }\n\n  isAvailable(): boolean {\n    return this.finished && !!this.names && areSetsEqual(this.names, this.seen);\n  }\n}\n","import { z } from \"zod/v3\";\nimport {\n  BaseOutputParser,\n  FormatInstructionsOptions,\n  OutputParserException,\n} from \"./base.js\";\nimport {\n  type InteropZodType,\n  type InferInteropZodOutput,\n  interopParseAsync,\n} from \"../utils/types/zod.js\";\nimport {\n  toJsonSchema,\n  type JsonSchema7Type,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"../utils/json_schema.js\";\n\nexport type JsonMarkdownStructuredOutputParserInput = {\n  interpolationDepth?: number;\n};\n\nexport interface JsonMarkdownFormatInstructionsOptions\n  extends FormatInstructionsOptions {\n  interpolationDepth?: number;\n}\n\nexport class StructuredOutputParser<\n  T extends InteropZodType\n> extends BaseOutputParser<InferInteropZodOutput<T>> {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"structured\"];\n\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n\n  constructor(public schema: T) {\n    super(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this(schema);\n  }\n\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this(zodSchema);\n  }\n\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions(): string {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(toJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text: string): Promise<InferInteropZodOutput<T>> {\n    try {\n      const trimmedText = text.trim();\n\n      const json =\n        // first case: if back ticks appear at the start of the text\n        trimmedText.match(/^```(?:json)?\\s*([\\s\\S]*?)```/)?.[1] ||\n        // second case: if back ticks with `json` appear anywhere in the text\n        trimmedText.match(/```json\\s*([\\s\\S]*?)```/)?.[1] ||\n        // otherwise, return the trimmed text\n        trimmedText;\n\n      const escapedJson = json\n        .replace(/\"([^\"\\\\]*(\\\\.[^\"\\\\]*)*)\"/g, (_match, capturedGroup) => {\n          const escapedInsideQuotes = capturedGroup.replace(/\\n/g, \"\\\\n\");\n          return `\"${escapedInsideQuotes}\"`;\n        })\n        .replace(/\\n/g, \"\");\n\n      return await interopParseAsync(this.schema, JSON.parse(escapedJson));\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n  }\n}\n\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser<\n  T extends InteropZodType\n> extends StructuredOutputParser<T> {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n\n  getFormatInstructions(\n    options?: JsonMarkdownFormatInstructionsOptions\n  ): string {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(\n      toJsonSchema(this.schema)\n    )\n      .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n      .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n\n  private _schemaToInstruction(\n    schemaInput: JsonSchema7Type,\n    indent = 2\n  ): string {\n    const schema = schemaInput as Extract<\n      JsonSchema7Type,\n      | JsonSchema7ObjectType\n      | JsonSchema7ArrayType\n      | JsonSchema7StringType\n      | JsonSchema7NumberType\n      | JsonSchema7NullableType\n    >;\n\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type: string;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex((type) => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \") as string;\n      } else {\n        type = schema.type;\n      }\n\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        const properties = Object.entries(schema.properties)\n          .map(([key, value]) => {\n            const isOptional = schema.required?.includes(key)\n              ? \"\"\n              : \" (optional)\";\n            return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(\n              value,\n              indent + 2\n            )}${isOptional}`;\n          })\n          .join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description\n          ? ` // ${schema.description}`\n          : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(\n          schema.items,\n          indent + 2\n        )}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n\n    if (\"anyOf\" in schema) {\n      return schema.anyOf\n        .map((s) => this._schemaToInstruction(s, indent))\n        .join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n\n    throw new Error(\"unsupported schema type\");\n  }\n\n  static fromZodSchema<T extends InteropZodType>(schema: T) {\n    return new this<T>(schema);\n  }\n\n  static fromNamesAndDescriptions<S extends { [key: string]: string }>(\n    schemas: S\n  ) {\n    const zodSchema = z.object(\n      Object.fromEntries(\n        Object.entries(schemas).map(\n          ([name, description]) =>\n            [name, z.string().describe(description)] as const\n        )\n      )\n    );\n\n    return new this<typeof zodSchema>(zodSchema);\n  }\n}\n\nexport interface AsymmetricStructuredOutputParserFields<\n  T extends InteropZodType\n> {\n  inputSchema: T;\n}\n\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport abstract class AsymmetricStructuredOutputParser<\n  T extends InteropZodType,\n  Y = unknown\n> extends BaseOutputParser<Y> {\n  private structuredInputParser: JsonMarkdownStructuredOutputParser<T>;\n\n  constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>) {\n    super(...arguments);\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(\n      inputSchema\n    );\n  }\n\n  /**\n   * Processes the parsed input into the desired output format. Must be\n   * implemented by subclasses.\n   * @param input The parsed input\n   * @returns The processed output.\n   */\n  abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n\n  async parse(text: string): Promise<Y> {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${text}\". Error: ${e}`,\n        text\n      );\n    }\n\n    return this.outputProcessor(parsedInput);\n  }\n\n  getFormatInstructions(): string {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}\n","import type { BaseChatModel } from \"../language_models/chat_models.js\";\nimport type { BasePromptTemplate } from \"../prompts/base.js\";\nimport type { BaseLanguageModelInterface } from \"../language_models/base.js\";\nimport type { BaseLLM } from \"../language_models/llms.js\";\nimport type { PartialValues } from \"../utils/types/index.js\";\n\nexport type BaseGetPromptAsyncOptions = {\n  partialVariables?: PartialValues;\n};\n\n/**\n * Abstract class that defines the interface for selecting a prompt for a\n * given language model.\n */\nexport abstract class BasePromptSelector {\n  /**\n   * Abstract method that must be implemented by any class that extends\n   * `BasePromptSelector`. It takes a language model as an argument and\n   * returns a prompt template.\n   * @param llm The language model for which to get a prompt.\n   * @returns A prompt template.\n   */\n  abstract getPrompt(llm: BaseLanguageModelInterface): BasePromptTemplate;\n\n  /**\n   * Asynchronous version of `getPrompt` that also accepts an options object\n   * for partial variables.\n   * @param llm The language model for which to get a prompt.\n   * @param options Optional object for partial variables.\n   * @returns A Promise that resolves to a prompt template.\n   */\n  async getPromptAsync(\n    llm: BaseLanguageModelInterface,\n    options?: BaseGetPromptAsyncOptions\n  ): Promise<BasePromptTemplate> {\n    const prompt = this.getPrompt(llm);\n    return prompt.partial(options?.partialVariables ?? {});\n  }\n}\n\n/**\n * Concrete implementation of `BasePromptSelector` that selects a prompt\n * based on a set of conditions. It has a default prompt that it returns\n * if none of the conditions are met.\n */\nexport class ConditionalPromptSelector extends BasePromptSelector {\n  defaultPrompt: BasePromptTemplate;\n\n  conditionals: Array<\n    [\n      condition: (llm: BaseLanguageModelInterface) => boolean,\n      prompt: BasePromptTemplate\n    ]\n  >;\n\n  constructor(\n    default_prompt: BasePromptTemplate,\n    conditionals: Array<\n      [\n        condition: (llm: BaseLanguageModelInterface) => boolean,\n        prompt: BasePromptTemplate\n      ]\n    > = []\n  ) {\n    super();\n    this.defaultPrompt = default_prompt;\n    this.conditionals = conditionals;\n  }\n\n  /**\n   * Method that selects a prompt based on a set of conditions. If none of\n   * the conditions are met, it returns the default prompt.\n   * @param llm The language model for which to get a prompt.\n   * @returns A prompt template.\n   */\n  getPrompt(llm: BaseLanguageModelInterface): BasePromptTemplate {\n    for (const [condition, prompt] of this.conditionals) {\n      if (condition(llm)) {\n        return prompt;\n      }\n    }\n    return this.defaultPrompt;\n  }\n}\n\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseLLM`.\n */\nexport function isLLM(llm: BaseLanguageModelInterface): llm is BaseLLM {\n  return llm._modelType() === \"base_llm\";\n}\n\n/**\n * Type guard function that checks if a given language model is of type\n * `BaseChatModel`.\n */\nexport function isChatModel(\n  llm: BaseLanguageModelInterface\n): llm is BaseChatModel {\n  return llm._modelType() === \"base_chat_model\";\n}\n","import { Runnable } from \"../runnables/base.js\";\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport type { DocumentInterface } from \"./document.js\";\n\n/**\n * Abstract base class for document transformation systems.\n *\n * A document transformation system takes an array of Documents and returns an\n * array of transformed Documents. These arrays do not necessarily have to have\n * the same length.\n *\n * One example of this is a text splitter that splits a large document into\n * many smaller documents.\n */\nexport abstract class BaseDocumentTransformer<\n  RunInput extends DocumentInterface[] = DocumentInterface[],\n  RunOutput extends DocumentInterface[] = DocumentInterface[]\n> extends Runnable<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"documents\", \"transformers\"];\n\n  /**\n   * Transform a list of documents.\n   * @param documents A sequence of documents to be transformed.\n   * @returns A list of transformed documents.\n   */\n  abstract transformDocuments(documents: RunInput): Promise<RunOutput>;\n\n  /**\n   * Method to invoke the document transformation. This method calls the\n   * transformDocuments method with the provided input.\n   * @param input The input documents to be transformed.\n   * @param _options Optional configuration object to customize the behavior of callbacks.\n   * @returns A Promise that resolves to the transformed documents.\n   */\n  invoke(input: RunInput, _options?: BaseCallbackConfig): Promise<RunOutput> {\n    return this.transformDocuments(input);\n  }\n}\n\n/**\n * Class for document transformers that return exactly one transformed document\n * for each input document.\n */\nexport abstract class MappingDocumentTransformer extends BaseDocumentTransformer {\n  async transformDocuments(\n    documents: DocumentInterface[]\n  ): Promise<DocumentInterface[]> {\n    const newDocuments = [];\n    for (const document of documents) {\n      const transformedDocument = await this._transformDocument(document);\n      newDocuments.push(transformedDocument);\n    }\n    return newDocuments;\n  }\n\n  abstract _transformDocument(\n    document: DocumentInterface\n  ): Promise<DocumentInterface>;\n}\n","import { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { StreamMode, StreamOutputMap } from \"./types.js\";\n\n// [namespace, streamMode, payload]\nexport type StreamChunk = [string[], StreamMode, unknown];\n\ntype StreamCheckpointsOutput<StreamValues> = StreamOutputMap<\n  \"checkpoints\",\n  false,\n  StreamValues,\n  unknown,\n  string,\n  unknown,\n  unknown,\n  undefined\n>;\n\ntype AnyStreamOutput = StreamOutputMap<\n  StreamMode[],\n  true,\n  unknown,\n  unknown,\n  string,\n  unknown,\n  unknown,\n  undefined\n>;\n\n/**\n * A wrapper around an IterableReadableStream that allows for aborting the stream when\n * {@link cancel} is called.\n */\nexport class IterableReadableStreamWithAbortSignal<\n  T\n> extends IterableReadableStream<T> {\n  protected _abortController: AbortController;\n\n  protected _innerReader: ReadableStreamDefaultReader<T>;\n\n  /**\n   * @param readableStream - The stream to wrap.\n   * @param abortController - The abort controller to use. Optional. One will be created if not provided.\n   */\n  constructor(\n    readableStream: ReadableStream<T>,\n    abortController?: AbortController\n  ) {\n    const reader = readableStream.getReader();\n    const ac = abortController ?? new AbortController();\n    super({\n      start(controller: ReadableStreamDefaultController<T>) {\n        return pump();\n        function pump(): Promise<T | undefined> {\n          return reader.read().then(({ done, value }) => {\n            // When no more data needs to be consumed, close the stream\n            if (done) {\n              controller.close();\n              return;\n            }\n            // Enqueue the next data chunk into our target stream\n            controller.enqueue(value);\n            return pump();\n          });\n        }\n      },\n    });\n    this._abortController = ac;\n    this._innerReader = reader;\n  }\n\n  /**\n   * Aborts the stream, abandoning any pending operations in progress. Calling this triggers an\n   * {@link AbortSignal} that is propagated to the tasks that are producing the data for this stream.\n   * @param reason - The reason for aborting the stream. Optional.\n   */\n  override async cancel(reason?: unknown) {\n    this._abortController.abort(reason);\n    this._innerReader.releaseLock();\n  }\n\n  /**\n   * The {@link AbortSignal} for the stream. Aborted when {@link cancel} is called.\n   */\n  get signal() {\n    return this._abortController.signal;\n  }\n}\n\nexport class IterableReadableWritableStream extends IterableReadableStream<StreamChunk> {\n  modes: Set<StreamMode>;\n\n  private controller: ReadableStreamDefaultController;\n\n  private passthroughFn?: (chunk: StreamChunk) => void;\n\n  private _closed: boolean = false;\n\n  get closed() {\n    return this._closed;\n  }\n\n  constructor(params: {\n    passthroughFn?: (chunk: StreamChunk) => void;\n    modes: Set<StreamMode>;\n  }) {\n    let streamControllerPromiseResolver: (\n      controller: ReadableStreamDefaultController\n    ) => void;\n    const streamControllerPromise: Promise<ReadableStreamDefaultController> =\n      new Promise<ReadableStreamDefaultController>((resolve) => {\n        streamControllerPromiseResolver = resolve;\n      });\n\n    super({\n      start: (controller) => {\n        streamControllerPromiseResolver!(controller);\n      },\n    });\n\n    // .start() will always be called before the stream can be interacted\n    // with anyway\n    void streamControllerPromise.then((controller) => {\n      this.controller = controller;\n    });\n\n    this.passthroughFn = params.passthroughFn;\n    this.modes = params.modes;\n  }\n\n  push(chunk: StreamChunk) {\n    this.passthroughFn?.(chunk);\n    this.controller.enqueue(chunk);\n  }\n\n  close() {\n    try {\n      this.controller.close();\n    } catch (e) {\n      // pass\n    } finally {\n      this._closed = true;\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error(e: any) {\n    this.controller.error(e);\n  }\n}\n\nfunction _stringifyAsDict(obj: unknown) {\n  return JSON.stringify(obj, function (key: string | number, value: unknown) {\n    const rawValue = this[key];\n    if (\n      rawValue != null &&\n      typeof rawValue === \"object\" &&\n      \"toDict\" in rawValue &&\n      typeof rawValue.toDict === \"function\"\n    ) {\n      const { type, data } = rawValue.toDict();\n      return { ...data, type };\n    }\n\n    return value;\n  });\n}\n\nfunction _serializeError(error: unknown) {\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  if (error instanceof Error) {\n    return { error: error.name, message: error.message };\n  }\n  return { error: \"Error\", message: JSON.stringify(error) };\n}\n\nfunction _isRunnableConfig(\n  config: unknown\n): config is RunnableConfig & { configurable: Record<string, unknown> } {\n  if (typeof config !== \"object\" || config == null) return false;\n  return (\n    \"configurable\" in config &&\n    typeof config.configurable === \"object\" &&\n    config.configurable != null\n  );\n}\n\nfunction _extractCheckpointFromConfig(\n  config: RunnableConfig | null | undefined\n) {\n  if (!_isRunnableConfig(config) || !config.configurable.thread_id) {\n    return null;\n  }\n\n  return {\n    thread_id: config.configurable.thread_id,\n    checkpoint_ns: config.configurable.checkpoint_ns || \"\",\n    checkpoint_id: config.configurable.checkpoint_id || null,\n    checkpoint_map: config.configurable.checkpoint_map || null,\n  };\n}\n\nfunction _serializeConfig(config: unknown) {\n  if (_isRunnableConfig(config)) {\n    const configurable = Object.fromEntries(\n      Object.entries(config.configurable).filter(\n        ([key]) => !key.startsWith(\"__\")\n      )\n    );\n\n    const newConfig = { ...config, configurable };\n    delete newConfig.callbacks;\n    return newConfig;\n  }\n\n  return config;\n}\n\nfunction _serializeCheckpoint(payload: StreamCheckpointsOutput<unknown>) {\n  const result: Record<string, unknown> = {\n    ...payload,\n    checkpoint: _extractCheckpointFromConfig(payload.config),\n    parent_checkpoint: _extractCheckpointFromConfig(payload.parentConfig),\n\n    config: _serializeConfig(payload.config),\n    parent_config: _serializeConfig(payload.parentConfig),\n\n    tasks: payload.tasks.map((task) => {\n      if (_isRunnableConfig(task.state)) {\n        const checkpoint = _extractCheckpointFromConfig(task.state);\n        if (checkpoint != null) {\n          const cloneTask: Record<string, unknown> = { ...task, checkpoint };\n          delete cloneTask.state;\n          return cloneTask;\n        }\n      }\n\n      return task;\n    }),\n  };\n\n  delete result.parentConfig;\n  return result;\n}\n\nexport function toEventStream(stream: AsyncGenerator) {\n  const encoder = new TextEncoder();\n  return new ReadableStream<Uint8Array>({\n    async start(controller) {\n      const enqueueChunk = (sse: {\n        id?: string;\n        event: string;\n        data: unknown;\n      }) => {\n        controller.enqueue(\n          encoder.encode(\n            `event: ${sse.event}\\ndata: ${_stringifyAsDict(sse.data)}\\n\\n`\n          )\n        );\n      };\n\n      try {\n        for await (const payload of stream) {\n          const [ns, mode, chunk] = payload as AnyStreamOutput;\n\n          let data: unknown = chunk;\n          if (mode === \"debug\") {\n            const debugChunk = chunk;\n\n            if (debugChunk.type === \"checkpoint\") {\n              data = {\n                ...debugChunk,\n                payload: _serializeCheckpoint(debugChunk.payload),\n              };\n            }\n          }\n\n          if (mode === \"checkpoints\") {\n            data = _serializeCheckpoint(chunk);\n          }\n\n          const event = ns?.length ? `${mode}|${ns.join(\"|\")}` : mode;\n          enqueueChunk({ event, data });\n        }\n      } catch (error) {\n        enqueueChunk({ event: \"error\", data: _serializeError(error) });\n      }\n\n      controller.close();\n    },\n  });\n}\n","import {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n  getInteropZodObjectShape,\n  extendInteropZodObject,\n  getInteropZodDefaultGetter,\n  interopZodObjectPartial,\n  InteropZodObjectShape,\n  isZodSchemaV3,\n  getSchemaDescription,\n} from \"@langchain/core/utils/types\";\nimport { BaseChannel } from \"../../channels/base.js\";\nimport { BinaryOperatorAggregate } from \"../../channels/binop.js\";\nimport { LastValue } from \"../../channels/last_value.js\";\n\nexport const META_EXTRAS_DESCRIPTION_PREFIX = \"lg:\";\n\n/** @internal */\nexport type ReducedZodChannel<\n  T extends InteropZodType,\n  TReducerSchema extends InteropZodType\n> = T & {\n  lg_reducer_schema: TReducerSchema;\n};\n\n/** @internal */\nexport type InteropZodToStateDefinition<\n  T extends InteropZodObject,\n  TShape = InteropZodObjectShape<T>\n> = {\n  [key in keyof TShape]: TShape[key] extends ReducedZodChannel<\n    infer Schema,\n    infer ReducerSchema\n  >\n    ? Schema extends InteropZodType<infer V>\n      ? ReducerSchema extends InteropZodType<infer U>\n        ? BaseChannel<V, U>\n        : never\n      : never\n    : TShape[key] extends InteropZodType<infer V, infer U>\n    ? BaseChannel<V, U>\n    : never;\n};\n\nexport type UpdateType<\n  T extends InteropZodObject,\n  TShape = InteropZodObjectShape<T>\n> = {\n  [key in keyof TShape]?: TShape[key] extends ReducedZodChannel<\n    infer Schema,\n    infer ReducerSchema\n  >\n    ? Schema extends InteropZodType<unknown>\n      ? ReducerSchema extends InteropZodType<infer U>\n        ? U\n        : never\n      : never\n    : TShape[key] extends InteropZodType<unknown, infer U>\n    ? U\n    : never;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface SchemaMeta<TValue = any, TUpdate = TValue> {\n  jsonSchemaExtra?: {\n    langgraph_nodes?: string[];\n    langgraph_type?: \"prompt\" | \"messages\";\n    [key: string]: unknown;\n  };\n  reducer?: {\n    schema?: InteropZodType<TUpdate>;\n    fn: (a: TValue, b: TUpdate) => TValue;\n  };\n  default?: () => TValue;\n}\n\n/**\n * A registry for storing and managing metadata associated with schemas.\n * This class provides methods to get, extend, remove, and check metadata for a given schema.\n */\nexport class SchemaMetaRegistry {\n  /**\n   * Internal map storing schema metadata.\n   * @internal\n   */\n  _map = new WeakMap<InteropZodType, SchemaMeta>();\n\n  /**\n   * Cache for extended schfemas.\n   * @internal\n   */\n  _extensionCache = new Map<string, WeakMap<InteropZodType, InteropZodType>>();\n\n  /**\n   * Retrieves the metadata associated with a given schema.\n   * @template TValue The value type of the schema.\n   * @template TUpdate The update type of the schema (defaults to TValue).\n   * @param schema The schema to retrieve metadata for.\n   * @returns The associated SchemaMeta, or undefined if not present.\n   */\n  get<TValue, TUpdate = TValue>(\n    schema: InteropZodType<TValue>\n  ): SchemaMeta<TValue, TUpdate> | undefined {\n    return this._map.get(schema);\n  }\n\n  /**\n   * Extends or sets the metadata for a given schema.\n   * @template TValue The value type of the schema.\n   * @template TUpdate The update type of the schema (defaults to TValue).\n   * @param schema The schema to extend metadata for.\n   * @param predicate A function that receives the existing metadata (or undefined) and returns the new metadata.\n   */\n  extend<TValue, TUpdate>(\n    schema: InteropZodType<TValue>,\n    predicate: (\n      meta: SchemaMeta<TValue, TUpdate> | undefined\n    ) => SchemaMeta<TValue, TUpdate>\n  ) {\n    const existingMeta = this.get<TValue, TUpdate>(schema);\n    this._map.set(schema, predicate(existingMeta));\n  }\n\n  /**\n   * Removes the metadata associated with a given schema.\n   * @param schema The schema to remove metadata for.\n   * @returns The SchemaMetaRegistry instance (for chaining).\n   */\n  remove(schema: InteropZodType): this {\n    this._map.delete(schema);\n    return this;\n  }\n\n  /**\n   * Checks if metadata exists for a given schema.\n   * @param schema The schema to check.\n   * @returns True if metadata exists, false otherwise.\n   */\n  has(schema: InteropZodType): boolean {\n    return this._map.has(schema);\n  }\n\n  /**\n   * Returns a mapping of channel instances for each property in the schema\n   * using the associated metadata in the registry.\n   *\n   * This is used to create the `channels` object that's passed to the `Graph` constructor.\n   *\n   * @template T The shape of the schema.\n   * @param schema The schema to extract channels from.\n   * @returns A mapping from property names to channel instances.\n   */\n  getChannelsForSchema<T extends InteropZodObject>(\n    schema: T\n  ): InteropZodToStateDefinition<T> {\n    const channels = {} as Record<string, BaseChannel>;\n    const shape = getInteropZodObjectShape(schema);\n    for (const [key, channelSchema] of Object.entries(shape)) {\n      const meta = this.get(channelSchema);\n      if (meta?.reducer) {\n        channels[key] = new BinaryOperatorAggregate<\n          InferInteropZodOutput<typeof channelSchema>\n        >(meta.reducer.fn, meta.default);\n      } else {\n        channels[key] = new LastValue();\n      }\n    }\n    return channels as InteropZodToStateDefinition<T>;\n  }\n\n  /**\n   * Returns a modified schema that introspectively looks at all keys of the provided\n   * object schema, and applies the augmentations based on meta provided with those keys\n   * in the registry and the selectors provided in the `effects` parameter.\n   *\n   * This assumes that the passed in schema is the \"root\" schema object for a graph where\n   * the keys of the schema are the channels of the graph. Because we need to represent\n   * the input of a graph in a couple of different ways, the `effects` parameter allows\n   * us to apply those augmentations based on pre determined conditions.\n   *\n   * @param schema The root schema object to extend.\n   * @param effects The effects that are being applied.\n   * @returns The extended schema.\n   */\n  getExtendedChannelSchemas<T extends InteropZodObject>(\n    schema: T,\n    effects: {\n      /**\n       * Augments the shape by using the reducer's schema if it exists\n       */\n      withReducerSchema?: boolean;\n      /**\n       * Applies the stringified jsonSchemaExtra as a description to the schema.\n       */\n      withJsonSchemaExtrasAsDescription?: boolean;\n      /**\n       * Applies the `.partial()` modifier to the schema.\n       */\n      asPartial?: boolean;\n    }\n  ): InteropZodObject {\n    // If no effects are being applied, return the schema unchanged\n    if (Object.keys(effects).length === 0) {\n      return schema;\n    }\n\n    // Cache key is determined by looking at the effects that are being applied\n    const cacheKey = Object.entries(effects)\n      .filter(([, v]) => v === true)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([k, v]) => `${k}:${v}`)\n      .join(\"|\");\n\n    const cache = this._extensionCache.get(cacheKey) ?? new WeakMap();\n    if (cache.has(schema)) return cache.get(schema)! as T;\n\n    let modifiedSchema: InteropZodObject = schema;\n\n    if (\n      effects.withReducerSchema ||\n      effects.withJsonSchemaExtrasAsDescription\n    ) {\n      const newShapeEntries = Object.entries(\n        getInteropZodObjectShape(schema)\n      ).map(([key, schema]) => {\n        const meta = this.get(schema);\n        let outputSchema = effects.withReducerSchema\n          ? meta?.reducer?.schema ?? schema\n          : schema;\n        if (\n          effects.withJsonSchemaExtrasAsDescription &&\n          meta?.jsonSchemaExtra\n        ) {\n          const description =\n            getSchemaDescription(outputSchema) ?? getSchemaDescription(schema);\n          const strExtras = JSON.stringify({\n            ...meta.jsonSchemaExtra,\n            description,\n          });\n          outputSchema = outputSchema.describe(\n            `${META_EXTRAS_DESCRIPTION_PREFIX}${strExtras}`\n          );\n        }\n        return [key, outputSchema];\n      });\n      modifiedSchema = extendInteropZodObject(\n        schema,\n        Object.fromEntries(newShapeEntries)\n      );\n      if (isZodSchemaV3(modifiedSchema)) {\n        modifiedSchema._def.unknownKeys = \"strip\";\n      }\n    }\n    if (effects.asPartial) {\n      modifiedSchema = interopZodObjectPartial(modifiedSchema);\n    }\n\n    cache.set(schema, modifiedSchema);\n    this._extensionCache.set(cacheKey, cache);\n    return modifiedSchema;\n  }\n}\n\nexport const schemaMetaRegistry = new SchemaMetaRegistry();\n\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate> & { reducer?: undefined }\n): TSchema;\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate>\n): ReducedZodChannel<TSchema, InteropZodType<TUpdate>>;\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate>\n): ReducedZodChannel<TSchema, InteropZodType<TUpdate>> | TSchema {\n  if (meta.reducer && !meta.default) {\n    const defaultValueGetter = getInteropZodDefaultGetter(schema);\n    if (defaultValueGetter != null) {\n      // eslint-disable-next-line no-param-reassign\n      meta.default = defaultValueGetter;\n    }\n  }\n  if (meta.reducer) {\n    const schemaWithReducer = Object.assign(schema, {\n      lg_reducer_schema: meta.reducer?.schema ?? schema,\n    });\n    schemaMetaRegistry.extend(schemaWithReducer, () => meta);\n    return schemaWithReducer;\n  } else {\n    schemaMetaRegistry.extend(schema, () => meta);\n    return schema;\n  }\n}\n","import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  type BaseMessageFields,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface SystemMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"system\"> {}\n\n/**\n * Represents a system message in a conversation.\n */\nexport class SystemMessage<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessage<TStructure, \"system\"> {\n  static lc_name() {\n    return \"SystemMessage\";\n  }\n\n  readonly type = \"system\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  /**\n   * Concatenates a string or another system message with the current system message.\n   * @param chunk - The chunk to concatenate with the system message.\n   * @returns A new system message with the concatenated content.\n   */\n  concat(chunk: string | SystemMessage) {\n    if (typeof chunk === \"string\") {\n      return new SystemMessage({\n        ...this,\n        content: mergeContent(this.content, chunk),\n      });\n    }\n\n    if (SystemMessage.isInstance(chunk)) {\n      return new SystemMessage({\n        ...this,\n        additional_kwargs: {\n          ...this.additional_kwargs,\n          ...chunk.additional_kwargs,\n        },\n        response_metadata: {\n          ...this.response_metadata,\n          ...chunk.response_metadata,\n        },\n        content: mergeContent(this.content, chunk.content),\n      });\n    }\n\n    throw new Error(\"Unexpected chunk type for system message\");\n  }\n\n  static isInstance(obj: unknown): obj is SystemMessage {\n    return super.isInstance(obj) && obj.type === \"system\";\n  }\n}\n\n/**\n * Represents a chunk of a system message, which can be concatenated with\n * other system message chunks.\n */\nexport class SystemMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"system\"> {\n  static lc_name() {\n    return \"SystemMessageChunk\";\n  }\n\n  readonly type = \"system\" as const;\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"system\">\n      | SystemMessageFields<TStructure>\n  ) {\n    super(fields);\n  }\n\n  concat(chunk: SystemMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      id: this.id ?? chunk.id,\n    });\n  }\n\n  static isInstance(obj: unknown): obj is SystemMessageChunk {\n    return super.isInstance(obj) && obj.type === \"system\";\n  }\n}\n\n/**\n * @deprecated Use {@link SystemMessage.isInstance} instead\n */\nexport function isSystemMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is SystemMessage<TStructure> {\n  return x._getType() === \"system\";\n}\n\n/**\n * @deprecated Use {@link SystemMessageChunk.isInstance} instead\n */\nexport function isSystemMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is SystemMessageChunk<TStructure> {\n  return x._getType() === \"system\";\n}\n","import {\n  Runnable,\n  RunnableConfig,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { CONFIG_KEY_CALL, RETURN, TAG_HIDDEN } from \"../constants.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"./write.js\";\nimport { CachePolicy, RetryPolicy } from \"./utils/index.js\";\nimport { RunnableCallable, type RunnableCallableArgs } from \"../utils.js\";\nimport { EntrypointFunc, EntrypointReturnT, TaskFunc } from \"../func/types.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Wraps a user function in a Runnable that writes the returned value to the RETURN channel.\n */\nexport function getRunnableForFunc<ArgsT extends unknown[], OutputT>(\n  name: string,\n  func: TaskFunc<ArgsT, OutputT>\n): Runnable<ArgsT, OutputT, LangGraphRunnableConfig> {\n  const run = new RunnableCallable<ArgsT, OutputT>({\n    func: (input: ArgsT) => func(...input),\n    name,\n    trace: false,\n    recurse: false,\n  } as RunnableCallableArgs);\n\n  return new RunnableSequence<ArgsT, OutputT>({\n    name,\n    first: run,\n    last: new ChannelWrite<OutputT>(\n      [{ channel: RETURN, value: PASSTHROUGH }],\n      [TAG_HIDDEN]\n    ),\n  });\n}\n\nexport function getRunnableForEntrypoint<InputT, OutputT>(\n  name: string,\n  func: EntrypointFunc<InputT, OutputT>\n): Runnable<InputT, EntrypointReturnT<OutputT>, LangGraphRunnableConfig> {\n  const run = new RunnableCallable<InputT, EntrypointReturnT<OutputT>>({\n    func: (input: InputT, config: LangGraphRunnableConfig) => {\n      return func(input, config);\n    },\n    name,\n    trace: false,\n    recurse: false,\n  });\n\n  return run;\n}\n\nexport type CallWrapperOptions<ArgsT extends unknown[], OutputT> = {\n  func: TaskFunc<ArgsT, OutputT>;\n  name: string;\n  retry?: RetryPolicy;\n  cache?: CachePolicy;\n};\n\nexport function call<ArgsT extends unknown[], OutputT>(\n  { func, name, cache, retry }: CallWrapperOptions<ArgsT, OutputT>,\n  ...args: ArgsT\n): Promise<OutputT> {\n  const config =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig() as RunnableConfig;\n  if (typeof config.configurable?.[CONFIG_KEY_CALL] === \"function\") {\n    return config.configurable[CONFIG_KEY_CALL](func, name, args, {\n      retry,\n      cache,\n      callbacks: config.callbacks,\n    });\n  }\n  throw new Error(\n    \"Async local storage not initialized. Please call initializeAsyncLocalStorageSingleton() before using this function.\"\n  );\n}\n","import { toJSONSchema } from \"zod/v4/core\";\nimport { dereference, type Schema } from \"@cfworker/json-schema\";\nimport {\n  isZodSchemaV3,\n  isZodSchemaV4,\n  InteropZodType,\n  interopZodObjectStrict,\n  isZodObjectV4,\n  ZodObjectV4,\n  interopZodTransformInputSchema,\n} from \"./types/zod.js\";\nimport {\n  type JsonSchema7Type as JSONSchema,\n  zodToJsonSchema,\n} from \"./zod-to-json-schema/index.js\";\n\nexport { deepCompareStrict, Validator } from \"@cfworker/json-schema\";\n\n/**\n * Converts a Zod schema or JSON schema to a JSON schema.\n * @param schema - The schema to convert.\n * @returns The converted schema.\n */\nexport function toJsonSchema(schema: InteropZodType | JSONSchema): JSONSchema {\n  if (isZodSchemaV4(schema)) {\n    const inputSchema = interopZodTransformInputSchema(schema, true);\n    if (isZodObjectV4(inputSchema)) {\n      const strictSchema = interopZodObjectStrict(\n        inputSchema,\n        true\n      ) as ZodObjectV4;\n      return toJSONSchema(strictSchema);\n    } else {\n      return toJSONSchema(schema);\n    }\n  }\n  if (isZodSchemaV3(schema)) {\n    return zodToJsonSchema(schema);\n  }\n  return schema as JSONSchema;\n}\n\n/**\n * Validates if a JSON schema validates only strings. May return false negatives in some edge cases\n * (like recursive or unresolvable refs).\n *\n * @param schema - The schema to validate.\n * @returns `true` if the schema validates only strings, `false` otherwise.\n */\nexport function validatesOnlyStrings(schema: unknown): boolean {\n  // Null, undefined, or empty schema\n  if (\n    !schema ||\n    typeof schema !== \"object\" ||\n    Object.keys(schema).length === 0 ||\n    Array.isArray(schema)\n  ) {\n    return false; // Validates anything, not just strings\n  }\n\n  // Explicit type constraint\n  if (\"type\" in schema) {\n    if (typeof schema.type === \"string\") {\n      return schema.type === \"string\";\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not sure why someone would do `\"type\": [\"string\"]` or especially `\"type\": [\"string\",\n      // \"string\", \"string\", ...]` but we're not here to judge\n      return schema.type.every((t) => t === \"string\");\n    }\n    return false; // Invalid or non-string type\n  }\n\n  // Enum with only string values\n  if (\"enum\" in schema) {\n    return (\n      Array.isArray(schema.enum) &&\n      schema.enum.length > 0 &&\n      schema.enum.every((val) => typeof val === \"string\")\n    );\n  }\n\n  // String constant\n  if (\"const\" in schema) {\n    return typeof schema.const === \"string\";\n  }\n\n  // Schema combinations\n  if (\"allOf\" in schema && Array.isArray(schema.allOf)) {\n    // If any subschema validates only strings, then the overall schema validates only strings\n    return schema.allOf.some((subschema) => validatesOnlyStrings(subschema));\n  }\n\n  if (\n    (\"anyOf\" in schema && Array.isArray(schema.anyOf)) ||\n    (\"oneOf\" in schema && Array.isArray(schema.oneOf))\n  ) {\n    const subschemas = (\n      \"anyOf\" in schema ? schema.anyOf : schema.oneOf\n    ) as unknown[];\n\n    // All subschemas must validate only strings\n    return (\n      subschemas.length > 0 &&\n      subschemas.every((subschema) => validatesOnlyStrings(subschema))\n    );\n  }\n\n  // We're not going to try on this one, it's too complex - we just assume if it has a \"not\" key and hasn't matched one of the above checks, it's not a string schema.\n  if (\"not\" in schema) {\n    return false; // The not case can validate non-strings\n  }\n\n  if (\"$ref\" in schema && typeof schema.$ref === \"string\") {\n    const ref = schema.$ref as string;\n    const resolved = dereference(schema as Schema);\n    if (resolved[ref]) {\n      return validatesOnlyStrings(resolved[ref]);\n    }\n    return false;\n  }\n\n  // ignore recursive refs and other cases where type is omitted for now\n  // ignore other cases for now where type is omitted\n\n  return false;\n}\n\n// Re-export of the types used throughout langchain for json schema serialization.\n// The plan is to eventually nix zod-to-json-schema altogether in place for\n// zod v4 / a more standardized way of serializing validated inputs, so its re-exported\n// here to remove the dependency on zod-to-json-schema in downstream packages until\n// a determination is made.\n\nexport {\n  type JsonSchema7Type,\n  type JsonSchema7Type as JSONSchema,\n  type JsonSchema7ArrayType,\n  type JsonSchema7ObjectType,\n  type JsonSchema7StringType,\n  type JsonSchema7NumberType,\n  type JsonSchema7NullableType,\n} from \"./zod-to-json-schema/index.js\";\n","import { Runnable } from \"../runnables/index.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport type { BasePromptValueInterface } from \"../prompt_values.js\";\nimport type { BaseMessage, ContentBlock } from \"../messages/index.js\";\nimport type { Callbacks } from \"../callbacks/manager.js\";\nimport type { Generation, ChatGeneration } from \"../outputs.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\n\n/**\n * Options for formatting instructions.\n */\nexport interface FormatInstructionsOptions {}\n\n/**\n * Abstract base class for parsing the output of a Large Language Model\n * (LLM) call. It provides methods for parsing the result of an LLM call\n * and invoking the parser with a given input.\n */\nexport abstract class BaseLLMOutputParser<T = unknown> extends Runnable<\n  string | BaseMessage,\n  T\n> {\n  /**\n   * Parses the result of an LLM call. This method is meant to be\n   * implemented by subclasses to define how the output from the LLM should\n   * be parsed.\n   * @param generations The generations from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  abstract parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T>;\n\n  /**\n   * Parses the result of an LLM call with a given prompt. By default, it\n   * simply calls `parseResult`.\n   * @param generations The generations from an LLM call.\n   * @param _prompt The prompt used in the LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parseResultWithPrompt(\n    generations: Generation[] | ChatGeneration[],\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parseResult(generations, callbacks);\n  }\n\n  protected _baseMessageToString(message: BaseMessage): string {\n    return typeof message.content === \"string\"\n      ? message.content\n      : this._baseMessageContentToString(message.content);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return JSON.stringify(content);\n  }\n\n  /**\n   * Calls the parser with a given input and optional configuration options.\n   * If the input is a string, it creates a generation with the input as\n   * text and calls `parseResult`. If the input is a `BaseMessage`, it\n   * creates a generation with the input as a message and the content of the\n   * input as text, and then calls `parseResult`.\n   * @param input The input to the parser, which can be a string or a `BaseMessage`.\n   * @param options Optional configuration options.\n   * @returns A promise of the parsed output.\n   */\n  async invoke(\n    input: string | BaseMessage,\n    options?: RunnableConfig\n  ): Promise<T> {\n    if (typeof input === \"string\") {\n      return this._callWithConfig(\n        async (input: string, options): Promise<T> =>\n          this.parseResult([{ text: input }], options?.callbacks),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    } else {\n      return this._callWithConfig(\n        async (input: BaseMessage, options): Promise<T> =>\n          this.parseResult(\n            [\n              {\n                message: input,\n                text: this._baseMessageToString(input),\n              },\n            ],\n            options?.callbacks\n          ),\n        input,\n        { ...options, runType: \"parser\" }\n      );\n    }\n  }\n}\n\n/**\n * Class to parse the output of an LLM call.\n */\nexport abstract class BaseOutputParser<\n  T = unknown\n> extends BaseLLMOutputParser<T> {\n  parseResult(\n    generations: Generation[] | ChatGeneration[],\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(generations[0].text, callbacks);\n  }\n\n  /**\n   * Parse the output of an LLM call.\n   *\n   * @param text - LLM output to parse.\n   * @returns Parsed output.\n   */\n  abstract parse(text: string, callbacks?: Callbacks): Promise<T>;\n\n  async parseWithPrompt(\n    text: string,\n    _prompt: BasePromptValueInterface,\n    callbacks?: Callbacks\n  ): Promise<T> {\n    return this.parse(text, callbacks);\n  }\n\n  /**\n   * Return a string describing the format of the output.\n   * @returns Format instructions.\n   * @param options - Options for formatting instructions.\n   * @example\n   * ```json\n   * {\n   *  \"foo\": \"bar\"\n   * }\n   * ```\n   */\n  abstract getFormatInstructions(options?: FormatInstructionsOptions): string;\n\n  /**\n   * Return the string type key uniquely identifying this class of parser\n   */\n  _type(): string {\n    throw new Error(\"_type not implemented\");\n  }\n}\n\n/**\n * Exception that output parsers should raise to signify a parsing error.\n *\n * This exists to differentiate parsing errors from other code or execution errors\n * that also may arise inside the output parser. OutputParserExceptions will be\n * available to catch and handle in ways to fix the parsing error, while other\n * errors will be raised.\n *\n * @param message - The error that's being re-raised or an error message.\n * @param llmOutput - String model output which is error-ing.\n * @param observation - String explanation of error which can be passed to a\n *     model to try and remediate the issue.\n * @param sendToLLM - Whether to send the observation and llm_output back to an Agent\n *     after an OutputParserException has been raised. This gives the underlying\n *     model driving the agent the context that the previous output was improperly\n *     structured, in the hopes that it will update the output to the correct\n *     format.\n */\nexport class OutputParserException extends Error {\n  llmOutput?: string;\n\n  observation?: string;\n\n  sendToLLM: boolean;\n\n  constructor(\n    message: string,\n    llmOutput?: string,\n    observation?: string,\n    sendToLLM = false\n  ) {\n    super(message);\n    this.llmOutput = llmOutput;\n    this.observation = observation;\n    this.sendToLLM = sendToLLM;\n\n    if (sendToLLM) {\n      if (observation === undefined || llmOutput === undefined) {\n        throw new Error(\n          \"Arguments 'observation' & 'llmOutput' are required if 'sendToLlm' is true\"\n        );\n      }\n    }\n\n    addLangChainErrorFields(this, \"OUTPUT_PARSING_FAILURE\");\n  }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type {\n  InputValues,\n  PartialValues,\n  StringWithAutocomplete,\n} from \"../utils/types/index.js\";\nimport { type BasePromptValueInterface } from \"../prompt_values.js\";\nimport { BaseOutputParser } from \"../output_parsers/index.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { BaseCallbackConfig } from \"../callbacks/manager.js\";\n\nexport type TypedPromptInputValues<RunInput> = InputValues<\n  StringWithAutocomplete<Extract<keyof RunInput, string>>\n>;\n\nexport type Example = Record<string, string>;\n\n/**\n * Input common to all prompt templates.\n */\nexport interface BasePromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  InputVariables extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> {\n  /**\n   * A list of variable names the prompt template expects\n   */\n  inputVariables: Array<Extract<keyof InputVariables, string>>;\n\n  /**\n   * How to parse the output of calling an LLM on this formatted prompt\n   */\n  outputParser?: BaseOutputParser;\n\n  /** Partial variables */\n  partialVariables?: PartialValues<PartialVariableName>;\n}\n\n/**\n * Base class for prompt templates. Exposes a format method that returns a\n * string prompt given a set of input values.\n */\nexport abstract class BasePromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    RunOutput extends BasePromptValueInterface = BasePromptValueInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends Runnable<RunInput, RunOutput>\n  implements BasePromptTemplateInput\n{\n  declare PromptValueReturnType: RunOutput;\n\n  lc_serializable = true;\n\n  lc_namespace = [\"langchain_core\", \"prompts\", this._getPromptType()];\n\n  get lc_attributes(): SerializedFields | undefined {\n    return {\n      partialVariables: undefined, // python doesn't support this yet\n    };\n  }\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  outputParser?: BaseOutputParser;\n\n  partialVariables: PartialValues<PartialVariableName>;\n\n  /**\n   * Metadata to be used for tracing.\n   */\n  metadata?: Record<string, unknown>;\n\n  /** Tags to be used for tracing. */\n  tags?: string[];\n\n  constructor(input: BasePromptTemplateInput) {\n    super(input);\n    const { inputVariables } = input;\n    if (inputVariables.includes(\"stop\")) {\n      throw new Error(\n        \"Cannot have an input variable named 'stop', as it is used internally, please rename.\"\n      );\n    }\n    Object.assign(this, input);\n  }\n\n  abstract partial(\n    values: PartialValues\n  ): Promise<BasePromptTemplate<RunInput, RunOutput, PartialVariableName>>;\n\n  /**\n   * Merges partial variables and user variables.\n   * @param userVariables The user variables to merge with the partial variables.\n   * @returns A Promise that resolves to an object containing the merged variables.\n   */\n  async mergePartialAndUserVariables(\n    userVariables: TypedPromptInputValues<RunInput>\n  ): Promise<\n    InputValues<Extract<keyof RunInput, string> | PartialVariableName>\n  > {\n    const partialVariables = this.partialVariables ?? {};\n    const partialValues: Record<string, string> = {};\n\n    for (const [key, value] of Object.entries(partialVariables)) {\n      if (typeof value === \"string\") {\n        partialValues[key] = value;\n      } else {\n        partialValues[key] = await (value as () => Promise<string>)();\n      }\n    }\n\n    const allKwargs = {\n      ...(partialValues as Record<PartialVariableName, string>),\n      ...userVariables,\n    };\n    return allKwargs;\n  }\n\n  /**\n   * Invokes the prompt template with the given input and options.\n   * @param input The input to invoke the prompt template with.\n   * @param options Optional configuration for the callback.\n   * @returns A Promise that resolves to the output of the prompt template.\n   */\n  async invoke(\n    input: RunInput,\n    options?: BaseCallbackConfig\n  ): Promise<RunOutput> {\n    const metadata = {\n      ...this.metadata,\n      ...options?.metadata,\n    };\n    const tags = [...(this.tags ?? []), ...(options?.tags ?? [])];\n    return this._callWithConfig(\n      (input: RunInput) => this.formatPromptValue(input),\n      input,\n      { ...options, tags, metadata, runType: \"prompt\" }\n    );\n  }\n\n  /**\n   * Format the prompt given the input values.\n   *\n   * @param values - A dictionary of arguments to be passed to the prompt template.\n   * @returns A formatted prompt string.\n   *\n   * @example\n   * ```ts\n   * prompt.format({ foo: \"bar\" });\n   * ```\n   */\n  abstract format(values: TypedPromptInputValues<RunInput>): Promise<string>;\n\n  /**\n   * Format the prompt given the input values and return a formatted prompt value.\n   * @param values\n   * @returns A formatted PromptValue.\n   */\n  abstract formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<RunOutput>;\n\n  /**\n   * Return the string type key uniquely identifying this class of prompt template.\n   */\n  abstract _getPromptType(): string;\n}\n","/* eslint-disable no-param-reassign */\nimport {\n  _coerceToRunnable,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  Runnable,\n  RunnableConfig,\n  RunnableFunc,\n  RunnableLike,\n  RunnableSequence,\n} from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport {\n  All,\n  BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  CheckpointMetadata,\n  CheckpointTuple,\n  compareChannelVersions,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  SCHEDULED,\n  SendProtocol,\n  uuid5,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  getOnlyChannels,\n} from \"../channels/base.js\";\nimport {\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_NODE_FINISHED,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_STREAM,\n  CONFIG_KEY_TASK_ID,\n  COPY,\n  END,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  Interrupt,\n  isInterrupted,\n  NULL_TASK_ID,\n  PUSH,\n  CONFIG_KEY_DURABILITY,\n  CONFIG_KEY_CHECKPOINT_NS,\n  type CommandInstance,\n  TASKS,\n} from \"../constants.js\";\nimport {\n  GraphRecursionError,\n  GraphValueError,\n  InvalidUpdateError,\n} from \"../errors.js\";\nimport { gatherIterator, patchConfigurable } from \"../utils.js\";\nimport {\n  _applyWrites,\n  _localRead,\n  _prepareNextTasks,\n  StrRecord,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  printStepCheckpoint,\n  printStepTasks,\n  printStepWrites,\n  tasksWithWrites,\n} from \"./debug.js\";\nimport { mapInput, readChannels } from \"./io.js\";\nimport { PregelLoop } from \"./loop.js\";\nimport { StreamMessagesHandler } from \"./messages.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { PregelRunner } from \"./runner.js\";\nimport {\n  IterableReadableStreamWithAbortSignal,\n  IterableReadableWritableStream,\n  toEventStream,\n} from \"./stream.js\";\nimport type {\n  Durability,\n  GetStateOptions,\n  MultipleChannelSubscriptionOptions,\n  PregelExecutableTask,\n  PregelInputType,\n  PregelInterface,\n  PregelOptions,\n  PregelOutputType,\n  PregelParams,\n  SingleChannelSubscriptionOptions,\n  StateSnapshot,\n  StreamMode,\n  StreamOutputMap,\n} from \"./types.js\";\nimport {\n  ensureLangGraphConfig,\n  getConfig,\n  recastCheckpointNamespace,\n} from \"./utils/config.js\";\nimport {\n  _coerceToDict,\n  combineAbortSignals,\n  combineCallbacks,\n  getNewChannelVersions,\n  patchCheckpointMap,\n  RetryPolicy,\n} from \"./utils/index.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\nimport { validateGraph, validateKeys } from \"./validate.js\";\nimport { ChannelWrite, ChannelWriteEntry, PASSTHROUGH } from \"./write.js\";\nimport { Topic } from \"../channels/topic.js\";\nimport { interrupt } from \"../interrupt.js\";\n\ntype WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;\ntype StreamEventsOptions = Parameters<Runnable[\"streamEvents\"]>[2];\n\n/**\n * Utility class for working with channels in the Pregel system.\n * Provides static methods for subscribing to channels and writing to them.\n *\n * Channels are the communication pathways between nodes in a Pregel graph.\n * They enable message passing and state updates between different parts of the graph.\n */\nexport class Channel {\n  /**\n   * Creates a PregelNode that subscribes to a single channel.\n   * This is used to define how nodes receive input from channels.\n   *\n   * @example\n   * ```typescript\n   * // Subscribe to a single channel\n   * const node = Channel.subscribeTo(\"messages\");\n   *\n   * // Subscribe to multiple channels\n   * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n   *\n   * // Subscribe with a custom key\n   * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n   * ```\n   *\n   * @param channel Single channel name to subscribe to\n   * @param options Subscription options\n   * @returns A PregelNode configured to receive from the specified channels\n   * @throws {Error} If a key is specified when subscribing to multiple channels\n   */\n  static subscribeTo(\n    channel: string,\n    options?: SingleChannelSubscriptionOptions\n  ): PregelNode;\n\n  /**\n   * Creates a PregelNode that subscribes to multiple channels.\n   * This is used to define how nodes receive input from channels.\n   *\n   * @example\n   * ```typescript\n   * // Subscribe to a single channel\n   * const node = Channel.subscribeTo(\"messages\");\n   *\n   * // Subscribe to multiple channels\n   * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n   *\n   * // Subscribe with a custom key\n   * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n   * ```\n   *\n   * @param channels Single channel name to subscribe to\n   * @param options Subscription options\n   * @returns A PregelNode configured to receive from the specified channels\n   * @throws {Error} If a key is specified when subscribing to multiple channels\n   */\n  static subscribeTo(\n    channels: string[],\n    options?: MultipleChannelSubscriptionOptions\n  ): PregelNode;\n\n  static subscribeTo(\n    channels: string | string[],\n    options?:\n      | SingleChannelSubscriptionOptions\n      | MultipleChannelSubscriptionOptions\n  ): PregelNode {\n    const { key, tags } = {\n      key: undefined,\n      tags: undefined,\n      ...(options ?? {}),\n    };\n    if (Array.isArray(channels) && key !== undefined) {\n      throw new Error(\n        \"Can't specify a key when subscribing to multiple channels\"\n      );\n    }\n\n    let channelMappingOrArray: string[] | Record<string, string>;\n\n    if (typeof channels === \"string\") {\n      if (key) {\n        channelMappingOrArray = { [key]: channels };\n      } else {\n        channelMappingOrArray = [channels];\n      }\n    } else {\n      channelMappingOrArray = Object.fromEntries(\n        channels.map((chan) => [chan, chan])\n      );\n    }\n\n    const triggers: string[] = Array.isArray(channels) ? channels : [channels];\n\n    return new PregelNode({\n      channels: channelMappingOrArray,\n      triggers,\n      tags,\n    });\n  }\n\n  /**\n   * Creates a ChannelWrite that specifies how to write values to channels.\n   * This is used to define how nodes send output to channels.\n   *\n   * @example\n   * ```typescript\n   * // Write to multiple channels\n   * const write = Channel.writeTo([\"output\", \"state\"]);\n   *\n   * // Write with specific values\n   * const write = Channel.writeTo([\"output\"], {\n   *   state: \"completed\",\n   *   result: calculateResult()\n   * });\n   *\n   * // Write with a transformation function\n   * const write = Channel.writeTo([\"output\"], {\n   *   result: (x) => processResult(x)\n   * });\n   * ```\n   *\n   * @param channels - Array of channel names to write to\n   * @param writes - Optional map of channel names to values or transformations\n   * @returns A ChannelWrite object that can be used to write to the specified channels\n   */\n  static writeTo(\n    channels: string[],\n    writes?: Record<string, WriteValue>\n  ): ChannelWrite {\n    const channelWriteEntries: Array<ChannelWriteEntry> = [];\n\n    for (const channel of channels) {\n      channelWriteEntries.push({\n        channel,\n        value: PASSTHROUGH,\n        skipNone: false,\n      });\n    }\n\n    for (const [key, value] of Object.entries(writes ?? {})) {\n      if (Runnable.isRunnable(value) || typeof value === \"function\") {\n        channelWriteEntries.push({\n          channel: key,\n          value: PASSTHROUGH,\n          skipNone: true,\n          mapper: _coerceToRunnable(value as RunnableLike),\n        });\n      } else {\n        channelWriteEntries.push({\n          channel: key,\n          value,\n          skipNone: false,\n        });\n      }\n    }\n\n    return new ChannelWrite(channelWriteEntries);\n  }\n}\n\nexport type { PregelInputType, PregelOptions, PregelOutputType };\n\n// This is a workaround to allow Pregel to override `invoke` / `stream` and `withConfig`\n// without having to adhere to the types in the `Runnable` class (thanks to `any`).\n// Alternatively we could mark those methods with @ts-ignore / @ts-expect-error,\n// but these do not get carried over when building via `tsc`.\nclass PartialRunnable<\n  RunInput,\n  RunOutput,\n  CallOptions extends RunnableConfig\n> extends Runnable<RunInput, RunOutput, CallOptions> {\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  override invoke(\n    _input: RunInput,\n    _options?: Partial<CallOptions>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    throw new Error(\"Not implemented\");\n  }\n\n  // Overriden by `Pregel`\n  override withConfig(_config: CallOptions): typeof this {\n    return super.withConfig(_config) as typeof this;\n  }\n\n  // Overriden by `Pregel`\n  override stream(\n    input: RunInput,\n    options?: Partial<CallOptions>\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<IterableReadableStream<any>> {\n    return super.stream(input, options);\n  }\n}\n\n/**\n * The Pregel class is the core runtime engine of LangGraph, implementing a message-passing graph computation model\n * inspired by [Google's Pregel system](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/).\n * It provides the foundation for building reliable, controllable agent workflows that can evolve state over time.\n *\n * Key features:\n * - Message passing between nodes in discrete \"supersteps\"\n * - Built-in persistence layer through checkpointers\n * - First-class streaming support for values, updates, and events\n * - Human-in-the-loop capabilities via interrupts\n * - Support for parallel node execution within supersteps\n *\n * The Pregel class is not intended to be instantiated directly by consumers. Instead, use the following higher-level APIs:\n * - {@link StateGraph}: The main graph class for building agent workflows\n *   - Compiling a {@link StateGraph} will return a {@link CompiledGraph} instance, which extends `Pregel`\n * - Functional API: A declarative approach using tasks and entrypoints\n *   - A `Pregel` instance is returned by the {@link entrypoint} function\n *\n * @example\n * ```typescript\n * // Using StateGraph API\n * const graph = new StateGraph(annotation)\n *   .addNode(\"nodeA\", myNodeFunction)\n *   .addEdge(\"nodeA\", \"nodeB\")\n *   .compile();\n *\n * // The compiled graph is a Pregel instance\n * const result = await graph.invoke(input);\n * ```\n *\n * @example\n * ```typescript\n * // Using Functional API\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * // Define tasks that can be composed\n * const addOne = task(\"add\", async (x: number) => x + 1);\n *\n * // Create a workflow using the entrypoint function\n * const workflow = entrypoint({\n *   name: \"workflow\",\n *   checkpointer: new MemorySaver()\n * }, async (numbers: number[]) => {\n *   // Tasks can be run in parallel\n *   const results = await Promise.all(numbers.map(n => addOne(n)));\n *   return results;\n * });\n *\n * // The workflow is a Pregel instance\n * const result = await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} or {@link ManagedValueSpec} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n * @typeParam InputType - Type of input values accepted by the graph\n * @typeParam OutputType - Type of output values produced by the graph\n */\nexport class Pregel<\n    Nodes extends StrRecord<string, PregelNode>,\n    Channels extends StrRecord<string, BaseChannel>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ContextType extends Record<string, any> = StrRecord<string, any>,\n    InputType = PregelInputType,\n    OutputType = PregelOutputType,\n    StreamUpdatesType = InputType,\n    StreamValuesType = OutputType,\n    NodeReturnType = unknown,\n    CommandType = CommandInstance,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    StreamCustom = any\n  >\n  extends PartialRunnable<\n    InputType | CommandType | null,\n    OutputType,\n    PregelOptions<Nodes, Channels, ContextType>\n  >\n  implements PregelInterface<Nodes, Channels, ContextType>\n{\n  /**\n   * Name of the class when serialized\n   * @internal\n   */\n  static lc_name() {\n    return \"LangGraph\";\n  }\n\n  /** @internal Used for type inference */\n  declare \"~InputType\": InputType;\n\n  /** @internal Used for type inference */\n  declare \"~OutputType\": OutputType;\n\n  /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  /** @internal Flag indicating this is a Pregel instance - necessary for serialization */\n  lg_is_pregel = true;\n\n  /** The nodes in the graph, mapping node names to their PregelNode instances */\n  nodes: Nodes;\n\n  /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */\n  channels: Channels;\n\n  /**\n   * The input channels for the graph. These channels receive the initial input when the graph is invoked.\n   * Can be a single channel key or an array of channel keys.\n   */\n  inputChannels: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * The output channels for the graph. These channels contain the final output when the graph completes.\n   * Can be a single channel key or an array of channel keys.\n   */\n  outputChannels: keyof Channels | Array<keyof Channels>;\n\n  /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */\n  autoValidate: boolean = true;\n\n  /**\n   * The streaming modes enabled for this graph. Defaults to [\"values\"].\n   * Supported modes:\n   * - \"values\": Streams the full state after each step\n   * - \"updates\": Streams state updates after each step\n   * - \"messages\": Streams messages from within nodes\n   * - \"custom\": Streams custom events from within nodes\n   * - \"debug\": Streams events related to the execution of the graph - useful for tracing & debugging graph execution\n   */\n  streamMode: StreamMode[] = [\"values\"];\n\n  /**\n   * Optional channels to stream. If not specified, all channels will be streamed.\n   * Can be a single channel key or an array of channel keys.\n   */\n  streamChannels?: keyof Channels | Array<keyof Channels>;\n\n  /**\n   * Optional array of node names or \"all\" to interrupt after executing these nodes.\n   * Used for implementing human-in-the-loop workflows.\n   */\n  interruptAfter?: Array<keyof Nodes> | All;\n\n  /**\n   * Optional array of node names or \"all\" to interrupt before executing these nodes.\n   * Used for implementing human-in-the-loop workflows.\n   */\n  interruptBefore?: Array<keyof Nodes> | All;\n\n  /** Optional timeout in milliseconds for the execution of each superstep */\n  stepTimeout?: number;\n\n  /** Whether to enable debug logging. Defaults to false. */\n  debug: boolean = false;\n\n  /**\n   * Optional checkpointer for persisting graph state.\n   * When provided, saves a checkpoint of the graph state at every superstep.\n   * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.\n   */\n  checkpointer?: BaseCheckpointSaver | boolean;\n\n  /** Optional retry policy for handling failures in node execution */\n  retryPolicy?: RetryPolicy;\n\n  /** The default configuration for graph execution, can be overridden on a per-invocation basis */\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * Optional long-term memory store for the graph, allows for persistence & retrieval of data across threads\n   */\n  store?: BaseStore;\n\n  /**\n   * Optional cache for the graph, useful for caching tasks.\n   */\n  cache?: BaseCache;\n\n  /**\n   * Optional interrupt helper function.\n   * @internal\n   */\n  private userInterrupt?: unknown;\n\n  /**\n   * The trigger to node mapping for the graph run.\n   * @internal\n   */\n  private triggerToNodes: Record<string, string[]> = {};\n\n  /**\n   * Constructor for Pregel - meant for internal use only.\n   *\n   * @internal\n   */\n  constructor(fields: PregelParams<Nodes, Channels>) {\n    super(fields);\n\n    let { streamMode } = fields;\n    if (streamMode != null && !Array.isArray(streamMode)) {\n      streamMode = [streamMode];\n    }\n\n    this.nodes = fields.nodes;\n    this.channels = fields.channels;\n\n    if (\n      TASKS in this.channels &&\n      \"lc_graph_name\" in this.channels[TASKS] &&\n      this.channels[TASKS].lc_graph_name !== \"Topic\"\n    ) {\n      throw new Error(\n        `Channel '${TASKS}' is reserved and cannot be used in the graph.`\n      );\n    } else {\n      (this.channels as Record<string, BaseChannel>)[TASKS] =\n        new Topic<SendProtocol>({ accumulate: false });\n    }\n\n    this.autoValidate = fields.autoValidate ?? this.autoValidate;\n    this.streamMode = streamMode ?? this.streamMode;\n    this.inputChannels = fields.inputChannels;\n    this.outputChannels = fields.outputChannels;\n    this.streamChannels = fields.streamChannels ?? this.streamChannels;\n    this.interruptAfter = fields.interruptAfter;\n    this.interruptBefore = fields.interruptBefore;\n    this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;\n    this.debug = fields.debug ?? this.debug;\n    this.checkpointer = fields.checkpointer;\n    this.retryPolicy = fields.retryPolicy;\n    this.config = fields.config;\n    this.store = fields.store;\n    this.cache = fields.cache;\n    this.name = fields.name;\n    this.triggerToNodes = fields.triggerToNodes ?? this.triggerToNodes;\n    this.userInterrupt = fields.userInterrupt;\n\n    if (this.autoValidate) {\n      this.validate();\n    }\n  }\n\n  /**\n   * Creates a new instance of the Pregel graph with updated configuration.\n   * This method follows the immutable pattern - instead of modifying the current instance,\n   * it returns a new instance with the merged configuration.\n   *\n   * @example\n   * ```typescript\n   * // Create a new instance with debug enabled\n   * const debugGraph = graph.withConfig({ debug: true });\n   *\n   * // Create a new instance with a specific thread ID\n   * const threadGraph = graph.withConfig({\n   *   configurable: { thread_id: \"123\" }\n   * });\n   * ```\n   *\n   * @param config - The configuration to merge with the current configuration\n   * @returns A new Pregel instance with the merged configuration\n   */\n  override withConfig(\n    config: Omit<LangGraphRunnableConfig, \"store\" | \"writer\" | \"interrupt\">\n  ): typeof this {\n    const mergedConfig = mergeConfigs(this.config, config);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new (this.constructor as any)({ ...this, config: mergedConfig });\n  }\n\n  /**\n   * Validates the graph structure to ensure it is well-formed.\n   * Checks for:\n   * - No orphaned nodes\n   * - Valid input/output channel configurations\n   * - Valid interrupt configurations\n   *\n   * @returns this - The Pregel instance for method chaining\n   * @throws {GraphValidationError} If the graph structure is invalid\n   */\n  validate(): this {\n    validateGraph<Nodes, Channels>({\n      nodes: this.nodes,\n      channels: this.channels,\n      outputChannels: this.outputChannels,\n      inputChannels: this.inputChannels,\n      streamChannels: this.streamChannels,\n      interruptAfterNodes: this.interruptAfter,\n      interruptBeforeNodes: this.interruptBefore,\n    });\n\n    for (const [name, node] of Object.entries(this.nodes)) {\n      for (const trigger of node.triggers) {\n        this.triggerToNodes[trigger] ??= [];\n        this.triggerToNodes[trigger].push(name);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Gets a list of all channels that should be streamed.\n   * If streamChannels is specified, returns those channels.\n   * Otherwise, returns all channels in the graph.\n   *\n   * @returns Array of channel keys to stream\n   */\n  get streamChannelsList(): Array<keyof Channels> {\n    if (Array.isArray(this.streamChannels)) {\n      return this.streamChannels;\n    } else if (this.streamChannels) {\n      return [this.streamChannels];\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  /**\n   * Gets the channels to stream in their original format.\n   * If streamChannels is specified, returns it as-is (either single key or array).\n   * Otherwise, returns all channels in the graph as an array.\n   *\n   * @returns Channel keys to stream, either as a single key or array\n   */\n  get streamChannelsAsIs(): keyof Channels | Array<keyof Channels> {\n    if (this.streamChannels) {\n      return this.streamChannels;\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  /**\n   * Gets a drawable representation of the graph structure.\n   * This is an async version of getGraph() and is the preferred method to use.\n   *\n   * @param config - Configuration for generating the graph visualization\n   * @returns A representation of the graph that can be visualized\n   */\n  async getGraphAsync(config: RunnableConfig) {\n    return this.getGraph(config);\n  }\n\n  /**\n   * Gets all subgraphs within this graph.\n   * A subgraph is a Pregel instance that is nested within a node of this graph.\n   *\n   * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.\n   * @param namespace - Optional namespace to filter subgraphs\n   * @param recurse - Whether to recursively get subgraphs of subgraphs\n   * @returns Generator yielding tuples of [name, subgraph]\n   */\n  *getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, Pregel<any, any>]> {\n    for (const [name, node] of Object.entries(this.nodes)) {\n      // filter by prefix\n      if (namespace !== undefined) {\n        if (!namespace.startsWith(name)) {\n          continue;\n        }\n      }\n      // find the subgraph if any\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      type SubgraphPregelType = Pregel<any, any> | undefined;\n\n      const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];\n\n      for (const candidate of candidates) {\n        const graph = findSubgraphPregel(candidate) as SubgraphPregelType;\n\n        if (graph !== undefined) {\n          if (name === namespace) {\n            yield [name, graph];\n            return;\n          }\n\n          if (namespace === undefined) {\n            yield [name, graph];\n          }\n\n          if (recurse) {\n            let newNamespace = namespace;\n            if (namespace !== undefined) {\n              newNamespace = namespace.slice(name.length + 1);\n            }\n            for (const [subgraphName, subgraph] of graph.getSubgraphs(\n              newNamespace,\n              recurse\n            )) {\n              yield [\n                `${name}${CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`,\n                subgraph,\n              ];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets all subgraphs within this graph asynchronously.\n   * A subgraph is a Pregel instance that is nested within a node of this graph.\n   *\n   * @param namespace - Optional namespace to filter subgraphs\n   * @param recurse - Whether to recursively get subgraphs of subgraphs\n   * @returns AsyncGenerator yielding tuples of [name, subgraph]\n   */\n  async *getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, Pregel<any, any>]> {\n    yield* this.getSubgraphs(namespace, recurse);\n  }\n\n  /**\n   * Prepares a state snapshot from saved checkpoint data.\n   * This is an internal method used by getState and getStateHistory.\n   *\n   * @param config - Configuration for preparing the snapshot\n   * @param saved - Optional saved checkpoint data\n   * @param subgraphCheckpointer - Optional checkpointer for subgraphs\n   * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels\n   * @returns A snapshot of the graph state\n   * @internal\n   */\n  protected async _prepareStateSnapshot({\n    config,\n    saved,\n    subgraphCheckpointer,\n    applyPendingWrites = false,\n  }: {\n    config: RunnableConfig;\n    saved?: CheckpointTuple;\n    subgraphCheckpointer?: BaseCheckpointSaver;\n    applyPendingWrites?: boolean;\n  }): Promise<StateSnapshot> {\n    if (saved === undefined) {\n      return {\n        values: {},\n        next: [],\n        config,\n        tasks: [],\n      };\n    }\n\n    // Create all channels\n    const channels = emptyChannels(\n      this.channels as Record<string, BaseChannel>,\n      saved.checkpoint\n    );\n\n    // Apply null writes first (from NULL_TASK_ID)\n    if (saved.pendingWrites?.length) {\n      const nullWrites = saved.pendingWrites\n        .filter(([taskId, _]) => taskId === NULL_TASK_ID)\n        .map(\n          ([_, channel, value]) => [String(channel), value] as [string, unknown]\n        );\n\n      if (nullWrites.length > 0) {\n        _applyWrites(\n          saved.checkpoint,\n          channels,\n          [\n            {\n              name: INPUT,\n              writes: nullWrites as PendingWrite[],\n              triggers: [],\n            },\n          ],\n          undefined,\n          this.triggerToNodes\n        );\n      }\n    }\n\n    // Prepare next tasks\n    const nextTasks = Object.values(\n      _prepareNextTasks(\n        saved.checkpoint,\n        saved.pendingWrites,\n        this.nodes,\n        channels,\n        saved.config,\n        true,\n        { step: (saved.metadata?.step ?? -1) + 1, store: this.store }\n      )\n    );\n\n    // Find subgraphs\n    const subgraphs = await gatherIterator(this.getSubgraphsAsync());\n    const parentNamespace = saved.config.configurable?.checkpoint_ns ?? \"\";\n    const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n\n    // Prepare task states for subgraphs\n    for (const task of nextTasks) {\n      const matchingSubgraph = subgraphs.find(([name]) => name === task.name);\n      if (!matchingSubgraph) {\n        continue;\n      }\n      // assemble checkpoint_ns for this task\n      let taskNs = `${String(task.name)}${CHECKPOINT_NAMESPACE_END}${task.id}`;\n      if (parentNamespace) {\n        taskNs = `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;\n      }\n      if (subgraphCheckpointer === undefined) {\n        // set config as signal that subgraph checkpoints exist\n        const config: RunnableConfig = {\n          configurable: {\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        taskStates[task.id] = config;\n      } else {\n        // get the state of the subgraph\n        const subgraphConfig: RunnableConfig = {\n          configurable: {\n            [CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        const pregel = matchingSubgraph[1];\n        taskStates[task.id] = await pregel.getState(subgraphConfig, {\n          subgraphs: true,\n        });\n      }\n    }\n\n    // Apply pending writes to tasks and then to channels if applyPendingWrites is true\n    if (applyPendingWrites && saved.pendingWrites?.length) {\n      // Map task IDs to task objects for easy lookup\n      const nextTaskById = Object.fromEntries(\n        nextTasks.map((task) => [task.id, task])\n      );\n\n      // Apply pending writes to the appropriate tasks\n      for (const [taskId, channel, value] of saved.pendingWrites) {\n        // Skip special channels and tasks not in nextTasks\n        if ([ERROR, INTERRUPT, SCHEDULED].includes(channel)) {\n          continue;\n        }\n        if (!(taskId in nextTaskById)) {\n          continue;\n        }\n        // Add the write to the task\n        nextTaskById[taskId].writes.push([String(channel), value]);\n      }\n\n      // Apply writes from tasks that have writes\n      const tasksWithWrites = nextTasks.filter(\n        (task) => task.writes.length > 0\n      );\n      if (tasksWithWrites.length > 0) {\n        _applyWrites(\n          saved.checkpoint,\n          channels,\n          tasksWithWrites as unknown as WritesProtocol[],\n          undefined,\n          this.triggerToNodes\n        );\n      }\n    }\n\n    // Preserve thread_id from the config in metadata\n    let metadata = saved?.metadata;\n    if (metadata && saved?.config?.configurable?.thread_id) {\n      metadata = {\n        ...metadata,\n        thread_id: saved.config.configurable.thread_id as string,\n      } as CheckpointMetadata;\n    }\n\n    // Filter next tasks - only include tasks without writes\n    const nextList = nextTasks\n      .filter((task) => task.writes.length === 0)\n      .map((task) => task.name as string);\n\n    // assemble the state snapshot\n    return {\n      values: readChannels(\n        channels,\n        this.streamChannelsAsIs as string | string[]\n      ),\n      next: nextList,\n      tasks: tasksWithWrites(\n        nextTasks,\n        saved?.pendingWrites ?? [],\n        taskStates,\n        this.streamChannelsAsIs\n      ),\n      metadata,\n      config: patchCheckpointMap(saved.config, saved.metadata),\n      createdAt: saved.checkpoint.ts,\n      parentConfig: saved.parentConfig,\n    };\n  }\n\n  /**\n   * Gets the current state of the graph.\n   * Requires a checkpointer to be configured.\n   *\n   * @param config - Configuration for retrieving the state\n   * @param options - Additional options\n   * @returns A snapshot of the current graph state\n   * @throws {GraphValueError} If no checkpointer is configured\n   */\n  async getState(\n    config: RunnableConfig,\n    options?: GetStateOptions\n  ): Promise<StateSnapshot> {\n    const checkpointer =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n      for await (const [name, subgraph] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        if (name === recastNamespace) {\n          return await subgraph.getState(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            { subgraphs: options?.subgraphs }\n          );\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config);\n    const saved = await checkpointer.getTuple(config);\n    const snapshot = await this._prepareStateSnapshot({\n      config: mergedConfig,\n      saved,\n      subgraphCheckpointer: options?.subgraphs ? checkpointer : undefined,\n      applyPendingWrites: !config.configurable?.checkpoint_id,\n    });\n    return snapshot;\n  }\n\n  /**\n   * Gets the history of graph states.\n   * Requires a checkpointer to be configured.\n   * Useful for:\n   * - Debugging execution history\n   * - Implementing time travel\n   * - Analyzing graph behavior\n   *\n   * @param config - Configuration for retrieving the history\n   * @param options - Options for filtering the history\n   * @returns An async iterator of state snapshots\n   * @throws {Error} If no checkpointer is configured\n   */\n  async *getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot> {\n    const checkpointer: BaseCheckpointSaver =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n\n      // find the subgraph with the matching name\n      for await (const [name, pregel] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        if (name === recastNamespace) {\n          yield* pregel.getStateHistory(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            options\n          );\n          return;\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config, {\n      configurable: { checkpoint_ns: checkpointNamespace },\n    });\n\n    for await (const checkpointTuple of checkpointer.list(\n      mergedConfig,\n      options\n    )) {\n      yield this._prepareStateSnapshot({\n        config: checkpointTuple.config,\n        saved: checkpointTuple,\n      });\n    }\n  }\n\n  /**\n   * Apply updates to the graph state in bulk.\n   * Requires a checkpointer to be configured.\n   *\n   * This method is useful for recreating a thread\n   * from a list of updates, especially if a checkpoint\n   * is created as a result of multiple tasks.\n   *\n   * @internal The API might change in the future.\n   *\n   * @param startConfig - Configuration for the update\n   * @param updates - The list of updates to apply to graph state\n   * @returns Updated configuration\n   * @throws {GraphValueError} If no checkpointer is configured\n   * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.\n   */\n  async bulkUpdateState(\n    startConfig: LangGraphRunnableConfig,\n    supersteps: Array<{\n      updates: Array<{\n        values?: Record<string, unknown> | unknown;\n        asNode?: keyof Nodes | string;\n      }>;\n    }>\n  ): Promise<RunnableConfig> {\n    const checkpointer: BaseCheckpointSaver | undefined =\n      startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\", {\n        lc_error_code: \"MISSING_CHECKPOINTER\",\n      });\n    }\n    if (supersteps.length === 0) {\n      throw new Error(\"No supersteps provided\");\n    }\n\n    if (supersteps.some((s) => s.updates.length === 0)) {\n      throw new Error(\"No updates provided\");\n    }\n\n    // delegate to subgraph\n    const checkpointNamespace: string =\n      startConfig.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      startConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastNamespace = recastCheckpointNamespace(checkpointNamespace);\n      // find the subgraph with the matching name\n      // eslint-disable-next-line no-unreachable-loop\n      for await (const [, pregel] of this.getSubgraphsAsync(\n        recastNamespace,\n        true\n      )) {\n        return await pregel.bulkUpdateState(\n          patchConfigurable(startConfig, {\n            [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n          }),\n          supersteps\n        );\n      }\n      throw new Error(`Subgraph \"${recastNamespace}\" not found`);\n    }\n\n    const updateSuperStep = async (\n      inputConfig: LangGraphRunnableConfig,\n      updates: {\n        values?: Record<string, unknown> | unknown;\n        asNode?: keyof Nodes | string;\n        taskId?: string;\n      }[]\n    ) => {\n      // get last checkpoint\n      const config = this.config\n        ? mergeConfigs(this.config, inputConfig)\n        : inputConfig;\n      const saved = await checkpointer.getTuple(config);\n      const checkpoint =\n        saved !== undefined\n          ? copyCheckpoint(saved.checkpoint)\n          : emptyCheckpoint();\n      const checkpointPreviousVersions = {\n        ...saved?.checkpoint.channel_versions,\n      };\n      const step = saved?.metadata?.step ?? -1;\n\n      // merge configurable fields with previous checkpoint config\n      let checkpointConfig = patchConfigurable(config, {\n        checkpoint_ns: config.configurable?.checkpoint_ns ?? \"\",\n      });\n      let checkpointMetadata = config.metadata ?? {};\n      if (saved?.config.configurable) {\n        checkpointConfig = patchConfigurable(config, saved.config.configurable);\n        checkpointMetadata = {\n          ...saved.metadata,\n          ...checkpointMetadata,\n        };\n      }\n\n      // Find last node that updated the state, if not provided\n      const { values, asNode } = updates[0];\n      if (values == null && asNode === undefined) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot create empty checkpoint with multiple updates`\n          );\n        }\n\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, undefined, step),\n          {\n            source: \"update\",\n            step: step + 1,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          {}\n        );\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      // update channels\n      const channels = emptyChannels(\n        this.channels as Record<string, BaseChannel>,\n        checkpoint\n      );\n\n      if (values === null && asNode === END) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot apply multiple updates when clearing state`\n          );\n        }\n\n        if (saved) {\n          // tasks for this checkpoint\n          const nextTasks = _prepareNextTasks(\n            checkpoint,\n            saved.pendingWrites || [],\n            this.nodes,\n            channels,\n            saved.config,\n            true,\n            {\n              step: (saved.metadata?.step ?? -1) + 1,\n              checkpointer,\n              store: this.store,\n            }\n          );\n\n          // apply null writes\n          const nullWrites = (saved.pendingWrites || [])\n            .filter((w) => w[0] === NULL_TASK_ID)\n            .map((w) => w.slice(1)) as PendingWrite<string>[];\n          if (nullWrites.length > 0) {\n            _applyWrites(\n              checkpoint,\n              channels,\n              [\n                {\n                  name: INPUT,\n                  writes: nullWrites,\n                  triggers: [],\n                },\n              ],\n              checkpointer.getNextVersion.bind(checkpointer),\n              this.triggerToNodes\n            );\n          }\n          // apply writes from tasks that already ran\n          for (const [taskId, k, v] of saved.pendingWrites || []) {\n            if ([ERROR, INTERRUPT, SCHEDULED].includes(k)) {\n              continue;\n            }\n            if (!(taskId in nextTasks)) {\n              continue;\n            }\n            nextTasks[taskId].writes.push([k, v]);\n          }\n          // clear all current tasks\n          _applyWrites(\n            checkpoint,\n            channels,\n            Object.values(nextTasks) as WritesProtocol<string>[],\n            checkpointer.getNextVersion.bind(checkpointer),\n            this.triggerToNodes\n          );\n        }\n        // save checkpoint\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, channels, step),\n          {\n            ...checkpointMetadata,\n            source: \"update\",\n            step: step + 1,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          getNewChannelVersions(\n            checkpointPreviousVersions,\n            checkpoint.channel_versions\n          )\n        );\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      if (asNode === COPY) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot copy checkpoint with multiple updates`\n          );\n        }\n\n        if (saved == null) {\n          throw new InvalidUpdateError(`Cannot copy a non-existent checkpoint`);\n        }\n\n        const isCopyWithUpdates = (\n          values: unknown\n        ): values is [values: unknown, asNode: string][] => {\n          if (!Array.isArray(values)) return false;\n          if (values.length === 0) return false;\n          return values.every((v) => Array.isArray(v) && v.length === 2);\n        };\n\n        const nextCheckpoint = createCheckpoint(checkpoint, undefined, step);\n        const nextConfig = await checkpointer.put(\n          saved.parentConfig ??\n            patchConfigurable(saved.config, { checkpoint_id: undefined }),\n          nextCheckpoint,\n          {\n            source: \"fork\",\n            step: step + 1,\n            parents: saved.metadata?.parents ?? {},\n          },\n          {}\n        );\n\n        // We want to both clone a checkpoint and update state in one go.\n        // Reuse the same task ID if possible.\n        if (isCopyWithUpdates(values)) {\n          // figure out the task IDs for the next update checkpoint\n          const nextTasks = _prepareNextTasks(\n            nextCheckpoint,\n            saved.pendingWrites,\n            this.nodes,\n            channels,\n            nextConfig,\n            false,\n            { step: step + 2 }\n          );\n\n          const tasksGroupBy = Object.values(nextTasks).reduce<\n            Record<string, { id: string }[]>\n          >((acc, { name, id }) => {\n            acc[name] ??= [];\n            acc[name].push({ id });\n            return acc;\n          }, {});\n\n          const userGroupBy = values.reduce<\n            Record<\n              string,\n              { values: unknown; asNode: string; taskId?: string }[]\n            >\n          >((acc, item) => {\n            const [values, asNode] = item;\n            acc[asNode] ??= [];\n\n            const targetIdx = acc[asNode].length;\n            const taskId = tasksGroupBy[asNode]?.[targetIdx]?.id;\n            acc[asNode].push({ values, asNode, taskId });\n\n            return acc;\n          }, {});\n\n          return updateSuperStep(\n            patchCheckpointMap(nextConfig, saved.metadata),\n            Object.values(userGroupBy).flat()\n          );\n        }\n\n        return patchCheckpointMap(nextConfig, saved.metadata);\n      }\n\n      if (asNode === INPUT) {\n        if (updates.length > 1) {\n          throw new InvalidUpdateError(\n            `Cannot apply multiple updates when updating as input`\n          );\n        }\n\n        const inputWrites = await gatherIterator(\n          mapInput(this.inputChannels, values)\n        );\n        if (inputWrites.length === 0) {\n          throw new InvalidUpdateError(\n            `Received no input writes for ${JSON.stringify(\n              this.inputChannels,\n              null,\n              2\n            )}`\n          );\n        }\n\n        // apply to checkpoint\n        _applyWrites(\n          checkpoint,\n          channels,\n          [\n            {\n              name: INPUT,\n              writes: inputWrites as PendingWrite[],\n              triggers: [],\n            },\n          ],\n          checkpointer.getNextVersion.bind(this.checkpointer),\n          this.triggerToNodes\n        );\n\n        // apply input write to channels\n        const nextStep =\n          saved?.metadata?.step != null ? saved.metadata.step + 1 : -1;\n        const nextConfig = await checkpointer.put(\n          checkpointConfig,\n          createCheckpoint(checkpoint, channels, nextStep),\n          {\n            source: \"input\",\n            step: nextStep,\n            parents: saved?.metadata?.parents ?? {},\n          },\n          getNewChannelVersions(\n            checkpointPreviousVersions,\n            checkpoint.channel_versions\n          )\n        );\n\n        // Store the writes\n        await checkpointer.putWrites(\n          nextConfig,\n          inputWrites as PendingWrite[],\n          uuid5(INPUT, checkpoint.id)\n        );\n\n        return patchCheckpointMap(\n          nextConfig,\n          saved ? saved.metadata : undefined\n        );\n      }\n\n      // apply pending writes, if not on specific checkpoint\n      if (\n        config.configurable?.checkpoint_id === undefined &&\n        saved?.pendingWrites !== undefined &&\n        saved.pendingWrites.length > 0\n      ) {\n        // tasks for this checkpoint\n        const nextTasks = _prepareNextTasks(\n          checkpoint,\n          saved.pendingWrites,\n          this.nodes,\n          channels,\n          saved.config,\n          true,\n          {\n            store: this.store,\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            checkpointer: this.checkpointer as any,\n            step: (saved.metadata?.step ?? -1) + 1,\n          }\n        );\n        // apply null writes\n        const nullWrites = (saved.pendingWrites ?? [])\n          .filter((w) => w[0] === NULL_TASK_ID)\n          .map((w) => w.slice(1)) as PendingWrite<string>[];\n        if (nullWrites.length > 0) {\n          _applyWrites(\n            saved.checkpoint,\n            channels,\n            [{ name: INPUT, writes: nullWrites, triggers: [] }],\n            undefined,\n            this.triggerToNodes\n          );\n        }\n        // apply writes\n        for (const [tid, k, v] of saved.pendingWrites) {\n          if (\n            [ERROR, INTERRUPT, SCHEDULED].includes(k) ||\n            nextTasks[tid] === undefined\n          ) {\n            continue;\n          }\n          nextTasks[tid].writes.push([k, v]);\n        }\n        const tasks = Object.values(nextTasks).filter((task) => {\n          return task.writes.length > 0;\n        });\n        if (tasks.length > 0) {\n          _applyWrites(\n            checkpoint,\n            channels,\n            tasks as WritesProtocol[],\n            undefined,\n            this.triggerToNodes\n          );\n        }\n      }\n      const nonNullVersion = Object.values(checkpoint.versions_seen)\n        .map((seenVersions) => {\n          return Object.values(seenVersions);\n        })\n        .flat()\n        .find((v) => !!v);\n\n      const validUpdates: Array<{\n        values: Record<string, unknown> | unknown;\n        asNode: keyof Nodes | string;\n        taskId?: string;\n      }> = [];\n\n      if (updates.length === 1) {\n        // eslint-disable-next-line prefer-const\n        let { values, asNode, taskId } = updates[0];\n        if (asNode === undefined && Object.keys(this.nodes).length === 1) {\n          // if only one node, use it\n          [asNode] = Object.keys(this.nodes);\n        } else if (asNode === undefined && nonNullVersion === undefined) {\n          if (\n            typeof this.inputChannels === \"string\" &&\n            this.nodes[this.inputChannels] !== undefined\n          ) {\n            asNode = this.inputChannels;\n          }\n        } else if (asNode === undefined) {\n          const lastSeenByNode = Object.entries(checkpoint.versions_seen)\n            .map(([n, seen]) => {\n              return Object.values(seen).map((v) => {\n                return [v, n] as const;\n              });\n            })\n            .flat()\n            .filter(([_, v]) => v !== INTERRUPT)\n            .sort(([aNumber], [bNumber]) =>\n              compareChannelVersions(aNumber, bNumber)\n            );\n          // if two nodes updated the state at the same time, it's ambiguous\n          if (lastSeenByNode) {\n            if (lastSeenByNode.length === 1) {\n              // eslint-disable-next-line prefer-destructuring\n              asNode = lastSeenByNode[0][1];\n            } else if (\n              lastSeenByNode[lastSeenByNode.length - 1][0] !==\n              lastSeenByNode[lastSeenByNode.length - 2][0]\n            ) {\n              // eslint-disable-next-line prefer-destructuring\n              asNode = lastSeenByNode[lastSeenByNode.length - 1][1];\n            }\n          }\n        }\n\n        if (asNode === undefined) {\n          throw new InvalidUpdateError(`Ambiguous update, specify \"asNode\"`);\n        }\n\n        validUpdates.push({ values, asNode, taskId });\n      } else {\n        for (const { asNode, values, taskId } of updates) {\n          if (asNode == null) {\n            throw new InvalidUpdateError(\n              `\"asNode\" is required when applying multiple updates`\n            );\n          }\n\n          validUpdates.push({ values, asNode, taskId });\n        }\n      }\n\n      const tasks: PregelExecutableTask<keyof Nodes, keyof Channels>[] = [];\n      for (const { asNode, values, taskId } of validUpdates) {\n        if (this.nodes[asNode] === undefined) {\n          throw new InvalidUpdateError(\n            `Node \"${asNode.toString()}\" does not exist`\n          );\n        }\n\n        // run all writers of the chosen node\n        const writers = this.nodes[asNode].getWriters();\n        if (!writers.length) {\n          throw new InvalidUpdateError(\n            `No writers found for node \"${asNode.toString()}\"`\n          );\n        }\n        tasks.push({\n          name: asNode,\n          input: values,\n          proc:\n            writers.length > 1\n              ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                RunnableSequence.from(writers as any, {\n                  omitSequenceTags: true,\n                })\n              : writers[0],\n          writes: [],\n          triggers: [INTERRUPT],\n          id: taskId ?? uuid5(INTERRUPT, checkpoint.id),\n          writers: [],\n        });\n      }\n\n      for (const task of tasks) {\n        // execute task\n        await task.proc.invoke(\n          task.input,\n          patchConfig<LangGraphRunnableConfig>(\n            {\n              ...config,\n              store: config?.store ?? this.store,\n            },\n            {\n              runName: config.runName ?? `${this.getName()}UpdateState`,\n              configurable: {\n                [CONFIG_KEY_SEND]: (items: [keyof Channels, unknown][]) =>\n                  task.writes.push(...items),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Channels> | keyof Channels,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    checkpoint,\n                    channels,\n                    // TODO: Why does keyof StrRecord allow number and symbol?\n                    task as PregelExecutableTask<string, string>,\n                    select_ as string | string[],\n                    fresh_\n                  ),\n              },\n            }\n          )\n        );\n      }\n\n      for (const task of tasks) {\n        // channel writes are saved to current checkpoint\n        const channelWrites = task.writes.filter((w) => w[0] !== PUSH);\n        // save task writes\n        if (saved !== undefined && channelWrites.length > 0) {\n          await checkpointer.putWrites(\n            checkpointConfig,\n            channelWrites as PendingWrite[],\n            task.id\n          );\n        }\n      }\n\n      // apply to checkpoint\n      // TODO: Why does keyof StrRecord allow number and symbol?\n      _applyWrites(\n        checkpoint,\n        channels,\n        tasks as PregelExecutableTask<string, string>[],\n        checkpointer.getNextVersion.bind(this.checkpointer),\n        this.triggerToNodes\n      );\n\n      const newVersions = getNewChannelVersions(\n        checkpointPreviousVersions,\n        checkpoint.channel_versions\n      );\n      const nextConfig = await checkpointer.put(\n        checkpointConfig,\n        createCheckpoint(checkpoint, channels, step + 1),\n        {\n          source: \"update\",\n          step: step + 1,\n          parents: saved?.metadata?.parents ?? {},\n        },\n        newVersions\n      );\n\n      for (const task of tasks) {\n        // push writes are saved to next checkpoint\n        const pushWrites = task.writes.filter((w) => w[0] === PUSH);\n\n        if (pushWrites.length > 0) {\n          await checkpointer.putWrites(\n            nextConfig,\n            pushWrites as PendingWrite[],\n            task.id\n          );\n        }\n      }\n\n      return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n    };\n\n    let currentConfig = startConfig;\n    for (const { updates } of supersteps) {\n      currentConfig = await updateSuperStep(currentConfig, updates);\n    }\n\n    return currentConfig;\n  }\n\n  /**\n   * Updates the state of the graph with new values.\n   * Requires a checkpointer to be configured.\n   *\n   * This method can be used for:\n   * - Implementing human-in-the-loop workflows\n   * - Modifying graph state during breakpoints\n   * - Integrating external inputs into the graph\n   *\n   * @param inputConfig - Configuration for the update\n   * @param values - The values to update the state with\n   * @param asNode - Optional node name to attribute the update to\n   * @returns Updated configuration\n   * @throws {GraphValueError} If no checkpointer is configured\n   * @throws {InvalidUpdateError} If the update cannot be attributed to a node\n   */\n  async updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nodes | string\n  ): Promise<RunnableConfig> {\n    return this.bulkUpdateState(inputConfig, [\n      { updates: [{ values, asNode }] },\n    ]);\n  }\n\n  /**\n   * Gets the default values for various graph configuration options.\n   * This is an internal method used to process and normalize configuration options.\n   *\n   * @param config - The input configuration options\n   * @returns A tuple containing normalized values for:\n   * - debug mode\n   * - stream modes\n   * - input keys\n   * - output keys\n   * - remaining config\n   * - interrupt before nodes\n   * - interrupt after nodes\n   * - checkpointer\n   * - store\n   * - whether stream mode is single\n   * - node cache\n   * - whether checkpoint during is enabled\n   * @internal\n   */\n  _defaults(config: PregelOptions<Nodes, Channels>): [\n    boolean, // debug\n    StreamMode[], // stream mode\n    string | string[], // input keys\n    string | string[], // output keys\n    LangGraphRunnableConfig, // config without pregel keys\n    All | string[], // interrupt before\n    All | string[], // interrupt after\n    BaseCheckpointSaver | undefined, // checkpointer\n    BaseStore | undefined, // store\n    boolean, // stream mode single\n    BaseCache | undefined, // node cache\n    Durability // durability\n  ] {\n    const {\n      debug,\n      streamMode,\n      inputKeys,\n      outputKeys,\n      interruptAfter,\n      interruptBefore,\n      ...rest\n    } = config;\n    let streamModeSingle = true;\n    const defaultDebug = debug !== undefined ? debug : this.debug;\n\n    let defaultOutputKeys = outputKeys;\n    if (defaultOutputKeys === undefined) {\n      defaultOutputKeys = this.streamChannelsAsIs;\n    } else {\n      validateKeys(defaultOutputKeys, this.channels);\n    }\n\n    let defaultInputKeys = inputKeys;\n    if (defaultInputKeys === undefined) {\n      defaultInputKeys = this.inputChannels;\n    } else {\n      validateKeys(defaultInputKeys, this.channels);\n    }\n\n    const defaultInterruptBefore =\n      interruptBefore ?? this.interruptBefore ?? [];\n\n    const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];\n\n    let defaultStreamMode: StreamMode[];\n    if (streamMode !== undefined) {\n      defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];\n      streamModeSingle = typeof streamMode === \"string\";\n    } else {\n      // if being called as a node in another graph, default to values mode\n      // but don't overwrite `streamMode`if provided\n      if (config.configurable?.[CONFIG_KEY_TASK_ID] !== undefined) {\n        defaultStreamMode = [\"values\"];\n      } else {\n        defaultStreamMode = this.streamMode;\n      }\n\n      streamModeSingle = true;\n    }\n\n    let defaultCheckpointer: BaseCheckpointSaver | undefined;\n    if (this.checkpointer === false) {\n      defaultCheckpointer = undefined;\n    } else if (\n      config !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] !== undefined\n    ) {\n      defaultCheckpointer = config.configurable[CONFIG_KEY_CHECKPOINTER];\n    } else if (this.checkpointer === true) {\n      throw new Error(\"checkpointer: true cannot be used for root graphs.\");\n    } else {\n      defaultCheckpointer = this.checkpointer;\n    }\n    const defaultStore: BaseStore | undefined = config.store ?? this.store;\n    const defaultCache: BaseCache | undefined = config.cache ?? this.cache;\n\n    if (config.durability != null && config.checkpointDuring != null) {\n      throw new Error(\n        \"Cannot use both `durability` and `checkpointDuring` at the same time.\"\n      );\n    }\n\n    const checkpointDuringDurability: Durability | undefined = (() => {\n      if (config.checkpointDuring == null) return undefined;\n      if (config.checkpointDuring === false) return \"exit\";\n      return \"async\";\n    })();\n\n    const defaultDurability: Durability =\n      config.durability ??\n      checkpointDuringDurability ??\n      config?.configurable?.[CONFIG_KEY_DURABILITY] ??\n      \"async\";\n\n    return [\n      defaultDebug,\n      defaultStreamMode,\n      defaultInputKeys as string | string[],\n      defaultOutputKeys as string | string[],\n      rest,\n      defaultInterruptBefore as All | string[],\n      defaultInterruptAfter as All | string[],\n      defaultCheckpointer,\n      defaultStore,\n      streamModeSingle,\n      defaultCache,\n      defaultDurability,\n    ];\n  }\n\n  /**\n   * Streams the execution of the graph, emitting state updates as they occur.\n   * This is the primary method for observing graph execution in real-time.\n   *\n   * Stream modes:\n   * - \"values\": Emits complete state after each step\n   * - \"updates\": Emits only state changes after each step\n   * - \"debug\": Emits detailed debug information\n   * - \"messages\": Emits messages from within nodes\n   * - \"custom\": Emits custom events from within nodes\n   * - \"checkpoints\": Emits checkpoints from within nodes\n   * - \"tasks\": Emits tasks from within nodes\n   *\n   * @param input - The input to start graph execution with\n   * @param options - Configuration options for streaming\n   * @returns An async iterable stream of graph state updates\n   */\n  override async stream<\n    TStreamMode extends StreamMode | StreamMode[] | undefined,\n    TSubgraphs extends boolean,\n    TEncoding extends \"text/event-stream\" | undefined\n  >(\n    input: InputType | CommandType | null,\n    options?: Partial<\n      PregelOptions<\n        Nodes,\n        Channels,\n        ContextType,\n        TStreamMode,\n        TSubgraphs,\n        TEncoding\n      >\n    >\n  ): Promise<\n    IterableReadableStream<\n      StreamOutputMap<\n        TStreamMode,\n        TSubgraphs,\n        StreamUpdatesType,\n        StreamValuesType,\n        keyof Nodes,\n        NodeReturnType,\n        StreamCustom,\n        TEncoding\n      >\n    >\n  > {\n    // The ensureConfig method called internally defaults recursionLimit to 25 if not\n    // passed directly in `options`.\n    // There is currently no way in _streamIterator to determine whether this was\n    // set by by ensureConfig or manually by the user, so we specify the bound value here\n    // and override if it is passed as an explicit param in `options`.\n    const abortController = new AbortController();\n\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n      signal: combineAbortSignals(options?.signal, abortController.signal)\n        .signal,\n    };\n\n    const stream = await super.stream(input, config);\n    return new IterableReadableStreamWithAbortSignal(\n      options?.encoding === \"text/event-stream\"\n        ? toEventStream(stream)\n        : stream,\n      abortController\n    );\n  }\n\n  /**\n   * @inheritdoc\n   */\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<StreamEvent>;\n\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n      encoding: \"text/event-stream\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<Uint8Array>;\n\n  override streamEvents(\n    input: InputType | CommandType | null,\n    options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    },\n    streamOptions?: StreamEventsOptions\n  ): IterableReadableStream<StreamEvent | Uint8Array> {\n    const abortController = new AbortController();\n\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n      // Similar to `stream`, we need to pass the `config.callbacks` here,\n      // otherwise the user-provided callback will get lost in `ensureLangGraphConfig`.\n\n      // extend the callbacks with the ones from the config\n      callbacks: combineCallbacks(this.config?.callbacks, options?.callbacks),\n      signal: combineAbortSignals(options?.signal, abortController.signal)\n        .signal,\n    };\n\n    return new IterableReadableStreamWithAbortSignal(\n      super.streamEvents(input, config, streamOptions),\n      abortController\n    );\n  }\n\n  /**\n   * Validates the input for the graph.\n   * @param input - The input to validate\n   * @returns The validated input\n   * @internal\n   */\n  protected async _validateInput(input: PregelInputType) {\n    return input;\n  }\n\n  /**\n   * Validates the context options for the graph.\n   * @param context - The context options to validate\n   * @returns The validated context options\n   * @internal\n   */\n  protected async _validateContext(\n    context: Partial<LangGraphRunnableConfig[\"context\"]>\n  ): Promise<LangGraphRunnableConfig[\"context\"]> {\n    return context;\n  }\n\n  /**\n   * Internal iterator used by stream() to generate state updates.\n   * This method handles the core logic of graph execution and streaming.\n   *\n   * @param input - The input to start graph execution with\n   * @param options - Configuration options for streaming\n   * @returns AsyncGenerator yielding state updates\n   * @internal\n   */\n  override async *_streamIterator(\n    input: PregelInputType | Command,\n    options?: Partial<PregelOptions<Nodes, Channels>>\n  ): AsyncGenerator<PregelOutputType> {\n    // Skip LGP encoding option is `streamEvents` is used\n    const streamEncoding =\n      \"version\" in (options ?? {}) ? undefined : options?.encoding ?? undefined;\n    const streamSubgraphs = options?.subgraphs;\n    const inputConfig = ensureLangGraphConfig(this.config, options);\n    if (\n      inputConfig.recursionLimit === undefined ||\n      inputConfig.recursionLimit < 1\n    ) {\n      throw new Error(`Passed \"recursionLimit\" must be at least 1.`);\n    }\n    if (\n      this.checkpointer !== undefined &&\n      this.checkpointer !== false &&\n      inputConfig.configurable === undefined\n    ) {\n      throw new Error(\n        `Checkpointer requires one or more of the following \"configurable\" keys: \"thread_id\", \"checkpoint_ns\", \"checkpoint_id\"`\n      );\n    }\n\n    const validInput = await this._validateInput(input);\n    const { runId, ...restConfig } = inputConfig;\n    // assign defaults\n    const [\n      debug,\n      streamMode,\n      ,\n      outputKeys,\n      config,\n      interruptBefore,\n      interruptAfter,\n      checkpointer,\n      store,\n      streamModeSingle,\n      cache,\n      durability,\n    ] = this._defaults(restConfig);\n\n    // At entrypoint, `configurable` is an alias for `context`.\n    if (typeof config.context !== \"undefined\") {\n      config.context = await this._validateContext(config.context);\n    } else {\n      config.configurable = await this._validateContext(config.configurable);\n    }\n\n    const stream = new IterableReadableWritableStream({\n      modes: new Set(streamMode),\n    });\n\n    // set up subgraph checkpointing\n    if (this.checkpointer === true) {\n      config.configurable ??= {};\n      const ns: string = config.configurable[CONFIG_KEY_CHECKPOINT_NS] ?? \"\";\n      config.configurable[CONFIG_KEY_CHECKPOINT_NS] = ns\n        .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n        .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n    }\n\n    // set up messages stream mode\n    if (streamMode.includes(\"messages\")) {\n      const messageStreamer = new StreamMessagesHandler((chunk) =>\n        stream.push(chunk)\n      );\n      const { callbacks } = config;\n      if (callbacks === undefined) {\n        config.callbacks = [messageStreamer];\n      } else if (Array.isArray(callbacks)) {\n        config.callbacks = callbacks.concat(messageStreamer);\n      } else {\n        const copiedCallbacks = callbacks.copy();\n        copiedCallbacks.addHandler(messageStreamer, true);\n        config.callbacks = copiedCallbacks;\n      }\n    }\n\n    config.writer ??= (chunk: unknown) => {\n      if (!streamMode.includes(\"custom\")) return;\n      const ns = (\n        getConfig()?.configurable?.[CONFIG_KEY_CHECKPOINT_NS] as\n          | string\n          | undefined\n      )\n        ?.split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .slice(0, -1);\n\n      stream.push([ns ?? [], \"custom\", chunk]);\n    };\n\n    config.interrupt ??= (this.userInterrupt as typeof interrupt) ?? interrupt;\n\n    const callbackManager = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager?.handleChainStart(\n      this.toJSON(), // chain\n      _coerceToDict(input, \"input\"), // inputs\n      runId, // run_id\n      undefined, // run_type\n      undefined, // tags\n      undefined, // metadata\n      config?.runName ?? this.getName() // run_name\n    );\n\n    const channelSpecs = getOnlyChannels(this.channels);\n    let loop: PregelLoop | undefined;\n    let loopError: unknown;\n\n    /**\n     * The PregelLoop will yield events from concurrent tasks as soon as they are\n     * generated. Each task can push multiple events onto the stream in any order.\n     *\n     * We use a separate background method and stream here in order to yield events\n     * from the loop to the main stream and therefore back to the user as soon as\n     * they are available.\n     */\n    const createAndRunLoop = async () => {\n      try {\n        loop = await PregelLoop.initialize({\n          input: validInput,\n          config,\n          checkpointer,\n          nodes: this.nodes,\n          channelSpecs,\n          outputKeys,\n          streamKeys: this.streamChannelsAsIs as string | string[],\n          store,\n          cache: cache as BaseCache<PendingWrite<string>[]>,\n          stream,\n          interruptAfter,\n          interruptBefore,\n          manager: runManager,\n          debug: this.debug,\n          triggerToNodes: this.triggerToNodes,\n          durability,\n        });\n\n        const runner = new PregelRunner({\n          loop,\n          nodeFinished: config.configurable?.[CONFIG_KEY_NODE_FINISHED],\n        });\n\n        if (options?.subgraphs) {\n          loop.config.configurable = {\n            ...loop.config.configurable,\n            [CONFIG_KEY_STREAM]: loop.stream,\n          };\n        }\n        await this._runLoop({ loop, runner, debug, config });\n\n        // wait for checkpoints to be persisted\n        if (durability === \"sync\") {\n          await Promise.all(loop?.checkpointerPromises ?? []);\n        }\n      } catch (e) {\n        loopError = e;\n      } finally {\n        try {\n          // Call `.stop()` again incase it was not called in the loop, e.g due to an error.\n          if (loop) {\n            await loop.store?.stop();\n            await loop.cache?.stop();\n          }\n          await Promise.all(loop?.checkpointerPromises ?? []);\n        } catch (e) {\n          loopError = loopError ?? e;\n        }\n        if (loopError) {\n          // \"Causes any future interactions with the associated stream to error\".\n          // Wraps ReadableStreamDefaultController#error:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/error\n          stream.error(loopError);\n        } else {\n          // Will end the iterator outside of this method,\n          // keeping previously enqueued chunks.\n          // Wraps ReadableStreamDefaultController#close:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/close\n          stream.close();\n        }\n      }\n    };\n    const runLoopPromise = createAndRunLoop();\n\n    try {\n      for await (const chunk of stream) {\n        if (chunk === undefined) {\n          throw new Error(\"Data structure error.\");\n        }\n        const [namespace, mode, payload] = chunk;\n        if (streamMode.includes(mode)) {\n          if (streamEncoding === \"text/event-stream\") {\n            if (streamSubgraphs) {\n              yield [namespace, mode, payload];\n            } else {\n              yield [null, mode, payload];\n            }\n            continue;\n          }\n          if (streamSubgraphs && !streamModeSingle) {\n            yield [namespace, mode, payload];\n          } else if (!streamModeSingle) {\n            yield [mode, payload];\n          } else if (streamSubgraphs) {\n            yield [namespace, payload];\n          } else {\n            yield payload;\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(loopError);\n      throw e;\n    } finally {\n      await runLoopPromise;\n    }\n    await runManager?.handleChainEnd(\n      loop?.output ?? {},\n      runId, // run_id\n      undefined, // run_type\n      undefined, // tags\n      undefined // metadata\n    );\n  }\n\n  /**\n   * Run the graph with a single input and config.\n   * @param input The input to the graph.\n   * @param options The configuration to use for the run.\n   */\n  override async invoke(\n    input: InputType | CommandType | null,\n    options?: Partial<\n      Omit<PregelOptions<Nodes, Channels, ContextType>, \"encoding\">\n    >\n  ): Promise<OutputType> {\n    const streamMode = options?.streamMode ?? \"values\";\n    const config = {\n      ...options,\n      outputKeys: options?.outputKeys ?? this.outputChannels,\n      streamMode,\n      encoding: undefined,\n    };\n    const chunks = [];\n    const stream = await this.stream(input, config);\n    const interruptChunks: Interrupt[][] = [];\n\n    let latest: OutputType | undefined;\n\n    for await (const chunk of stream) {\n      if (streamMode === \"values\") {\n        if (isInterrupted(chunk)) {\n          interruptChunks.push(chunk[INTERRUPT]);\n        } else {\n          latest = chunk as OutputType;\n        }\n      } else {\n        chunks.push(chunk);\n      }\n    }\n\n    if (streamMode === \"values\") {\n      if (interruptChunks.length > 0) {\n        const interrupts = interruptChunks.flat(1);\n        if (latest == null) return { [INTERRUPT]: interrupts } as OutputType;\n        if (typeof latest === \"object\") {\n          return { ...latest, [INTERRUPT]: interrupts };\n        }\n      }\n\n      return latest as OutputType;\n    }\n    return chunks as OutputType;\n  }\n\n  private async _runLoop(params: {\n    loop: PregelLoop;\n    runner: PregelRunner;\n    config: RunnableConfig;\n    debug: boolean;\n  }): Promise<void> {\n    const { loop, runner, debug, config } = params;\n    let tickError;\n    try {\n      while (\n        await loop.tick({ inputKeys: this.inputChannels as string | string[] })\n      ) {\n        for (const { task } of await loop._matchCachedWrites()) {\n          loop._outputWrites(task.id, task.writes, true);\n        }\n\n        if (debug) {\n          printStepCheckpoint(\n            loop.checkpointMetadata.step,\n            loop.channels,\n            this.streamChannelsList as string[]\n          );\n        }\n        if (debug) {\n          printStepTasks(loop.step, Object.values(loop.tasks));\n        }\n        await runner.tick({\n          timeout: this.stepTimeout,\n          retryPolicy: this.retryPolicy,\n          onStepWrite: (step, writes) => {\n            if (debug) {\n              printStepWrites(\n                step,\n                writes,\n                this.streamChannelsList as string[]\n              );\n            }\n          },\n          maxConcurrency: config.maxConcurrency,\n          signal: config.signal,\n        });\n      }\n      if (loop.status === \"out_of_steps\") {\n        throw new GraphRecursionError(\n          [\n            `Recursion limit of ${config.recursionLimit} reached`,\n            \"without hitting a stop condition. You can increase the\",\n            `limit by setting the \"recursionLimit\" config key.`,\n          ].join(\" \"),\n          {\n            lc_error_code: \"GRAPH_RECURSION_LIMIT\",\n          }\n        );\n      }\n    } catch (e) {\n      tickError = e as Error;\n      const suppress = await loop.finishAndHandleError(tickError);\n      if (!suppress) {\n        throw e;\n      }\n    } finally {\n      if (tickError === undefined) {\n        await loop.finishAndHandleError();\n      }\n    }\n  }\n\n  async clearCache(): Promise<void> {\n    await this.cache?.clear([]);\n  }\n}\n","/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { z } from \"zod/v3\";\nimport { Annotation } from \"./annotation.js\";\nimport { Messages, messagesStateReducer } from \"./message.js\";\nimport { SchemaMeta, withLangGraph } from \"./zod/meta.js\";\n\n/**\n * Prebuilt state annotation that combines returned messages.\n * Can handle standard messages and special modifiers like {@link RemoveMessage}\n * instances.\n *\n * Specifically, importing and using the prebuilt MessagesAnnotation like this:\n *\n * @example\n * ```ts\n * import { MessagesAnnotation, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Is equivalent to initializing your state manually like this:\n *\n * @example\n * ```ts\n * import { BaseMessage } from \"@langchain/core/messages\";\n * import { Annotation, StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n *\n * export const StateAnnotation = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: messagesStateReducer,\n *     default: () => [],\n *   }),\n * });\n *\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(...)\n *   ...\n * ```\n */\nexport const MessagesAnnotation = Annotation.Root({\n  messages: Annotation<BaseMessage[], Messages>({\n    reducer: messagesStateReducer,\n    default: () => [],\n  }),\n});\n\n/**\n * Prebuilt schema meta for Zod state definition.\n *\n * @example\n * ```ts\n * import { z } from \"zod/v4-mini\";\n * import { MessagesZodState, StateGraph } from \"@langchain/langgraph\";\n *\n * const AgentState = z.object({\n *   messages: z.custom<BaseMessage[]>().register(registry, MessagesZodMeta),\n * });\n * ```\n */\nexport const MessagesZodMeta: SchemaMeta<BaseMessage[], Messages> = {\n  reducer: { fn: messagesStateReducer },\n  jsonSchemaExtra: { langgraph_type: \"messages\" },\n  default: () => [],\n};\n\n/**\n * Prebuilt state object that uses Zod to combine returned messages.\n * This utility is synonymous with the `MessagesAnnotation` annotation,\n * but uses Zod as the way to express messages state.\n *\n * You can use import and use this prebuilt schema like this:\n *\n * @example\n * ```ts\n * import { MessagesZodState, StateGraph } from \"@langchain/langgraph\";\n *\n * const graph = new StateGraph(MessagesZodState)\n *   .addNode(...)\n *   ...\n * ```\n *\n * Which is equivalent to initializing the schema object manually like this:\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n * import type { BaseMessage, BaseMessageLike } from \"@langchain/core/messages\";\n * import { StateGraph, messagesStateReducer } from \"@langchain/langgraph\";\n * import \"@langchain/langgraph/zod\";\n *\n * const AgentState = z.object({\n *   messages: z\n *     .custom<BaseMessage[]>()\n *     .default(() => [])\n *     .langgraph.reducer(\n *        messagesStateReducer,\n *        z.custom<BaseMessageLike | BaseMessageLike[]>()\n *     ),\n * });\n * const graph = new StateGraph(AgentState)\n *   .addNode(...)\n *   ...\n * ```\n */\nexport const MessagesZodState = z.object({\n  messages: withLangGraph(z.custom<BaseMessage[]>(), MessagesZodMeta),\n});\n","import type { ContentBlock } from \"../content/index.js\";\nimport type { AIMessageChunk, AIMessage } from \"../ai.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { convertToV1FromOpenAIDataBlock, isOpenAIDataBlock } from \"./data.js\";\nimport {\n  _isArray,\n  _isContentBlock,\n  _isObject,\n  _isString,\n  iife,\n} from \"./utils.js\";\n\n/**\n * Converts a ChatOpenAICompletions message to an array of v1 standard content blocks.\n *\n * This function processes an AI message from ChatOpenAICompletions API format\n * and converts it to the standardized v1 content block format. It handles both\n * string content and structured content blocks, as well as tool calls.\n *\n * @param message - The AI message containing ChatOpenAICompletions formatted content\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage(\"Hello world\");\n * const standardBlocks = convertToV1FromChatCompletions(message);\n * // Returns: [{ type: \"text\", text: \"Hello world\" }]\n * ```\n *\n * @example\n * ```typescript\n * const message = new AIMessage([\n *   { type: \"text\", text: \"Hello\" },\n *   { type: \"image_url\", image_url: { url: \"https://example.com/image.png\" } }\n * ]);\n * message.tool_calls = [\n *   { id: \"call_123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletions(message);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello\" },\n * //   { type: \"image\", url: \"https://example.com/image.png\" },\n * //   { type: \"tool_call\", id: \"call_123\", name: \"calculator\", args: { a: 1, b: 2 } }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletions(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n  if (typeof message.content === \"string\") {\n    blocks.push({\n      type: \"text\",\n      text: message.content,\n    });\n  } else {\n    blocks.push(...convertToV1FromChatCompletionsInput(message.content));\n  }\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n  return blocks;\n}\n\n/**\n * Converts a ChatOpenAICompletions message chunk to an array of v1 standard content blocks.\n *\n * This function processes an AI message chunk from OpenAI's chat completions API and converts\n * it to the standardized v1 content block format. It handles both string and array content,\n * as well as tool calls that may be present in the chunk.\n *\n * @param message - The AI message chunk containing OpenAI-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const chunk = new AIMessage(\"Hello\");\n * const standardBlocks = convertToV1FromChatCompletionsChunk(chunk);\n * // Returns: [{ type: \"text\", text: \"Hello\" }]\n * ```\n *\n * @example\n * ```typescript\n * const chunk = new AIMessage([\n *   { type: \"text\", text: \"Processing...\" }\n * ]);\n * chunk.tool_calls = [\n *   { id: \"call_456\", name: \"search\", args: { query: \"test\" } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletionsChunk(chunk);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Processing...\" },\n * //   { type: \"tool_call\", id: \"call_456\", name: \"search\", args: { query: \"test\" } }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletionsChunk(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n  if (typeof message.content === \"string\") {\n    blocks.push({\n      type: \"text\",\n      text: message.content,\n    });\n  } else {\n    blocks.push(...convertToV1FromChatCompletionsInput(message.content));\n  }\n\n  // TODO: parse chunk position information\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n  return blocks;\n}\n\n/**\n * Converts an array of ChatOpenAICompletions content blocks to v1 standard content blocks.\n *\n * This function processes content blocks from OpenAI's Chat Completions API format\n * and converts them to the standardized v1 content block format. It handles both\n * OpenAI-specific data blocks (which require conversion) and standard blocks\n * (which are passed through with type assertion).\n *\n * @param blocks - Array of content blocks in ChatOpenAICompletions format\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const openaiBlocks = [\n *   { type: \"text\", text: \"Hello world\" },\n *   { type: \"image_url\", image_url: { url: \"https://example.com/image.png\" } }\n * ];\n *\n * const standardBlocks = convertToV1FromChatCompletionsInput(openaiBlocks);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello world\" },\n * //   { type: \"image\", url: \"https://example.com/image.png\" }\n * // ]\n * ```\n */\nexport function convertToV1FromChatCompletionsInput(\n  blocks: Array<ContentBlock>\n): Array<ContentBlock.Standard> {\n  const convertedBlocks: Array<ContentBlock.Standard> = [];\n  for (const block of blocks) {\n    if (isOpenAIDataBlock(block)) {\n      convertedBlocks.push(convertToV1FromOpenAIDataBlock(block));\n    } else {\n      convertedBlocks.push(block as ContentBlock.Standard);\n    }\n  }\n  return convertedBlocks;\n}\n\nfunction convertResponsesAnnotation(\n  annotation: ContentBlock\n): ContentBlock | ContentBlock.Citation {\n  if (annotation.type === \"url_citation\") {\n    const { url, title, start_index, end_index } = annotation;\n    return {\n      type: \"citation\",\n      url,\n      title,\n      startIndex: start_index,\n      endIndex: end_index,\n    };\n  }\n  if (annotation.type === \"file_citation\") {\n    const { file_id, filename, index } = annotation;\n    return {\n      type: \"citation\",\n      title: filename,\n      startIndex: index,\n      endIndex: index,\n      fileId: file_id,\n    };\n  }\n  return annotation;\n}\n\n/**\n * Converts a ChatOpenAIResponses message to an array of v1 standard content blocks.\n *\n * This function processes an AI message containing OpenAI Responses-specific content blocks\n * and converts them to the standardized v1 content block format. It handles reasoning summaries,\n * text content with annotations, tool calls, and various tool outputs including code interpreter,\n * web search, file search, computer calls, and MCP-related blocks.\n *\n * @param message - The AI message containing OpenAI Responses-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const message = new AIMessage({\n *   content: [{ type: \"text\", text: \"Hello world\", annotations: [] }],\n *   tool_calls: [{ id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } }],\n *   additional_kwargs: {\n *     reasoning: { summary: [{ text: \"Let me calculate this...\" }] },\n *     tool_outputs: [\n *       {\n *         type: \"code_interpreter_call\",\n *         code: \"print('hello')\",\n *         outputs: [{ type: \"logs\", logs: \"hello\" }]\n *       }\n *     ]\n *   }\n * });\n *\n * const standardBlocks = convertToV1FromResponses(message);\n * // Returns:\n * // [\n * //   { type: \"reasoning\", reasoning: \"Let me calculate this...\" },\n * //   { type: \"text\", text: \"Hello world\", annotations: [] },\n * //   { type: \"tool_call\", id: \"123\", name: \"calculator\", args: { a: 1, b: 2 } },\n * //   { type: \"code_interpreter_call\", code: \"print('hello')\" },\n * //   { type: \"code_interpreter_result\", output: [{ type: \"code_interpreter_output\", returnCode: 0, stdout: \"hello\" }] }\n * // ]\n * ```\n */\nexport function convertToV1FromResponses(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    if (\n      _isObject(message.additional_kwargs?.reasoning) &&\n      _isArray(message.additional_kwargs.reasoning.summary)\n    ) {\n      const summary =\n        message.additional_kwargs.reasoning.summary.reduce<string>(\n          (acc, item) => {\n            if (_isObject(item) && _isString(item.text)) {\n              return `${acc}${item.text}`;\n            }\n            return acc;\n          },\n          \"\"\n        );\n      yield {\n        type: \"reasoning\",\n        reasoning: summary,\n      };\n    }\n    const content =\n      typeof message.content === \"string\"\n        ? [{ type: \"text\", text: message.content }]\n        : message.content;\n    for (const block of content) {\n      if (_isContentBlock(block, \"text\")) {\n        const { text, annotations, ...rest } = block;\n        if (Array.isArray(annotations)) {\n          yield {\n            ...rest,\n            type: \"text\",\n            text: String(text),\n            annotations: annotations.map(convertResponsesAnnotation),\n          };\n        } else {\n          yield {\n            ...rest,\n            type: \"text\",\n            text: String(text),\n          };\n        }\n      }\n    }\n    for (const toolCall of message.tool_calls ?? []) {\n      yield {\n        type: \"tool_call\",\n        id: toolCall.id,\n        name: toolCall.name,\n        args: toolCall.args,\n      };\n    }\n    if (\n      _isObject(message.additional_kwargs) &&\n      _isArray(message.additional_kwargs.tool_outputs)\n    ) {\n      for (const toolOutput of message.additional_kwargs.tool_outputs) {\n        if (_isContentBlock(toolOutput, \"web_search_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"web_search\",\n            args: { query: toolOutput.query },\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"file_search_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"file_search\",\n            args: { query: toolOutput.query },\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"computer_call\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"code_interpreter_call\")) {\n          if (_isString(toolOutput.code)) {\n            yield {\n              id: toolOutput.id,\n              type: \"server_tool_call\",\n              name: \"code_interpreter\",\n              args: { code: toolOutput.code },\n            };\n          }\n          if (_isArray(toolOutput.outputs)) {\n            const returnCode = iife(() => {\n              if (toolOutput.status === \"in_progress\") return undefined;\n              if (toolOutput.status === \"completed\") return 0;\n              if (toolOutput.status === \"incomplete\") return 127;\n              if (toolOutput.status === \"interpreting\") return undefined;\n              if (toolOutput.status === \"failed\") return 1;\n              return undefined;\n            });\n            for (const output of toolOutput.outputs) {\n              if (_isContentBlock(output, \"logs\")) {\n                yield {\n                  type: \"server_tool_call_result\",\n                  toolCallId: toolOutput.id ?? \"\",\n                  status: \"success\",\n                  output: {\n                    type: \"code_interpreter_output\",\n                    returnCode: returnCode ?? 0,\n                    stderr: [0, undefined].includes(returnCode)\n                      ? undefined\n                      : String(output.logs),\n                    stdout: [0, undefined].includes(returnCode)\n                      ? String(output.logs)\n                      : undefined,\n                  },\n                };\n                continue;\n              }\n            }\n          }\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_call\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"mcp_call\",\n            args: toolOutput.input,\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_list_tools\")) {\n          yield {\n            id: toolOutput.id,\n            type: \"server_tool_call\",\n            name: \"mcp_list_tools\",\n            args: toolOutput.input,\n          };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"mcp_approval_request\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        } else if (_isContentBlock(toolOutput, \"image_generation_call\")) {\n          yield { type: \"non_standard\", value: toolOutput };\n          continue;\n        }\n        if (_isObject(toolOutput)) {\n          yield { type: \"non_standard\", value: toolOutput };\n        }\n      }\n    }\n  }\n  return Array.from(iterateContent());\n}\n\n/**\n * Converts a ChatOpenAIResponses message chunk to an array of v1 standard content blocks.\n *\n * This function processes an AI message chunk containing OpenAI-specific content blocks\n * and converts them to the standardized v1 content block format. It handles both the\n * regular message content and tool call chunks that are specific to streaming responses.\n *\n * @param message - The AI message chunk containing OpenAI-formatted content blocks\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * const messageChunk = new AIMessageChunk({\n *   content: [{ type: \"text\", text: \"Hello\" }],\n *   tool_call_chunks: [\n *     { id: \"call_123\", name: \"calculator\", args: '{\"a\": 1' }\n *   ]\n * });\n *\n * const standardBlocks = convertToV1FromResponsesChunk(messageChunk);\n * // Returns:\n * // [\n * //   { type: \"text\", text: \"Hello\" },\n * //   { type: \"tool_call_chunk\", id: \"call_123\", name: \"calculator\", args: '{\"a\": 1' }\n * // ]\n * ```\n */\nexport function convertToV1FromResponsesChunk(\n  message: AIMessageChunk\n): Array<ContentBlock.Standard> {\n  function* iterateContent(): Iterable<ContentBlock.Standard> {\n    yield* convertToV1FromResponses(message);\n    for (const toolCallChunk of message.tool_call_chunks ?? []) {\n      yield {\n        type: \"tool_call_chunk\",\n        id: toolCallChunk.id,\n        name: toolCallChunk.name,\n        args: toolCallChunk.args,\n      };\n    }\n  }\n  return Array.from(iterateContent());\n}\n\nexport const ChatOpenAITranslator: StandardContentBlockTranslator = {\n  translateContent: (message) => {\n    if (typeof message.content === \"string\") {\n      return convertToV1FromChatCompletions(message);\n    }\n    return convertToV1FromResponses(message);\n  },\n  translateContentChunk: (message) => {\n    if (typeof message.content === \"string\") {\n      return convertToV1FromChatCompletionsChunk(message);\n    }\n    return convertToV1FromResponsesChunk(message);\n  },\n};\n","import { BaseStringPromptTemplate } from \"./string.js\";\nimport type {\n  BasePromptTemplateInput,\n  TypedPromptInputValues,\n  Example,\n} from \"./base.js\";\nimport type { BaseExampleSelector } from \"../example_selectors/base.js\";\nimport {\n  type TemplateFormat,\n  checkValidTemplate,\n  renderTemplate,\n} from \"./template.js\";\nimport { PromptTemplate } from \"./prompt.js\";\nimport type { SerializedFewShotTemplate } from \"./serde.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/index.js\";\nimport {\n  BaseChatPromptTemplate,\n  type BaseMessagePromptTemplate,\n} from \"./chat.js\";\n\nexport interface FewShotPromptTemplateInput\n  extends BasePromptTemplateInput<InputValues> {\n  /**\n   * Examples to format into the prompt. Exactly one of this or\n   * {@link exampleSelector} must be\n   * provided.\n   */\n  examples?: Example[];\n\n  /**\n   * An {@link BaseExampleSelector} Examples to format into the prompt. Exactly one of this or\n   * {@link examples} must be\n   * provided.\n   */\n  exampleSelector?: BaseExampleSelector;\n\n  /**\n   * An {@link PromptTemplate} used to format a single example.\n   */\n  examplePrompt: PromptTemplate;\n\n  /**\n   * String separator used to join the prefix, the examples, and suffix.\n   */\n  exampleSeparator?: string;\n\n  /**\n   * A prompt template string to put before the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  prefix?: string;\n\n  /**\n   * A prompt template string to put after the examples.\n   */\n  suffix?: string;\n\n  /**\n   * The format of the prompt template. Options are: 'f-string'\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization.\n   */\n  validateTemplate?: boolean;\n}\n\n/**\n * Prompt template that contains few-shot examples.\n * @augments BasePromptTemplate\n * @augments FewShotPromptTemplateInput\n * @example\n * ```typescript\n * const examplePrompt = PromptTemplate.fromTemplate(\n *   \"Input: {input}\\nOutput: {output}\",\n * );\n *\n * const exampleSelector = await SemanticSimilarityExampleSelector.fromExamples(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   new OpenAIEmbeddings(),\n *   HNSWLib,\n *   { k: 1 },\n * );\n *\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt,\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n *\n * // Format the dynamic prompt with the input 'rainy'\n * console.log(await dynamicPrompt.format({ adjective: \"rainy\" }));\n *\n * ```\n */\nexport class FewShotPromptTemplate\n  extends BaseStringPromptTemplate\n  implements FewShotPromptTemplateInput\n{\n  lc_serializable = false;\n\n  examples?: InputValues[];\n\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  examplePrompt: PromptTemplate;\n\n  suffix = \"\";\n\n  exampleSeparator = \"\\n\\n\";\n\n  prefix = \"\";\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  constructor(input: FewShotPromptTemplateInput) {\n    super(input);\n    Object.assign(this, input);\n\n    if (this.examples !== undefined && this.exampleSelector !== undefined) {\n      throw new Error(\n        \"Only one of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.examples === undefined && this.exampleSelector === undefined) {\n      throw new Error(\n        \"One of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.prefix + this.suffix,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  _getPromptType(): \"few_shot\" {\n    return \"few_shot\";\n  }\n\n  static lc_name() {\n    return \"FewShotPromptTemplate\";\n  }\n\n  private async getExamples(\n    inputVariables: InputValues\n  ): Promise<InputValues[]> {\n    if (this.examples !== undefined) {\n      return this.examples;\n    }\n    if (this.exampleSelector !== undefined) {\n      return this.exampleSelector.selectExamples(inputVariables);\n    }\n\n    throw new Error(\n      \"One of 'examples' and 'example_selector' should be provided\"\n    );\n  }\n\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new FewShotPromptTemplate(promptDict);\n  }\n\n  /**\n   * Formats the prompt with the given values.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async format(values: InputValues): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    const examples = await this.getExamples(allValues);\n\n    const exampleStrings = await Promise.all(\n      examples.map((example) => this.examplePrompt.format(example))\n    );\n    const template = [this.prefix, ...exampleStrings, this.suffix].join(\n      this.exampleSeparator\n    );\n    return renderTemplate(template, this.templateFormat, allValues);\n  }\n\n  serialize(): SerializedFewShotTemplate {\n    if (this.exampleSelector || !this.examples) {\n      throw new Error(\n        \"Serializing an example selector is not currently supported\"\n      );\n    }\n    if (this.outputParser !== undefined) {\n      throw new Error(\n        \"Serializing an output parser is not currently supported\"\n      );\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      example_prompt: this.examplePrompt.serialize(),\n      example_separator: this.exampleSeparator,\n      suffix: this.suffix,\n      prefix: this.prefix,\n      template_format: this.templateFormat,\n      examples: this.examples,\n    };\n  }\n\n  static async deserialize(\n    data: SerializedFewShotTemplate\n  ): Promise<FewShotPromptTemplate> {\n    const { example_prompt } = data;\n    if (!example_prompt) {\n      throw new Error(\"Missing example prompt\");\n    }\n    const examplePrompt = await PromptTemplate.deserialize(example_prompt);\n\n    let examples: Example[];\n\n    if (Array.isArray(data.examples)) {\n      examples = data.examples;\n    } else {\n      throw new Error(\n        \"Invalid examples format. Only list or string are supported.\"\n      );\n    }\n\n    return new FewShotPromptTemplate({\n      inputVariables: data.input_variables,\n      examplePrompt,\n      examples,\n      exampleSeparator: data.example_separator,\n      prefix: data.prefix,\n      suffix: data.suffix,\n      templateFormat: data.template_format,\n    });\n  }\n}\n\nexport interface FewShotChatMessagePromptTemplateInput\n  extends BasePromptTemplateInput<InputValues> {\n  /**\n   * Examples to format into the prompt. Exactly one of this or\n   * {@link exampleSelector} must be\n   * provided.\n   */\n  examples?: Example[];\n\n  /**\n   * An {@link BaseMessagePromptTemplate} | {@link BaseChatPromptTemplate} used to format a single example.\n   */\n  examplePrompt: BaseMessagePromptTemplate | BaseChatPromptTemplate;\n\n  /**\n   * String separator used to join the prefix, the examples, and suffix.\n   *\n   * @defaultValue `\"\\n\\n\"`\n   */\n  exampleSeparator?: string;\n\n  /**\n   * An {@link BaseExampleSelector} Examples to format into the prompt. Exactly one of this or\n   * {@link examples} must be\n   * provided.\n   */\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  /**\n   * A prompt template string to put before the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  prefix?: string;\n\n  /**\n   * A prompt template string to put after the examples.\n   *\n   * @defaultValue `\"\"`\n   */\n  suffix?: string;\n\n  /**\n   * The format of the prompt template. Options are: 'f-string'\n   *\n   * @defaultValue `f-string`\n   */\n  templateFormat?: TemplateFormat;\n\n  /**\n   * Whether or not to try validating the template on initialization.\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n}\n\n/**\n * Chat prompt template that contains few-shot examples.\n * @augments BasePromptTemplateInput\n * @augments FewShotChatMessagePromptTemplateInput\n */\nexport class FewShotChatMessagePromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends BaseChatPromptTemplate\n  implements FewShotChatMessagePromptTemplateInput\n{\n  lc_serializable = true;\n\n  examples?: InputValues[];\n\n  exampleSelector?: BaseExampleSelector | undefined;\n\n  examplePrompt: BaseMessagePromptTemplate | BaseChatPromptTemplate;\n\n  suffix = \"\";\n\n  exampleSeparator = \"\\n\\n\";\n\n  prefix = \"\";\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  validateTemplate = true;\n\n  _getPromptType(): \"few_shot_chat\" {\n    return \"few_shot_chat\";\n  }\n\n  static lc_name() {\n    return \"FewShotChatMessagePromptTemplate\";\n  }\n\n  constructor(fields: FewShotChatMessagePromptTemplateInput) {\n    super(fields);\n\n    this.examples = fields.examples;\n    this.examplePrompt = fields.examplePrompt;\n    this.exampleSeparator = fields.exampleSeparator ?? \"\\n\\n\";\n    this.exampleSelector = fields.exampleSelector;\n    this.prefix = fields.prefix ?? \"\";\n    this.suffix = fields.suffix ?? \"\";\n    this.templateFormat = fields.templateFormat ?? \"f-string\";\n    this.validateTemplate = fields.validateTemplate ?? true;\n\n    if (this.examples !== undefined && this.exampleSelector !== undefined) {\n      throw new Error(\n        \"Only one of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.examples === undefined && this.exampleSelector === undefined) {\n      throw new Error(\n        \"One of 'examples' and 'example_selector' should be provided\"\n      );\n    }\n\n    if (this.validateTemplate) {\n      let totalInputVariables: string[] = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(\n          Object.keys(this.partialVariables)\n        );\n      }\n      checkValidTemplate(\n        this.prefix + this.suffix,\n        this.templateFormat,\n        totalInputVariables\n      );\n    }\n  }\n\n  private async getExamples(\n    inputVariables: InputValues\n  ): Promise<InputValues[]> {\n    if (this.examples !== undefined) {\n      return this.examples;\n    }\n    if (this.exampleSelector !== undefined) {\n      return this.exampleSelector.selectExamples(inputVariables);\n    }\n\n    throw new Error(\n      \"One of 'examples' and 'example_selector' should be provided\"\n    );\n  }\n\n  /**\n   * Formats the list of values and returns a list of formatted messages.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    let examples = await this.getExamples(allValues);\n\n    examples = examples.map((example) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const result: Record<string, any> = {};\n      this.examplePrompt.inputVariables.forEach((inputVariable) => {\n        result[inputVariable] = example[inputVariable];\n      });\n      return result;\n    });\n\n    const messages: BaseMessage[] = [];\n    for (const example of examples) {\n      const exampleMessages = await this.examplePrompt.formatMessages(example);\n      messages.push(...exampleMessages);\n    }\n    return messages;\n  }\n\n  /**\n   * Formats the prompt with the given values.\n   * @param values The values to format the prompt with.\n   * @returns A promise that resolves to a string representing the formatted prompt.\n   */\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    const examples = await this.getExamples(allValues);\n    const exampleMessages = await Promise.all(\n      examples.map((example) => this.examplePrompt.formatMessages(example))\n    );\n    const exampleStrings = exampleMessages\n      .flat()\n      .map((message) => message.content);\n    const template = [this.prefix, ...exampleStrings, this.suffix].join(\n      this.exampleSeparator\n    );\n    return renderTemplate(template, this.templateFormat, allValues);\n  }\n\n  /**\n   * Partially formats the prompt with the given values.\n   * @param values The values to partially format the prompt with.\n   * @returns A promise that resolves to an instance of `FewShotChatMessagePromptTemplate` with the given values partially formatted.\n   */\n  async partial(\n    values: PartialValues<PartialVariableName>\n  ): Promise<FewShotChatMessagePromptTemplate<RunInput, PartialVariableName>> {\n    const newInputVariables = this.inputVariables.filter(\n      (variable) => !(variable in values)\n    ) as Exclude<Extract<keyof RunInput, string>, PartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | PartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new FewShotChatMessagePromptTemplate<\n      InputValues<Exclude<Extract<keyof RunInput, string>, PartialVariableName>>\n    >(promptDict);\n  }\n}\n","import { RunnableConfig } from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { BaseStore } from \"@langchain/langgraph-checkpoint\";\nimport { LangGraphRunnableConfig } from \"../runnable_types.js\";\nimport {\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_SCRATCHPAD,\n} from \"../../constants.js\";\n\nconst COPIABLE_KEYS = [\"tags\", \"metadata\", \"callbacks\", \"configurable\"];\n\nconst CONFIG_KEYS = [\n  \"tags\",\n  \"metadata\",\n  \"callbacks\",\n  \"runName\",\n  \"maxConcurrency\",\n  \"recursionLimit\",\n  \"configurable\",\n  \"runId\",\n  \"outputKeys\",\n  \"streamMode\",\n  \"store\",\n  \"writer\",\n  \"interrupt\",\n  \"context\",\n  \"interruptBefore\",\n  \"interruptAfter\",\n  \"checkpointDuring\",\n  \"durability\",\n  \"signal\",\n];\n\nconst DEFAULT_RECURSION_LIMIT = 25;\n\nexport function ensureLangGraphConfig(\n  ...configs: (LangGraphRunnableConfig | undefined)[]\n): RunnableConfig {\n  const empty: LangGraphRunnableConfig = {\n    tags: [],\n    metadata: {},\n    callbacks: undefined,\n    recursionLimit: DEFAULT_RECURSION_LIMIT,\n    configurable: {},\n  };\n\n  const implicitConfig: RunnableConfig =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  if (implicitConfig !== undefined) {\n    for (const [k, v] of Object.entries(implicitConfig)) {\n      if (v !== undefined) {\n        if (COPIABLE_KEYS.includes(k)) {\n          let copiedValue;\n          if (Array.isArray(v)) {\n            copiedValue = [...v];\n          } else if (typeof v === \"object\") {\n            if (\n              k === \"callbacks\" &&\n              \"copy\" in v &&\n              typeof v.copy === \"function\"\n            ) {\n              copiedValue = v.copy();\n            } else {\n              copiedValue = { ...v };\n            }\n          } else {\n            copiedValue = v;\n          }\n          empty[k as keyof RunnableConfig] = copiedValue;\n        } else {\n          empty[k as keyof RunnableConfig] = v;\n        }\n      }\n    }\n  }\n\n  for (const config of configs) {\n    if (config === undefined) {\n      continue;\n    }\n\n    for (const [k, v] of Object.entries(config)) {\n      if (v !== undefined && CONFIG_KEYS.includes(k)) {\n        empty[k as keyof LangGraphRunnableConfig] = v;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(empty.configurable!)) {\n    empty.metadata = empty.metadata ?? {};\n    if (\n      !key.startsWith(\"__\") &&\n      (typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\") &&\n      !(key in empty.metadata!)\n    ) {\n      empty.metadata[key] = value;\n    }\n  }\n\n  return empty;\n}\n\n/**\n * A helper utility function that returns the {@link BaseStore} that was set when the graph was initialized\n *\n * @returns a reference to the {@link BaseStore} that was set when the graph was initialized\n */\nexport function getStore(\n  config?: LangGraphRunnableConfig\n): BaseStore | undefined {\n  const runConfig: LangGraphRunnableConfig =\n    config ?? AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\n  if (runConfig === undefined) {\n    throw new Error(\n      [\n        \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n        \"If you're running `getStore` in such environment, pass the `config` from the node function directly.\",\n      ].join(\"\\n\")\n    );\n  }\n\n  return runConfig?.store;\n}\n\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined.\n *\n * @returns a reference to the {@link LangGraphRunnableConfig#writer} if \"custom\" stream mode is enabled, otherwise undefined\n */\nexport function getWriter(\n  config?: LangGraphRunnableConfig\n): ((chunk: unknown) => void) | undefined {\n  const runConfig: LangGraphRunnableConfig =\n    config ?? AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\n  if (runConfig === undefined) {\n    throw new Error(\n      [\n        \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n        \"If you're running `getWriter` in such environment, pass the `config` from the node function directly.\",\n      ].join(\"\\n\")\n    );\n  }\n\n  return runConfig?.writer || runConfig?.configurable?.writer;\n}\n\n/**\n * A helper utility function that returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized.\n *\n * Note: This only works when running in an environment that supports node:async_hooks and AsyncLocalStorage. If you're running this in a\n * web environment, access the LangGraphRunnableConfig from the node function directly.\n *\n * @returns the {@link LangGraphRunnableConfig} that was set when the graph was initialized\n */\nexport function getConfig(): LangGraphRunnableConfig {\n  return AsyncLocalStorageProviderSingleton.getRunnableConfig();\n}\n\n/**\n * A helper utility function that returns the input for the currently executing task\n *\n * @returns the input for the currently executing task\n */\nexport function getCurrentTaskInput<T = unknown>(\n  config?: LangGraphRunnableConfig\n): T {\n  const runConfig: LangGraphRunnableConfig =\n    config ?? AsyncLocalStorageProviderSingleton.getRunnableConfig();\n\n  if (runConfig === undefined) {\n    throw new Error(\n      [\n        \"Config not retrievable. This is likely because you are running in an environment without support for AsyncLocalStorage.\",\n        \"If you're running `getCurrentTaskInput` in such environment, pass the `config` from the node function directly.\",\n      ].join(\"\\n\")\n    );\n  }\n\n  if (\n    runConfig.configurable?.[CONFIG_KEY_SCRATCHPAD]?.currentTaskInput ===\n    undefined\n  ) {\n    throw new Error(\"BUG: internal scratchpad not initialized.\");\n  }\n\n  return runConfig!.configurable![CONFIG_KEY_SCRATCHPAD]!.currentTaskInput as T;\n}\n\nexport function recastCheckpointNamespace(namespace: string): string {\n  return namespace\n    .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n    .filter((part) => !part.match(/^\\d+$/))\n    .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n    .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n}\n\nexport function getParentCheckpointNamespace(namespace: string): string {\n  const parts = namespace.split(CHECKPOINT_NAMESPACE_SEPARATOR);\n  while (parts.length > 1 && parts[parts.length - 1].match(/^\\d+$/)) {\n    parts.pop();\n  }\n  return parts.slice(0, -1).join(CHECKPOINT_NAMESPACE_SEPARATOR);\n}\n","import type {\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\n\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelExecutableTask } from \"./types.js\";\nimport {\n  _isSend,\n  Command,\n  ERROR,\n  INTERRUPT,\n  NULL_TASK_ID,\n  RESUME,\n  RETURN,\n  TAG_HIDDEN,\n  TASKS,\n} from \"../constants.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { isXXH3 } from \"../hash.js\";\n\nexport function readChannel<C extends PropertyKey>(\n  channels: Record<C, BaseChannel>,\n  chan: C,\n  catchErrors: boolean = true,\n  returnException: boolean = false\n): unknown | null {\n  try {\n    return channels[chan].get();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    if (e.name === EmptyChannelError.unminifiable_name) {\n      if (returnException) {\n        return e;\n      } else if (catchErrors) {\n        return null;\n      }\n    }\n    throw e;\n  }\n}\n\nexport function readChannels<C extends PropertyKey>(\n  channels: Record<C, BaseChannel>,\n  select: C | Array<C>,\n  skipEmpty: boolean = true\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> | any {\n  if (Array.isArray(select)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const values = {} as Record<C, any>;\n    for (const k of select) {\n      try {\n        values[k] = readChannel(channels, k, !skipEmpty);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        }\n      }\n    }\n    return values;\n  } else {\n    return readChannel(channels, select);\n  }\n}\n\n/**\n * Map input chunk to a sequence of pending writes in the form (channel, value).\n */\nexport function* mapCommand(\n  cmd: Command,\n  pendingWrites: CheckpointPendingWrite[]\n): Generator<[string, string, unknown]> {\n  if (cmd.graph === Command.PARENT) {\n    throw new InvalidUpdateError(\"There is no parent graph.\");\n  }\n  if (cmd.goto) {\n    let sends;\n    if (Array.isArray(cmd.goto)) {\n      sends = cmd.goto;\n    } else {\n      sends = [cmd.goto];\n    }\n    for (const send of sends) {\n      if (_isSend(send)) {\n        yield [NULL_TASK_ID, TASKS, send];\n      } else if (typeof send === \"string\") {\n        yield [NULL_TASK_ID, `branch:to:${send}`, \"__start__\"];\n      } else {\n        throw new Error(\n          `In Command.send, expected Send or string, got ${typeof send}`\n        );\n      }\n    }\n  }\n  if (cmd.resume) {\n    if (\n      typeof cmd.resume === \"object\" &&\n      Object.keys(cmd.resume).length &&\n      Object.keys(cmd.resume).every(isXXH3)\n    ) {\n      for (const [tid, resume] of Object.entries(cmd.resume)) {\n        const existing =\n          pendingWrites\n            .filter((w) => w[0] === tid && w[1] === RESUME)\n            .map((w) => w[2])\n            .slice(0, 1) ?? [];\n        existing.push(resume);\n        yield [tid, RESUME, existing];\n      }\n    } else {\n      yield [NULL_TASK_ID, RESUME, cmd.resume];\n    }\n  }\n  if (cmd.update) {\n    if (typeof cmd.update !== \"object\" || !cmd.update) {\n      throw new Error(\n        \"Expected cmd.update to be a dict mapping channel names to update values\"\n      );\n    }\n\n    if (Array.isArray(cmd.update)) {\n      for (const [k, v] of cmd.update) {\n        yield [NULL_TASK_ID, k, v];\n      }\n    } else {\n      for (const [k, v] of Object.entries(cmd.update)) {\n        yield [NULL_TASK_ID, k, v];\n      }\n    }\n  }\n}\n\n/**\n * Map input chunk to a sequence of pending writes in the form [channel, value].\n */\nexport function* mapInput<C extends PropertyKey>(\n  inputChannels: C | Array<C>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<[C, any]> {\n  if (chunk !== undefined && chunk !== null) {\n    if (\n      Array.isArray(inputChannels) &&\n      typeof chunk === \"object\" &&\n      !Array.isArray(chunk)\n    ) {\n      for (const k in chunk) {\n        if (inputChannels.includes(k as C)) {\n          yield [k as C, chunk[k]];\n        }\n      }\n    } else if (Array.isArray(inputChannels)) {\n      throw new Error(\n        `Input chunk must be an object when \"inputChannels\" is an array`\n      );\n    } else {\n      yield [inputChannels, chunk];\n    }\n  }\n}\n\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n */\nexport function* mapOutputValues<C extends PropertyKey>(\n  outputChannels: C | Array<C>,\n  pendingWrites: readonly PendingWrite<C>[] | true,\n  channels: Record<C, BaseChannel>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<Record<string, any>, any> {\n  if (Array.isArray(outputChannels)) {\n    if (\n      pendingWrites === true ||\n      pendingWrites.find(([chan, _]) => outputChannels.includes(chan))\n    ) {\n      yield readChannels(channels, outputChannels);\n    }\n  } else {\n    if (\n      pendingWrites === true ||\n      pendingWrites.some(([chan, _]) => chan === outputChannels)\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      yield readChannel(channels, outputChannels) as any;\n    }\n  }\n}\n\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n * @internal\n *\n * @param outputChannels - The channels to output.\n * @param tasks - The tasks to output.\n * @param cached - Whether the output is cached.\n *\n * @returns A generator that yields the output chunk (if any).\n */\nexport function* mapOutputUpdates<N extends PropertyKey, C extends PropertyKey>(\n  outputChannels: C | Array<C>,\n  tasks: readonly [PregelExecutableTask<N, C>, PendingWrite<C>[]][],\n  cached?: boolean\n): Generator<Record<N, Record<string, unknown> | unknown>> {\n  const outputTasks = tasks.filter(([task, ww]) => {\n    return (\n      (task.config === undefined || !task.config.tags?.includes(TAG_HIDDEN)) &&\n      ww[0][0] !== ERROR &&\n      ww[0][0] !== INTERRUPT\n    );\n  });\n  if (!outputTasks.length) {\n    return;\n  }\n\n  let updated: [N, Record<string, unknown>][];\n\n  if (\n    outputTasks.some(([task]) =>\n      task.writes.some(([chan, _]) => chan === RETURN)\n    )\n  ) {\n    // TODO: probably should assert that RETURN is the only \"non-special\" channel (starts with \"__\")\n    updated = outputTasks.flatMap(([task]) =>\n      task.writes\n        .filter(([chan, _]) => chan === RETURN)\n        .map(([_, value]) => [task.name, value] as [N, Record<string, unknown>])\n    );\n  } else if (!Array.isArray(outputChannels)) {\n    // special case where graph state is a single channel (MessageGraph)\n    // probably using this in functional API, too\n    updated = outputTasks.flatMap(([task]) =>\n      task.writes\n        .filter(([chan, _]) => chan === outputChannels)\n        .map(([_, value]) => [task.name, value] as [N, Record<string, unknown>])\n    );\n  } else {\n    updated = outputTasks.flatMap(([task]) => {\n      const { writes } = task;\n      const counts: Record<C, number> = {} as Record<C, number>;\n      for (const [chan] of writes) {\n        if (outputChannels.includes(chan)) {\n          counts[chan] = (counts[chan] || 0) + 1;\n        }\n      }\n\n      if ((Object.values(counts) as number[]).some((count) => count > 1)) {\n        // Multiple writes to the same channel: create separate entries\n        return writes\n          .filter(([chan]) => outputChannels.includes(chan))\n          .map(\n            ([chan, value]) =>\n              [task.name, { [chan]: value }] as [N, Record<string, unknown>]\n          );\n      } else {\n        // Single write to each channel: create a single combined entry\n        return [\n          [\n            task.name,\n            Object.fromEntries(\n              writes.filter(([chan]) => outputChannels.includes(chan))\n            ),\n          ] as [N, Record<string, unknown>],\n        ];\n      }\n    });\n  }\n\n  const grouped = {} as Record<N, unknown[]>;\n\n  for (const [node, value] of updated) {\n    if (!(node in grouped)) {\n      grouped[node] = [];\n    }\n    grouped[node].push(value);\n  }\n\n  const flattened = {} as Record<N, unknown>;\n  for (const node in grouped) {\n    if (grouped[node].length === 1) {\n      const [write] = grouped[node];\n      flattened[node] = write;\n    } else {\n      flattened[node] = grouped[node];\n    }\n  }\n\n  if (cached) {\n    flattened[\"__metadata__\" as N] = { cached };\n  }\n  yield flattened;\n}\n\nexport function single<T>(iter: IterableIterator<T>): T | null {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const value of iter) {\n    return value;\n  }\n  return null;\n}\n","import {\n  BaseStore,\n  type OperationResults,\n  type Item,\n  type Operation,\n  MatchCondition,\n  ListNamespacesOperation,\n  PutOperation,\n  SearchOperation,\n  GetOperation,\n  type IndexConfig,\n  type SearchItem,\n} from \"./base.js\";\nimport { tokenizePath, compareValues, getTextAtPath } from \"./utils.js\";\n\n/**\n * In-memory key-value store with optional vector search.\n *\n * A lightweight store implementation using JavaScript Maps. Supports basic\n * key-value operations and vector search when configured with embeddings.\n *\n * @example\n * ```typescript\n * // Basic key-value storage\n * const store = new InMemoryStore();\n * await store.put([\"users\", \"123\"], \"prefs\", { theme: \"dark\" });\n * const item = await store.get([\"users\", \"123\"], \"prefs\");\n *\n * // Vector search with embeddings\n * import { OpenAIEmbeddings } from \"@langchain/openai\";\n * const store = new InMemoryStore({\n *   index: {\n *     dims: 1536,\n *     embeddings: new OpenAIEmbeddings({ modelName: \"text-embedding-3-small\" }),\n *   }\n * });\n *\n * // Store documents\n * await store.put([\"docs\"], \"doc1\", { text: \"Python tutorial\" });\n * await store.put([\"docs\"], \"doc2\", { text: \"TypeScript guide\" });\n *\n * // Search by similarity\n * const results = await store.search([\"docs\"], { query: \"python programming\" });\n * ```\n *\n * **Warning**: This store keeps all data in memory. Data is lost when the process exits.\n * For persistence, use a database-backed store.\n */\nexport class InMemoryStore extends BaseStore {\n  private data: Map<string, Map<string, Item>> = new Map();\n\n  // Namespace -> Key -> Path/field -> Vector\n  private vectors: Map<string, Map<string, Map<string, number[]>>> = new Map();\n\n  private _indexConfig?: IndexConfig & {\n    __tokenizedFields: Array<[string, string[]]>;\n  };\n\n  constructor(options?: { index?: IndexConfig }) {\n    super();\n    if (options?.index) {\n      this._indexConfig = {\n        ...options.index,\n        __tokenizedFields: (options.index.fields ?? [\"$\"]).map((p) => [\n          p,\n          p === \"$\" ? [p] : tokenizePath(p),\n        ]),\n      };\n    }\n  }\n\n  async batch<Op extends readonly Operation[]>(\n    operations: Op\n  ): Promise<OperationResults<Op>> {\n    const results = [];\n    const putOps = new Map<string, PutOperation>();\n    const searchOps = new Map<number, [SearchOperation, Item[]]>();\n\n    // First pass - handle gets and prepare search/put operations\n    for (let i = 0; i < operations.length; i += 1) {\n      const op = operations[i];\n      if (\"key\" in op && \"namespace\" in op && !(\"value\" in op)) {\n        // GetOperation\n        results.push(this.getOperation(op));\n      } else if (\"namespacePrefix\" in op) {\n        // SearchOperation\n        const candidates = this.filterItems(op);\n        searchOps.set(i, [op, candidates]);\n        results.push(null);\n      } else if (\"value\" in op) {\n        // PutOperation\n        const key = `${op.namespace.join(\":\")}:${op.key}`;\n        putOps.set(key, op);\n        results.push(null);\n      } else if (\"matchConditions\" in op) {\n        // ListNamespacesOperation\n        results.push(this.listNamespacesOperation(op));\n      }\n    }\n\n    // Handle search operations with embeddings\n    if (searchOps.size > 0) {\n      if (this._indexConfig?.embeddings) {\n        const queries = new Set<string>();\n        for (const [op] of searchOps.values()) {\n          if (op.query) queries.add(op.query);\n        }\n\n        // Get embeddings for all queries\n        const queryEmbeddings =\n          queries.size > 0\n            ? await Promise.all(\n                Array.from(queries).map((q) =>\n                  this._indexConfig!.embeddings.embedQuery(q)\n                )\n              )\n            : [];\n        const queryVectors = Object.fromEntries(\n          Array.from(queries).map((q, i) => [q, queryEmbeddings[i]])\n        );\n\n        // Process each search operation\n        for (const [i, [op, candidates]] of searchOps.entries()) {\n          if (op.query && queryVectors[op.query]) {\n            const queryVector = queryVectors[op.query];\n            const scoredResults = this.scoreResults(\n              candidates,\n              queryVector,\n              op.offset ?? 0,\n              op.limit ?? 10\n            );\n            results[i] = scoredResults;\n          } else {\n            results[i] = this.paginateResults(\n              candidates.map((item) => ({ ...item, score: undefined })),\n              op.offset ?? 0,\n              op.limit ?? 10\n            );\n          }\n        }\n      } else {\n        // No embeddings - just paginate the filtered results\n        for (const [i, [op, candidates]] of searchOps.entries()) {\n          results[i] = this.paginateResults(\n            candidates.map((item) => ({ ...item, score: undefined })),\n            op.offset ?? 0,\n            op.limit ?? 10\n          );\n        }\n      }\n    }\n\n    // Handle put operations with embeddings\n    if (putOps.size > 0 && this._indexConfig?.embeddings) {\n      const toEmbed = this.extractTexts(Array.from(putOps.values()));\n      if (Object.keys(toEmbed).length > 0) {\n        const embeddings = await this._indexConfig.embeddings.embedDocuments(\n          Object.keys(toEmbed)\n        );\n        this.insertVectors(toEmbed, embeddings);\n      }\n    }\n\n    // Apply all put operations\n    for (const op of putOps.values()) {\n      this.putOperation(op);\n    }\n\n    return results as OperationResults<Op>;\n  }\n\n  private getOperation(op: GetOperation): Item | null {\n    const namespaceKey = op.namespace.join(\":\");\n    const item = this.data.get(namespaceKey)?.get(op.key);\n    return item ?? null;\n  }\n\n  private putOperation(op: PutOperation): void {\n    const namespaceKey = op.namespace.join(\":\");\n    if (!this.data.has(namespaceKey)) {\n      this.data.set(namespaceKey, new Map());\n    }\n    const namespaceMap = this.data.get(namespaceKey)!;\n\n    if (op.value === null) {\n      namespaceMap.delete(op.key);\n    } else {\n      const now = new Date();\n      if (namespaceMap.has(op.key)) {\n        const item = namespaceMap.get(op.key)!;\n        item.value = op.value;\n        item.updatedAt = now;\n      } else {\n        namespaceMap.set(op.key, {\n          value: op.value,\n          key: op.key,\n          namespace: op.namespace,\n          createdAt: now,\n          updatedAt: now,\n        });\n      }\n    }\n  }\n\n  private listNamespacesOperation(op: ListNamespacesOperation): string[][] {\n    const allNamespaces = Array.from(this.data.keys()).map((ns) =>\n      ns.split(\":\")\n    );\n    let namespaces = allNamespaces;\n\n    if (op.matchConditions && op.matchConditions.length > 0) {\n      namespaces = namespaces.filter((ns) =>\n        op.matchConditions!.every((condition) => this.doesMatch(condition, ns))\n      );\n    }\n\n    if (op.maxDepth !== undefined) {\n      namespaces = Array.from(\n        new Set(namespaces.map((ns) => ns.slice(0, op.maxDepth).join(\":\")))\n      ).map((ns) => ns.split(\":\"));\n    }\n\n    namespaces.sort((a, b) => a.join(\":\").localeCompare(b.join(\":\")));\n\n    return namespaces.slice(\n      op.offset ?? 0,\n      (op.offset ?? 0) + (op.limit ?? namespaces.length)\n    );\n  }\n\n  private doesMatch(matchCondition: MatchCondition, key: string[]): boolean {\n    const { matchType, path } = matchCondition;\n\n    if (matchType === \"prefix\") {\n      if (path.length > key.length) return false;\n      return path.every((pElem, index) => {\n        const kElem = key[index];\n        return pElem === \"*\" || kElem === pElem;\n      });\n    } else if (matchType === \"suffix\") {\n      if (path.length > key.length) return false;\n      return path.every((pElem, index) => {\n        const kElem = key[key.length - path.length + index];\n        return pElem === \"*\" || kElem === pElem;\n      });\n    }\n\n    throw new Error(`Unsupported match type: ${matchType}`);\n  }\n\n  private filterItems(op: SearchOperation): Item[] {\n    const candidates: Item[] = [];\n    for (const [namespace, items] of this.data.entries()) {\n      if (namespace.startsWith(op.namespacePrefix.join(\":\"))) {\n        candidates.push(...items.values());\n      }\n    }\n\n    let filteredCandidates = candidates;\n    if (op.filter) {\n      filteredCandidates = candidates.filter((item) =>\n        Object.entries(op.filter!).every(([key, value]) =>\n          compareValues(item.value[key], value)\n        )\n      );\n    }\n    return filteredCandidates;\n  }\n\n  private scoreResults(\n    candidates: Item[],\n    queryVector: number[],\n    offset: number = 0,\n    limit: number = 10\n  ): SearchItem[] {\n    const flatItems: Item[] = [];\n    const flatVectors: number[][] = [];\n    const scoreless: Item[] = [];\n\n    for (const item of candidates) {\n      const vectors = this.getVectors(item);\n      if (vectors.length) {\n        for (const vector of vectors) {\n          flatItems.push(item);\n          flatVectors.push(vector);\n        }\n      } else {\n        scoreless.push(item);\n      }\n    }\n\n    const scores = this.cosineSimilarity(queryVector, flatVectors);\n\n    const sortedResults = scores\n      .map((score, i) => [score, flatItems[i]] as [number, Item])\n      .sort((a, b) => b[0] - a[0]);\n\n    const seen = new Set<string>();\n    const kept: Array<[number | undefined, Item]> = [];\n\n    for (const [score, item] of sortedResults) {\n      const key = `${item.namespace.join(\":\")}:${item.key}`;\n      if (seen.has(key)) continue;\n\n      const ix = seen.size;\n      if (ix >= offset + limit) break;\n      if (ix < offset) {\n        seen.add(key);\n        continue;\n      }\n\n      seen.add(key);\n      kept.push([score, item]);\n    }\n\n    if (scoreless.length && kept.length < limit) {\n      for (const item of scoreless.slice(0, limit - kept.length)) {\n        const key = `${item.namespace.join(\":\")}:${item.key}`;\n        if (!seen.has(key)) {\n          seen.add(key);\n          kept.push([undefined, item]);\n        }\n      }\n    }\n    return kept.map(([score, item]) => ({\n      ...item,\n      score,\n    }));\n  }\n\n  private paginateResults(\n    results: SearchItem[],\n    offset: number,\n    limit: number\n  ): SearchItem[] {\n    return results.slice(offset, offset + limit);\n  }\n\n  private extractTexts(ops: PutOperation[]): {\n    [text: string]: [string[], string, string][];\n  } {\n    if (!ops.length || !this._indexConfig) {\n      return {};\n    }\n\n    const toEmbed: { [text: string]: [string[], string, string][] } = {};\n\n    for (const op of ops) {\n      if (op.value !== null && op.index !== false) {\n        const paths =\n          op.index === null || op.index === undefined\n            ? this._indexConfig.__tokenizedFields ?? []\n            : op.index.map(\n                (ix) => [ix, tokenizePath(ix)] as [string, string[]]\n              );\n        for (const [path, field] of paths) {\n          const texts = getTextAtPath(op.value, field);\n          if (texts.length) {\n            if (texts.length > 1) {\n              texts.forEach((text, i) => {\n                if (!toEmbed[text]) toEmbed[text] = [];\n                toEmbed[text].push([op.namespace, op.key, `${path}.${i}`]);\n              });\n            } else {\n              if (!toEmbed[texts[0]]) toEmbed[texts[0]] = [];\n              toEmbed[texts[0]].push([op.namespace, op.key, path]);\n            }\n          }\n        }\n      }\n    }\n\n    return toEmbed;\n  }\n\n  private insertVectors(\n    texts: { [text: string]: [string[], string, string][] },\n    embeddings: number[][]\n  ): void {\n    for (const [text, metadata] of Object.entries(texts)) {\n      const embedding = embeddings.shift();\n      if (!embedding) {\n        throw new Error(`No embedding found for text: ${text}`);\n      }\n\n      for (const [namespace, key, field] of metadata) {\n        const namespaceKey = namespace.join(\":\");\n        if (!this.vectors.has(namespaceKey)) {\n          this.vectors.set(namespaceKey, new Map());\n        }\n        const namespaceMap = this.vectors.get(namespaceKey)!;\n        if (!namespaceMap.has(key)) {\n          namespaceMap.set(key, new Map());\n        }\n        const itemMap = namespaceMap.get(key)!;\n        itemMap.set(field, embedding);\n      }\n    }\n  }\n\n  private getVectors(item: Item): number[][] {\n    const namespaceKey = item.namespace.join(\":\");\n    const itemKey = item.key;\n    if (!this.vectors.has(namespaceKey)) {\n      return [];\n    }\n    const namespaceMap = this.vectors.get(namespaceKey)!;\n    if (!namespaceMap.has(itemKey)) {\n      return [];\n    }\n    const itemMap = namespaceMap.get(itemKey)!;\n    const vectors = Array.from(itemMap.values());\n    if (!vectors.length) {\n      return [];\n    }\n    return vectors;\n  }\n\n  private cosineSimilarity(X: number[], Y: number[][]): number[] {\n    if (!Y.length) return [];\n\n    // Calculate dot products for all vectors at once\n    const dotProducts = Y.map((vector) =>\n      vector.reduce((acc, val, i) => acc + val * X[i], 0)\n    );\n\n    // Calculate magnitudes\n    const magnitude1 = Math.sqrt(X.reduce((acc, val) => acc + val * val, 0));\n    const magnitudes2 = Y.map((vector) =>\n      Math.sqrt(vector.reduce((acc, val) => acc + val * val, 0))\n    );\n\n    // Calculate similarities\n    return dotProducts.map((dot, i) => {\n      const magnitude2 = magnitudes2[i];\n      return magnitude1 && magnitude2 ? dot / (magnitude1 * magnitude2) : 0;\n    });\n  }\n\n  public get indexConfig(): IndexConfig | undefined {\n    return this._indexConfig;\n  }\n}\n\n/** @deprecated Alias for InMemoryStore */\nexport class MemoryStore extends InMemoryStore {}\n","import { Serializable } from \"./load/serializable.js\";\nimport { type BaseMessage } from \"./messages/base.js\";\nimport { HumanMessage } from \"./messages/human.js\";\nimport { getBufferString } from \"./messages/utils.js\";\n\nexport interface BasePromptValueInterface extends Serializable {\n  toString(): string;\n\n  toChatMessages(): BaseMessage[];\n}\n\nexport interface StringPromptValueInterface extends BasePromptValueInterface {\n  value: string;\n}\n\nexport interface ChatPromptValueInterface extends BasePromptValueInterface {\n  messages: BaseMessage[];\n}\n\n/**\n * Base PromptValue class. All prompt values should extend this class.\n */\nexport abstract class BasePromptValue\n  extends Serializable\n  implements BasePromptValueInterface\n{\n  abstract toString(): string;\n\n  abstract toChatMessages(): BaseMessage[];\n}\n\n/**\n * Represents a prompt value as a string. It extends the BasePromptValue\n * class and overrides the toString and toChatMessages methods.\n */\nexport class StringPromptValue\n  extends BasePromptValue\n  implements StringPromptValueInterface\n{\n  static lc_name(): string {\n    return \"StringPromptValue\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  value: string;\n\n  constructor(value: string) {\n    super({ value });\n    this.value = value;\n  }\n\n  toString() {\n    return this.value;\n  }\n\n  toChatMessages() {\n    return [new HumanMessage(this.value)];\n  }\n}\n\n/**\n * Interface for the fields of a ChatPromptValue.\n */\nexport interface ChatPromptValueFields {\n  messages: BaseMessage[];\n}\n\n/**\n * Class that represents a chat prompt value. It extends the\n * BasePromptValue and includes an array of BaseMessage instances.\n */\nexport class ChatPromptValue\n  extends BasePromptValue\n  implements ChatPromptValueInterface\n{\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ChatPromptValue\";\n  }\n\n  messages: BaseMessage[];\n\n  constructor(messages: BaseMessage[]);\n\n  constructor(fields: ChatPromptValueFields);\n\n  constructor(fields: BaseMessage[] | ChatPromptValueFields) {\n    if (Array.isArray(fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { messages: fields };\n    }\n\n    super(fields);\n    this.messages = fields.messages;\n  }\n\n  toString() {\n    return getBufferString(this.messages);\n  }\n\n  toChatMessages() {\n    return this.messages;\n  }\n}\n\nexport type ImageContent = {\n  /** Specifies the detail level of the image. */\n  detail?: \"auto\" | \"low\" | \"high\";\n\n  /** Either a URL of the image or the base64 encoded image data. */\n  url: string;\n};\n\nexport interface ImagePromptValueFields {\n  imageUrl: ImageContent;\n}\n\n/**\n * Class that represents an image prompt value. It extends the\n * BasePromptValue and includes an ImageURL instance.\n */\nexport class ImagePromptValue extends BasePromptValue {\n  lc_namespace = [\"langchain_core\", \"prompt_values\"];\n\n  lc_serializable = true;\n\n  static lc_name() {\n    return \"ImagePromptValue\";\n  }\n\n  imageUrl: ImageContent;\n\n  /** @ignore */\n  value: string;\n\n  constructor(fields: ImagePromptValueFields);\n\n  constructor(fields: ImageContent);\n\n  constructor(fields: ImageContent | ImagePromptValueFields) {\n    if (!(\"imageUrl\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { imageUrl: fields };\n    }\n\n    super(fields);\n    this.imageUrl = fields.imageUrl;\n  }\n\n  toString() {\n    return this.imageUrl.url;\n  }\n\n  toChatMessages() {\n    return [\n      new HumanMessage({\n        content: [\n          {\n            type: \"image_url\",\n            image_url: {\n              detail: this.imageUrl.detail,\n              url: this.imageUrl.url,\n            },\n          },\n        ],\n      }),\n    ];\n  }\n}\n","import { PendingWrite } from \"@langchain/langgraph-checkpoint\";\nimport {\n  Call,\n  PregelAbortSignals,\n  PregelExecutableTask,\n  PregelScratchpad,\n} from \"./types.js\";\nimport {\n  CachePolicy,\n  combineAbortSignals,\n  patchConfigurable,\n  RetryPolicy,\n} from \"./utils/index.js\";\nimport {\n  CONFIG_KEY_SCRATCHPAD,\n  ERROR,\n  INTERRUPT,\n  RESUME,\n  NO_WRITES,\n  TAG_HIDDEN,\n  RETURN,\n  CONFIG_KEY_CALL,\n  CONFIG_KEY_ABORT_SIGNALS,\n} from \"../constants.js\";\nimport { GraphBubbleUp, isGraphBubbleUp, isGraphInterrupt } from \"../errors.js\";\nimport { _runWithRetry, SettledPregelTask } from \"./retry.js\";\nimport { PregelLoop } from \"./loop.js\";\n\nconst PROMISE_ADDED_SYMBOL = Symbol.for(\"promiseAdded\");\n\nfunction createPromiseBarrier() {\n  const barrier: {\n    next: () => void;\n    wait: Promise<unknown>;\n  } = {\n    next: () => void 0,\n    wait: Promise.resolve(PROMISE_ADDED_SYMBOL),\n  };\n\n  function waitHandler(resolve: (value: typeof PROMISE_ADDED_SYMBOL) => void) {\n    barrier.next = () => {\n      barrier.wait = new Promise(waitHandler);\n      resolve(PROMISE_ADDED_SYMBOL);\n    };\n  }\n  barrier.wait = new Promise(waitHandler);\n  return barrier;\n}\n\n/**\n * Options for the {@link PregelRunner#tick} method.\n */\nexport type TickOptions = {\n  /**\n   * The deadline before which all tasks must be completed.\n   */\n  timeout?: number;\n\n  /**\n   * An optional {@link AbortSignal} to cancel processing of tasks.\n   */\n  signal?: AbortSignal;\n\n  /**\n   * The {@link RetryPolicy} to use for the tick.\n   */\n  retryPolicy?: RetryPolicy;\n\n  /**\n   * An optional callback to be called after all task writes are completed.\n   */\n  onStepWrite?: (step: number, writes: PendingWrite[]) => void;\n\n  /**\n   * The maximum number of tasks to execute concurrently.\n   */\n  maxConcurrency?: number;\n};\n\n/**\n * Responsible for handling task execution on each tick of the {@link PregelLoop}.\n */\nexport class PregelRunner {\n  private nodeFinished?: (id: string) => void;\n\n  private loop: PregelLoop;\n\n  /**\n   * Construct a new PregelRunner, which executes tasks from the provided PregelLoop.\n   * @param loop - The PregelLoop that produces tasks for this runner to execute.\n   */\n  constructor({\n    loop,\n    nodeFinished,\n  }: {\n    loop: PregelLoop;\n    nodeFinished?: (id: string) => void;\n  }) {\n    this.loop = loop;\n    this.nodeFinished = nodeFinished;\n  }\n\n  /**\n   * Execute tasks from the current step of the PregelLoop.\n   *\n   * Note: this method does NOT call {@link PregelLoop}#tick. That must be handled externally.\n   * @param options - Options for the execution.\n   */\n  async tick(options: TickOptions = {}) {\n    const { timeout, retryPolicy, onStepWrite, maxConcurrency } = options;\n\n    const nodeErrors: Set<Error> = new Set();\n    let graphBubbleUp: GraphBubbleUp | undefined;\n\n    const exceptionSignalController = new AbortController();\n    const exceptionSignal = exceptionSignalController.signal;\n    const stepTimeoutSignal = timeout\n      ? AbortSignal.timeout(timeout)\n      : undefined;\n\n    // Start task execution\n    const pendingTasks = Object.values(this.loop.tasks).filter(\n      (t) => t.writes.length === 0\n    );\n\n    const { signals, disposeCombinedSignal } = this._initializeAbortSignals({\n      exceptionSignal,\n      stepTimeoutSignal,\n      signal: options.signal,\n    });\n\n    const taskStream = this._executeTasksWithRetry(pendingTasks, {\n      signals,\n      retryPolicy,\n      maxConcurrency,\n    });\n\n    for await (const { task, error, signalAborted } of taskStream) {\n      this._commit(task, error);\n      if (isGraphInterrupt(error)) {\n        graphBubbleUp = error;\n      } else if (isGraphBubbleUp(error) && !isGraphInterrupt(graphBubbleUp)) {\n        graphBubbleUp = error;\n      } else if (error && (nodeErrors.size === 0 || !signalAborted)) {\n        /*\n         * The goal here is to capture the exception that causes the graph to terminate early. In\n         * theory it's possible for multiple nodes to throw, so this also handles the edge case of\n         * capturing concurrent exceptions thrown before the node saw an abort. This is checked via\n         * the signalAborted flag, which records the state of the abort signal at the time the node\n         * execution finished.\n         *\n         * There is a case however where one node throws some error causing us to trigger an abort,\n         * which then causes other concurrently executing nodes to throw their own AbortErrors. In\n         * this case we don't care about reporting the abort errors thrown by the other nodes,\n         * because they don't tell the user anything about what caused the graph execution to\n         * terminate early, so we ignore them (and any other errors that occur after the node sees\n         * an abort signal).\n         */\n        exceptionSignalController.abort();\n        nodeErrors.add(error);\n      }\n    }\n\n    disposeCombinedSignal?.();\n\n    onStepWrite?.(\n      this.loop.step,\n      Object.values(this.loop.tasks)\n        .map((task) => task.writes)\n        .flat()\n    );\n\n    if (nodeErrors.size === 1) {\n      throw Array.from(nodeErrors)[0];\n    } else if (nodeErrors.size > 1) {\n      throw new AggregateError(\n        Array.from(nodeErrors),\n        `Multiple errors occurred during superstep ${this.loop.step}. See the \"errors\" field of this exception for more details.`\n      );\n    }\n\n    if (isGraphInterrupt(graphBubbleUp)) {\n      throw graphBubbleUp;\n    }\n\n    if (isGraphBubbleUp(graphBubbleUp) && this.loop.isNested) {\n      throw graphBubbleUp;\n    }\n  }\n\n  /**\n   * Initializes the current AbortSignals for the PregelRunner, handling the various ways that\n   * AbortSignals must be chained together so that the PregelLoop can be interrupted if necessary\n   * while still allowing nodes to gracefully exit.\n   *\n   * This method must only be called once per PregelRunner#tick. It has the side effect of updating\n   * the PregelLoop#config with the new AbortSignals so they may be propagated correctly to future\n   * ticks and subgraph calls.\n   *\n   * @param options - Options for the initialization.\n   * @returns The current abort signals.\n   * @internal\n   */\n  private _initializeAbortSignals({\n    exceptionSignal,\n    stepTimeoutSignal,\n    signal,\n  }: {\n    exceptionSignal: AbortSignal;\n    stepTimeoutSignal?: AbortSignal;\n    signal?: AbortSignal;\n  }): { signals: PregelAbortSignals; disposeCombinedSignal?: () => void } {\n    const previousSignals = (this.loop.config.configurable?.[\n      CONFIG_KEY_ABORT_SIGNALS\n    ] ?? {}) as PregelAbortSignals;\n\n    // We always inherit the external abort signal from AsyncLocalStorage,\n    // since that's the only way the signal is inherited by the subgraph calls.\n    const externalAbortSignal = previousSignals.externalAbortSignal ?? signal;\n\n    // inherit the step timeout signal from parent graph\n    const timeoutAbortSignal =\n      stepTimeoutSignal ?? previousSignals.timeoutAbortSignal;\n\n    const { signal: composedAbortSignal, dispose: disposeCombinedSignal } =\n      combineAbortSignals(\n        externalAbortSignal,\n        timeoutAbortSignal,\n        exceptionSignal\n      );\n\n    const signals: PregelAbortSignals = {\n      externalAbortSignal,\n      timeoutAbortSignal,\n      composedAbortSignal,\n    };\n\n    this.loop.config = patchConfigurable(this.loop.config, {\n      [CONFIG_KEY_ABORT_SIGNALS]: signals,\n    });\n\n    return { signals, disposeCombinedSignal };\n  }\n\n  /**\n   * Concurrently executes tasks with the requested retry policy, yielding a {@link SettledPregelTask} for each task as it completes.\n   * @param tasks - The tasks to execute.\n   * @param options - Options for the execution.\n   */\n  private async *_executeTasksWithRetry(\n    tasks: PregelExecutableTask<string, string>[],\n    options?: {\n      signals?: PregelAbortSignals;\n      retryPolicy?: RetryPolicy;\n      maxConcurrency?: number;\n    }\n  ): AsyncGenerator<SettledPregelTask> {\n    const { retryPolicy, maxConcurrency, signals } = options ?? {};\n\n    const barrier = createPromiseBarrier();\n    const executingTasksMap: Record<\n      string,\n      Promise<{\n        task: PregelExecutableTask<string, string>;\n        result?: unknown;\n        error?: Error;\n      }>\n    > = {};\n\n    const thisCall = {\n      executingTasksMap,\n      barrier,\n      retryPolicy,\n      scheduleTask: async (\n        task: PregelExecutableTask<string, string>,\n        writeIdx: number,\n        call?: Call\n      ) => this.loop.acceptPush(task, writeIdx, call),\n    };\n\n    if (signals?.composedAbortSignal?.aborted) {\n      // note: don't use throwIfAborted here because it throws a DOMException,\n      // which isn't consistent with how we throw on abort below.\n      throw new Error(\"Abort\");\n    }\n\n    let startedTasksCount = 0;\n\n    let listener: (() => void) | undefined;\n    const timeoutOrCancelSignal = combineAbortSignals(\n      signals?.externalAbortSignal,\n      signals?.timeoutAbortSignal\n    );\n\n    const abortPromise = timeoutOrCancelSignal.signal\n      ? new Promise<never>((_resolve, reject) => {\n          listener = () => reject(new Error(\"Abort\"));\n          timeoutOrCancelSignal.signal?.addEventListener(\"abort\", listener, {\n            once: true,\n          });\n        })\n      : undefined;\n\n    while (\n      (startedTasksCount === 0 || Object.keys(executingTasksMap).length > 0) &&\n      tasks.length\n    ) {\n      for (\n        ;\n        Object.values(executingTasksMap).length <\n          (maxConcurrency ?? tasks.length) && startedTasksCount < tasks.length;\n        startedTasksCount += 1\n      ) {\n        const task = tasks[startedTasksCount];\n\n        executingTasksMap[task.id] = _runWithRetry(\n          task,\n          retryPolicy,\n          { [CONFIG_KEY_CALL]: call?.bind(thisCall, this, task) },\n          signals?.composedAbortSignal\n        ).catch((error) => {\n          return {\n            task,\n            error,\n            signalAborted: signals?.composedAbortSignal?.aborted,\n          };\n        });\n      }\n\n      const settledTask = await Promise.race([\n        ...Object.values(executingTasksMap),\n        ...(abortPromise ? [abortPromise] : []),\n        barrier.wait,\n      ]);\n\n      if (settledTask === PROMISE_ADDED_SYMBOL) {\n        continue;\n      }\n\n      yield settledTask as SettledPregelTask;\n\n      if (listener != null) {\n        timeoutOrCancelSignal.signal?.removeEventListener(\"abort\", listener);\n        timeoutOrCancelSignal.dispose?.();\n      }\n\n      delete executingTasksMap[(settledTask as SettledPregelTask).task.id];\n    }\n  }\n\n  /**\n   * Determines what writes to apply based on whether the task completed successfully, and what type of error occurred.\n   *\n   * Throws an error if the error is a {@link GraphBubbleUp} error and {@link PregelLoop}#isNested is true.\n   *\n   * @param task - The task to commit.\n   * @param error - The error that occurred, if any.\n   */\n  private _commit(task: PregelExecutableTask<string, string>, error?: Error) {\n    if (error !== undefined) {\n      if (isGraphInterrupt(error)) {\n        if (error.interrupts.length) {\n          const interrupts: PendingWrite<string>[] = error.interrupts.map(\n            (interrupt) => [INTERRUPT, interrupt]\n          );\n          const resumes = task.writes.filter((w) => w[0] === RESUME);\n          if (resumes.length) {\n            interrupts.push(...resumes);\n          }\n          this.loop.putWrites(task.id, interrupts);\n        }\n      } else if (isGraphBubbleUp(error) && task.writes.length) {\n        this.loop.putWrites(task.id, task.writes);\n      } else {\n        this.loop.putWrites(task.id, [\n          [ERROR, { message: error.message, name: error.name }],\n        ]);\n      }\n    } else {\n      if (\n        this.nodeFinished &&\n        (task.config?.tags == null || !task.config.tags.includes(TAG_HIDDEN))\n      ) {\n        this.nodeFinished(String(task.name));\n      }\n\n      if (task.writes.length === 0) {\n        // Add no writes marker\n        task.writes.push([NO_WRITES, null]);\n      }\n\n      // Save task writes to checkpointer\n      this.loop.putWrites(task.id, task.writes);\n    }\n  }\n}\n\nasync function call(\n  this: {\n    executingTasksMap: Record<\n      string,\n      Promise<{\n        task: PregelExecutableTask<string, string>;\n        result?: unknown;\n        error?: Error;\n      }>\n    >;\n\n    barrier: {\n      next: () => void;\n      wait: Promise<unknown>;\n    };\n\n    retryPolicy?: RetryPolicy;\n\n    scheduleTask: (\n      task: PregelExecutableTask<string, string>,\n      writeIdx: number,\n      call?: Call\n    ) => Promise<PregelExecutableTask<string, string> | void>;\n  },\n  runner: PregelRunner,\n  task: PregelExecutableTask<string, string>,\n  func: (...args: unknown[]) => unknown | Promise<unknown>,\n  name: string,\n  input: unknown,\n  options: {\n    retry?: RetryPolicy;\n    cache?: CachePolicy;\n    callbacks?: unknown;\n  } = {}\n): Promise<unknown> {\n  // Schedule PUSH tasks, collect promises\n  const scratchpad = task.config?.configurable?.[CONFIG_KEY_SCRATCHPAD] as\n    | PregelScratchpad<unknown>\n    | undefined;\n\n  if (!scratchpad) {\n    throw new Error(\n      `BUG: No scratchpad found on task ${task.name}__${task.id}`\n    );\n  }\n\n  const cnt = scratchpad.callCounter;\n  scratchpad.callCounter += 1;\n\n  // schedule the next task, if the callback returns one\n  const wcall = new Call({\n    func,\n    name,\n    input,\n    cache: options.cache,\n    retry: options.retry,\n    callbacks: options.callbacks,\n  });\n  const nextTask = await this.scheduleTask(task, cnt, wcall);\n  if (!nextTask) return undefined;\n\n  // Check if this task is already running\n  const existingPromise = this.executingTasksMap[nextTask.id];\n\n  if (existingPromise !== undefined) {\n    // If the parent task was retried, the next task might already be running\n    return existingPromise;\n  }\n\n  if (nextTask.writes.length > 0) {\n    // If it already ran, return the result\n    const returns = nextTask.writes.filter(([c]) => c === RETURN);\n    const errors = nextTask.writes.filter(([c]) => c === ERROR);\n\n    if (returns.length > 0) {\n      // Task completed successfully\n      if (returns.length === 1) return Promise.resolve(returns[0][1]);\n\n      // should be unreachable\n      throw new Error(\n        `BUG: multiple returns found for task ${nextTask.name}__${nextTask.id}`\n      );\n    }\n\n    if (errors.length > 0) {\n      // Task failed\n      if (errors.length === 1) {\n        const errorValue = errors[0][1];\n        const error =\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          errorValue instanceof Error\n            ? errorValue\n            : new Error(String(errorValue));\n\n        return Promise.reject(error);\n      }\n\n      // the only way this should happen is if the task executes multiple times and writes aren't cleared\n      throw new Error(\n        `BUG: multiple errors found for task ${nextTask.name}__${nextTask.id}`\n      );\n    }\n\n    return undefined;\n  } else {\n    // Schedule the next task with retry\n    const prom = _runWithRetry<string, string>(nextTask, options.retry, {\n      [CONFIG_KEY_CALL]: call.bind(this, runner, nextTask),\n    });\n\n    this.executingTasksMap[nextTask.id] = prom;\n    this.barrier.next();\n\n    return prom.then(({ result, error }) => {\n      if (error) return Promise.reject(error);\n      return result;\n    });\n  }\n}\n","import {\n  BaseMessage,\n  BaseMessageChunk,\n  type BaseMessageFields,\n  mergeContent,\n  _mergeDicts,\n  _mergeObj,\n  _mergeStatus,\n} from \"./base.js\";\nimport { $InferMessageContent, MessageStructure } from \"./message.js\";\nimport { Constructor } from \"./utils.js\";\n\nexport interface ToolMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"tool\"> {\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n  tool_call_id: string;\n  status?: \"success\" | \"error\";\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Marker parameter for objects that tools can return directly.\n *\n * If a custom BaseTool is invoked with a ToolCall and the output of custom code is\n * not an instance of DirectToolOutput, the output will automatically be coerced to\n * a string and wrapped in a ToolMessage.\n */\nexport interface DirectToolOutput {\n  readonly lc_direct_tool_output: true;\n}\n\nexport function isDirectToolOutput(x: unknown): x is DirectToolOutput {\n  return (\n    x != null &&\n    typeof x === \"object\" &&\n    \"lc_direct_tool_output\" in x &&\n    x.lc_direct_tool_output === true\n  );\n}\n\n/**\n * Represents a tool message in a conversation.\n */\nexport class ToolMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"tool\">\n  implements DirectToolOutput\n{\n  static lc_name() {\n    return \"ToolMessage\";\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return { tool_call_id: \"tool_call_id\" };\n  }\n\n  lc_direct_tool_output = true as const;\n\n  readonly type = \"tool\" as const;\n\n  /**\n   * Status of the tool invocation.\n   * @version 0.2.19\n   */\n  status?: \"success\" | \"error\";\n\n  tool_call_id: string;\n\n  metadata?: Record<string, unknown>;\n\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"tool\"> | ToolMessageFields,\n    tool_call_id: string,\n    name?: string\n  );\n\n  constructor(fields: ToolMessageFields<TStructure>);\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"tool\">\n      | ToolMessageFields<TStructure>,\n    tool_call_id?: string,\n    name?: string\n  ) {\n    const toolMessageFields: ToolMessageFields<TStructure> =\n      typeof fields === \"string\" || Array.isArray(fields)\n        ? { content: fields, name, tool_call_id: tool_call_id! }\n        : fields;\n    super(toolMessageFields);\n    this.tool_call_id = toolMessageFields.tool_call_id;\n    this.artifact = toolMessageFields.artifact;\n    this.status = toolMessageFields.status;\n    this.metadata = toolMessageFields.metadata;\n  }\n\n  static isInstance(message: unknown): message is ToolMessage {\n    return super.isInstance(message) && message.type === \"tool\";\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_call_id: this.tool_call_id,\n      artifact: this.artifact,\n    };\n  }\n}\n\n/**\n * Represents a chunk of a tool message, which can be concatenated\n * with other tool message chunks.\n */\nexport class ToolMessageChunk<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageChunk<TStructure, \"tool\"> {\n  readonly type = \"tool\" as const;\n\n  tool_call_id: string;\n\n  /**\n   * Status of the tool invocation.\n   * @version 0.2.19\n   */\n  status?: \"success\" | \"error\";\n\n  /**\n   * Artifact of the Tool execution which is not meant to be sent to the model.\n   *\n   * Should only be specified if it is different from the message content, e.g. if only\n   * a subset of the full tool output is being passed as message content but the full\n   * output is needed in other parts of the code.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  artifact?: any;\n\n  constructor(fields: ToolMessageFields<TStructure>) {\n    super(fields);\n    this.tool_call_id = fields.tool_call_id;\n    this.artifact = fields.artifact;\n    this.status = fields.status;\n  }\n\n  static lc_name() {\n    return \"ToolMessageChunk\";\n  }\n\n  concat(chunk: ToolMessageChunk<TStructure>) {\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls({\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: _mergeDicts(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      artifact: _mergeObj(this.artifact, chunk.artifact),\n      tool_call_id: this.tool_call_id,\n      id: this.id ?? chunk.id,\n      status: _mergeStatus(this.status, chunk.status),\n    });\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_call_id: this.tool_call_id,\n      artifact: this.artifact,\n    };\n  }\n}\n\nexport interface ToolCall<\n  TName extends string = string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  TArgs extends Record<string, any> = Record<string, any>\n> {\n  readonly type?: \"tool_call\";\n  /**\n   * If provided, an identifier associated with the tool call\n   */\n  id?: string;\n  /**\n   * The name of the tool being called\n   */\n  name: TName;\n  /**\n   * The arguments to the tool call\n   */\n  args: TArgs;\n}\n\n/**\n * A chunk of a tool call (e.g., as part of a stream).\n * When merging ToolCallChunks (e.g., via AIMessageChunk.__add__),\n * all string attributes are concatenated. Chunks are only merged if their\n * values of `index` are equal and not None.\n *\n * @example\n * ```ts\n * const leftChunks = [\n *   {\n *     name: \"foo\",\n *     args: '{\"a\":',\n *     index: 0\n *   }\n * ];\n *\n * const leftAIMessageChunk = new AIMessageChunk({\n *   content: \"\",\n *   tool_call_chunks: leftChunks\n * });\n *\n * const rightChunks = [\n *   {\n *     name: undefined,\n *     args: '1}',\n *     index: 0\n *   }\n * ];\n *\n * const rightAIMessageChunk = new AIMessageChunk({\n *   content: \"\",\n *   tool_call_chunks: rightChunks\n * });\n *\n * const result = leftAIMessageChunk.concat(rightAIMessageChunk);\n * // result.tool_call_chunks is equal to:\n * // [\n * //   {\n * //     name: \"foo\",\n * //     args: '{\"a\":1}'\n * //     index: 0\n * //   }\n * // ]\n * ```\n */\nexport interface ToolCallChunk<TName extends string = string> {\n  readonly type?: \"tool_call_chunk\";\n  /**\n   * If provided, a substring of an identifier for the tool call\n   */\n  id?: string;\n  /**\n   * If provided, a substring of the name of the tool to be called\n   */\n  name?: TName;\n  /**\n   * If provided, a JSON substring of the arguments to the tool call\n   */\n  args?: string;\n  /**\n   * If provided, the index of the tool call in a sequence\n   */\n  index?: number;\n}\n\nexport interface InvalidToolCall<TName extends string = string> {\n  readonly type?: \"invalid_tool_call\";\n  /**\n   * If provided, an identifier associated with the tool call\n   */\n  id?: string;\n  /**\n      /**\n     * The name of the tool being called\n     */\n  name?: TName;\n  /**\n   * The arguments to the tool call\n   */\n  args?: string;\n  /**\n   * An error message associated with the tool call\n   */\n  error?: string;\n  /**\n   * Index of block in aggregate response\n   */\n  index?: string | number;\n}\n\nexport function defaultToolCallParser(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCalls: Record<string, any>[]\n): [ToolCall[], InvalidToolCall[]] {\n  const toolCalls: ToolCall[] = [];\n  const invalidToolCalls: InvalidToolCall[] = [];\n  for (const toolCall of rawToolCalls) {\n    if (!toolCall.function) {\n      continue;\n    } else {\n      const functionName = toolCall.function.name;\n      try {\n        const functionArgs = JSON.parse(toolCall.function.arguments);\n        toolCalls.push({\n          name: functionName || \"\",\n          args: functionArgs || {},\n          id: toolCall.id,\n        });\n      } catch {\n        invalidToolCalls.push({\n          name: functionName,\n          args: toolCall.function.arguments,\n          id: toolCall.id,\n          error: \"Malformed args.\",\n        });\n      }\n    }\n  }\n  return [toolCalls, invalidToolCalls];\n}\n\n/**\n * @deprecated Use {@link ToolMessage.isInstance} instead\n */\nexport function isToolMessage(x: unknown): x is ToolMessage {\n  return (\n    typeof x === \"object\" &&\n    x !== null &&\n    \"getType\" in x &&\n    typeof x.getType === \"function\" &&\n    x.getType() === \"tool\"\n  );\n}\n\n/**\n * @deprecated Use {@link ToolMessageChunk.isInstance} instead\n */\nexport function isToolMessageChunk(x: BaseMessageChunk): x is ToolMessageChunk {\n  return x._getType() === \"tool\";\n}\n","import * as uuid from \"uuid\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type {\n  ChatGenerationChunk,\n  GenerationChunk,\n  LLMResult,\n} from \"../outputs.js\";\nimport {\n  Serializable,\n  Serialized,\n  SerializedNotImplemented,\n  get_lc_unique_name,\n} from \"../load/serializable.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Error = any;\n\n/**\n * Interface for the input parameters of the BaseCallbackHandler class. It\n * allows to specify which types of events should be ignored by the\n * callback handler.\n */\nexport interface BaseCallbackHandlerInput {\n  ignoreLLM?: boolean;\n  ignoreChain?: boolean;\n  ignoreAgent?: boolean;\n  ignoreRetriever?: boolean;\n  ignoreCustomEvent?: boolean;\n  _awaitHandler?: boolean;\n  raiseError?: boolean;\n}\n\n/**\n * Interface for the indices of a new token produced by an LLM or Chat\n * Model in streaming mode.\n */\nexport interface NewTokenIndices {\n  prompt: number;\n  completion: number;\n}\n\n// TODO: Add all additional callback fields here\nexport type HandleLLMNewTokenCallbackFields = {\n  chunk?: GenerationChunk | ChatGenerationChunk;\n};\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nabstract class BaseCallbackHandlerMethodsClass {\n  /**\n   * Called at the start of an LLM or Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleLLMStart?(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called when an LLM/ChatModel in `streaming` mode produces a new token\n   */\n  handleLLMNewToken?(\n    token: string,\n    /**\n     * idx.prompt is the index of the prompt that produced the token\n     *   (if there are multiple prompts)\n     * idx.completion is the index of the completion that produced the token\n     *   (if multiple completions per prompt are requested)\n     */\n    idx: NewTokenIndices,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if an LLM/ChatModel run encounters an error\n   */\n  handleLLMError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of an LLM/ChatModel run, with the output and the run ID.\n   */\n  handleLLMEnd?(\n    output: LLMResult,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleChatModelStart?(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chain run, with the chain name and inputs\n   * and the run ID.\n   */\n  handleChainStart?(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runType?: string,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Chain run encounters an error\n   */\n  handleChainError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Chain run, with the outputs and the run ID.\n   */\n  handleChainEnd?(\n    outputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Tool run, with the tool name and input\n   * and the run ID.\n   */\n  handleToolStart?(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Tool run encounters an error\n   */\n  handleToolError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Tool run, with the tool output and the run ID.\n   */\n  handleToolEnd?(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    output: any,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleText?(\n    text: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent is about to execute an action,\n   * with the action and the run ID.\n   */\n  handleAgentAction?(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent finishes execution, before it exits.\n   * with the final output and the run ID.\n   */\n  handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  handleRetrieverStart?(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverEnd?(\n    documents: DocumentInterface[],\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n}\n\n/**\n * Base interface for callbacks. All methods are optional. If a method is not\n * implemented, it will be ignored. If a method is implemented, it will be\n * called at the appropriate time. All methods are called with the run ID of\n * the LLM/ChatModel/Chain that is running, which is generated by the\n * CallbackManager.\n *\n * @interface\n */\nexport type CallbackHandlerMethods = BaseCallbackHandlerMethodsClass;\n\n/**\n * Interface for handlers that can indicate a preference for streaming responses.\n * When implemented, this allows the handler to signal whether it prefers to receive\n * streaming responses from language models rather than complete responses.\n */\nexport interface CallbackHandlerPrefersStreaming {\n  readonly lc_prefer_streaming: boolean;\n}\n\nexport function callbackHandlerPrefersStreaming(x: BaseCallbackHandler) {\n  return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nexport abstract class BaseCallbackHandler\n  extends BaseCallbackHandlerMethodsClass\n  implements BaseCallbackHandlerInput, Serializable\n{\n  lc_serializable = false;\n\n  get lc_namespace(): [\"langchain_core\", \"callbacks\", string] {\n    return [\"langchain_core\", \"callbacks\", this.name];\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_attributes(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof BaseCallbackHandler),\n    ];\n  }\n\n  lc_kwargs: SerializedFields;\n\n  abstract name: string;\n\n  ignoreLLM = false;\n\n  ignoreChain = false;\n\n  ignoreAgent = false;\n\n  ignoreRetriever = false;\n\n  ignoreCustomEvent = false;\n\n  raiseError = false;\n\n  awaitHandlers =\n    getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\";\n\n  constructor(input?: BaseCallbackHandlerInput) {\n    super();\n    this.lc_kwargs = input || {};\n    if (input) {\n      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n      this.ignoreCustomEvent =\n        input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n      this.raiseError = input.raiseError ?? this.raiseError;\n      this.awaitHandlers =\n        this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n    }\n  }\n\n  copy(): BaseCallbackHandler {\n    return new (this.constructor as new (\n      input?: BaseCallbackHandlerInput\n    ) => BaseCallbackHandler)(this);\n  }\n\n  toJSON(): Serialized {\n    return Serializable.prototype.toJSON.call(this);\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return Serializable.prototype.toJSONNotImplemented.call(this);\n  }\n\n  static fromMethods(methods: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuid.v4();\n\n      constructor() {\n        super();\n        Object.assign(this, methods);\n      }\n    }\n    return new Handler();\n  }\n}\n\nexport const isBaseCallbackHandler = (x: unknown) => {\n  const callbackHandler = x as BaseCallbackHandler;\n  return (\n    callbackHandler !== undefined &&\n    typeof callbackHandler.copy === \"function\" &&\n    typeof callbackHandler.name === \"string\" &&\n    typeof callbackHandler.awaitHandlers === \"boolean\"\n  );\n};\n","// @ts-nocheck\n\n// Inlined to deal with portability issues\n// Originally from: https://github.com/isaacs/sax-js\n\nconst initializeSax = function () {\n  const sax: any = {};\n  sax.parser = function (strict, opt) {\n    return new SAXParser(strict, opt);\n  };\n  sax.SAXParser = SAXParser;\n  sax.SAXStream = SAXStream;\n  sax.createStream = createStream;\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024;\n\n  const buffers = [\n    \"comment\",\n    \"sgmlDecl\",\n    \"textNode\",\n    \"tagName\",\n    \"doctype\",\n    \"procInstName\",\n    \"procInstBody\",\n    \"entity\",\n    \"attribName\",\n    \"attribValue\",\n    \"cdata\",\n    \"script\",\n  ];\n\n  sax.EVENTS = [\n    \"text\",\n    \"processinginstruction\",\n    \"sgmldeclaration\",\n    \"doctype\",\n    \"comment\",\n    \"opentagstart\",\n    \"attribute\",\n    \"opentag\",\n    \"closetag\",\n    \"opencdata\",\n    \"cdata\",\n    \"closecdata\",\n    \"error\",\n    \"end\",\n    \"ready\",\n    \"script\",\n    \"opennamespace\",\n    \"closenamespace\",\n  ];\n\n  function SAXParser(strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt);\n    }\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.q = parser.c = \"\";\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;\n    parser.opt = opt || {};\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;\n    parser.looseCase = parser.opt.lowercase ? \"toLowerCase\" : \"toUpperCase\";\n    parser.tags = [];\n    parser.closed = parser.closedRoot = parser.sawRoot = false;\n    parser.tag = parser.error = null;\n    parser.strict = !!strict;\n    parser.noscript = !!(strict || parser.opt.noscript);\n    parser.state = S.BEGIN;\n    parser.strictEntities = parser.opt.strictEntities;\n    parser.ENTITIES = parser.strictEntities\n      ? Object.create(sax.XML_ENTITIES)\n      : Object.create(sax.ENTITIES);\n    parser.attribList = [];\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS);\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false;\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0;\n    }\n    emit(parser, \"onready\");\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F() {}\n      F.prototype = o;\n      var newf = new F();\n      return newf;\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength(parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);\n    var maxActual = 0;\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length;\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case \"textNode\":\n            closeText(parser);\n            break;\n\n          case \"cdata\":\n            emitNode(parser, \"oncdata\", parser.cdata);\n            parser.cdata = \"\";\n            break;\n\n          case \"script\":\n            emitNode(parser, \"onscript\", parser.script);\n            parser.script = \"\";\n            break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \" + buffers[i]);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual;\n    parser.bufferCheckPosition = m + parser.position;\n  }\n\n  function clearBuffers(parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = \"\";\n    }\n  }\n\n  function flushBuffers(parser) {\n    closeText(parser);\n    if (parser.cdata !== \"\") {\n      emitNode(parser, \"oncdata\", parser.cdata);\n      parser.cdata = \"\";\n    }\n    if (parser.script !== \"\") {\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () {\n      end(this);\n    },\n    write: write,\n    resume: function () {\n      this.error = null;\n      return this;\n    },\n    close: function () {\n      return this.write(null);\n    },\n    flush: function () {\n      flushBuffers(this);\n    },\n  };\n\n  var Stream = ReadableStream;\n  if (!Stream) Stream = function () {};\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== \"error\" && ev !== \"end\";\n  });\n\n  function createStream(strict, opt) {\n    return new SAXStream(strict, opt);\n  }\n\n  function SAXStream(strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt);\n    }\n\n    Stream.apply(this);\n\n    this._parser = new SAXParser(strict, opt);\n    this.writable = true;\n    this.readable = true;\n\n    var me = this;\n\n    this._parser.onend = function () {\n      me.emit(\"end\");\n    };\n\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null;\n    };\n\n    this._decoder = null;\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev, {\n        get: function () {\n          return me._parser[\"on\" + ev];\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev);\n            me._parser[\"on\" + ev] = h;\n            return h;\n          }\n          me.on(ev, h);\n        },\n        enumerable: true,\n        configurable: false,\n      });\n    });\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream,\n    },\n  });\n\n  SAXStream.prototype.write = function (data) {\n    this._parser.write(data.toString());\n    this.emit(\"data\", data);\n    return true;\n  };\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk);\n    }\n    this._parser.end();\n    return true;\n  };\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\" + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\" + ev] = function () {\n        var args =\n          arguments.length === 1\n            ? [arguments[0]]\n            : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = \"[CDATA[\";\n  var DOCTYPE = \"DOCTYPE\";\n  var XML_NAMESPACE = \"http://www.w3.org/XML/1998/namespace\";\n  var XMLNS_NAMESPACE = \"http://www.w3.org/2000/xmlns/\";\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n\n  var nameBody =\n    /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  var entityStart =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/;\n  var entityBody =\n    /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/;\n\n  function isWhitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\r\" || c === \"\\t\";\n  }\n\n  function isQuote(c) {\n    return c === '\"' || c === \"'\";\n  }\n\n  function isAttribEnd(c) {\n    return c === \">\" || isWhitespace(c);\n  }\n\n  function isMatch(regex, c) {\n    return regex.test(c);\n  }\n\n  function notMatch(regex, c) {\n    return !isMatch(regex, c);\n  }\n\n  var S = 0;\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++, // <script> ... <\n  };\n\n  sax.XML_ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n  };\n\n  sax.ENTITIES = {\n    amp: \"&\",\n    gt: \">\",\n    lt: \"<\",\n    quot: '\"',\n    apos: \"'\",\n    AElig: 198,\n    Aacute: 193,\n    Acirc: 194,\n    Agrave: 192,\n    Aring: 197,\n    Atilde: 195,\n    Auml: 196,\n    Ccedil: 199,\n    ETH: 208,\n    Eacute: 201,\n    Ecirc: 202,\n    Egrave: 200,\n    Euml: 203,\n    Iacute: 205,\n    Icirc: 206,\n    Igrave: 204,\n    Iuml: 207,\n    Ntilde: 209,\n    Oacute: 211,\n    Ocirc: 212,\n    Ograve: 210,\n    Oslash: 216,\n    Otilde: 213,\n    Ouml: 214,\n    THORN: 222,\n    Uacute: 218,\n    Ucirc: 219,\n    Ugrave: 217,\n    Uuml: 220,\n    Yacute: 221,\n    aacute: 225,\n    acirc: 226,\n    aelig: 230,\n    agrave: 224,\n    aring: 229,\n    atilde: 227,\n    auml: 228,\n    ccedil: 231,\n    eacute: 233,\n    ecirc: 234,\n    egrave: 232,\n    eth: 240,\n    euml: 235,\n    iacute: 237,\n    icirc: 238,\n    igrave: 236,\n    iuml: 239,\n    ntilde: 241,\n    oacute: 243,\n    ocirc: 244,\n    ograve: 242,\n    oslash: 248,\n    otilde: 245,\n    ouml: 246,\n    szlig: 223,\n    thorn: 254,\n    uacute: 250,\n    ucirc: 251,\n    ugrave: 249,\n    uuml: 252,\n    yacute: 253,\n    yuml: 255,\n    copy: 169,\n    reg: 174,\n    nbsp: 160,\n    iexcl: 161,\n    cent: 162,\n    pound: 163,\n    curren: 164,\n    yen: 165,\n    brvbar: 166,\n    sect: 167,\n    uml: 168,\n    ordf: 170,\n    laquo: 171,\n    not: 172,\n    shy: 173,\n    macr: 175,\n    deg: 176,\n    plusmn: 177,\n    sup1: 185,\n    sup2: 178,\n    sup3: 179,\n    acute: 180,\n    micro: 181,\n    para: 182,\n    middot: 183,\n    cedil: 184,\n    ordm: 186,\n    raquo: 187,\n    frac14: 188,\n    frac12: 189,\n    frac34: 190,\n    iquest: 191,\n    times: 215,\n    divide: 247,\n    OElig: 338,\n    oelig: 339,\n    Scaron: 352,\n    scaron: 353,\n    Yuml: 376,\n    fnof: 402,\n    circ: 710,\n    tilde: 732,\n    Alpha: 913,\n    Beta: 914,\n    Gamma: 915,\n    Delta: 916,\n    Epsilon: 917,\n    Zeta: 918,\n    Eta: 919,\n    Theta: 920,\n    Iota: 921,\n    Kappa: 922,\n    Lambda: 923,\n    Mu: 924,\n    Nu: 925,\n    Xi: 926,\n    Omicron: 927,\n    Pi: 928,\n    Rho: 929,\n    Sigma: 931,\n    Tau: 932,\n    Upsilon: 933,\n    Phi: 934,\n    Chi: 935,\n    Psi: 936,\n    Omega: 937,\n    alpha: 945,\n    beta: 946,\n    gamma: 947,\n    delta: 948,\n    epsilon: 949,\n    zeta: 950,\n    eta: 951,\n    theta: 952,\n    iota: 953,\n    kappa: 954,\n    lambda: 955,\n    mu: 956,\n    nu: 957,\n    xi: 958,\n    omicron: 959,\n    pi: 960,\n    rho: 961,\n    sigmaf: 962,\n    sigma: 963,\n    tau: 964,\n    upsilon: 965,\n    phi: 966,\n    chi: 967,\n    psi: 968,\n    omega: 969,\n    thetasym: 977,\n    upsih: 978,\n    piv: 982,\n    ensp: 8194,\n    emsp: 8195,\n    thinsp: 8201,\n    zwnj: 8204,\n    zwj: 8205,\n    lrm: 8206,\n    rlm: 8207,\n    ndash: 8211,\n    mdash: 8212,\n    lsquo: 8216,\n    rsquo: 8217,\n    sbquo: 8218,\n    ldquo: 8220,\n    rdquo: 8221,\n    bdquo: 8222,\n    dagger: 8224,\n    Dagger: 8225,\n    bull: 8226,\n    hellip: 8230,\n    permil: 8240,\n    prime: 8242,\n    Prime: 8243,\n    lsaquo: 8249,\n    rsaquo: 8250,\n    oline: 8254,\n    frasl: 8260,\n    euro: 8364,\n    image: 8465,\n    weierp: 8472,\n    real: 8476,\n    trade: 8482,\n    alefsym: 8501,\n    larr: 8592,\n    uarr: 8593,\n    rarr: 8594,\n    darr: 8595,\n    harr: 8596,\n    crarr: 8629,\n    lArr: 8656,\n    uArr: 8657,\n    rArr: 8658,\n    dArr: 8659,\n    hArr: 8660,\n    forall: 8704,\n    part: 8706,\n    exist: 8707,\n    empty: 8709,\n    nabla: 8711,\n    isin: 8712,\n    notin: 8713,\n    ni: 8715,\n    prod: 8719,\n    sum: 8721,\n    minus: 8722,\n    lowast: 8727,\n    radic: 8730,\n    prop: 8733,\n    infin: 8734,\n    ang: 8736,\n    and: 8743,\n    or: 8744,\n    cap: 8745,\n    cup: 8746,\n    int: 8747,\n    there4: 8756,\n    sim: 8764,\n    cong: 8773,\n    asymp: 8776,\n    ne: 8800,\n    equiv: 8801,\n    le: 8804,\n    ge: 8805,\n    sub: 8834,\n    sup: 8835,\n    nsub: 8836,\n    sube: 8838,\n    supe: 8839,\n    oplus: 8853,\n    otimes: 8855,\n    perp: 8869,\n    sdot: 8901,\n    lceil: 8968,\n    rceil: 8969,\n    lfloor: 8970,\n    rfloor: 8971,\n    lang: 9001,\n    rang: 9002,\n    loz: 9674,\n    spades: 9824,\n    clubs: 9827,\n    hearts: 9829,\n    diams: 9830,\n  };\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key];\n    var s = typeof e === \"number\" ? String.fromCharCode(e) : e;\n    sax.ENTITIES[key] = s;\n  });\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s;\n  }\n\n  // shorthand\n  S = sax.STATE;\n\n  function emit(parser, event, data) {\n    parser[event] && parser[event](data);\n  }\n\n  function emitNode(parser, nodeType, data) {\n    if (parser.textNode) closeText(parser);\n    emit(parser, nodeType, data);\n  }\n\n  function closeText(parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode) emit(parser, \"ontext\", parser.textNode);\n    parser.textNode = \"\";\n  }\n\n  function textopts(opt, text) {\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error(parser, er) {\n    closeText(parser);\n    if (parser.trackPosition) {\n      er +=\n        \"\\nLine: \" +\n        parser.line +\n        \"\\nColumn: \" +\n        parser.column +\n        \"\\nChar: \" +\n        parser.c;\n    }\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.sawRoot && !parser.closedRoot)\n      strictFail(parser, \"Unclosed root tag\");\n    if (\n      parser.state !== S.BEGIN &&\n      parser.state !== S.BEGIN_WHITESPACE &&\n      parser.state !== S.TEXT\n    ) {\n      error(parser, \"Unexpected end\");\n    }\n    closeText(parser);\n    parser.c = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    SAXParser.call(parser, parser.strict, parser.opt);\n    return parser;\n  }\n\n  function strictFail(parser, message) {\n    if (typeof parser !== \"object\" || !(parser instanceof SAXParser)) {\n      throw new Error(\"bad call to strictFail\");\n    }\n    if (parser.strict) {\n      error(parser, message);\n    }\n  }\n\n  function newTag(parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();\n    var parent = parser.tags[parser.tags.length - 1] || parser;\n    var tag = (parser.tag = { name: parser.tagName, attributes: {} });\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns;\n    }\n    parser.attribList.length = 0;\n    emitNode(parser, \"onopentagstart\", tag);\n  }\n\n  function qname(name, attribute) {\n    var i = name.indexOf(\":\");\n    var qualName = i < 0 ? [\"\", name] : name.split(\":\");\n    var prefix = qualName[0];\n    var local = qualName[1];\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === \"xmlns\") {\n      prefix = \"xmlns\";\n      local = \"\";\n    }\n\n    return { prefix: prefix, local: local };\n  }\n\n  function attrib(parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]();\n    }\n\n    if (\n      parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)\n    ) {\n      parser.attribName = parser.attribValue = \"\";\n      return;\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true);\n      var prefix = qn.prefix;\n      var local = qn.local;\n\n      if (prefix === \"xmlns\") {\n        // namespace binding attribute. push the binding into scope\n        if (local === \"xml\" && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(\n            parser,\n            \"xml: prefix must be bound to \" +\n              XML_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else if (\n          local === \"xmlns\" &&\n          parser.attribValue !== XMLNS_NAMESPACE\n        ) {\n          strictFail(\n            parser,\n            \"xmlns: prefix must be bound to \" +\n              XMLNS_NAMESPACE +\n              \"\\n\" +\n              \"Actual: \" +\n              parser.attribValue\n          );\n        } else {\n          var tag = parser.tag;\n          var parent = parser.tags[parser.tags.length - 1] || parser;\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns);\n          }\n          tag.ns[local] = parser.attribValue;\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue]);\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue;\n      emitNode(parser, \"onattribute\", {\n        name: parser.attribName,\n        value: parser.attribValue,\n      });\n    }\n\n    parser.attribName = parser.attribValue = \"\";\n  }\n\n  function openTag(parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag;\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName);\n      tag.prefix = qn.prefix;\n      tag.local = qn.local;\n      tag.uri = tag.ns[qn.prefix] || \"\";\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(\n          parser,\n          \"Unbound namespace prefix: \" + JSON.stringify(parser.tagName)\n        );\n        tag.uri = qn.prefix;\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, \"onopennamespace\", {\n            prefix: p,\n            uri: tag.ns[p],\n          });\n        });\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i];\n        var name = nv[0];\n        var value = nv[1];\n        var qualName = qname(name, true);\n        var prefix = qualName.prefix;\n        var local = qualName.local;\n        var uri = prefix === \"\" ? \"\" : tag.ns[prefix] || \"\";\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri,\n        };\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== \"xmlns\" && !uri) {\n          strictFail(\n            parser,\n            \"Unbound namespace prefix: \" + JSON.stringify(prefix)\n          );\n          a.uri = prefix;\n        }\n        parser.tag.attributes[name] = a;\n        emitNode(parser, \"onattribute\", a);\n      }\n      parser.attribList.length = 0;\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing;\n\n    // process the tag\n    parser.sawRoot = true;\n    parser.tags.push(parser.tag);\n    emitNode(parser, \"onopentag\", parser.tag);\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === \"script\") {\n        parser.state = S.SCRIPT;\n      } else {\n        parser.state = S.TEXT;\n      }\n      parser.tag = null;\n      parser.tagName = \"\";\n    }\n    parser.attribName = parser.attribValue = \"\";\n    parser.attribList.length = 0;\n  }\n\n  function closeTag(parser) {\n    if (!parser.tagName) {\n      strictFail(parser, \"Weird empty close tag.\");\n      parser.textNode += \"</>\";\n      parser.state = S.TEXT;\n      return;\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== \"script\") {\n        parser.script += \"</\" + parser.tagName + \">\";\n        parser.tagName = \"\";\n        parser.state = S.SCRIPT;\n        return;\n      }\n      emitNode(parser, \"onscript\", parser.script);\n      parser.script = \"\";\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length;\n    var tagName = parser.tagName;\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]();\n    }\n    var closeTo = tagName;\n    while (t--) {\n      var close = parser.tags[t];\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, \"Unexpected close tag\");\n      } else {\n        break;\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, \"Unmatched closing tag: \" + parser.tagName);\n      parser.textNode += \"</\" + parser.tagName + \">\";\n      parser.state = S.TEXT;\n      return;\n    }\n    parser.tagName = tagName;\n    var s = parser.tags.length;\n    while (s-- > t) {\n      var tag = (parser.tag = parser.tags.pop());\n      parser.tagName = parser.tag.name;\n      emitNode(parser, \"onclosetag\", parser.tagName);\n\n      var x = {};\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i];\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser;\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p];\n          emitNode(parser, \"onclosenamespace\", { prefix: p, uri: n });\n        });\n      }\n    }\n    if (t === 0) parser.closedRoot = true;\n    parser.tagName = parser.attribValue = parser.attribName = \"\";\n    parser.attribList.length = 0;\n    parser.state = S.TEXT;\n  }\n\n  function parseEntity(parser) {\n    var entity = parser.entity;\n    var entityLC = entity.toLowerCase();\n    var num;\n    var numStr = \"\";\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity];\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC];\n    }\n    entity = entityLC;\n    if (entity.charAt(0) === \"#\") {\n      if (entity.charAt(1) === \"x\") {\n        entity = entity.slice(2);\n        num = parseInt(entity, 16);\n        numStr = num.toString(16);\n      } else {\n        entity = entity.slice(1);\n        num = parseInt(entity, 10);\n        numStr = num.toString(10);\n      }\n    }\n    entity = entity.replace(/^0+/, \"\");\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, \"Invalid character entity\");\n      return \"&\" + parser.entity + \";\";\n    }\n\n    return String.fromCodePoint(num);\n  }\n\n  function beginWhiteSpace(parser, c) {\n    if (c === \"<\") {\n      parser.state = S.OPEN_WAKA;\n      parser.startTagPosition = parser.position;\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, \"Non-whitespace before first tag.\");\n      parser.textNode = c;\n      parser.state = S.TEXT;\n    }\n  }\n\n  function charAt(chunk, i) {\n    var result = \"\";\n    if (i < chunk.length) {\n      result = chunk.charAt(i);\n    }\n    return result;\n  }\n\n  function write(chunk) {\n    var parser = this;\n    if (this.error) {\n      throw this.error;\n    }\n    if (parser.closed) {\n      return error(\n        parser,\n        \"Cannot write after close. Assign an onready handler.\"\n      );\n    }\n    if (chunk === null) {\n      return end(parser);\n    }\n    if (typeof chunk === \"object\") {\n      chunk = chunk.toString();\n    }\n    var i = 0;\n    var c = \"\";\n    while (true) {\n      c = charAt(chunk, i++);\n      parser.c = c;\n\n      if (!c) {\n        break;\n      }\n\n      if (parser.trackPosition) {\n        parser.position++;\n        if (c === \"\\n\") {\n          parser.line++;\n          parser.column = 0;\n        } else {\n          parser.column++;\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE;\n          if (c === \"\\uFEFF\") {\n            continue;\n          }\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c);\n          continue;\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1;\n            while (c && c !== \"<\" && c !== \"&\") {\n              c = charAt(chunk, i++);\n              if (c && parser.trackPosition) {\n                parser.position++;\n                if (c === \"\\n\") {\n                  parser.line++;\n                  parser.column = 0;\n                } else {\n                  parser.column++;\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1);\n          }\n          if (\n            c === \"<\" &&\n            !(parser.sawRoot && parser.closedRoot && !parser.strict)\n          ) {\n            parser.state = S.OPEN_WAKA;\n            parser.startTagPosition = parser.position;\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, \"Text data outside of root node.\");\n            }\n            if (c === \"&\") {\n              parser.state = S.TEXT_ENTITY;\n            } else {\n              parser.textNode += c;\n            }\n          }\n          continue;\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === \"<\") {\n            parser.state = S.SCRIPT_ENDING;\n          } else {\n            parser.script += c;\n          }\n          continue;\n\n        case S.SCRIPT_ENDING:\n          if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n          } else {\n            parser.script += \"<\" + c;\n            parser.state = S.SCRIPT;\n          }\n          continue;\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === \"!\") {\n            parser.state = S.SGML_DECL;\n            parser.sgmlDecl = \"\";\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG;\n            parser.tagName = c;\n          } else if (c === \"/\") {\n            parser.state = S.CLOSE_TAG;\n            parser.tagName = \"\";\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST;\n            parser.procInstName = parser.procInstBody = \"\";\n          } else {\n            strictFail(parser, \"Unencoded <\");\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition;\n              c = new Array(pad).join(\" \") + c;\n            }\n            parser.textNode += \"<\" + c;\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, \"onopencdata\");\n            parser.state = S.CDATA;\n            parser.sgmlDecl = \"\";\n            parser.cdata = \"\";\n          } else if (parser.sgmlDecl + c === \"--\") {\n            parser.state = S.COMMENT;\n            parser.comment = \"\";\n            parser.sgmlDecl = \"\";\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE;\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser, \"Inappropriately located doctype declaration\");\n            }\n            parser.doctype = \"\";\n            parser.sgmlDecl = \"\";\n          } else if (c === \">\") {\n            emitNode(parser, \"onsgmldeclaration\", parser.sgmlDecl);\n            parser.sgmlDecl = \"\";\n            parser.state = S.TEXT;\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED;\n            parser.sgmlDecl += c;\n          } else {\n            parser.sgmlDecl += c;\n          }\n          continue;\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL;\n            parser.q = \"\";\n          }\n          parser.sgmlDecl += c;\n          continue;\n\n        case S.DOCTYPE:\n          if (c === \">\") {\n            parser.state = S.TEXT;\n            emitNode(parser, \"ondoctype\", parser.doctype);\n            parser.doctype = true; // just remember that we saw it.\n          } else {\n            parser.doctype += c;\n            if (c === \"[\") {\n              parser.state = S.DOCTYPE_DTD;\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED;\n              parser.q = c;\n            }\n          }\n          continue;\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.q = \"\";\n            parser.state = S.DOCTYPE;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c;\n          if (c === \"]\") {\n            parser.state = S.DOCTYPE;\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED;\n            parser.q = c;\n          }\n          continue;\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c;\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD;\n            parser.q = \"\";\n          }\n          continue;\n\n        case S.COMMENT:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDING;\n          } else {\n            parser.comment += c;\n          }\n          continue;\n\n        case S.COMMENT_ENDING:\n          if (c === \"-\") {\n            parser.state = S.COMMENT_ENDED;\n            parser.comment = textopts(parser.opt, parser.comment);\n            if (parser.comment) {\n              emitNode(parser, \"oncomment\", parser.comment);\n            }\n            parser.comment = \"\";\n          } else {\n            parser.comment += \"-\" + c;\n            parser.state = S.COMMENT;\n          }\n          continue;\n\n        case S.COMMENT_ENDED:\n          if (c !== \">\") {\n            strictFail(parser, \"Malformed comment\");\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += \"--\" + c;\n            parser.state = S.COMMENT;\n          } else {\n            parser.state = S.TEXT;\n          }\n          continue;\n\n        case S.CDATA:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING;\n          } else {\n            parser.cdata += c;\n          }\n          continue;\n\n        case S.CDATA_ENDING:\n          if (c === \"]\") {\n            parser.state = S.CDATA_ENDING_2;\n          } else {\n            parser.cdata += \"]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.CDATA_ENDING_2:\n          if (c === \">\") {\n            if (parser.cdata) {\n              emitNode(parser, \"oncdata\", parser.cdata);\n            }\n            emitNode(parser, \"onclosecdata\");\n            parser.cdata = \"\";\n            parser.state = S.TEXT;\n          } else if (c === \"]\") {\n            parser.cdata += \"]\";\n          } else {\n            parser.cdata += \"]]\" + c;\n            parser.state = S.CDATA;\n          }\n          continue;\n\n        case S.PROC_INST:\n          if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY;\n          } else {\n            parser.procInstName += c;\n          }\n          continue;\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue;\n          } else if (c === \"?\") {\n            parser.state = S.PROC_INST_ENDING;\n          } else {\n            parser.procInstBody += c;\n          }\n          continue;\n\n        case S.PROC_INST_ENDING:\n          if (c === \">\") {\n            emitNode(parser, \"onprocessinginstruction\", {\n              name: parser.procInstName,\n              body: parser.procInstBody,\n            });\n            parser.procInstName = parser.procInstBody = \"\";\n            parser.state = S.TEXT;\n          } else {\n            parser.procInstBody += \"?\" + c;\n            parser.state = S.PROC_INST_BODY;\n          }\n          continue;\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else {\n            newTag(parser);\n            if (c === \">\") {\n              openTag(parser);\n            } else if (c === \"/\") {\n              parser.state = S.OPEN_TAG_SLASH;\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, \"Invalid character in tag name\");\n              }\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.OPEN_TAG_SLASH:\n          if (c === \">\") {\n            openTag(parser, true);\n            closeTag(parser);\n          } else {\n            strictFail(\n              parser,\n              \"Forward-slash in opening tag not followed by >\"\n            );\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (c === \">\") {\n            strictFail(parser, \"Attribute without value\");\n            parser.attribValue = parser.attribName;\n            attrib(parser);\n            openTag(parser);\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE;\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === \"=\") {\n            parser.state = S.ATTRIB_VALUE;\n          } else if (isWhitespace(c)) {\n            continue;\n          } else {\n            strictFail(parser, \"Attribute without value\");\n            parser.tag.attributes[parser.attribName] = \"\";\n            parser.attribValue = \"\";\n            emitNode(parser, \"onattribute\", {\n              name: parser.attribName,\n              value: \"\",\n            });\n            parser.attribName = \"\";\n            if (c === \">\") {\n              openTag(parser);\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c;\n              parser.state = S.ATTRIB_NAME;\n            } else {\n              strictFail(parser, \"Invalid attribute name\");\n              parser.state = S.ATTRIB;\n            }\n          }\n          continue;\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue;\n          } else if (isQuote(c)) {\n            parser.q = c;\n            parser.state = S.ATTRIB_VALUE_QUOTED;\n          } else {\n            strictFail(parser, \"Unquoted attribute value\");\n            parser.state = S.ATTRIB_VALUE_UNQUOTED;\n            parser.attribValue = c;\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          parser.q = \"\";\n          parser.state = S.ATTRIB_VALUE_CLOSED;\n          continue;\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB;\n          } else if (c === \">\") {\n            openTag(parser);\n          } else if (c === \"/\") {\n            parser.state = S.OPEN_TAG_SLASH;\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, \"No whitespace between attributes\");\n            parser.attribName = c;\n            parser.attribValue = \"\";\n            parser.state = S.ATTRIB_NAME;\n          } else {\n            strictFail(parser, \"Invalid attribute name\");\n          }\n          continue;\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === \"&\") {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U;\n            } else {\n              parser.attribValue += c;\n            }\n            continue;\n          }\n          attrib(parser);\n          if (c === \">\") {\n            openTag(parser);\n          } else {\n            parser.state = S.ATTRIB;\n          }\n          continue;\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue;\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += \"</\" + c;\n                parser.state = S.SCRIPT;\n              } else {\n                strictFail(parser, \"Invalid tagname in closing tag.\");\n              }\n            } else {\n              parser.tagName = c;\n            }\n          } else if (c === \">\") {\n            closeTag(parser);\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c;\n          } else if (parser.script) {\n            parser.script += \"</\" + parser.tagName;\n            parser.tagName = \"\";\n            parser.state = S.SCRIPT;\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, \"Invalid tagname in closing tag\");\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE;\n          }\n          continue;\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue;\n          }\n          if (c === \">\") {\n            closeTag(parser);\n          } else {\n            strictFail(parser, \"Invalid characters in closing tag\");\n          }\n          continue;\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState;\n          var buffer;\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT;\n              buffer = \"textNode\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED;\n              buffer = \"attribValue\";\n              break;\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED;\n              buffer = \"attribValue\";\n              break;\n          }\n\n          if (c === \";\") {\n            if (parser.opt.unparsedEntities) {\n              var parsedEntity = parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n              parser.write(parsedEntity);\n            } else {\n              parser[buffer] += parseEntity(parser);\n              parser.entity = \"\";\n              parser.state = returnState;\n            }\n          } else if (\n            isMatch(parser.entity.length ? entityBody : entityStart, c)\n          ) {\n            parser.entity += c;\n          } else {\n            strictFail(parser, \"Invalid character in entity name\");\n            parser[buffer] += \"&\" + parser.entity + c;\n            parser.entity = \"\";\n            parser.state = returnState;\n          }\n\n          continue;\n\n        default: /* istanbul ignore next */ {\n          throw new Error(parser, \"Unknown state: \" + parser.state);\n        }\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser);\n    }\n    return parser;\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode;\n      var floor = Math.floor;\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000;\n        var codeUnits = [];\n        var highSurrogate;\n        var lowSurrogate;\n        var index = -1;\n        var length = arguments.length;\n        if (!length) {\n          return \"\";\n        }\n        var result = \"\";\n        while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10ffff || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError(\"Invalid code point: \" + codePoint);\n          }\n          if (codePoint <= 0xffff) {\n            // BMP code point\n            codeUnits.push(codePoint);\n          } else {\n            // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000;\n            highSurrogate = (codePoint >> 10) + 0xd800;\n            lowSurrogate = (codePoint % 0x400) + 0xdc00;\n            codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits);\n            codeUnits.length = 0;\n          }\n        }\n        return result;\n      };\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, \"fromCodePoint\", {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true,\n        });\n      } else {\n        String.fromCodePoint = fromCodePoint;\n      }\n    })();\n  }\n  return sax;\n};\n\nconst sax = /** #__PURE__ */ initializeSax();\n\nexport { sax };\n","import { Runnable, type RunnableBatchOptions } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\nexport type RouterInput = {\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input: any;\n};\n\n/**\n * A runnable that routes to a set of runnables based on Input['key'].\n * Returns the output of the selected runnable.\n * @example\n * ```typescript\n * import { RouterRunnable, RunnableLambda } from \"@langchain/core/runnables\";\n *\n * const router = new RouterRunnable({\n *   runnables: {\n *     toUpperCase: RunnableLambda.from((text: string) => text.toUpperCase()),\n *     reverseText: RunnableLambda.from((text: string) =>\n *       text.split(\"\").reverse().join(\"\")\n *     ),\n *   },\n * });\n *\n * // Invoke the 'reverseText' runnable\n * const result1 = router.invoke({ key: \"reverseText\", input: \"Hello World\" });\n *\n * // \"dlroW olleH\"\n *\n * // Invoke the 'toUpperCase' runnable\n * const result2 = router.invoke({ key: \"toUpperCase\", input: \"Hello World\" });\n *\n * // \"HELLO WORLD\"\n * ```\n */\nexport class RouterRunnable<\n  RunInput extends RouterInput,\n  RunnableInput,\n  RunOutput\n> extends Runnable<RunInput, RunOutput> {\n  static lc_name() {\n    return \"RouterRunnable\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n\n  constructor(fields: {\n    runnables: Record<string, Runnable<RunnableInput, RunOutput>>;\n  }) {\n    super(fields);\n    this.runnables = fields.runnables;\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunOutput> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.invoke(actualInput, ensureConfig(options));\n  }\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions?: false }\n  ): Promise<RunOutput[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions & { returnExceptions: true }\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]>;\n\n  async batch(\n    inputs: RunInput[],\n    options?: Partial<RunnableConfig> | Partial<RunnableConfig>[],\n    batchOptions?: RunnableBatchOptions\n  ): Promise<(RunOutput | Error)[]> {\n    const keys = inputs.map((input) => input.key);\n    const actualInputs = inputs.map((input) => input.input);\n    const missingKey = keys.find((key) => this.runnables[key] === undefined);\n    if (missingKey !== undefined) {\n      throw new Error(`One or more keys do not have a corresponding runnable.`);\n    }\n    const runnables = keys.map((key) => this.runnables[key]);\n    const optionsList = this._getOptionsList(options ?? {}, inputs.length);\n    const maxConcurrency =\n      optionsList[0]?.maxConcurrency ?? batchOptions?.maxConcurrency;\n    const batchSize =\n      maxConcurrency && maxConcurrency > 0 ? maxConcurrency : inputs.length;\n    const batchResults = [];\n    for (let i = 0; i < actualInputs.length; i += batchSize) {\n      const batchPromises = actualInputs\n        .slice(i, i + batchSize)\n        .map((actualInput, i) =>\n          runnables[i].invoke(actualInput, optionsList[i])\n        );\n      const batchResult = await Promise.all(batchPromises);\n      batchResults.push(batchResult);\n    }\n    return batchResults.flat();\n  }\n\n  async stream(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<IterableReadableStream<RunOutput>> {\n    const { key, input: actualInput } = input;\n    const runnable = this.runnables[key];\n    if (runnable === undefined) {\n      throw new Error(`No runnable associated with key \"${key}\".`);\n    }\n    return runnable.stream(actualInput, options);\n  }\n}\n","// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\n\nimport type { BaseCallbackConfig } from \"../callbacks/manager.js\";\nimport {\n  AIMessage,\n  HumanMessage,\n  SystemMessage,\n  BaseMessage,\n  ChatMessage,\n  type BaseMessageLike,\n  coerceMessageLikeToMessage,\n  isBaseMessage,\n  MessageContent,\n  ContentBlock,\n} from \"../messages/index.js\";\nimport {\n  type ChatPromptValueInterface,\n  ChatPromptValue,\n} from \"../prompt_values.js\";\nimport type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport { Runnable } from \"../runnables/base.js\";\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport {\n  BasePromptTemplate,\n  type BasePromptTemplateInput,\n  type TypedPromptInputValues,\n} from \"./base.js\";\nimport {\n  PromptTemplate,\n  type ParamsFromFString,\n  PromptTemplateInput,\n  ExtractedFStringParams,\n} from \"./prompt.js\";\nimport { ImagePromptTemplate } from \"./image.js\";\nimport {\n  ParsedTemplateNode,\n  TemplateFormat,\n  parseFString,\n  parseMustache,\n} from \"./template.js\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nimport { DictPromptTemplate } from \"./dict.js\";\n\n/**\n * Abstract class that serves as a base for creating message prompt\n * templates. It defines how to format messages for different roles in a\n * conversation.\n */\nexport abstract class BaseMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  RunOutput extends BaseMessage[] = BaseMessage[]\n> extends Runnable<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"chat\"];\n\n  lc_serializable = true;\n\n  abstract inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  /**\n   * Method that takes an object of TypedPromptInputValues and returns a\n   * promise that resolves to an array of BaseMessage instances.\n   * @param values Object of TypedPromptInputValues\n   * @returns Formatted array of BaseMessages\n   */\n  abstract formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<RunOutput>;\n\n  /**\n   * Calls the formatMessages method with the provided input and options.\n   * @param input Input for the formatMessages method\n   * @param options Optional BaseCallbackConfig\n   * @returns Formatted output messages\n   */\n  async invoke(\n    input: RunInput,\n    options?: BaseCallbackConfig\n  ): Promise<RunOutput> {\n    return this._callWithConfig(\n      (input: RunInput) => this.formatMessages(input),\n      input,\n      { ...options, runType: \"prompt\" }\n    );\n  }\n}\n\n/**\n * Interface for the fields of a MessagePlaceholder.\n */\nexport interface MessagesPlaceholderFields<T extends string> {\n  variableName: T;\n  optional?: boolean;\n}\n\n/**\n * Class that represents a placeholder for messages in a chat prompt. It\n * extends the BaseMessagePromptTemplate.\n */\nexport class MessagesPlaceholder<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any\n  >\n  extends BaseMessagePromptTemplate<RunInput>\n  implements MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n{\n  static lc_name() {\n    return \"MessagesPlaceholder\";\n  }\n\n  variableName: Extract<keyof RunInput, string>;\n\n  optional: boolean;\n\n  constructor(variableName: Extract<keyof RunInput, string>);\n\n  constructor(\n    fields: MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n  );\n\n  constructor(\n    fields:\n      | Extract<keyof RunInput, string>\n      | MessagesPlaceholderFields<Extract<keyof RunInput, string>>\n  ) {\n    if (typeof fields === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      fields = { variableName: fields };\n    }\n    super(fields);\n    this.variableName = fields.variableName;\n    this.optional = fields.optional ?? false;\n  }\n\n  get inputVariables() {\n    return [this.variableName];\n  }\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const input = values[this.variableName];\n    if (this.optional && !input) {\n      return [];\n    } else if (!input) {\n      const error = new Error(\n        `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages as an input value. Received: undefined`\n      );\n      error.name = \"InputFormatError\";\n      throw error;\n    }\n\n    let formattedMessages;\n    try {\n      if (Array.isArray(input)) {\n        formattedMessages = input.map(coerceMessageLikeToMessage);\n      } else {\n        formattedMessages = [coerceMessageLikeToMessage(input)];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      const readableInput =\n        typeof input === \"string\" ? input : JSON.stringify(input, null, 2);\n      const error = new Error(\n        [\n          `Field \"${this.variableName}\" in prompt uses a MessagesPlaceholder, which expects an array of BaseMessages or coerceable values as input.`,\n          `Received value: ${readableInput}`,\n          `Additional message: ${e.message}`,\n        ].join(\"\\n\\n\")\n      );\n      error.name = \"InputFormatError\";\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (error as any).lc_error_code = e.lc_error_code;\n      throw error;\n    }\n\n    return formattedMessages;\n  }\n}\n\n/**\n * Interface for the fields of a MessageStringPromptTemplate.\n */\nexport interface MessageStringPromptTemplateFields<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends InputValues = any\n> {\n  prompt: BaseStringPromptTemplate<T, string>;\n}\n\n/**\n * Abstract class that serves as a base for creating message string prompt\n * templates. It extends the BaseMessagePromptTemplate.\n */\nexport abstract class BaseMessageStringPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends BaseMessagePromptTemplate<RunInput> {\n  prompt: BaseStringPromptTemplate<\n    InputValues<Extract<keyof RunInput, string>>,\n    string\n  >;\n\n  constructor(\n    prompt: BaseStringPromptTemplate<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields: MessageStringPromptTemplateFields<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields:\n      | MessageStringPromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<\n          InputValues<Extract<keyof RunInput, string>>,\n          string\n        >\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields };\n    }\n    super(fields);\n    this.prompt = fields.prompt;\n  }\n\n  get inputVariables() {\n    return this.prompt.inputVariables;\n  }\n\n  abstract format(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage>;\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    return [await this.format(values)];\n  }\n}\n\n/**\n * Abstract class that serves as a base for creating chat prompt\n * templates. It extends the BasePromptTemplate.\n */\nexport abstract class BaseChatPromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplate<\n  RunInput,\n  ChatPromptValueInterface,\n  PartialVariableName\n> {\n  constructor(input: BasePromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n  }\n\n  abstract formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]>;\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<string> {\n    return (await this.formatPromptValue(values)).toString();\n  }\n\n  async formatPromptValue(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<ChatPromptValueInterface> {\n    const resultMessages = await this.formatMessages(values);\n    return new ChatPromptValue(resultMessages);\n  }\n}\n\n/**\n * Interface for the fields of a ChatMessagePromptTemplate.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface ChatMessagePromptTemplateFields<T extends InputValues = any>\n  extends MessageStringPromptTemplateFields<T> {\n  role: string;\n}\n\n/**\n * Class that represents a chat message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nexport class ChatMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends BaseMessageStringPromptTemplate<RunInput> {\n  static lc_name() {\n    return \"ChatMessagePromptTemplate\";\n  }\n\n  role: string;\n\n  constructor(\n    prompt: BaseStringPromptTemplate<\n      InputValues<Extract<keyof RunInput, string>>\n    >,\n    role: string\n  );\n\n  constructor(\n    fields: ChatMessagePromptTemplateFields<\n      InputValues<Extract<keyof RunInput, string>>\n    >\n  );\n\n  constructor(\n    fields:\n      | ChatMessagePromptTemplateFields<\n          InputValues<Extract<keyof RunInput, string>>\n        >\n      | BaseStringPromptTemplate<InputValues<Extract<keyof RunInput, string>>>,\n    role?: string\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields, role: role! };\n    }\n    super(fields);\n    this.role = fields.role;\n  }\n\n  async format(values: RunInput): Promise<BaseMessage> {\n    return new ChatMessage(await this.prompt.format(values), this.role);\n  }\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(template: T, role: string, options?: { templateFormat?: TemplateFormat }) {\n    return new this(\n      PromptTemplate.fromTemplate<RunInput, T>(template, {\n        templateFormat: options?.templateFormat,\n      }),\n      role\n    );\n  }\n}\n\ninterface _TextTemplateParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  text?: string | Record<string, any>;\n}\n\nfunction isTextTemplateParam(param: unknown): param is _TextTemplateParam {\n  if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n    return false;\n  }\n  return (\n    Object.keys(param).length === 1 &&\n    \"text\" in param &&\n    typeof param.text === \"string\"\n  );\n}\n\ninterface _ImageTemplateParam {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  image_url?: string | Record<string, any>;\n}\n\nfunction isImageTemplateParam(param: unknown): param is _ImageTemplateParam {\n  if (param === null || typeof param !== \"object\" || Array.isArray(param)) {\n    return false;\n  }\n  return (\n    \"image_url\" in param &&\n    (typeof param.image_url === \"string\" ||\n      (typeof param.image_url === \"object\" &&\n        param.image_url !== null &&\n        \"url\" in param.image_url &&\n        typeof param.image_url.url === \"string\"))\n  );\n}\n\ntype MessageClass =\n  | typeof HumanMessage\n  | typeof AIMessage\n  | typeof SystemMessage;\n\ntype ChatMessageClass = typeof ChatMessage;\n\ninterface _StringImageMessagePromptTemplateOptions<\n  Format extends TemplateFormat = TemplateFormat\n> extends Record<string, unknown> {\n  templateFormat?: Format;\n}\n\nclass _StringImageMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  RunOutput extends BaseMessage[] = BaseMessage[]\n> extends BaseMessagePromptTemplate<RunInput, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"chat\"];\n\n  lc_serializable = true;\n\n  inputVariables: Array<Extract<keyof RunInput, string>> = [];\n\n  additionalOptions: _StringImageMessagePromptTemplateOptions = {};\n\n  prompt:\n    | BaseStringPromptTemplate<\n        InputValues<Extract<keyof RunInput, string>>,\n        string\n      >\n    | Array<\n        | BaseStringPromptTemplate<\n            InputValues<Extract<keyof RunInput, string>>,\n            string\n          >\n        | ImagePromptTemplate<\n            InputValues<Extract<keyof RunInput, string>>,\n            string\n          >\n        | MessageStringPromptTemplateFields<\n            InputValues<Extract<keyof RunInput, string>>\n          >\n        | DictPromptTemplate<InputValues<Extract<keyof RunInput, string>>>\n      >;\n\n  protected messageClass?: MessageClass;\n\n  static _messageClass(): MessageClass {\n    throw new Error(\n      \"Can not invoke _messageClass from inside _StringImageMessagePromptTemplate\"\n    );\n  }\n\n  // ChatMessage contains role field, others don't.\n  // Because of this, we have a separate class property for ChatMessage.\n  protected chatMessageClass?: ChatMessageClass;\n\n  constructor(\n    /** @TODO When we come up with a better way to type prompt templates, fix this */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    fields: any,\n    additionalOptions?: _StringImageMessagePromptTemplateOptions\n  ) {\n    if (!(\"prompt\" in fields)) {\n      // eslint-disable-next-line no-param-reassign\n      fields = { prompt: fields };\n    }\n    super(fields);\n    this.prompt = fields.prompt;\n    if (Array.isArray(this.prompt)) {\n      let inputVariables: Extract<keyof RunInput, string>[] = [];\n      this.prompt.forEach((prompt) => {\n        if (\"inputVariables\" in prompt) {\n          inputVariables = inputVariables.concat(prompt.inputVariables);\n        }\n      });\n      this.inputVariables = inputVariables;\n    } else {\n      this.inputVariables = this.prompt.inputVariables;\n    }\n    this.additionalOptions = additionalOptions ?? this.additionalOptions;\n  }\n\n  createMessage(content: MessageContent) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const constructor = this.constructor as any;\n    if (constructor._messageClass()) {\n      const MsgClass = constructor._messageClass();\n      return new MsgClass({ content });\n    } else if (constructor.chatMessageClass) {\n      const MsgClass = constructor.chatMessageClass();\n      // Assuming ChatMessage constructor also takes a content argument\n      return new MsgClass({\n        content,\n        role: this.getRoleFromMessageClass(MsgClass.lc_name()),\n      });\n    } else {\n      throw new Error(\"No message class defined\");\n    }\n  }\n\n  getRoleFromMessageClass(name: string) {\n    switch (name) {\n      case \"HumanMessage\":\n        return \"human\";\n      case \"AIMessage\":\n        return \"ai\";\n      case \"SystemMessage\":\n        return \"system\";\n      case \"ChatMessage\":\n        return \"chat\";\n      default:\n        throw new Error(\"Invalid message class name\");\n    }\n  }\n\n  static fromTemplate(\n    template:\n      | string\n      | Array<\n          | string\n          | _TextTemplateParam\n          | _ImageTemplateParam\n          | Record<string, unknown>\n        >,\n    additionalOptions?: _StringImageMessagePromptTemplateOptions\n  ) {\n    if (typeof template === \"string\") {\n      return new this(PromptTemplate.fromTemplate(template, additionalOptions));\n    }\n    const prompt: Array<\n      | PromptTemplate<InputValues>\n      | ImagePromptTemplate<InputValues>\n      | DictPromptTemplate\n    > = [];\n    for (const item of template) {\n      // handle string cases\n      if (typeof item === \"string\") {\n        prompt.push(PromptTemplate.fromTemplate(item, additionalOptions));\n      } else if (item === null) {\n        // pass\n      } else if (isTextTemplateParam(item)) {\n        let text = \"\";\n        if (typeof item.text === \"string\") {\n          text = item.text ?? \"\";\n        }\n\n        const options = {\n          ...additionalOptions,\n          additionalContentFields: item as ContentBlock,\n        };\n        prompt.push(PromptTemplate.fromTemplate(text, options));\n      } else if (isImageTemplateParam(item)) {\n        let imgTemplate = item.image_url ?? \"\";\n        let imgTemplateObject: ImagePromptTemplate<InputValues>;\n        let inputVariables: string[] = [];\n        if (typeof imgTemplate === \"string\") {\n          let parsedTemplate: ParsedTemplateNode[];\n          if (additionalOptions?.templateFormat === \"mustache\") {\n            parsedTemplate = parseMustache(imgTemplate);\n          } else {\n            parsedTemplate = parseFString(imgTemplate);\n          }\n\n          const variables = parsedTemplate.flatMap((item) =>\n            item.type === \"variable\" ? [item.name] : []\n          );\n\n          if ((variables?.length ?? 0) > 0) {\n            if (variables.length > 1) {\n              throw new Error(\n                `Only one format variable allowed per image template.\\nGot: ${variables}\\nFrom: ${imgTemplate}`\n              );\n            }\n            inputVariables = [variables[0]];\n          } else {\n            inputVariables = [];\n          }\n\n          imgTemplate = { url: imgTemplate };\n          imgTemplateObject = new ImagePromptTemplate<InputValues>({\n            template: imgTemplate,\n            inputVariables,\n            templateFormat: additionalOptions?.templateFormat,\n            additionalContentFields: item as ContentBlock,\n          });\n        } else if (typeof imgTemplate === \"object\") {\n          if (\"url\" in imgTemplate) {\n            let parsedTemplate: ParsedTemplateNode[];\n            if (additionalOptions?.templateFormat === \"mustache\") {\n              parsedTemplate = parseMustache(imgTemplate.url);\n            } else {\n              parsedTemplate = parseFString(imgTemplate.url);\n            }\n\n            inputVariables = parsedTemplate.flatMap((item) =>\n              item.type === \"variable\" ? [item.name] : []\n            );\n          } else {\n            inputVariables = [];\n          }\n          imgTemplateObject = new ImagePromptTemplate<InputValues>({\n            template: imgTemplate,\n            inputVariables,\n            templateFormat: additionalOptions?.templateFormat,\n            additionalContentFields: item as ContentBlock,\n          });\n        } else {\n          throw new Error(\"Invalid image template\");\n        }\n        prompt.push(imgTemplateObject);\n      } else if (typeof item === \"object\") {\n        prompt.push(\n          new DictPromptTemplate({\n            template: item,\n            templateFormat: additionalOptions?.templateFormat,\n          })\n        );\n      }\n    }\n    return new this({ prompt, additionalOptions });\n  }\n\n  async format(input: TypedPromptInputValues<RunInput>): Promise<BaseMessage> {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (this.prompt instanceof BaseStringPromptTemplate) {\n      const text = await this.prompt.format(input);\n\n      return this.createMessage(text);\n    } else {\n      const content: MessageContent = [];\n      for (const prompt of this.prompt) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let inputs: Record<string, any> = {};\n        if (!(\"inputVariables\" in prompt)) {\n          throw new Error(\n            `Prompt ${prompt} does not have inputVariables defined.`\n          );\n        }\n        for (const item of prompt.inputVariables) {\n          if (!inputs) {\n            inputs = { [item]: input[item] };\n          }\n          inputs = { ...inputs, [item]: input[item] };\n        }\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (prompt instanceof BaseStringPromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          if (formatted !== \"\") {\n            content.push({\n              ...additionalContentFields,\n              type: \"text\",\n              text: formatted,\n            });\n          }\n          /** @TODO replace this */\n          // eslint-disable-next-line no-instanceof/no-instanceof\n        } else if (prompt instanceof ImagePromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          content.push({\n            ...additionalContentFields,\n            type: \"image_url\",\n            image_url: formatted,\n          });\n          // eslint-disable-next-line no-instanceof/no-instanceof\n        } else if (prompt instanceof DictPromptTemplate) {\n          const formatted = await prompt.format(\n            inputs as TypedPromptInputValues<RunInput>\n          );\n          let additionalContentFields: ContentBlock | undefined;\n          if (\"additionalContentFields\" in prompt) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            additionalContentFields = prompt.additionalContentFields as any;\n          }\n          content.push({\n            ...additionalContentFields,\n            ...formatted,\n          } as ContentBlock);\n        }\n      }\n      return this.createMessage(content);\n    }\n  }\n\n  async formatMessages(values: RunInput): Promise<RunOutput> {\n    return [await this.format(values)] as BaseMessage[] as RunOutput;\n  }\n}\n\n/**\n * Class that represents a human message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = HumanMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class HumanMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof HumanMessage {\n    return HumanMessage;\n  }\n\n  static lc_name() {\n    return \"HumanMessagePromptTemplate\";\n  }\n}\n\n/**\n * Class that represents an AI message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n */\nexport class AIMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof AIMessage {\n    return AIMessage;\n  }\n\n  static lc_name() {\n    return \"AIMessagePromptTemplate\";\n  }\n}\n\n/**\n * Class that represents a system message prompt template. It extends the\n * BaseMessageStringPromptTemplate.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const formatted = await message.format({ text: \"Hello world!\" });\n *\n * const chatPrompt = ChatPromptTemplate.fromMessages([message]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class SystemMessagePromptTemplate<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any\n> extends _StringImageMessagePromptTemplate<RunInput> {\n  static _messageClass(): typeof SystemMessage {\n    return SystemMessage;\n  }\n\n  static lc_name() {\n    return \"SystemMessagePromptTemplate\";\n  }\n}\n\n/**\n * Interface for the input of a ChatPromptTemplate.\n */\nexport interface ChatPromptTemplateInput<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  PartialVariableName extends string = any\n> extends BasePromptTemplateInput<RunInput, PartialVariableName> {\n  /**\n   * The prompt messages\n   */\n  promptMessages: Array<BaseMessagePromptTemplate | BaseMessage>;\n\n  /**\n   * Whether to try validating the template on initialization\n   *\n   * @defaultValue `true`\n   */\n  validateTemplate?: boolean;\n\n  /**\n   * The formatting method to use on the prompt.\n   * @default \"f-string\"\n   */\n  templateFormat?: TemplateFormat;\n}\n\nexport type BaseMessagePromptTemplateLike =\n  | BaseMessagePromptTemplate\n  | BaseMessageLike;\n\nfunction _isBaseMessagePromptTemplate(\n  baseMessagePromptTemplateLike: BaseMessagePromptTemplateLike\n): baseMessagePromptTemplateLike is BaseMessagePromptTemplate {\n  return (\n    typeof (baseMessagePromptTemplateLike as BaseMessagePromptTemplate)\n      .formatMessages === \"function\"\n  );\n}\n\nfunction _coerceMessagePromptTemplateLike<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput extends InputValues = any,\n  Extra extends Omit<\n    ChatPromptTemplateInput<RunInput>,\n    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n  > = Omit<\n    ChatPromptTemplateInput<RunInput>,\n    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n  >\n>(\n  messagePromptTemplateLike: BaseMessagePromptTemplateLike,\n  extra?: Extra\n): BaseMessagePromptTemplate | BaseMessage {\n  if (\n    _isBaseMessagePromptTemplate(messagePromptTemplateLike) ||\n    isBaseMessage(messagePromptTemplateLike)\n  ) {\n    return messagePromptTemplateLike;\n  }\n  if (\n    Array.isArray(messagePromptTemplateLike) &&\n    messagePromptTemplateLike[0] === \"placeholder\"\n  ) {\n    const messageContent = messagePromptTemplateLike[1];\n    if (\n      extra?.templateFormat === \"mustache\" &&\n      typeof messageContent === \"string\" &&\n      messageContent.slice(0, 2) === \"{{\" &&\n      messageContent.slice(-2) === \"}}\"\n    ) {\n      const variableName = messageContent.slice(2, -2);\n      return new MessagesPlaceholder({ variableName, optional: true });\n    } else if (\n      typeof messageContent === \"string\" &&\n      messageContent[0] === \"{\" &&\n      messageContent[messageContent.length - 1] === \"}\"\n    ) {\n      const variableName = messageContent.slice(1, -1);\n      return new MessagesPlaceholder({ variableName, optional: true });\n    }\n    throw new Error(\n      `Invalid placeholder template for format ${\n        extra?.templateFormat ?? `\"f-string\"`\n      }: \"${\n        messagePromptTemplateLike[1]\n      }\". Expected a variable name surrounded by ${\n        extra?.templateFormat === \"mustache\" ? \"double\" : \"single\"\n      } curly braces.`\n    );\n  }\n  const message = coerceMessageLikeToMessage(messagePromptTemplateLike);\n  let templateData:\n    | string\n    | (\n        | string\n        | _TextTemplateParam\n        | _ImageTemplateParam\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        | Record<string, any>\n      )[];\n\n  if (typeof message.content === \"string\") {\n    templateData = message.content;\n  } else {\n    // Assuming message.content is an array of complex objects, transform it.\n    templateData = message.content.map((item) => {\n      if (\"text\" in item) {\n        return { ...item, text: item.text };\n      } else if (\"image_url\" in item) {\n        return { ...item, image_url: item.image_url };\n      } else {\n        return item;\n      }\n    });\n  }\n\n  if (message._getType() === \"human\") {\n    return HumanMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (message._getType() === \"ai\") {\n    return AIMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (message._getType() === \"system\") {\n    return SystemMessagePromptTemplate.fromTemplate(templateData, extra);\n  } else if (ChatMessage.isInstance(message)) {\n    return ChatMessagePromptTemplate.fromTemplate(\n      message.content as string,\n      message.role,\n      extra\n    );\n  } else {\n    throw new Error(\n      `Could not coerce message prompt template from input. Received message type: \"${message._getType()}\".`\n    );\n  }\n}\n\nfunction isMessagesPlaceholder(\n  x: BaseMessagePromptTemplate | BaseMessage\n): x is MessagesPlaceholder {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return (x.constructor as any).lc_name() === \"MessagesPlaceholder\";\n}\n\n/**\n * Class that represents a chat prompt. It extends the\n * BaseChatPromptTemplate and uses an array of BaseMessagePromptTemplate\n * instances to format a series of messages for a conversation.\n * @example\n * ```typescript\n * const message = SystemMessagePromptTemplate.fromTemplate(\"{text}\");\n * const chatPrompt = ChatPromptTemplate.fromMessages([\n *   [\"ai\", \"You are a helpful assistant.\"],\n *   message,\n * ]);\n * const formattedChatPrompt = await chatPrompt.invoke({\n *   text: \"Hello world!\",\n * });\n * ```\n */\nexport class ChatPromptTemplate<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    PartialVariableName extends string = any\n  >\n  extends BaseChatPromptTemplate<RunInput, PartialVariableName>\n  implements ChatPromptTemplateInput<RunInput, PartialVariableName>\n{\n  static lc_name() {\n    return \"ChatPromptTemplate\";\n  }\n\n  get lc_aliases(): Record<string, string> {\n    return {\n      promptMessages: \"messages\",\n    };\n  }\n\n  promptMessages: Array<BaseMessagePromptTemplate | BaseMessage>;\n\n  validateTemplate = true;\n\n  templateFormat: TemplateFormat = \"f-string\";\n\n  constructor(input: ChatPromptTemplateInput<RunInput, PartialVariableName>) {\n    super(input);\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (\n      input.templateFormat === \"mustache\" &&\n      input.validateTemplate === undefined\n    ) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n\n    if (this.validateTemplate) {\n      const inputVariablesMessages = new Set<string>();\n      for (const promptMessage of this.promptMessages) {\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        if (promptMessage instanceof BaseMessage) continue;\n        for (const inputVariable of promptMessage.inputVariables) {\n          inputVariablesMessages.add(inputVariable);\n        }\n      }\n\n      const totalInputVariables = this.inputVariables as string[];\n      const inputVariablesInstance = new Set(\n        this.partialVariables\n          ? totalInputVariables.concat(Object.keys(this.partialVariables))\n          : totalInputVariables\n      );\n      const difference = new Set(\n        [...inputVariablesInstance].filter(\n          (x) => !inputVariablesMessages.has(x)\n        )\n      );\n      if (difference.size > 0) {\n        throw new Error(\n          `Input variables \\`${[\n            ...difference,\n          ]}\\` are not used in any of the prompt messages.`\n        );\n      }\n      const otherDifference = new Set(\n        [...inputVariablesMessages].filter(\n          (x) => !inputVariablesInstance.has(x)\n        )\n      );\n      if (otherDifference.size > 0) {\n        throw new Error(\n          `Input variables \\`${[\n            ...otherDifference,\n          ]}\\` are used in prompt messages but not in the prompt template.`\n        );\n      }\n    }\n  }\n\n  _getPromptType(): \"chat\" {\n    return \"chat\";\n  }\n\n  private async _parseImagePrompts(\n    message: BaseMessage,\n    inputValues: InputValues<\n      PartialVariableName | Extract<keyof RunInput, string>\n    >\n  ): Promise<BaseMessage> {\n    if (typeof message.content === \"string\") {\n      return message;\n    }\n    const formattedMessageContent = await Promise.all(\n      message.content.map(async (item) => {\n        if (item.type !== \"image_url\") {\n          return item;\n        }\n\n        let imageUrl = \"\";\n        if (typeof item.image_url === \"string\") {\n          imageUrl = item.image_url;\n        } else if (\n          typeof item.image_url === \"object\" &&\n          item.image_url !== null &&\n          \"url\" in item.image_url &&\n          typeof item.image_url.url === \"string\"\n        ) {\n          imageUrl = item.image_url.url;\n        }\n\n        const promptTemplatePlaceholder = PromptTemplate.fromTemplate(\n          imageUrl,\n          {\n            templateFormat: this.templateFormat,\n          }\n        );\n        const formattedUrl = await promptTemplatePlaceholder.format(\n          inputValues\n        );\n\n        if (\n          typeof item.image_url === \"object\" &&\n          item.image_url !== null &&\n          \"url\" in item.image_url\n        ) {\n          // eslint-disable-next-line no-param-reassign\n          item.image_url.url = formattedUrl;\n        } else {\n          item.image_url = formattedUrl;\n        }\n        return item;\n      })\n    );\n    message.content = formattedMessageContent;\n    return message;\n  }\n\n  async formatMessages(\n    values: TypedPromptInputValues<RunInput>\n  ): Promise<BaseMessage[]> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    let resultMessages: BaseMessage[] = [];\n\n    for (const promptMessage of this.promptMessages) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (promptMessage instanceof BaseMessage) {\n        resultMessages.push(\n          await this._parseImagePrompts(promptMessage, allValues)\n        );\n      } else {\n        let inputValues: InputValues;\n\n        if (this.templateFormat === \"mustache\") {\n          inputValues = { ...allValues };\n        } else {\n          inputValues = promptMessage.inputVariables.reduce(\n            (acc, inputVariable) => {\n              if (\n                !(inputVariable in allValues) &&\n                !(\n                  isMessagesPlaceholder(promptMessage) && promptMessage.optional\n                )\n              ) {\n                const error = addLangChainErrorFields(\n                  new Error(\n                    `Missing value for input variable \\`${inputVariable.toString()}\\``\n                  ),\n                  \"INVALID_PROMPT_INPUT\"\n                );\n                throw error;\n              }\n              acc[inputVariable] = allValues[inputVariable];\n              return acc;\n            },\n            {} as InputValues\n          );\n        }\n        const message = await promptMessage.formatMessages(inputValues);\n        resultMessages = resultMessages.concat(message);\n      }\n    }\n    return resultMessages;\n  }\n\n  async partial<NewPartialVariableName extends string>(\n    values: PartialValues<NewPartialVariableName>\n  ) {\n    // This is implemented in a way it doesn't require making\n    // BaseMessagePromptTemplate aware of .partial()\n    const newInputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    ) as Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>[];\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    } as PartialValues<PartialVariableName | NewPartialVariableName>;\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables,\n    };\n    return new ChatPromptTemplate<\n      InputValues<\n        Exclude<Extract<keyof RunInput, string>, NewPartialVariableName>\n      >\n    >(promptDict);\n  }\n\n  /**\n   * Load prompt template from a template f-string\n   */\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"f-string\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string>,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput>>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, \"mustache\">,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<InputValues>;\n\n  static fromTemplate<\n    RunInput extends InputValues = Symbol,\n    T extends string = string\n  >(\n    template: T,\n    options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >\n  ): ChatPromptTemplate<ExtractedFStringParams<T, RunInput> | InputValues> {\n    const prompt = PromptTemplate.fromTemplate(template, options);\n    const humanTemplate = new HumanMessagePromptTemplate({ prompt });\n    return this.fromMessages<\n      RunInput extends Symbol ? ParamsFromFString<T> : RunInput\n    >([humanTemplate]);\n  }\n\n  /**\n   * Create a chat model-specific prompt from individual chat messages\n   * or message-like tuples.\n   * @param promptMessages Messages to be passed to the chat model\n   * @returns A new ChatPromptTemplate\n   */\n  static fromMessages<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    RunInput extends InputValues = any,\n    Extra extends ChatPromptTemplateInput<RunInput> = ChatPromptTemplateInput<RunInput>\n  >(\n    promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[],\n    extra?: Omit<\n      Extra,\n      \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n    >\n  ): ChatPromptTemplate<RunInput> {\n    const flattenedMessages = promptMessages.reduce(\n      (acc: Array<BaseMessagePromptTemplate | BaseMessage>, promptMessage) =>\n        acc.concat(\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          promptMessage instanceof ChatPromptTemplate\n            ? promptMessage.promptMessages\n            : [\n                _coerceMessagePromptTemplateLike<\n                  RunInput,\n                  Omit<\n                    Extra,\n                    \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n                  >\n                >(promptMessage, extra),\n              ]\n        ),\n      []\n    );\n    const flattenedPartialVariables = promptMessages.reduce(\n      (acc, promptMessage) =>\n        // eslint-disable-next-line no-instanceof/no-instanceof\n        promptMessage instanceof ChatPromptTemplate\n          ? Object.assign(acc, promptMessage.partialVariables)\n          : acc,\n      Object.create(null) as PartialValues\n    );\n    const inputVariables = new Set<string>();\n    for (const promptMessage of flattenedMessages) {\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (promptMessage instanceof BaseMessage) continue;\n      for (const inputVariable of promptMessage.inputVariables) {\n        if (inputVariable in flattenedPartialVariables) {\n          continue;\n        }\n        inputVariables.add(inputVariable);\n      }\n    }\n    return new this<RunInput>({\n      ...extra,\n      inputVariables: [...inputVariables] as Extract<keyof RunInput, string>[],\n      promptMessages: flattenedMessages,\n      partialVariables: flattenedPartialVariables,\n      templateFormat: extra?.templateFormat,\n    });\n  }\n}\n","import {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"./transform.js\";\nimport { Operation, compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nimport { ChatGeneration, Generation } from \"../outputs.js\";\n\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\n\nexport interface XMLOutputParserFields\n  extends BaseCumulativeTransformOutputParserInput {\n  /**\n   * Optional list of tags that the output should conform to.\n   * Only used in formatting of the prompt.\n   */\n  tags?: string[];\n}\n\nexport type Content = string | undefined | Array<{ [key: string]: Content }>;\n\nexport type XMLResult = {\n  [key: string]: Content;\n};\n\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser<XMLResult> {\n  tags?: string[];\n\n  constructor(fields?: XMLOutputParserFields) {\n    super(fields);\n\n    this.tags = fields?.tags;\n  }\n\n  static lc_name() {\n    return \"XMLOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\"];\n\n  lc_serializable = true;\n\n  protected _diff(\n    prev: unknown | undefined,\n    next: unknown\n  ): Operation[] | undefined {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{ op: \"replace\", path: \"\", value: next }];\n    }\n    return compare(prev, next);\n  }\n\n  async parsePartialResult(\n    generations: ChatGeneration[] | Generation[]\n  ): Promise<XMLResult | undefined> {\n    return parseXMLMarkdown(generations[0].text);\n  }\n\n  async parse(text: string): Promise<XMLResult> {\n    return parseXMLMarkdown(text);\n  }\n\n  getFormatInstructions(): string {\n    const withTags = !!(this.tags && this.tags.length > 0);\n    return withTags\n      ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n      : XML_FORMAT_INSTRUCTIONS;\n  }\n}\n\nconst strip = (text: string) =>\n  text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\n\ntype ParsedResult = {\n  name: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  attributes: Record<string, any>;\n  children: Array<ParsedResult>;\n  text?: string;\n  isSelfClosing: boolean;\n};\n\nconst parseParsedResult = (input: ParsedResult): XMLResult => {\n  if (Object.keys(input).length === 0) {\n    return {};\n  }\n  const result: XMLResult = {};\n  if (input.children.length > 0) {\n    result[input.name] = input.children.map(parseParsedResult);\n    return result;\n  } else {\n    result[input.name] = input.text ?? undefined;\n    return result;\n  }\n};\n\nexport function parseXMLMarkdown(s: string): XMLResult {\n  const cleanedString = strip(s);\n  const parser = sax.parser(true);\n  let parsedResult: ParsedResult = {} as ParsedResult;\n  const elementStack: ParsedResult[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onopentag = (node: any) => {\n    const element = {\n      name: node.name,\n      attributes: node.attributes,\n      children: [],\n      text: \"\",\n      isSelfClosing: node.isSelfClosing,\n    };\n\n    if (elementStack.length > 0) {\n      const parentElement = elementStack[elementStack.length - 1];\n      parentElement.children.push(element);\n    } else {\n      parsedResult = element as ParsedResult;\n    }\n\n    if (!node.isSelfClosing) {\n      elementStack.push(element);\n    }\n  };\n\n  parser.onclosetag = () => {\n    if (elementStack.length > 0) {\n      const lastElement = elementStack.pop();\n      if (elementStack.length === 0 && lastElement) {\n        parsedResult = lastElement as ParsedResult;\n      }\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.ontext = (text: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.text += text;\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onattribute = (attr: any) => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.attributes[attr.name] = attr.value;\n    }\n  };\n\n  // Try to find XML string within triple backticks.\n  const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  const xmlString = match ? match[2] : cleanedString;\n  parser.write(xmlString).close();\n\n  // Remove the XML declaration if present\n  if (parsedResult && parsedResult.name === \"?xml\") {\n    parsedResult = parsedResult.children[0] as ParsedResult;\n  }\n\n  return parseParsedResult(parsedResult);\n}\n","import type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { SerializedBasePromptTemplate } from \"./serde.js\";\nimport { BasePromptTemplate, type BasePromptTemplateInput } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n\n/**\n * Type that includes the name of the prompt and the prompt itself.\n */\nexport type PipelinePromptParams<\n  PromptTemplateType extends BasePromptTemplate\n> = {\n  name: string;\n  prompt: PromptTemplateType;\n};\n\n/**\n * Type that extends the BasePromptTemplateInput type, excluding the\n * inputVariables property. It includes an array of pipelinePrompts and a\n * finalPrompt.\n */\nexport type PipelinePromptTemplateInput<\n  PromptTemplateType extends BasePromptTemplate\n> = Omit<BasePromptTemplateInput, \"inputVariables\"> & {\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n  finalPrompt: PromptTemplateType;\n};\n\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate<\n  PromptTemplateType extends BasePromptTemplate\n> extends BasePromptTemplate {\n  static lc_name() {\n    return \"PipelinePromptTemplate\";\n  }\n\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n\n  finalPrompt: PromptTemplateType;\n\n  constructor(input: PipelinePromptTemplateInput<PromptTemplateType>) {\n    super({ ...input, inputVariables: [] });\n    this.pipelinePrompts = input.pipelinePrompts;\n    this.finalPrompt = input.finalPrompt;\n    this.inputVariables = this.computeInputValues();\n  }\n\n  /**\n   * Computes the input values required by the pipeline prompts.\n   * @returns Array of input values required by the pipeline prompts.\n   */\n  protected computeInputValues() {\n    const intermediateValues = this.pipelinePrompts.map(\n      (pipelinePrompt) => pipelinePrompt.name\n    );\n    const inputValues = this.pipelinePrompts\n      .map((pipelinePrompt) =>\n        pipelinePrompt.prompt.inputVariables.filter(\n          (inputValue) => !intermediateValues.includes(inputValue)\n        )\n      )\n      .flat();\n    return [...new Set(inputValues)];\n  }\n\n  protected static extractRequiredInputValues(\n    allValues: InputValues,\n    requiredValueNames: string[]\n  ) {\n    return requiredValueNames.reduce((requiredValues, valueName) => {\n      requiredValues[valueName] = allValues[valueName];\n      return requiredValues;\n    }, {} as InputValues);\n  }\n\n  /**\n   * Formats the pipeline prompts based on the provided input values.\n   * @param values Input values to format the pipeline prompts.\n   * @returns Promise that resolves with the formatted input values.\n   */\n  protected async formatPipelinePrompts(\n    values: InputValues\n  ): Promise<InputValues> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this\n      .pipelinePrompts) {\n      const pipelinePromptInputValues =\n        PipelinePromptTemplate.extractRequiredInputValues(\n          allValues,\n          pipelinePrompt.inputVariables\n        );\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (pipelinePrompt instanceof ChatPromptTemplate) {\n        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(\n          pipelinePromptInputValues\n        );\n      } else {\n        allValues[pipelinePromptName] = await pipelinePrompt.format(\n          pipelinePromptInputValues\n        );\n      }\n    }\n    return PipelinePromptTemplate.extractRequiredInputValues(\n      allValues,\n      this.finalPrompt.inputVariables\n    );\n  }\n\n  /**\n   * Formats the final prompt value based on the provided input values.\n   * @param values Input values to format the final prompt value.\n   * @returns Promise that resolves with the formatted final prompt value.\n   */\n  async formatPromptValue(\n    values: InputValues\n  ): Promise<PromptTemplateType[\"PromptValueReturnType\"]> {\n    return this.finalPrompt.formatPromptValue(\n      await this.formatPipelinePrompts(values)\n    );\n  }\n\n  async format(values: InputValues): Promise<string> {\n    return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n  }\n\n  /**\n   * Handles partial prompts, which are prompts that have been partially\n   * filled with input values.\n   * @param values Partial input values.\n   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n   */\n  async partial(\n    values: PartialValues\n  ): Promise<PipelinePromptTemplate<PromptTemplateType>> {\n    const promptDict = { ...this };\n    promptDict.inputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    return new PipelinePromptTemplate<PromptTemplateType>(promptDict);\n  }\n\n  serialize(): SerializedBasePromptTemplate {\n    throw new Error(\"Not implemented.\");\n  }\n\n  _getPromptType(): string {\n    return \"pipeline\";\n  }\n}\n","import { EmptyChannelError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * A configurable PubSub Topic.\n */\nexport class Topic<Value> extends BaseChannel<\n  Array<Value>,\n  Value | Value[],\n  [Value[], Value[]]\n> {\n  lc_graph_name = \"Topic\";\n\n  unique = false;\n\n  accumulate = false;\n\n  seen: Set<Value>;\n\n  values: Value[];\n\n  constructor(fields?: {\n    /**\n     * Whether to only add unique values to the topic. If `true`, only unique values (using reference equality) will be added to the topic.\n     */\n    unique?: boolean;\n    /**\n     * Whether to accumulate values across steps. If `false`, the channel will be emptied after each step.\n     */\n    accumulate?: boolean;\n  }) {\n    super();\n\n    this.unique = fields?.unique ?? this.unique;\n    this.accumulate = fields?.accumulate ?? this.accumulate;\n    // State\n    this.seen = new Set<Value>();\n    this.values = [];\n  }\n\n  public fromCheckpoint(checkpoint?: [Value[], Value[]]) {\n    const empty = new Topic<Value>({\n      unique: this.unique,\n      accumulate: this.accumulate,\n    });\n    if (typeof checkpoint !== \"undefined\") {\n      empty.seen = new Set(checkpoint[0]);\n      // eslint-disable-next-line prefer-destructuring\n      empty.values = checkpoint[1];\n    }\n    return empty as this;\n  }\n\n  public update(values: Array<Value | Value[]>): boolean {\n    let updated = false;\n    if (!this.accumulate) {\n      updated = this.values.length > 0;\n      this.values = [];\n    }\n    const flatValues = values.flat() as Value[];\n    if (flatValues.length > 0) {\n      if (this.unique) {\n        for (const value of flatValues) {\n          if (!this.seen.has(value)) {\n            updated = true;\n            this.seen.add(value);\n            this.values.push(value);\n          }\n        }\n      } else {\n        updated = true;\n        this.values.push(...flatValues);\n      }\n    }\n    return updated;\n  }\n\n  public get(): Array<Value> {\n    if (this.values.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.values;\n  }\n\n  public checkpoint(): [Value[], Value[]] {\n    return [[...this.seen], this.values];\n  }\n\n  isAvailable(): boolean {\n    return this.values.length !== 0;\n  }\n}\n","import { concat } from \"../utils/stream.js\";\nimport {\n  Runnable,\n  RunnableAssign,\n  RunnableMap,\n  RunnableMapLike,\n} from \"./base.js\";\nimport { ensureConfig, type RunnableConfig } from \"./config.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype RunnablePassthroughFunc<RunInput = any> =\n  | ((input: RunInput) => void)\n  | ((input: RunInput, config?: RunnableConfig) => void)\n  | ((input: RunInput) => Promise<void>)\n  | ((input: RunInput, config?: RunnableConfig) => Promise<void>);\n\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough<RunInput = any> extends Runnable<\n  RunInput,\n  RunInput\n> {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  func?: RunnablePassthroughFunc<RunInput>;\n\n  constructor(fields?: { func?: RunnablePassthroughFunc<RunInput> }) {\n    super(fields);\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n\n  async invoke(\n    input: RunInput,\n    options?: Partial<RunnableConfig>\n  ): Promise<RunInput> {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n\n    return this._callWithConfig(\n      (input: RunInput) => Promise.resolve(input),\n      input,\n      config\n    );\n  }\n\n  async *transform(\n    generator: AsyncGenerator<RunInput>,\n    options: Partial<RunnableConfig>\n  ): AsyncGenerator<RunInput> {\n    const config = ensureConfig(options);\n    let finalOutput: RunInput | undefined;\n    let finalOutputSupported = true;\n\n    for await (const chunk of this._transformStreamWithConfig(\n      generator,\n      (input: AsyncGenerator<RunInput>) => input,\n      config\n    )) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk as any);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({ model: \"gpt-4o-mini\" }).withConfig({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign<\n    RunInput extends Record<string, unknown> = Record<string, unknown>,\n    RunOutput extends Record<string, unknown> = Record<string, unknown>\n  >(\n    mapping: RunnableMapLike<RunInput, RunOutput>\n  ): RunnableAssign<RunInput, RunInput & RunOutput> {\n    return new RunnableAssign(new RunnableMap({ steps: mapping }));\n  }\n}\n","import {\n  type Client,\n  type LangSmithTracingClientInterface,\n  getDefaultProjectName,\n} from \"langsmith\";\nimport { RunTree, type RunTreeConfig } from \"langsmith/run_trees\";\nimport { getCurrentRunTree } from \"langsmith/singletons/traceable\";\n\nimport {\n  BaseRun,\n  RunCreate,\n  RunUpdate as BaseRunUpdate,\n  KVMap,\n} from \"langsmith/schemas\";\nimport { BaseTracer } from \"./base.js\";\nimport { BaseCallbackHandlerInput } from \"../callbacks/base.js\";\nimport { getDefaultLangChainClientSingleton } from \"../singletons/tracer.js\";\n\nexport interface Run extends BaseRun {\n  id: string;\n  child_runs: this[];\n  child_execution_order: number;\n  dotted_order?: string;\n  trace_id?: string;\n}\n\nexport interface RunCreate2 extends RunCreate {\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface RunUpdate extends BaseRunUpdate {\n  events: BaseRun[\"events\"];\n  inputs: KVMap;\n  trace_id?: string;\n  dotted_order?: string;\n}\n\nexport interface LangChainTracerFields extends BaseCallbackHandlerInput {\n  exampleId?: string;\n  projectName?: string;\n  client?: LangSmithTracingClientInterface;\n  replicas?: RunTreeConfig[\"replicas\"];\n}\n\nexport class LangChainTracer\n  extends BaseTracer\n  implements LangChainTracerFields\n{\n  name = \"langchain_tracer\";\n\n  projectName?: string;\n\n  exampleId?: string;\n\n  client: LangSmithTracingClientInterface;\n\n  replicas?: RunTreeConfig[\"replicas\"];\n\n  usesRunTreeMap = true;\n\n  constructor(fields: LangChainTracerFields = {}) {\n    super(fields);\n    const { exampleId, projectName, client, replicas } = fields;\n\n    this.projectName = projectName ?? getDefaultProjectName();\n    this.replicas = replicas;\n    this.exampleId = exampleId;\n    this.client = client ?? getDefaultLangChainClientSingleton();\n\n    const traceableTree = LangChainTracer.getTraceableRunTree();\n    if (traceableTree) {\n      this.updateFromRunTree(traceableTree);\n    }\n  }\n\n  protected async persistRun(_run: Run): Promise<void> {\n    // empty\n  }\n\n  async onRunCreate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.postRun();\n  }\n\n  async onRunUpdate(run: Run): Promise<void> {\n    const runTree = this.getRunTreeWithTracingConfig(run.id);\n    await runTree?.patchRun();\n  }\n\n  getRun(id: string): Run | undefined {\n    return this.runTreeMap.get(id);\n  }\n\n  updateFromRunTree(runTree: RunTree) {\n    this.runTreeMap.set(runTree.id, runTree);\n    let rootRun: RunTree = runTree;\n    const visited = new Set<string>();\n    while (rootRun.parent_run) {\n      if (visited.has(rootRun.id)) break;\n      visited.add(rootRun.id);\n\n      if (!rootRun.parent_run) break;\n      rootRun = rootRun.parent_run as RunTree;\n    }\n    visited.clear();\n\n    const queue = [rootRun];\n    while (queue.length > 0) {\n      const current = queue.shift();\n      if (!current || visited.has(current.id)) continue;\n      visited.add(current.id);\n\n      this.runTreeMap.set(current.id, current);\n      if (current.child_runs) {\n        queue.push(...current.child_runs);\n      }\n    }\n\n    this.client = runTree.client ?? this.client;\n    this.replicas = runTree.replicas ?? this.replicas;\n    this.projectName = runTree.project_name ?? this.projectName;\n    this.exampleId = runTree.reference_example_id ?? this.exampleId;\n  }\n\n  getRunTreeWithTracingConfig(id: string): RunTree | undefined {\n    const runTree = this.runTreeMap.get(id);\n    if (!runTree) return undefined;\n\n    return new RunTree({\n      ...runTree,\n      client: this.client as Client,\n      project_name: this.projectName,\n      replicas: this.replicas,\n      reference_example_id: this.exampleId,\n      tracingEnabled: true,\n    });\n  }\n\n  static getTraceableRunTree(): RunTree | undefined {\n    try {\n      return (\n        // The type cast here provides forward compatibility. Old versions of LangSmith will just\n        // ignore the permitAbsentRunTree arg.\n        (\n          getCurrentRunTree as (\n            permitAbsentRunTree: boolean\n          ) => ReturnType<typeof getCurrentRunTree> | undefined\n        )(true)\n      );\n    } catch {\n      return undefined;\n    }\n  }\n}\n","// @ts-nocheck\n\n// Inlined because of ESM import issues\n\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\n\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function hasOwnProperty(obj, key) {\n  return _hasOwnProperty.call(obj, key);\n}\nexport function _objectKeys(obj) {\n  if (Array.isArray(obj)) {\n    const keys = new Array(obj.length);\n    for (let k = 0; k < keys.length; k++) {\n      keys[k] = \"\" + k;\n    }\n    return keys;\n  }\n  if (Object.keys) {\n    return Object.keys(obj);\n  }\n  let keys = [];\n  for (let i in obj) {\n    if (hasOwnProperty(obj, i)) {\n      keys.push(i);\n    }\n  }\n  return keys;\n}\n/**\n * Deeply clone the object.\n * https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n * @param  {any} obj value to clone\n * @return {any} cloned obj\n */\nexport function _deepClone(obj) {\n  switch (typeof obj) {\n    case \"object\":\n      return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n    case \"undefined\":\n      return null; //this is how JSON.stringify behaves for array items\n    default:\n      return obj; //no need to clone primitives\n  }\n}\n//3x faster than cached /^\\d+$/.test(str)\nexport function isInteger(str: string): boolean {\n  let i = 0;\n  const len = str.length;\n  let charCode;\n  while (i < len) {\n    charCode = str.charCodeAt(i);\n    if (charCode >= 48 && charCode <= 57) {\n      i++;\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n/**\n * Escapes a json pointer path\n * @param path The raw pointer\n * @return the Escaped path\n */\nexport function escapePathComponent(path: string): string {\n  if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1) return path;\n  return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nexport function unescapePathComponent(path: string): string {\n  return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n\nexport function _getPathRecursive(root: Object, obj: Object): string {\n  let found;\n  for (let key in root) {\n    if (hasOwnProperty(root, key)) {\n      if (root[key] === obj) {\n        return escapePathComponent(key) + \"/\";\n      } else if (typeof root[key] === \"object\") {\n        found = _getPathRecursive(root[key], obj);\n        if (found != \"\") {\n          return escapePathComponent(key) + \"/\" + found;\n        }\n      }\n    }\n  }\n  return \"\";\n}\n\nexport function getPath(root: Object, obj: Object): string {\n  if (root === obj) {\n    return \"/\";\n  }\n  const path = _getPathRecursive(root, obj);\n  if (path === \"\") {\n    throw new Error(\"Object not found in root\");\n  }\n  return `/${path}`;\n}\n/**\n * Recursively checks whether an object has any undefined values inside.\n */\nexport function hasUndefined(obj: any): boolean {\n  if (obj === undefined) {\n    return true;\n  }\n  if (obj) {\n    if (Array.isArray(obj)) {\n      for (let i = 0, len = obj.length; i < len; i++) {\n        if (hasUndefined(obj[i])) {\n          return true;\n        }\n      }\n    } else if (typeof obj === \"object\") {\n      const objKeys = _objectKeys(obj);\n      const objKeysLength = objKeys.length;\n      for (var i = 0; i < objKeysLength; i++) {\n        if (hasUndefined(obj[objKeys[i]])) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport type JsonPatchErrorName =\n  | \"SEQUENCE_NOT_AN_ARRAY\"\n  | \"OPERATION_NOT_AN_OBJECT\"\n  | \"OPERATION_OP_INVALID\"\n  | \"OPERATION_PATH_INVALID\"\n  | \"OPERATION_FROM_REQUIRED\"\n  | \"OPERATION_VALUE_REQUIRED\"\n  | \"OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED\"\n  | \"OPERATION_PATH_CANNOT_ADD\"\n  | \"OPERATION_PATH_UNRESOLVABLE\"\n  | \"OPERATION_FROM_UNRESOLVABLE\"\n  | \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\"\n  | \"OPERATION_VALUE_OUT_OF_BOUNDS\"\n  | \"TEST_OPERATION_FAILED\";\n\nfunction patchErrorMessageFormatter(message: String, args: Object): string {\n  const messageParts = [message];\n  for (const key in args) {\n    const value =\n      typeof args[key] === \"object\"\n        ? JSON.stringify(args[key], null, 2)\n        : args[key]; // pretty print\n    if (typeof value !== \"undefined\") {\n      messageParts.push(`${key}: ${value}`);\n    }\n  }\n  return messageParts.join(\"\\n\");\n}\nexport class PatchError extends Error {\n  constructor(\n    message: string,\n    public name: JsonPatchErrorName,\n    public index?: number,\n    public operation?: any,\n    public tree?: any\n  ) {\n    super(\n      patchErrorMessageFormatter(message, { name, index, operation, tree })\n    );\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n    this.message = patchErrorMessageFormatter(message, {\n      name,\n      index,\n      operation,\n      tree,\n    });\n  }\n}\n","import { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseCheckpointSaver,\n  type PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\nimport { GraphInterrupt, GraphValueError } from \"./errors.js\";\nimport {\n  CONFIG_KEY_CHECKPOINT_NS,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_SEND,\n  CONFIG_KEY_CHECKPOINTER,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  RESUME,\n} from \"./constants.js\";\nimport { PregelScratchpad } from \"./pregel/types.js\";\nimport { XXH3 } from \"./hash.js\";\n\n/**\n * Interrupts the execution of a graph node.\n * This function can be used to pause execution of a node, and return the value of the `resume`\n * input when the graph is re-invoked using `Command`.\n * Multiple interrupts can be called within a single node, and each will be handled sequentially.\n *\n * When an interrupt is called:\n * 1. If there's a `resume` value available (from a previous `Command`), it returns that value.\n * 2. Otherwise, it throws a `GraphInterrupt` with the provided value\n * 3. The graph can be resumed by passing a `Command` with a `resume` value\n *\n * Because the `interrupt` function propagates by throwing a special `GraphInterrupt` error,\n * you should avoid using `try/catch` blocks around the `interrupt` function,\n * or if you do, ensure that the `GraphInterrupt` error is thrown again within your `catch` block.\n *\n * @param value - The value to include in the interrupt. This will be available in task.interrupts[].value\n * @returns The `resume` value provided when the graph is re-invoked with a Command\n *\n * @example\n * ```typescript\n * // Define a node that uses multiple interrupts\n * const nodeWithInterrupts = () => {\n *   // First interrupt - will pause execution and include {value: 1} in task values\n *   const answer1 = interrupt({ value: 1 });\n *\n *   // Second interrupt - only called after first interrupt is resumed\n *   const answer2 = interrupt({ value: 2 });\n *\n *   // Use the resume values\n *   return { myKey: answer1 + \" \" + answer2 };\n * };\n *\n * // Resume the graph after first interrupt\n * await graph.stream(new Command({ resume: \"answer 1\" }));\n *\n * // Resume the graph after second interrupt\n * await graph.stream(new Command({ resume: \"answer 2\" }));\n * // Final result: { myKey: \"answer 1 answer 2\" }\n * ```\n *\n * @throws {Error} If called outside the context of a graph\n * @throws {GraphInterrupt} When no resume value is available\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function interrupt<I = unknown, R = any>(value: I): R {\n  const config: RunnableConfig | undefined =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  if (!config) {\n    throw new Error(\"Called interrupt() outside the context of a graph.\");\n  }\n\n  const conf = config.configurable;\n  if (!conf) {\n    throw new Error(\"No configurable found in config\");\n  }\n\n  const checkpointer: BaseCheckpointSaver = conf[CONFIG_KEY_CHECKPOINTER];\n  if (!checkpointer) {\n    throw new GraphValueError(\"No checkpointer set\", {\n      lc_error_code: \"MISSING_CHECKPOINTER\",\n    });\n  }\n\n  // Track interrupt index\n  const scratchpad: PregelScratchpad = conf[CONFIG_KEY_SCRATCHPAD];\n  scratchpad.interruptCounter += 1;\n  const idx = scratchpad.interruptCounter;\n\n  // Find previous resume values\n  if (scratchpad.resume.length > 0 && idx < scratchpad.resume.length) {\n    conf[CONFIG_KEY_SEND]?.([[RESUME, scratchpad.resume] as PendingWrite]);\n    return scratchpad.resume[idx] as R;\n  }\n\n  // Find current resume value\n  if (scratchpad.nullResume !== undefined) {\n    if (scratchpad.resume.length !== idx) {\n      throw new Error(\n        `Resume length mismatch: ${scratchpad.resume.length} !== ${idx}`\n      );\n    }\n    const v = scratchpad.consumeNullResume();\n    scratchpad.resume.push(v);\n    conf[CONFIG_KEY_SEND]?.([[RESUME, scratchpad.resume] as PendingWrite]);\n    return v as R;\n  }\n\n  // No resume value found\n  const ns: string[] | undefined = conf[CONFIG_KEY_CHECKPOINT_NS]?.split(\n    CHECKPOINT_NAMESPACE_SEPARATOR\n  );\n\n  const id = ns ? XXH3(ns.join(CHECKPOINT_NAMESPACE_SEPARATOR)) : undefined;\n  throw new GraphInterrupt([{ id, value }]);\n}\n\ntype FilterAny<X> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n>() => T extends any ? 1 : 2\n  ? never\n  : X;\n\nexport type InferInterruptInputType<T> = T extends typeof interrupt<\n  infer I,\n  unknown\n>\n  ? I\n  : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends { [key: string]: typeof interrupt<any, any> }\n  ? { [K in keyof T]: InferInterruptInputType<T[K]> }[keyof T]\n  : unknown;\n\nexport type InferInterruptResumeType<\n  T,\n  TInner = false\n> = T extends typeof interrupt<never, infer R>\n  ? TInner extends true\n    ? FilterAny<R>\n    : R\n  : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends { [key: string]: typeof interrupt<any, any> }\n  ? { [K in keyof T]: InferInterruptResumeType<T[K], true> }[keyof T]\n  : unknown;\n","import { isRunTree, RunTree } from \"langsmith/run_trees\";\nimport { BaseCallbackHandler } from \"../../callbacks/base.js\";\nimport {\n  _CONTEXT_VARIABLES_KEY,\n  getGlobalAsyncLocalStorageInstance,\n} from \"./globals.js\";\n\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\nexport function setContextVariable<T>(name: PropertyKey, value: T): void {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    throw new Error(\n      `Internal error: Global shared async local storage instance has not been initialized.`\n    );\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  const contextVars = { ...runTree?.[_CONTEXT_VARIABLES_KEY] };\n  contextVars[name] = value;\n  let newValue = {};\n  if (isRunTree(runTree)) {\n    newValue = new RunTree(runTree);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (newValue as any)[_CONTEXT_VARIABLES_KEY] = contextVars;\n  asyncLocalStorageInstance.enterWith(newValue);\n}\n\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getContextVariable<T = any>(name: PropertyKey): T | undefined {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    return undefined;\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];\n}\n\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\n\nexport const _getConfigureHooks = () =>\n  getContextVariable<ConfigureHook[]>(LC_CONFIGURE_HOOKS_KEY) || [];\n\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nexport const registerConfigureHook = (config: ConfigureHook) => {\n  if (config.envVar && !config.handlerClass) {\n    throw new Error(\n      \"If envVar is set, handlerClass must also be set to a non-None value.\"\n    );\n  }\n  setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);\n};\n\nexport type ConfigureHook = {\n  contextVar?: string;\n  inheritable?: boolean;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handlerClass?: new (...args: any[]) => BaseCallbackHandler;\n  envVar?: string;\n};\n","import { Serializable } from \"./load/serializable.js\";\n\n/**\n * Abstract interface for a key-value store.\n */\nexport abstract class BaseStore<K, V> extends Serializable {\n  /**\n   * Abstract method to get multiple values for a set of keys.\n   * @param {K[]} keys - An array of keys.\n   * @returns {Promise<(V | undefined)[]>} - A Promise that resolves with array of values or undefined if key not found.\n   */\n  abstract mget(keys: K[]): Promise<(V | undefined)[]>;\n\n  /**\n   * Abstract method to set a value for multiple keys.\n   * @param {[K, V][]} keyValuePairs - An array of key-value pairs.\n   * @returns {Promise<void>} - A Promise that resolves when the operation is complete.\n   */\n  abstract mset(keyValuePairs: [K, V][]): Promise<void>;\n\n  /**\n   * Abstract method to delete multiple keys.\n   * @param {K[]} keys - An array of keys to delete.\n   * @returns {Promise<void>} - A Promise that resolves when the operation is complete.\n   */\n  abstract mdelete(keys: K[]): Promise<void>;\n\n  /**\n   * Abstract method to yield keys optionally based on a prefix.\n   * @param {string} prefix - Optional prefix to filter keys.\n   * @returns {AsyncGenerator<K | string>} - An asynchronous generator that yields keys on iteration.\n   */\n  abstract yieldKeys(prefix?: string): AsyncGenerator<K | string>;\n}\n\n/**\n * In-memory implementation of the BaseStore using a dictionary. Used for\n * storing key-value pairs in memory.\n * @example\n * ```typescript\n * const store = new InMemoryStore<BaseMessage>();\n * await store.mset(\n *   Array.from({ length: 5 }).map((_, index) => [\n *     `message:id:${index}`,\n *     index % 2 === 0\n *       ? new AIMessage(\"ai stuff...\")\n *       : new HumanMessage(\"human stuff...\"),\n *   ]),\n * );\n *\n * const retrievedMessages = await store.mget([\"message:id:0\", \"message:id:1\"]);\n * await store.mdelete(await store.yieldKeys(\"message:id:\").toArray());\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class InMemoryStore<T = any> extends BaseStore<string, T> {\n  lc_namespace = [\"langchain\", \"storage\"];\n\n  protected store: Record<string, T> = {};\n\n  /**\n   * Retrieves the values associated with the given keys from the store.\n   * @param keys Keys to retrieve values for.\n   * @returns Array of values associated with the given keys.\n   */\n  async mget(keys: string[]) {\n    return keys.map((key) => this.store[key]);\n  }\n\n  /**\n   * Sets the values for the given keys in the store.\n   * @param keyValuePairs Array of key-value pairs to set in the store.\n   * @returns Promise that resolves when all key-value pairs have been set.\n   */\n  async mset(keyValuePairs: [string, T][]): Promise<void> {\n    for (const [key, value] of keyValuePairs) {\n      this.store[key] = value;\n    }\n  }\n\n  /**\n   * Deletes the given keys and their associated values from the store.\n   * @param keys Keys to delete from the store.\n   * @returns Promise that resolves when all keys have been deleted.\n   */\n  async mdelete(keys: string[]): Promise<void> {\n    for (const key of keys) {\n      delete this.store[key];\n    }\n  }\n\n  /**\n   * Asynchronous generator that yields keys from the store. If a prefix is\n   * provided, it only yields keys that start with the prefix.\n   * @param prefix Optional prefix to filter keys.\n   * @returns AsyncGenerator that yields keys from the store.\n   */\n  async *yieldKeys(prefix?: string | undefined): AsyncGenerator<string> {\n    const keys = Object.keys(this.store);\n    for (const key of keys) {\n      if (prefix === undefined || key.startsWith(prefix)) {\n        yield key;\n      }\n    }\n  }\n}\n","/* eslint-disable */\n// @ts-nocheck\n\n// Stringify that can handle circular references.\n// Inlined due to ESM import issues\n// Source: https://www.npmjs.com/package/fast-safe-stringify\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = \"[Circular]\";\n\nvar arr = [];\nvar replacerStack = [];\n\nfunction defaultOptions() {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER,\n  };\n}\n\n// Regular stringify\nexport function stringify(obj, replacer?, spacer?, options?) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n\n  decirc(obj, \"\", 0, [], undefined, 0, options);\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer);\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\n      \"[unable to serialize, circular reference is too complex to analyze]\"\n    );\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\n\nfunction setReplace(replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace });\n      arr.push([parent, k, val, propertyDescriptor]);\n    } else {\n      replacerStack.push([val, k, replace]);\n    }\n  } else {\n    parent[k] = replace;\n    arr.push([parent, k, val]);\n  }\n}\n\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== \"undefined\" &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (\n      typeof options.edgesLimit !== \"undefined\" &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      var keys = Object.keys(val);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        decirc(val[key], key, i, stack, val, depth, options);\n      }\n    }\n    stack.pop();\n  }\n}\n\n// Stable-stringify\nfunction compareFunction(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction deterministicStringify(obj, replacer, spacer, options) {\n  if (typeof options === \"undefined\") {\n    options = defaultOptions();\n  }\n\n  var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n  var res;\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer);\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n    }\n  } catch (_) {\n    return JSON.stringify(\n      \"[unable to serialize, circular reference is too complex to analyze]\"\n    );\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop();\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3]);\n      } else {\n        part[0][part[1]] = part[2];\n      }\n    }\n  }\n  return res;\n}\n\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1;\n  var i;\n  if (typeof val === \"object\" && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n        return;\n      }\n    }\n    try {\n      if (typeof val.toJSON === \"function\") {\n        return;\n      }\n    } catch (_) {\n      return;\n    }\n\n    if (\n      typeof options.depthLimit !== \"undefined\" &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    if (\n      typeof options.edgesLimit !== \"undefined\" &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n      return;\n    }\n\n    stack.push(val);\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options);\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {};\n      var keys = Object.keys(val).sort(compareFunction);\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        deterministicDecirc(val[key], key, i, stack, val, depth, options);\n        tmp[key] = val[key];\n      }\n      if (typeof parent !== \"undefined\") {\n        arr.push([parent, k, val]);\n        parent[k] = tmp;\n      } else {\n        return tmp;\n      }\n    }\n    stack.pop();\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n  replacer =\n    typeof replacer !== \"undefined\"\n      ? replacer\n      : function (k, v) {\n          return v;\n        };\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i];\n        if (part[1] === key && part[0] === val) {\n          val = part[2];\n          replacerStack.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return replacer.call(this, key, val);\n  };\n}\n","import { BaseTransformOutputParser } from \"./transform.js\";\nimport { ContentBlock } from \"../messages/index.js\";\n\n/**\n * OutputParser that parses LLMResult into the top likely string.\n * @example\n * ```typescript\n * const promptTemplate = PromptTemplate.fromTemplate(\n *   \"Tell me a joke about {topic}\",\n * );\n *\n * const chain = RunnableSequence.from([\n *   promptTemplate,\n *   new ChatOpenAI({ model: \"gpt-4o-mini\" }),\n *   new StringOutputParser(),\n * ]);\n *\n * const result = await chain.invoke({ topic: \"bears\" });\n * console.log(\"What do you call a bear with no teeth? A gummy bear!\");\n * ```\n */\nexport class StringOutputParser extends BaseTransformOutputParser<string> {\n  static lc_name() {\n    return \"StrOutputParser\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"output_parsers\", \"string\"];\n\n  lc_serializable = true;\n\n  /**\n   * Parses a string output from an LLM call. This method is meant to be\n   * implemented by subclasses to define how a string output from an LLM\n   * should be parsed.\n   * @param text The string output from an LLM call.\n   * @param callbacks Optional callbacks.\n   * @returns A promise of the parsed output.\n   */\n  parse(text: string): Promise<string> {\n    return Promise.resolve(text);\n  }\n\n  getFormatInstructions(): string {\n    return \"\";\n  }\n\n  protected _textContentToString(content: ContentBlock.Text): string {\n    return content.text;\n  }\n\n  protected _imageUrlContentToString(\n    _content: ContentBlock.Data.URLContentBlock\n  ): string {\n    throw new Error(\n      `Cannot coerce a multimodal \"image_url\" message part into a string.`\n    );\n  }\n\n  protected _messageContentToString(content: ContentBlock): string {\n    switch (content.type) {\n      case \"text\":\n      case \"text_delta\":\n        if (\"text\" in content) {\n          // Type guard for MessageContentText\n          return this._textContentToString(content as ContentBlock.Text);\n        }\n        break;\n      case \"image_url\":\n        if (\"image_url\" in content) {\n          // Type guard for MessageContentImageUrl\n          return this._imageUrlContentToString(\n            content as ContentBlock.Data.URLContentBlock\n          );\n        }\n        break;\n      default:\n        throw new Error(\n          `Cannot coerce \"${content.type}\" message part into a string.`\n        );\n    }\n    throw new Error(`Invalid content type: ${content.type}`);\n  }\n\n  protected _baseMessageContentToString(content: ContentBlock[]): string {\n    return content.reduce(\n      (acc: string, item: ContentBlock) =>\n        acc + this._messageContentToString(item),\n      \"\"\n    );\n  }\n}\n","import {\n  BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { Pregel } from \"../pregel/index.js\";\nimport { PregelNode } from \"../pregel/read.js\";\nimport {\n  CONFIG_KEY_PREVIOUS_STATE,\n  END,\n  PREVIOUS,\n  START,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { call, getRunnableForEntrypoint } from \"../pregel/call.js\";\nimport type { CachePolicy, RetryPolicy } from \"../pregel/utils/index.js\";\nimport { LastValue } from \"../channels/last_value.js\";\nimport {\n  EntrypointFinal,\n  EntrypointReturnT,\n  EntrypointFinalSaveT,\n  EntrypointFunc,\n  TaskFunc,\n} from \"./types.js\";\nimport { LangGraphRunnableConfig } from \"../pregel/runnable_types.js\";\nimport {\n  RunnableCallable,\n  isAsyncGeneratorFunction,\n  isGeneratorFunction,\n} from \"../utils.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"../pregel/write.js\";\n\n/**\n * Options for the {@link task} function\n */\nexport interface TaskOptions {\n  /**\n   * The name of the task, analogous to the node name in {@link StateGraph}.\n   */\n  name: string;\n  /**\n   * The retry policy for the task. Configures how many times and under what conditions\n   * the task should be retried if it fails.\n   */\n  retry?: RetryPolicy;\n\n  /**\n   * The cache policy for the task. Configures how the task should be cached.\n   */\n  cachePolicy?: CachePolicy;\n}\n\n/**\n * Define a LangGraph task using the `task` function.\n *\n * Tasks can only be called from within an {@link entrypoint} or from within a StateGraph.\n * A task can be called like a regular function with the following differences:\n *\n * - When a checkpointer is enabled, the function inputs and outputs must be serializable.\n * - The wrapped function can only be called from within an entrypoint or StateGraph.\n * - Calling the function produces a promise. This makes it easy to parallelize tasks.\n *\n * @typeParam ArgsT - The type of arguments the task function accepts\n * @typeParam OutputT - The type of value the task function returns\n * @param optionsOrName - Either an {@link TaskOptions} object, or a string for the name of the task\n * @param func - The function that executes this task\n * @returns A proxy function that accepts the same arguments as the original and always returns the result as a Promise\n *\n * @example basic example\n * ```typescript\n * const addOne = task(\"add\", async (a: number) => a + 1);\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n *\n * // Call the entrypoint\n * await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @example using a retry policy\n * ```typescript\n * const addOne = task({\n *     name: \"add\",\n *     retry: { maxAttempts: 3 }\n *   },\n *   async (a: number) => a + 1\n * );\n *\n * const workflow = entrypoint(\"example\", async (numbers: number[]) => {\n *   const promises = numbers.map(n => addOne(n));\n *   const results = await Promise.all(promises);\n *   return results;\n * });\n * ```\n * @category Functional API\n */\nexport function task<ArgsT extends unknown[], OutputT>(\n  optionsOrName: TaskOptions | string,\n  func: TaskFunc<ArgsT, OutputT>\n): (...args: ArgsT) => Promise<OutputT> {\n  const options =\n    typeof optionsOrName === \"string\"\n      ? { name: optionsOrName, retry: undefined, cachePolicy: undefined }\n      : optionsOrName;\n\n  const { name, retry } = options;\n  if (isAsyncGeneratorFunction(func) || isGeneratorFunction(func)) {\n    throw new Error(\n      \"Generators are disallowed as tasks. For streaming responses, use config.write.\"\n    );\n  }\n\n  const cachePolicy =\n    options.cachePolicy ??\n    // `cache` was mistakingly used as an alias for `cachePolicy` in v0.3.x,\n    // TODO: remove in 1.x\n    (\"cache\" in options ? (options.cache as CachePolicy) : undefined);\n\n  let cache: CachePolicy | undefined;\n  if (typeof cachePolicy === \"boolean\") {\n    cache = cachePolicy ? {} : undefined;\n  } else {\n    cache = cachePolicy;\n  }\n\n  return (...args: ArgsT) => {\n    return call({ func, name, retry, cache }, ...args);\n  };\n}\n\n/**\n * Options for the {@link entrypoint} function\n */\nexport type EntrypointOptions = {\n  /**\n   * The name of the {@link entrypoint}, analogous to the node name in {@link StateGraph}.\n   * This name is used for logging, debugging, and checkpoint identification.\n   */\n  name: string;\n  /**\n   * The checkpointer for the {@link entrypoint}. Used to save and restore state between\n   * invocations of the workflow.\n   */\n  checkpointer?: BaseCheckpointSaver;\n  /**\n   * The store for the {@link entrypoint}. Used to persist data across workflow runs.\n   */\n  store?: BaseStore;\n\n  /**\n   * The cache for the {@link entrypoint}. Used to cache values between workflow runs.\n   */\n  cache?: BaseCache;\n};\n\n/**\n * Type declaration for the entrypoint function with its properties\n * @category Functional API\n */\nexport interface EntrypointFunction {\n  <InputT, OutputT>(\n    optionsOrName: EntrypointOptions | string,\n    func: EntrypointFunc<InputT, OutputT>\n  ): Pregel<\n    Record<string, PregelNode<InputT, EntrypointReturnT<OutputT>>>,\n    {\n      [START]: EphemeralValue<InputT>;\n      [END]: LastValue<EntrypointReturnT<OutputT>>;\n      [PREVIOUS]: LastValue<EntrypointFinalSaveT<OutputT>>;\n    },\n    Record<string, unknown>,\n    InputT,\n    EntrypointReturnT<OutputT>,\n    // Because the update type is an return type union of tasks + entrypoint,\n    // thus we can't type it properly.\n    any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    Awaited<EntrypointReturnT<OutputT>>\n  >;\n\n  /**\n   * A helper utility for use with the functional API that returns a value to the caller,\n   * as well as a separate state value to persist to the checkpoint. This allows workflows\n   * to maintain state between runs while returning different values to the caller.\n   *\n   * @typeParam ValueT - The type of the value to return to the caller\n   * @typeParam SaveT - The type of the state to save to the checkpoint\n   * @param options.value - The value to return to the caller\n   * @param options.save - The value to save to the checkpoint\n   * @returns An object with the value and save properties\n   *\n   * @example\n   * ```typescript\n   * return entrypoint.final({\n   *   value: \"result for caller\",\n   *   save: { counter: currentCount + 1 }\n   * });\n   * ```\n   */\n  final<ValueT, SaveT>(options: {\n    value?: ValueT;\n    save?: SaveT;\n  }): EntrypointFinal<ValueT, SaveT>;\n}\n\n/**\n * Define a LangGraph workflow using the `entrypoint` function.\n *\n * ### Function signature\n *\n * The wrapped function must accept at most **two parameters**. The first parameter\n * is the input to the function. The second (optional) parameter is a\n * {@link LangGraphRunnableConfig} object. If you wish to pass multiple parameters to\n * the function, you can pass them as an object.\n *\n * ### Helper functions\n *\n * #### Streaming\n * To write data to the \"custom\" stream, use the {@link getWriter} function, or the\n * {@link LangGraphRunnableConfig.writer} property.\n *\n * #### State management\n * The {@link getPreviousState} function can be used to access the previous state\n * that was returned from the last invocation of the entrypoint on the same thread id.\n *\n * If you wish to save state other than the return value, you can use the\n * {@link entrypoint.final} function.\n *\n * @typeParam InputT - The type of input the entrypoint accepts\n * @typeParam OutputT - The type of output the entrypoint produces\n * @param optionsOrName - Either an {@link EntrypointOptions} object, or a string for the name of the entrypoint\n * @param func - The function that executes this entrypoint\n * @returns A {@link Pregel} instance that can be run to execute the workflow\n *\n * @example Using entrypoint and tasks\n * ```typescript\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n * import { interrupt, Command } from \"@langchain/langgraph\";\n *\n * const composeEssay = task(\"compose\", async (topic: string) => {\n *   await new Promise(r => setTimeout(r, 1000)); // Simulate slow operation\n *   return `An essay about ${topic}`;\n * });\n *\n * const reviewWorkflow = entrypoint({\n *   name: \"review\",\n *   checkpointer: new MemorySaver()\n * }, async (topic: string) => {\n *   const essay = await composeEssay(topic);\n *   const humanReview = await interrupt({\n *     question: \"Please provide a review\",\n *     essay\n *   });\n *   return {\n *     essay,\n *     review: humanReview\n *   };\n * });\n *\n * // Example configuration for the workflow\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * // Topic for the essay\n * const topic = \"cats\";\n *\n * // Stream the workflow to generate the essay and await human review\n * for await (const result of reviewWorkflow.stream(topic, config)) {\n *   console.log(result);\n * }\n *\n * // Example human review provided after the interrupt\n * const humanReview = \"This essay is great.\";\n *\n * // Resume the workflow with the provided human review\n * for await (const result of reviewWorkflow.stream(new Command({ resume: humanReview }), config)) {\n *   console.log(result);\n * }\n * ```\n *\n * @example Accessing the previous return value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const accumulator = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (input: string) => {\n *   const previous = getPreviousState<number>();\n *   return previous !== undefined ? `${previous } ${input}` : input;\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n * await accumulator.invoke(\"hello\", config); // returns \"hello\"\n * await accumulator.invoke(\"world\", config); // returns \"hello world\"\n * ```\n *\n * @example Using entrypoint.final to save a value\n * ```typescript\n * import { entrypoint, getPreviousState } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * const myWorkflow = entrypoint({\n *   name: \"accumulator\",\n *   checkpointer: new MemorySaver()\n * }, async (num: number) => {\n *   const previous = getPreviousState<number>();\n *\n *   // This will return the previous value to the caller, saving\n *   // 2 * num to the checkpoint, which will be used in the next invocation\n *   // for the `previous` parameter.\n *   return entrypoint.final({\n *     value: previous ?? 0,\n *     save: 2 * num\n *   });\n * });\n *\n * const config = {\n *   configurable: {\n *     thread_id: \"some_thread\"\n *   }\n * };\n *\n * await myWorkflow.invoke(3, config); // 0 (previous was undefined)\n * await myWorkflow.invoke(1, config); // 6 (previous was 3 * 2 from the previous invocation)\n * ```\n * @category Functional API\n */\nexport const entrypoint = function entrypoint<InputT, OutputT>(\n  optionsOrName: EntrypointOptions | string,\n  func: EntrypointFunc<InputT, OutputT>\n) {\n  const { name, checkpointer, store, cache } =\n    typeof optionsOrName === \"string\"\n      ? { name: optionsOrName, checkpointer: undefined, store: undefined }\n      : optionsOrName;\n  if (isAsyncGeneratorFunction(func) || isGeneratorFunction(func)) {\n    throw new Error(\n      \"Generators are disallowed as entrypoints. For streaming responses, use config.write.\"\n    );\n  }\n  const streamMode = \"updates\";\n  const bound = getRunnableForEntrypoint(name, func);\n\n  // Helper to check if a value is an EntrypointFinal\n  function isEntrypointFinal(\n    value: unknown\n  ): value is EntrypointFinal<unknown, unknown> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      \"__lg_type\" in value &&\n      value.__lg_type === \"__pregel_final\"\n    );\n  }\n\n  // Helper function to pluck the return value from EntrypointFinal or passthrough\n  const pluckReturnValue = new RunnableCallable({\n    name: \"pluckReturnValue\",\n    func: (value: unknown) => {\n      return isEntrypointFinal(value) ? value.value : value;\n    },\n  });\n\n  // Helper function to pluck the save value from EntrypointFinal or passthrough\n  const pluckSaveValue = new RunnableCallable({\n    name: \"pluckSaveValue\",\n    func: (value: unknown) => {\n      return isEntrypointFinal(value) ? value.save : value;\n    },\n  });\n\n  const entrypointNode = new PregelNode<InputT, EntrypointReturnT<OutputT>>({\n    bound,\n    triggers: [START],\n    channels: [START],\n    writers: [\n      new ChannelWrite(\n        [\n          { channel: END, value: PASSTHROUGH, mapper: pluckReturnValue },\n          { channel: PREVIOUS, value: PASSTHROUGH, mapper: pluckSaveValue },\n        ],\n        [TAG_HIDDEN]\n      ),\n    ],\n  });\n\n  return new Pregel<\n    Record<string, PregelNode<InputT, EntrypointReturnT<OutputT>>>, // node types\n    {\n      [START]: EphemeralValue<InputT>;\n      [END]: LastValue<EntrypointReturnT<OutputT>>;\n      [PREVIOUS]: LastValue<EntrypointFinalSaveT<OutputT>>;\n    }, // channel types\n    Record<string, unknown>, // configurable types\n    InputT, // input type\n    EntrypointReturnT<OutputT> // output type\n  >({\n    name,\n    checkpointer,\n    nodes: {\n      [name]: entrypointNode,\n    },\n    channels: {\n      [START]: new EphemeralValue<InputT>(),\n      [END]: new LastValue<EntrypointReturnT<OutputT>>(),\n      [PREVIOUS]: new LastValue<EntrypointFinalSaveT<OutputT>>(),\n    },\n    inputChannels: START,\n    outputChannels: END,\n    streamChannels: END,\n    streamMode,\n    store,\n    cache,\n  });\n} as EntrypointFunction;\n\n// documented by the EntrypointFunction interface\nentrypoint.final = function final<ValueT, SaveT>({\n  value,\n  save,\n}: {\n  value?: ValueT;\n  save?: SaveT;\n}): EntrypointFinal<ValueT, SaveT> {\n  return { value, save, __lg_type: \"__pregel_final\" };\n};\n\n/**\n * A helper utility function for use with the functional API that returns the previous\n * state from the checkpoint from the last invocation of the current thread.\n *\n * This function allows workflows to access state that was saved in previous runs\n * using {@link entrypoint.final}.\n *\n * @typeParam StateT - The type of the state that was previously saved\n * @returns The previous saved state from the last invocation of the current thread\n *\n * @example\n * ```typescript\n * const previousState = getPreviousState<{ counter: number }>();\n * const newCount = (previousState?.counter ?? 0) + 1;\n * ```\n * @category Functional API\n */\nexport function getPreviousState<StateT>(): StateT {\n  const config: LangGraphRunnableConfig =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  return config.configurable?.[CONFIG_KEY_PREVIOUS_STATE] as StateT;\n}\n","/* eslint-disable prefer-template */\n/* eslint-disable default-case */\n// Adapted from https://github.com/gfortaine/fetch-event-source/blob/main/src/parse.ts\n// due to a packaging issue in the original.\n// MIT License\nimport { IterableReadableStream } from \"./stream.js\";\n\nexport const EventStreamContentType = \"text/event-stream\";\n\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n  /** The event ID to set the EventSource object's last event ID value. */\n  id: string;\n  /** A string identifying the type of event described. */\n  event: string;\n  /** The event data */\n  data: string;\n  /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n  retry?: number;\n}\n\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport async function getBytes(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  stream: ReadableStream<Uint8Array> | AsyncIterable<any>,\n  onChunk: (arr: Uint8Array, flush?: boolean) => void\n) {\n  // TODO: Use Async iteration for both cases?\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  if (stream instanceof ReadableStream) {\n    const reader = stream.getReader();\n    // CHANGED: Introduced a \"flush\" mechanism to process potential pending messages when the stream ends.\n    //          This change is essential to ensure that we capture every last piece of information from streams,\n    //          such as those from Azure OpenAI, which may not terminate with a blank line. Without this\n    //          mechanism, we risk ignoring a possibly significant last message.\n    //          See https://github.com/langchain-ai/langchainjs/issues/1299 for details.\n    while (true) {\n      const result = await reader.read();\n      if (result.done) {\n        onChunk(new Uint8Array(), true);\n        break;\n      }\n      onChunk(result.value);\n    }\n  } else {\n    try {\n      // Handle Node.js Readable streams with async iteration\n      for await (const chunk of stream) {\n        onChunk(new Uint8Array(chunk));\n      }\n      onChunk(new Uint8Array(), true);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new Error(\n        [\n          \"Parsing event source stream failed.\",\n          \"Ensure your implementation of fetch returns a web or Node readable stream.\",\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n}\n\nconst enum ControlChars {\n  NewLine = 10,\n  CarriageReturn = 13,\n  Space = 32,\n  Colon = 58,\n}\n\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport function getLines(\n  onLine: (line: Uint8Array, fieldLength: number, flush?: boolean) => void\n) {\n  let buffer: Uint8Array | undefined;\n  let position: number; // current read position\n  let fieldLength: number; // length of the `field` portion of the line\n  let discardTrailingNewline = false;\n\n  // return a function that can process each incoming byte chunk:\n  return function onChunk(arr: Uint8Array, flush?: boolean) {\n    if (flush) {\n      onLine(arr, 0, true);\n      return;\n    }\n\n    if (buffer === undefined) {\n      buffer = arr;\n      position = 0;\n      fieldLength = -1;\n    } else {\n      // we're still parsing the old line. Append the new bytes into buffer:\n      buffer = concat(buffer, arr);\n    }\n\n    const bufLength = buffer.length;\n    let lineStart = 0; // index where the current line starts\n    while (position < bufLength) {\n      if (discardTrailingNewline) {\n        if (buffer[position] === ControlChars.NewLine) {\n          lineStart = ++position; // skip to next char\n        }\n\n        discardTrailingNewline = false;\n      }\n\n      // start looking forward till the end of line:\n      let lineEnd = -1; // index of the \\r or \\n char\n      for (; position < bufLength && lineEnd === -1; ++position) {\n        switch (buffer[position]) {\n          case ControlChars.Colon:\n            if (fieldLength === -1) {\n              // first colon in line\n              fieldLength = position - lineStart;\n            }\n            break;\n          // @ts-expect-error \\r case below should fallthrough to \\n:\n          case ControlChars.CarriageReturn:\n            discardTrailingNewline = true;\n          // eslint-disable-next-line no-fallthrough\n          case ControlChars.NewLine:\n            lineEnd = position;\n            break;\n        }\n      }\n\n      if (lineEnd === -1) {\n        // We reached the end of the buffer but the line hasn't ended.\n        // Wait for the next arr and then continue parsing:\n        break;\n      }\n\n      // we've reached the line end, send it out:\n      onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\n      lineStart = position; // we're now on the next line\n      fieldLength = -1;\n    }\n\n    if (lineStart === bufLength) {\n      buffer = undefined; // we've finished reading it\n    } else if (lineStart !== 0) {\n      // Create a new view into buffer beginning at lineStart so we don't\n      // need to copy over the previous lines when we get the new arr:\n      buffer = buffer.subarray(lineStart);\n      position -= lineStart;\n    }\n  };\n}\n\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport function getMessages(\n  onMessage?: (msg: EventSourceMessage) => void,\n  onId?: (id: string) => void,\n  onRetry?: (retry: number) => void\n) {\n  let message = newMessage();\n  const decoder = new TextDecoder();\n\n  // return a function that can process each incoming line buffer:\n  return function onLine(\n    line: Uint8Array,\n    fieldLength: number,\n    flush?: boolean\n  ) {\n    if (flush) {\n      if (!isEmpty(message)) {\n        onMessage?.(message);\n        message = newMessage();\n      }\n      return;\n    }\n\n    if (line.length === 0) {\n      // empty line denotes end of message. Trigger the callback and start a new message:\n      onMessage?.(message);\n      message = newMessage();\n    } else if (fieldLength > 0) {\n      // exclude comments and lines with no values\n      // line is of format \"<field>:<value>\" or \"<field>: <value>\"\n      // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n      const field = decoder.decode(line.subarray(0, fieldLength));\n      const valueOffset =\n        fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);\n      const value = decoder.decode(line.subarray(valueOffset));\n\n      switch (field) {\n        case \"data\":\n          // if this message already has data, append the new value to the old.\n          // otherwise, just set to the new value:\n          message.data = message.data ? message.data + \"\\n\" + value : value; // otherwise,\n          break;\n        case \"event\":\n          message.event = value;\n          break;\n        case \"id\":\n          onId?.((message.id = value));\n          break;\n        case \"retry\": {\n          const retry = parseInt(value, 10);\n          if (!Number.isNaN(retry)) {\n            // per spec, ignore non-integers\n            onRetry?.((message.retry = retry));\n          }\n          break;\n        }\n      }\n    }\n  };\n}\n\nfunction concat(a: Uint8Array, b: Uint8Array) {\n  const res = new Uint8Array(a.length + b.length);\n  res.set(a);\n  res.set(b, a.length);\n  return res;\n}\n\nfunction newMessage(): EventSourceMessage {\n  // data, event, and id must be initialized to empty strings:\n  // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation\n  // retry should be initialized to undefined so we return a consistent shape\n  // to the js engine all the time: https://mathiasbynens.be/notes/shapes-ics#takeaways\n  return {\n    data: \"\",\n    event: \"\",\n    id: \"\",\n    retry: undefined,\n  };\n}\n\nexport function convertEventStreamToIterableReadableDataStream(\n  stream: ReadableStream,\n  onMetadataEvent?: (e: unknown) => unknown\n) {\n  const dataStream = new ReadableStream({\n    async start(controller) {\n      const enqueueLine = getMessages((msg) => {\n        if (msg.event === \"error\") {\n          throw new Error(msg.data ?? \"Unspecified event streaming error.\");\n        } else if (msg.event === \"metadata\") {\n          onMetadataEvent?.(msg);\n        } else {\n          if (msg.data) controller.enqueue(msg.data);\n        }\n      });\n      const onLine = (\n        line: Uint8Array,\n        fieldLength: number,\n        flush?: boolean\n      ) => {\n        enqueueLine(line, fieldLength, flush);\n        if (flush) controller.close();\n      };\n      await getBytes(stream, getLines(onLine));\n    },\n  });\n  return IterableReadableStream.fromReadableStream(dataStream);\n}\n\nfunction isEmpty(message: EventSourceMessage): boolean {\n  return (\n    message.data === \"\" &&\n    message.event === \"\" &&\n    message.id === \"\" &&\n    message.retry === undefined\n  );\n}\n","import {\n  ReadonlyCheckpoint,\n  uuid6,\n  Checkpoint,\n} from \"@langchain/langgraph-checkpoint\";\nimport { EmptyChannelError } from \"../errors.js\";\n\nexport function isBaseChannel(obj: unknown): obj is BaseChannel {\n  return obj != null && (obj as BaseChannel).lg_is_channel === true;\n}\n\n/** @internal */\nexport abstract class BaseChannel<\n  ValueType = unknown,\n  UpdateType = unknown,\n  CheckpointType = unknown\n> {\n  ValueType: ValueType;\n\n  UpdateType: UpdateType;\n\n  /**\n   * The name of the channel.\n   */\n  abstract lc_graph_name: string;\n\n  /** @ignore */\n  lg_is_channel = true;\n\n  /**\n   * Return a new identical channel, optionally initialized from a checkpoint.\n   * Can be thought of as a \"restoration\" from a checkpoint which is a \"snapshot\" of the channel's state.\n   *\n   * @param {CheckpointType | undefined} checkpoint\n   * @param {CheckpointType | undefined} initialValue\n   * @returns {this}\n   */\n  abstract fromCheckpoint(checkpoint?: CheckpointType): this;\n\n  /**\n   * Update the channel's value with the given sequence of updates.\n   * The order of the updates in the sequence is arbitrary.\n   * This method is called by Pregel for all channels at the end of each step.\n   * If there are no updates, it is called with an empty sequence.\n   *\n   * Raises InvalidUpdateError if the sequence of updates is invalid.\n   * Returns True if the channel was updated, False otherwise.\n   *\n   * @throws {InvalidUpdateError} if the sequence of updates is invalid.\n   * @param {Array<UpdateType>} values\n   * @returns {void}\n   */\n  abstract update(values: UpdateType[]): boolean;\n\n  /**\n   * Return the current value of the channel.\n   *\n   * @throws {EmptyChannelError} if the channel is empty (never updated yet).\n   * @returns {ValueType}\n   */\n  abstract get(): ValueType;\n\n  /**\n   * Return a string representation of the channel's current state.\n   *\n   * @throws {EmptyChannelError} if the channel is empty (never updated yet), or doesn't support checkpoints.\n   * @returns {CheckpointType | undefined}\n   */\n  abstract checkpoint(): CheckpointType | undefined;\n\n  /**\n   * Mark the current value of the channel as consumed. By default, no-op.\n   * A channel can use this method to modify its state, preventing the value\n   * from being consumed again.\n   *\n   * Returns True if the channel was updated, False otherwise.\n   */\n  consume(): boolean {\n    return false;\n  }\n\n  /**\n   * Notify the channel that the Pregel run is finishing. By default, no-op.\n   * A channel can use this method to modify its state, preventing finish.\n   *\n   * Returns True if the channel was updated, False otherwise.\n   */\n  finish(): boolean {\n    return false;\n  }\n\n  /**\n   * Return True if the channel is available (not empty), False otherwise.\n   * Subclasses should override this method to provide a more efficient\n   * implementation than calling get() and catching EmptyChannelError.\n   */\n  isAvailable(): boolean {\n    try {\n      this.get();\n      return true;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.name === EmptyChannelError.unminifiable_name) {\n        return false;\n      }\n      throw error;\n    }\n  }\n}\n\nconst IS_ONLY_BASE_CHANNEL = Symbol.for(\"LG_IS_ONLY_BASE_CHANNEL\");\nexport function getOnlyChannels(\n  channels: Record<string, BaseChannel>\n): Record<string, BaseChannel> {\n  // @ts-expect-error - we know it's a record of base channels\n  if (channels[IS_ONLY_BASE_CHANNEL] === true) return channels;\n\n  const newChannels = {} as Record<string, BaseChannel>;\n  for (const k in channels) {\n    if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;\n    const value = channels[k];\n    if (isBaseChannel(value)) newChannels[k] = value;\n  }\n\n  Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });\n  return newChannels;\n}\n\nexport function emptyChannels<Cc extends Record<string, BaseChannel>>(\n  channels: Cc,\n  checkpoint: ReadonlyCheckpoint\n): Cc {\n  const filteredChannels = getOnlyChannels(channels) as Cc;\n\n  const newChannels = {} as Cc;\n  for (const k in filteredChannels) {\n    if (!Object.prototype.hasOwnProperty.call(filteredChannels, k)) continue;\n    const channelValue = checkpoint.channel_values[k];\n    newChannels[k] = filteredChannels[k].fromCheckpoint(channelValue);\n  }\n  Object.assign(newChannels, { [IS_ONLY_BASE_CHANNEL]: true });\n  return newChannels;\n}\n\nexport function createCheckpoint<ValueType>(\n  checkpoint: ReadonlyCheckpoint,\n  channels: Record<string, BaseChannel<ValueType>> | undefined,\n  step: number,\n  options?: { id?: string }\n): Checkpoint {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let values: Record<string, any>;\n  if (channels === undefined) {\n    values = checkpoint.channel_values;\n  } else {\n    values = {};\n    for (const k in channels) {\n      if (!Object.prototype.hasOwnProperty.call(channels, k)) continue;\n      try {\n        values[k] = channels[k].checkpoint();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (error: any) {\n        if (error.name === EmptyChannelError.unminifiable_name) {\n          // no-op\n        } else {\n          throw error; // Rethrow unexpected errors\n        }\n      }\n    }\n  }\n\n  return {\n    v: 4,\n    id: options?.id ?? uuid6(step),\n    ts: new Date().toISOString(),\n    channel_values: values,\n    channel_versions: checkpoint.channel_versions,\n    versions_seen: checkpoint.versions_seen,\n  };\n}\n","import { KVMap } from \"langsmith/schemas\";\nimport { Client } from \"langsmith\";\nimport { Document, DocumentInterface } from \"../documents/document.js\";\nimport { AsyncCallerParams } from \"../utils/async_caller.js\";\nimport { BaseDocumentLoader } from \"./base.js\";\n\n// TODO: Replace with import from `langsmith` once exposed.\ninterface ClientConfig {\n  apiUrl?: string;\n  apiKey?: string;\n  callerOptions?: AsyncCallerParams;\n  timeout_ms?: number;\n  webUrl?: string;\n  anonymizer?: (values: KVMap) => KVMap;\n  hideInputs?: boolean | ((inputs: KVMap) => KVMap);\n  hideOutputs?: boolean | ((outputs: KVMap) => KVMap);\n  autoBatchTracing?: boolean;\n  pendingAutoBatchedRunLimit?: number;\n  fetchOptions?: RequestInit;\n}\n\nexport interface LangSmithLoaderFields {\n  datasetId?: string;\n  datasetName?: string;\n  exampleIds?: Array<string>;\n  asOf?: Date | string;\n  splits?: string[];\n  inlineS3Urls?: boolean;\n  offset?: number;\n  limit?: number;\n  metadata?: KVMap;\n  filter?: string;\n  contentKey?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  formatContent?: (content: any) => string;\n  client?: Client;\n  clientConfig?: ClientConfig;\n}\n\n/**\n * Document loader integration with LangSmith.\n *\n * ## [Constructor args](https://api.js.langchain.com/interfaces/_langchain_core.document_loaders_langsmith.LangSmithLoaderFields.html)\n *\n * <details open>\n * <summary><strong>Load</strong></summary>\n *\n * ```typescript\n * import { LangSmithLoader } from '@langchain/core/document_loaders/langsmith';\n * import { Client } from 'langsmith';\n *\n * const langSmithClient = new Client({\n *   apiKey: process.env.LANGSMITH_API_KEY,\n * })\n *\n * const loader = new LangSmithLoader({\n *   datasetId: \"9a3b36f7-b308-40a5-9b46-6613853b6330\",\n *   limit: 1,\n * });\n *\n * const docs = await loader.load();\n * ```\n *\n * ```txt\n * [\n *   {\n *     pageContent: '{\\n  \"input_key_str\": \"string\",\\n  \"input_key_bool\": true\\n}',\n *     metadata: {\n *       id: '8523d9e9-c123-4b23-9b46-21021nds289e',\n *       created_at: '2024-08-19T17:09:14.806441+00:00',\n *       modified_at: '2024-08-19T17:09:14.806441+00:00',\n *       name: '#8517 @ brace-test-dataset',\n *       dataset_id: '9a3b36f7-b308-40a5-9b46-6613853b6330',\n *       source_run_id: null,\n *       metadata: [Object],\n *       inputs: [Object],\n *       outputs: [Object]\n *     }\n *   }\n * ]\n * ```\n * </details>\n */\nexport class LangSmithLoader extends BaseDocumentLoader {\n  datasetId?: string;\n\n  datasetName?: string;\n\n  exampleIds?: Array<string>;\n\n  asOf?: Date | string;\n\n  splits?: string[];\n\n  inlineS3Urls?: boolean;\n\n  offset?: number;\n\n  limit?: number;\n\n  metadata?: KVMap;\n\n  filter?: string;\n\n  contentKey: string[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  formatContent: (content: any) => string;\n\n  client: Client;\n\n  constructor(fields: LangSmithLoaderFields) {\n    super();\n\n    if (fields.client && fields.clientConfig) {\n      throw new Error(\"client and clientConfig cannot both be provided.\");\n    }\n    this.client = fields.client ?? new Client(fields?.clientConfig);\n    this.contentKey = fields.contentKey ? fields.contentKey.split(\".\") : [];\n    this.formatContent = fields.formatContent ?? _stringify;\n    this.datasetId = fields.datasetId;\n    this.datasetName = fields.datasetName;\n    this.exampleIds = fields.exampleIds;\n    this.asOf = fields.asOf;\n    this.splits = fields.splits;\n    this.inlineS3Urls = fields.inlineS3Urls;\n    this.offset = fields.offset;\n    this.limit = fields.limit;\n    this.metadata = fields.metadata;\n    this.filter = fields.filter;\n  }\n\n  async load(): Promise<Document[]> {\n    const documents: DocumentInterface[] = [];\n    for await (const example of this.client.listExamples({\n      datasetId: this.datasetId,\n      datasetName: this.datasetName,\n      exampleIds: this.exampleIds,\n      asOf: this.asOf,\n      splits: this.splits,\n      inlineS3Urls: this.inlineS3Urls,\n      offset: this.offset,\n      limit: this.limit,\n      metadata: this.metadata,\n      filter: this.filter,\n    })) {\n      let content = example.inputs;\n      for (const key of this.contentKey) {\n        content = content[key];\n      }\n      const contentStr = this.formatContent(content);\n\n      const metadata: KVMap = example;\n      [\"created_at\", \"modified_at\"].forEach((k) => {\n        if (k in metadata) {\n          if (typeof metadata[k] === \"object\") {\n            // Dates are of type `object`, we want to convert them to strings.\n            metadata[k] = metadata[k].toString();\n          }\n        }\n      });\n\n      documents.push({\n        pageContent: contentStr,\n        metadata,\n      });\n    }\n    return documents;\n  }\n}\n\nfunction _stringify(x: string | KVMap): string {\n  if (typeof x === \"string\") {\n    return x;\n  } else {\n    try {\n      return JSON.stringify(x, null, 2);\n    } catch {\n      return String(x);\n    }\n  }\n}\n","import { z } from \"zod/v3\";\nimport { z as z4, ZodError } from \"zod/v4\";\nimport {\n  validate,\n  type Schema as ValidationSchema,\n} from \"@cfworker/json-schema\";\nimport {\n  CallbackManager,\n  CallbackManagerForToolRun,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../language_models/base.js\";\nimport {\n  mergeConfigs,\n  ensureConfig,\n  patchConfig,\n  pickRunnableConfigKeys,\n  type RunnableConfig,\n} from \"../runnables/config.js\";\nimport type { RunnableFunc } from \"../runnables/base.js\";\nimport { isDirectToolOutput, ToolCall, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport type { RunnableToolLike } from \"../runnables/base.js\";\nimport {\n  _configHasToolCallId,\n  _isToolCall,\n  ToolInputParsingException,\n} from \"./utils.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodObject,\n  type InteropZodType,\n  interopParseAsync,\n  isSimpleStringZodSchema,\n  isInteropZodError,\n  isInteropZodSchema,\n  type ZodStringV3,\n  type ZodStringV4,\n  type ZodObjectV3,\n  type ZodObjectV4,\n} from \"../utils/types/zod.js\";\nimport { getAbortSignalError } from \"../utils/signal.js\";\nimport type {\n  StructuredToolCallInput,\n  ToolInputSchemaBase,\n  ToolReturnType,\n  ResponseFormat,\n  ToolInputSchemaInputType,\n  ToolInputSchemaOutputType,\n  ToolParams,\n  ToolRunnableConfig,\n  StructuredToolInterface,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  StringInputToolSchema,\n  ToolInterface,\n  ToolOutputType,\n  ToolRuntime,\n} from \"./types.js\";\nimport { type JSONSchema, validatesOnlyStrings } from \"../utils/json_schema.js\";\n\nexport type {\n  BaseDynamicToolInput,\n  ContentAndArtifact,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  ResponseFormat,\n  StructuredToolCallInput,\n  StructuredToolInterface,\n  StructuredToolParams,\n  ToolInterface,\n  ToolParams,\n  ToolReturnType,\n  ToolRunnableConfig,\n  ToolInputSchemaBase as ToolSchemaBase,\n} from \"./types.js\";\n\nexport {\n  isLangChainTool,\n  isRunnableToolLike,\n  isStructuredTool,\n  isStructuredToolParams,\n  type ToolRuntime,\n} from \"./types.js\";\n\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport abstract class StructuredTool<\n    SchemaT = ToolInputSchemaBase,\n    SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n    SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n    ToolOutputT = ToolOutputType\n  >\n  extends BaseLangChain<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  >\n  implements StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT>\n{\n  abstract name: string;\n\n  abstract description: string;\n\n  abstract schema: SchemaT;\n\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect = false;\n\n  verboseParsingErrors = false;\n\n  get lc_namespace() {\n    return [\"langchain\", \"tools\"];\n  }\n\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat = \"content\";\n\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n\n  constructor(fields?: ToolParams) {\n    super(fields ?? {});\n\n    this.verboseParsingErrors =\n      fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n    this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n    this.metadata = fields?.metadata ?? this.metadata;\n    this.extras = fields?.extras ?? this.extras;\n  }\n\n  protected abstract _call(\n    arg: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT>;\n\n  /**\n   * Invokes the tool with the provided input and configuration.\n   * @param input The input for the tool.\n   * @param config Optional configuration for the tool.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  async invoke<\n    TInput extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    input: TInput,\n    config?: TConfig\n  ): Promise<ToolReturnType<TInput, TConfig, ToolOutputT>> {\n    let toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >;\n\n    let enrichedConfig: ToolRunnableConfig = ensureConfig(\n      mergeConfigs(this.defaultConfig, config)\n    );\n    if (_isToolCall(input)) {\n      toolInput = input.args as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n      enrichedConfig = {\n        ...enrichedConfig,\n        toolCall: input,\n      };\n    } else {\n      toolInput = input as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n    }\n\n    return this.call(toolInput, enrichedConfig) as Promise<\n      ToolReturnType<TInput, TConfig, ToolOutputT>\n    >;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>> {\n    // Determine the actual input that needs parsing/validation.\n    // If arg is a ToolCall, use its args; otherwise, use arg directly.\n    const inputForValidation = _isToolCall(arg) ? arg.args : arg;\n\n    let parsed: SchemaOutputT; // This will hold the successfully parsed input of the expected output type.\n    if (isInteropZodSchema(this.schema)) {\n      try {\n        // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n        parsed = await interopParseAsync(\n          this.schema as InteropZodType,\n          inputForValidation as Exclude<TArg, ToolCall>\n        );\n      } catch (e) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${(e as Error).message}`;\n        }\n        if (isInteropZodError(e)) {\n          message = `${message}\\n\\n${z4.prettifyError(e as ZodError)}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n    } else {\n      const result = validate(\n        inputForValidation,\n        this.schema as ValidationSchema\n      );\n      if (!result.valid) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${result.errors\n            .map((e) => `${e.keywordLocation}: ${e.error}`)\n            .join(\"\\n\")}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n      // Assign the validated input to parsed\n      // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n      parsed = inputForValidation as SchemaOutputT;\n    }\n\n    const config = parseCallbackConfigArg(configArg);\n    const callbackManager_ = CallbackManager.configure(\n      config.callbacks,\n      this.callbacks,\n      config.tags || tags,\n      this.tags,\n      config.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleToolStart(\n      this.toJSON(),\n      // Log the original raw input arg\n      typeof arg === \"string\" ? arg : JSON.stringify(arg),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config.runName\n    );\n    delete config.runId;\n    let result;\n    try {\n      // Pass the correctly typed parsed input to _call\n      result = await this._call(parsed, runManager, config);\n    } catch (e) {\n      await runManager?.handleToolError(e);\n      throw e;\n    }\n    let content;\n    let artifact;\n    if (this.responseFormat === \"content_and_artifact\") {\n      if (Array.isArray(result) && result.length === 2) {\n        [content, artifact] = result;\n      } else {\n        throw new Error(\n          `Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(\n            result\n          )}`\n        );\n      }\n    } else {\n      content = result;\n    }\n\n    let toolCallId: string | undefined;\n    // Extract toolCallId ONLY if the original arg was a ToolCall\n    if (_isToolCall(arg)) {\n      toolCallId = arg.id;\n    }\n    // Or if it was provided in the config's toolCall property\n    if (!toolCallId && _configHasToolCallId(config)) {\n      toolCallId = config.toolCall.id;\n    }\n\n    const formattedOutput = _formatToolOutput<ToolOutputT>({\n      content,\n      artifact,\n      toolCallId,\n      name: this.name,\n      metadata: this.metadata,\n    });\n    await runManager?.handleToolEnd(formattedOutput);\n    return formattedOutput as ToolReturnType<TArg, TConfig, ToolOutputT>;\n  }\n}\n\n/**\n * Base class for Tools that accept input as a string.\n */\nexport abstract class Tool<ToolOutputT = ToolOutputType>\n  extends StructuredTool<\n    StringInputToolSchema,\n    ToolInputSchemaOutputType<StringInputToolSchema>,\n    ToolInputSchemaInputType<StringInputToolSchema>,\n    ToolOutputT\n  >\n  implements\n    ToolInterface<\n      StringInputToolSchema,\n      ToolInputSchemaInputType<StringInputToolSchema>,\n      ToolOutputT\n    >\n{\n  schema = z\n    .object({ input: z.string().optional() })\n    .transform((obj) => obj.input);\n\n  constructor(fields?: ToolParams) {\n    super(fields);\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  // Match the base class signature including the generics and conditional return type\n  call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    // Prepare the input for the base class call method.\n    // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n    const structuredArg =\n      typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n\n    // Ensure TConfig is passed to super.call\n    return super.call(structuredArg, callbacks);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool<\n  ToolOutputT = ToolOutputType\n> extends Tool<ToolOutputT> {\n  static lc_name() {\n    return \"DynamicTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicToolInput<ToolOutputT>[\"func\"];\n\n  constructor(fields: DynamicToolInput<ToolOutputT>) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  async call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    // Call the Tool class's call method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig);\n  }\n\n  /** @ignore */\n  async _call(\n    input: string, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(input, runManager, parentConfig);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nexport class DynamicStructuredTool<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends StructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT> {\n  static lc_name() {\n    return \"DynamicStructuredTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>[\"func\"];\n\n  schema: SchemaT;\n\n  constructor(\n    fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>\n  ) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    this.schema = fields.schema;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  // Match the base class signature\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n\n    // Call the base class method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig, tags);\n  }\n\n  protected _call(\n    arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0],\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: RunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(arg, runManager, parentConfig);\n  }\n}\n\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport abstract class BaseToolkit {\n  abstract tools: StructuredToolInterface[];\n\n  getTools(): StructuredToolInterface[] {\n    return this.tools;\n  }\n}\n\n/**\n * Parameters for the tool function.\n * Schema can be provided as Zod or JSON schema.\n * Both schema types will be validated.\n * @template {ToolInputSchemaBase} RunInput The input schema for the tool.\n */\ninterface ToolWrapperParams<RunInput = ToolInputSchemaBase | undefined>\n  extends ToolParams {\n  /**\n   * The name of the tool. If using with an LLM, this\n   * will be passed as the tool name.\n   */\n  name: string;\n  /**\n   * The description of the tool.\n   * @default `${fields.name} tool`\n   */\n  description?: string;\n  /**\n   * The input schema for the tool. If using an LLM, this\n   * will be passed as the tool schema to generate arguments\n   * for.\n   */\n  schema?: RunInput;\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Creates a new StructuredTool instance with the provided function, name, description, and schema.\n *\n * Schema can be provided as Zod or JSON schema, and both will be validated.\n *\n * @function\n * @template {ToolInputSchemaBase} SchemaT The input schema for the tool.\n * @template {ToolReturnType} ToolOutputT The output type of the tool.\n *\n * @param {RunnableFunc<z.output<SchemaT>, ToolOutputT>} func - The function to invoke when the tool is called.\n * @param {ToolWrapperParams<SchemaT>} fields - An object containing the following properties:\n * @param {string} fields.name The name of the tool.\n * @param {string | undefined} fields.description The description of the tool. Defaults to either the description on the Zod schema, or `${fields.name} tool`.\n * @param {z.AnyZodObject | z.ZodString | undefined} fields.schema The Zod schema defining the input for the tool. If undefined, it will default to a Zod string schema.\n *\n * @returns {DynamicStructuredTool<SchemaT>} A new StructuredTool instance.\n */\nexport function tool<SchemaT extends ZodStringV3, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<SchemaT extends ZodStringV4, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<\n    Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n):\n  | DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>\n  | DynamicTool<ToolOutputT>;\n\n// Overloads with ToolRuntime as CallOptions\nexport function tool<\n  SchemaT extends ZodStringV3,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodStringV4,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n):\n  | DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>\n  | DynamicTool<ToolOutputT> {\n  const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);\n  const isStringJSONSchema = validatesOnlyStrings(fields.schema);\n\n  // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n  if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n    return new DynamicTool<ToolOutputT>({\n      ...fields,\n      description:\n        fields.description ??\n        (fields.schema as { description?: string } | undefined)?.description ??\n        `${fields.name} tool`,\n      func: async (input, runManager, config) => {\n        return new Promise<ToolOutputT>((resolve, reject) => {\n          const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild(),\n          });\n          // eslint-disable-next-line no-void\n          void AsyncLocalStorageProviderSingleton.runWithConfig(\n            pickRunnableConfigKeys(childConfig),\n            async () => {\n              try {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                resolve(func(input as any, childConfig as any));\n              } catch (e) {\n                reject(e);\n              }\n            }\n          );\n        });\n      },\n    });\n  }\n\n  const schema = fields.schema as InteropZodObject | JSONSchema;\n\n  const description =\n    fields.description ??\n    (fields.schema as { description?: string }).description ??\n    `${fields.name} tool`;\n\n  return new DynamicStructuredTool<\n    typeof schema,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT\n  >({\n    ...fields,\n    description,\n    schema,\n    func: async (input, runManager, config) => {\n      return new Promise<ToolOutputT>((resolve, reject) => {\n        let listener: (() => void) | undefined;\n        const cleanup = () => {\n          if (config?.signal && listener) {\n            config.signal.removeEventListener(\"abort\", listener);\n          }\n        };\n\n        if (config?.signal) {\n          listener = () => {\n            cleanup();\n            reject(getAbortSignalError(config.signal));\n          };\n          config.signal.addEventListener(\"abort\", listener);\n        }\n\n        const childConfig = patchConfig(config, {\n          callbacks: runManager?.getChild(),\n        });\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              const result = await func(input as any, childConfig as any);\n\n              /**\n               * If the signal is aborted, we don't want to resolve the promise\n               * as the promise is already rejected.\n               */\n              if (config?.signal?.aborted) {\n                cleanup();\n                return;\n              }\n\n              cleanup();\n              resolve(result);\n            } catch (e) {\n              cleanup();\n              reject(e);\n            }\n          }\n        );\n      });\n    },\n  }) as DynamicStructuredTool<\n    SchemaT,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT\n  >;\n}\n\nfunction _formatToolOutput<TOutput extends ToolOutputType>(params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}): ToolMessage | TOutput {\n  const { content, artifact, toolCallId, metadata } = params;\n  if (toolCallId && !isDirectToolOutput(content)) {\n    if (\n      typeof content === \"string\" ||\n      (Array.isArray(content) &&\n        content.every((item) => typeof item === \"object\"))\n    ) {\n      return new ToolMessage({\n        status: \"success\",\n        content,\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    } else {\n      return new ToolMessage({\n        status: \"success\",\n        content: _stringify(content),\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    }\n  } else {\n    return content;\n  }\n}\n\nfunction _stringify(content: unknown): string {\n  try {\n    return JSON.stringify(content, null, 2) ?? \"\";\n  } catch (_noOp) {\n    return `${content}`;\n  }\n}\n\nexport type ServerTool = Record<string, unknown>;\nexport type ClientTool =\n  | StructuredToolInterface\n  | DynamicTool\n  | RunnableToolLike;\n","import {\n  BaseChatMessageHistory,\n  BaseListChatMessageHistory,\n} from \"../chat_history.js\";\nimport {\n  AIMessage,\n  BaseMessage,\n  HumanMessage,\n  isBaseMessage,\n} from \"../messages/index.js\";\nimport { Run } from \"../tracers/base.js\";\nimport {\n  Runnable,\n  RunnableBinding,\n  type RunnableBindingArgs,\n  RunnableLambda,\n} from \"./base.js\";\nimport { RunnableConfig } from \"./config.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n\ntype GetSessionHistoryCallable = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ...args: Array<any>\n) =>\n  | Promise<BaseChatMessageHistory | BaseListChatMessageHistory>\n  | BaseChatMessageHistory\n  | BaseListChatMessageHistory;\n\nexport interface RunnableWithMessageHistoryInputs<RunInput, RunOutput>\n  extends Omit<RunnableBindingArgs<RunInput, RunOutput>, \"bound\" | \"config\"> {\n  runnable: Runnable<RunInput, RunOutput>;\n  getMessageHistory: GetSessionHistoryCallable;\n  inputMessagesKey?: string;\n  outputMessagesKey?: string;\n  historyMessagesKey?: string;\n  config?: RunnableConfig;\n}\n\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // pnpm install @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"@langchain/classic/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory<\n  RunInput,\n  RunOutput\n> extends RunnableBinding<RunInput, RunOutput> {\n  runnable: Runnable<RunInput, RunOutput>;\n\n  inputMessagesKey?: string;\n\n  outputMessagesKey?: string;\n\n  historyMessagesKey?: string;\n\n  getMessageHistory: GetSessionHistoryCallable;\n\n  constructor(fields: RunnableWithMessageHistoryInputs<RunInput, RunOutput>) {\n    let historyChain: Runnable = RunnableLambda.from((input, options) =>\n      this._enterHistory(input, options ?? {})\n    ).withConfig({ runName: \"loadHistory\" });\n\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain,\n      }).withConfig({ runName: \"insertHistory\" });\n    }\n\n    const bound = historyChain\n      .pipe(\n        fields.runnable.withListeners({\n          onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        })\n      )\n      .withConfig({ runName: \"RunnableWithMessageHistory\" });\n\n    const config = fields.config ?? {};\n\n    super({\n      ...fields,\n      config,\n      bound,\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n\n  _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedInputValue;\n    if (\n      typeof inputValue === \"object\" &&\n      !Array.isArray(inputValue) &&\n      !isBaseMessage(inputValue)\n    ) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(\n          parsedInputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue: string | BaseMessage | Array<BaseMessage> | Record<string, any>\n  ): Array<BaseMessage> {\n    let parsedOutputValue;\n    if (\n      !Array.isArray(outputValue) &&\n      !isBaseMessage(outputValue) &&\n      typeof outputValue !== \"string\"\n    ) {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(\n        `Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(\n          parsedOutputValue,\n          null,\n          2\n        )}`\n      );\n    }\n  }\n\n  async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input: any,\n    kwargs?: RunnableConfig\n  ): Promise<BaseMessage[]> {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n\n  async _exitHistory(run: Run, config: RunnableConfig): Promise<void> {\n    const history = config.configurable?.messageHistory;\n\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(\n        `Output values from 'Run' undefined. Run: ${JSON.stringify(\n          run,\n          null,\n          2\n        )}`\n      );\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n\n  async _mergeConfig(...configs: Array<RunnableConfig | undefined>) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\",\n      };\n      const exampleConfig = { configurable: { sessionId: \"123\" } };\n      throw new Error(\n        `sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n          `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(\n            exampleConfig\n          )})`\n      );\n    }\n    // attach messageHistory\n    const { sessionId } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(\n      sessionId\n    );\n    return config;\n  }\n}\n","import {\n  Runnable,\n  RunnableLike,\n  _coerceToDict,\n  _coerceToRunnable,\n} from \"./base.js\";\nimport {\n  RunnableConfig,\n  getCallbackManagerForConfig,\n  patchConfig,\n} from \"./config.js\";\nimport { CallbackManagerForChainRun } from \"../callbacks/manager.js\";\nimport { concat } from \"../utils/stream.js\";\n\n/**\n * Type for a branch in the RunnableBranch. It consists of a condition\n * runnable and a branch runnable. The condition runnable is used to\n * determine whether the branch should be executed, and the branch runnable\n * is executed if the condition is true.\n */\nexport type Branch<RunInput, RunOutput> = [\n  Runnable<RunInput, boolean>,\n  Runnable<RunInput, RunOutput>\n];\n\nexport type BranchLike<RunInput, RunOutput> = [\n  RunnableLike<RunInput, boolean>,\n  RunnableLike<RunInput, RunOutput>\n];\n\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch<RunInput = any, RunOutput = any> extends Runnable<\n  RunInput,\n  RunOutput\n> {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n\n  lc_namespace = [\"langchain_core\", \"runnables\"];\n\n  lc_serializable = true;\n\n  default: Runnable<RunInput, RunOutput>;\n\n  branches: Branch<RunInput, RunOutput>[];\n\n  constructor(fields: {\n    branches: Branch<RunInput, RunOutput>[];\n    default: Runnable<RunInput, RunOutput>;\n  }) {\n    super(fields);\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from<RunInput = any, RunOutput = any>(\n    branches: [\n      ...BranchLike<RunInput, RunOutput>[],\n      RunnableLike<RunInput, RunOutput>\n    ]\n  ) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1) as BranchLike<\n      RunInput,\n      RunOutput\n    >[];\n    const coercedBranches: Branch<RunInput, RunOutput>[] = branchLikes.map(\n      ([condition, runnable]) => [\n        _coerceToRunnable(condition),\n        _coerceToRunnable(runnable),\n      ]\n    );\n    const defaultBranch = _coerceToRunnable(\n      branches[branches.length - 1] as RunnableLike<RunInput, RunOutput>\n    );\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch,\n    });\n  }\n\n  async _invoke(\n    input: RunInput,\n    config?: Partial<RunnableConfig>,\n    runManager?: CallbackManagerForChainRun\n  ): Promise<RunOutput> {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`),\n        })\n      );\n      if (conditionValue) {\n        result = await branchRunnable.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`),\n          })\n        );\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(\n        input,\n        patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\"),\n        })\n      );\n    }\n    return result;\n  }\n\n  async invoke(\n    input: RunInput,\n    config: RunnableConfig = {}\n  ): Promise<RunOutput> {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n\n  async *_streamIterator(input: RunInput, config?: Partial<RunnableConfig>) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      config?.runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName\n    );\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(`condition:${i + 1}`),\n          })\n        );\n        if (conditionValue) {\n          stream = await branchRunnable.stream(\n            input,\n            patchConfig(config, {\n              callbacks: runManager?.getChild(`branch:${i + 1}`),\n            })\n          );\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(\n          input,\n          patchConfig(config, {\n            callbacks: runManager?.getChild(\"branch:default\"),\n          })\n        );\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk as RunOutput);\n              } catch {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}\n","import { Example } from \"../prompts/base.js\";\nimport { BaseExampleSelector } from \"./base.js\";\nimport { PromptTemplate } from \"../prompts/prompt.js\";\n\n/**\n * Calculates the length of a text based on the number of words and lines.\n */\nfunction getLengthBased(text: string): number {\n  return text.split(/\\n| /).length;\n}\n\n/**\n * Interface for the input parameters of the LengthBasedExampleSelector\n * class.\n */\nexport interface LengthBasedExampleSelectorInput {\n  examplePrompt: PromptTemplate;\n  maxLength?: number;\n  getTextLength?: (text: string) => number;\n}\n\n/**\n * A specialized example selector that selects examples based on their\n * length, ensuring that the total length of the selected examples does\n * not exceed a specified maximum length.\n * @example\n * ```typescript\n * const exampleSelector = new LengthBasedExampleSelector(\n *   [\n *     { input: \"happy\", output: \"sad\" },\n *     { input: \"tall\", output: \"short\" },\n *     { input: \"energetic\", output: \"lethargic\" },\n *     { input: \"sunny\", output: \"gloomy\" },\n *     { input: \"windy\", output: \"calm\" },\n *   ],\n *   {\n *     examplePrompt: new PromptTemplate({\n *       inputVariables: [\"input\", \"output\"],\n *       template: \"Input: {input}\\nOutput: {output}\",\n *     }),\n *     maxLength: 25,\n *   },\n * );\n * const dynamicPrompt = new FewShotPromptTemplate({\n *   exampleSelector,\n *   examplePrompt: new PromptTemplate({\n *     inputVariables: [\"input\", \"output\"],\n *     template: \"Input: {input}\\nOutput: {output}\",\n *   }),\n *   prefix: \"Give the antonym of every input\",\n *   suffix: \"Input: {adjective}\\nOutput:\",\n *   inputVariables: [\"adjective\"],\n * });\n * console.log(dynamicPrompt.format({ adjective: \"big\" }));\n * console.log(\n *   dynamicPrompt.format({\n *     adjective:\n *       \"big and huge and massive and large and gigantic and tall and much much much much much bigger than everything else\",\n *   }),\n * );\n * ```\n */\nexport class LengthBasedExampleSelector extends BaseExampleSelector {\n  protected examples: Example[] = [];\n\n  examplePrompt!: PromptTemplate;\n\n  getTextLength: (text: string) => number = getLengthBased;\n\n  maxLength = 2048;\n\n  exampleTextLengths: number[] = [];\n\n  constructor(data: LengthBasedExampleSelectorInput) {\n    super(data);\n    this.examplePrompt = data.examplePrompt;\n    this.maxLength = data.maxLength ?? 2048;\n    this.getTextLength = data.getTextLength ?? getLengthBased;\n  }\n\n  /**\n   * Adds an example to the list of examples and calculates its length.\n   * @param example The example to be added.\n   * @returns Promise that resolves when the example has been added and its length calculated.\n   */\n  async addExample(example: Example): Promise<void> {\n    this.examples.push(example);\n    const stringExample = await this.examplePrompt.format(example);\n    this.exampleTextLengths.push(this.getTextLength(stringExample));\n  }\n\n  /**\n   * Calculates the lengths of the examples.\n   * @param v Array of lengths of the examples.\n   * @param values Instance of LengthBasedExampleSelector.\n   * @returns Promise that resolves with an array of lengths of the examples.\n   */\n  async calculateExampleTextLengths(\n    v: number[],\n    values: LengthBasedExampleSelector\n  ): Promise<number[]> {\n    if (v.length > 0) {\n      return v;\n    }\n\n    const { examples, examplePrompt } = values;\n    const stringExamples = await Promise.all(\n      examples.map((eg: Example) => examplePrompt.format(eg))\n    );\n    return stringExamples.map((eg: string) => this.getTextLength(eg));\n  }\n\n  /**\n   * Selects examples until the total length of the selected examples\n   * reaches the maxLength.\n   * @param inputVariables The input variables for the examples.\n   * @returns Promise that resolves with an array of selected examples.\n   */\n  async selectExamples(inputVariables: Example): Promise<Example[]> {\n    const inputs = Object.values(inputVariables).join(\" \");\n    let remainingLength = this.maxLength - this.getTextLength(inputs);\n    let i = 0;\n    const examples: Example[] = [];\n\n    while (remainingLength > 0 && i < this.examples.length) {\n      const newLength = remainingLength - this.exampleTextLengths[i];\n      if (newLength < 0) {\n        break;\n      } else {\n        examples.push(this.examples[i]);\n        remainingLength = newLength;\n      }\n      i += 1;\n    }\n\n    return examples;\n  }\n\n  /**\n   * Creates a new instance of LengthBasedExampleSelector and adds a list of\n   * examples to it.\n   * @param examples Array of examples to be added.\n   * @param args Input parameters for the LengthBasedExampleSelector.\n   * @returns Promise that resolves with a new instance of LengthBasedExampleSelector with the examples added.\n   */\n  static async fromExamples(\n    examples: Example[],\n    args: LengthBasedExampleSelectorInput\n  ) {\n    const selector = new LengthBasedExampleSelector(args);\n    await Promise.all(examples.map((eg) => selector.addExample(eg)));\n    return selector;\n  }\n}\n","import {\n  CallbackManager,\n  CallbackManagerForRetrieverRun,\n  Callbacks,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { Runnable, type RunnableInterface } from \"../runnables/base.js\";\nimport { RunnableConfig, ensureConfig } from \"../runnables/config.js\";\n\n/**\n * Input configuration options for initializing a retriever that extends\n * the `BaseRetriever` class. This interface provides base properties\n * common to all retrievers, allowing customization of callback functions,\n * tagging, metadata, and logging verbosity.\n *\n * Fields:\n * - `callbacks` (optional): An array of callback functions that handle various\n *   events during retrieval, such as logging, error handling, or progress updates.\n *\n * - `tags` (optional): An array of strings used to add contextual tags to\n *   retrieval operations, allowing for easier categorization and tracking.\n *\n * - `metadata` (optional): A record of key-value pairs to store additional\n *   contextual information for retrieval operations, which can be useful\n *   for logging or auditing purposes.\n *\n * - `verbose` (optional): A boolean flag that, if set to `true`, enables\n *   detailed logging and output during the retrieval process. Defaults to `false`.\n */\nexport interface BaseRetrieverInput {\n  callbacks?: Callbacks;\n  tags?: string[];\n  metadata?: Record<string, unknown>;\n  verbose?: boolean;\n}\n\n/**\n * Interface for a base retriever that defines core functionality for\n * retrieving relevant documents from a source based on a query.\n *\n * The `BaseRetrieverInterface` standardizes the `getRelevantDocuments` method,\n * enabling retrieval of documents that match the query criteria.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nexport interface BaseRetrieverInterface<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Metadata extends Record<string, any> = Record<string, any>\n> extends RunnableInterface<string, DocumentInterface<Metadata>[]> {}\n\n/**\n * Abstract base class for a document retrieval system, designed to\n * process string queries and return the most relevant documents from a source.\n *\n * `BaseRetriever` provides common properties and methods for derived retrievers,\n * such as callbacks, tagging, and verbose logging. Custom retrieval systems\n * should extend this class and implement `_getRelevantDocuments` to define\n * the specific retrieval logic.\n *\n * @template Metadata - The type of metadata associated with each document,\n *                      defaulting to `Record<string, any>`.\n */\nexport abstract class BaseRetriever<\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Metadata extends Record<string, any> = Record<string, any>\n  >\n  extends Runnable<string, DocumentInterface<Metadata>[]>\n  implements BaseRetrieverInterface\n{\n  /**\n   * Optional callbacks to handle various events in the retrieval process.\n   */\n  callbacks?: Callbacks;\n\n  /**\n   * Tags to label or categorize the retrieval operation.\n   */\n  tags?: string[];\n\n  /**\n   * Metadata to provide additional context or information about the retrieval\n   * operation.\n   */\n  metadata?: Record<string, unknown>;\n\n  /**\n   * If set to `true`, enables verbose logging for the retrieval process.\n   */\n  verbose?: boolean;\n\n  /**\n   * Constructs a new `BaseRetriever` instance with optional configuration fields.\n   *\n   * @param fields - Optional input configuration that can include `callbacks`,\n   *                 `tags`, `metadata`, and `verbose` settings for custom retriever behavior.\n   */\n  constructor(fields?: BaseRetrieverInput) {\n    super(fields);\n    this.callbacks = fields?.callbacks;\n    this.tags = fields?.tags ?? [];\n    this.metadata = fields?.metadata ?? {};\n    this.verbose = fields?.verbose ?? false;\n  }\n\n  /**\n   * TODO: This should be an abstract method, but we'd like to avoid breaking\n   * changes to people currently using subclassed custom retrievers.\n   * Change it on next major release.\n   */\n  /**\n   * Placeholder method for retrieving relevant documents based on a query.\n   *\n   * This method is intended to be implemented by subclasses and will be\n   * converted to an abstract method in the next major release. Currently, it\n   * throws an error if not implemented, ensuring that custom retrievers define\n   * the specific retrieval logic.\n   *\n   * @param _query - The query string used to search for relevant documents.\n   * @param _callbacks - (optional) Callback manager for managing callbacks\n   *                     during retrieval.\n   * @returns A promise resolving to an array of `DocumentInterface` instances relevant to the query.\n   * @throws {Error} Throws an error indicating the method is not implemented.\n   */\n  _getRelevantDocuments(\n    _query: string,\n    _callbacks?: CallbackManagerForRetrieverRun\n  ): Promise<DocumentInterface<Metadata>[]> {\n    throw new Error(\"Not implemented!\");\n  }\n\n  /**\n   * Executes a retrieval operation.\n   *\n   * @param input - The query string used to search for relevant documents.\n   * @param options - (optional) Configuration options for the retrieval run,\n   *                  which may include callbacks, tags, and metadata.\n   * @returns A promise that resolves to an array of `DocumentInterface` instances\n   *          representing the most relevant documents to the query.\n   */\n  async invoke(\n    input: string,\n    options?: RunnableConfig\n  ): Promise<DocumentInterface<Metadata>[]> {\n    const parsedConfig = ensureConfig(parseCallbackConfigArg(options));\n    const callbackManager_ = await CallbackManager.configure(\n      parsedConfig.callbacks,\n      this.callbacks,\n      parsedConfig.tags,\n      this.tags,\n      parsedConfig.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleRetrieverStart(\n      this.toJSON(),\n      input,\n      parsedConfig.runId,\n      undefined,\n      undefined,\n      undefined,\n      parsedConfig.runName\n    );\n    try {\n      const results = await this._getRelevantDocuments(input, runManager);\n      await runManager?.handleRetrieverEnd(results);\n      return results;\n    } catch (error) {\n      await runManager?.handleRetrieverError(error);\n      throw error;\n    }\n  }\n}\n","// @ts-nocheck\n\n// Inlined to deal with portability issues with importing crypto module\n\n/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.11.1\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2025\n * @license MIT\n */\n/*jslint bitwise: true */\n\"use strict\";\n\nvar HEX_CHARS = \"0123456789abcdef\".split(\"\");\nvar EXTRA = [-2147483648, 8388608, 32768, 128];\nvar SHIFT = [24, 16, 8, 0];\nvar K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n  0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n  0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n  0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n  0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n  0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n];\nvar OUTPUT_TYPES = [\"hex\", \"array\", \"digest\", \"arrayBuffer\"];\n\nvar blocks = [];\n\nfunction Sha256(is224, sharedMemory) {\n  if (sharedMemory) {\n    blocks[0] =\n      blocks[16] =\n      blocks[1] =\n      blocks[2] =\n      blocks[3] =\n      blocks[4] =\n      blocks[5] =\n      blocks[6] =\n      blocks[7] =\n      blocks[8] =\n      blocks[9] =\n      blocks[10] =\n      blocks[11] =\n      blocks[12] =\n      blocks[13] =\n      blocks[14] =\n      blocks[15] =\n        0;\n    this.blocks = blocks;\n  } else {\n    this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  }\n\n  if (is224) {\n    this.h0 = 0xc1059ed8;\n    this.h1 = 0x367cd507;\n    this.h2 = 0x3070dd17;\n    this.h3 = 0xf70e5939;\n    this.h4 = 0xffc00b31;\n    this.h5 = 0x68581511;\n    this.h6 = 0x64f98fa7;\n    this.h7 = 0xbefa4fa4;\n  } else {\n    // 256\n    this.h0 = 0x6a09e667;\n    this.h1 = 0xbb67ae85;\n    this.h2 = 0x3c6ef372;\n    this.h3 = 0xa54ff53a;\n    this.h4 = 0x510e527f;\n    this.h5 = 0x9b05688c;\n    this.h6 = 0x1f83d9ab;\n    this.h7 = 0x5be0cd19;\n  }\n\n  this.block = this.start = this.bytes = this.hBytes = 0;\n  this.finalized = this.hashed = false;\n  this.first = true;\n  this.is224 = is224;\n}\n\nSha256.prototype.update = function (message) {\n  if (this.finalized) {\n    return;\n  }\n  var notString,\n    type = typeof message;\n  if (type !== \"string\") {\n    if (type === \"object\") {\n      if (message === null) {\n        throw new Error(ERROR);\n      } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n        message = new Uint8Array(message);\n      } else if (!Array.isArray(message)) {\n        if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n          throw new Error(ERROR);\n        }\n      }\n    } else {\n      throw new Error(ERROR);\n    }\n    notString = true;\n  }\n  var code,\n    index = 0,\n    i,\n    length = message.length,\n    blocks = this.blocks;\n  while (index < length) {\n    if (this.hashed) {\n      this.hashed = false;\n      blocks[0] = this.block;\n      this.block =\n        blocks[16] =\n        blocks[1] =\n        blocks[2] =\n        blocks[3] =\n        blocks[4] =\n        blocks[5] =\n        blocks[6] =\n        blocks[7] =\n        blocks[8] =\n        blocks[9] =\n        blocks[10] =\n        blocks[11] =\n        blocks[12] =\n        blocks[13] =\n        blocks[14] =\n        blocks[15] =\n          0;\n    }\n\n    if (notString) {\n      for (i = this.start; index < length && i < 64; ++index) {\n        blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3];\n      }\n    } else {\n      for (i = this.start; index < length && i < 64; ++index) {\n        code = message.charCodeAt(index);\n        if (code < 0x80) {\n          blocks[i >>> 2] |= code << SHIFT[i++ & 3];\n        } else if (code < 0x800) {\n          blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        } else if (code < 0xd800 || code >= 0xe000) {\n          blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        } else {\n          code =\n            0x10000 +\n            (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n          blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3];\n          blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n        }\n      }\n    }\n\n    this.lastByteIndex = i;\n    this.bytes += i - this.start;\n    if (i >= 64) {\n      this.block = blocks[16];\n      this.start = i - 64;\n      this.hash();\n      this.hashed = true;\n    } else {\n      this.start = i;\n    }\n  }\n  if (this.bytes > 4294967295) {\n    this.hBytes += (this.bytes / 4294967296) << 0;\n    this.bytes = this.bytes % 4294967296;\n  }\n  return this;\n};\n\nSha256.prototype.finalize = function () {\n  if (this.finalized) {\n    return;\n  }\n  this.finalized = true;\n  var blocks = this.blocks,\n    i = this.lastByteIndex;\n  blocks[16] = this.block;\n  blocks[i >>> 2] |= EXTRA[i & 3];\n  this.block = blocks[16];\n  if (i >= 56) {\n    if (!this.hashed) {\n      this.hash();\n    }\n    blocks[0] = this.block;\n    blocks[16] =\n      blocks[1] =\n      blocks[2] =\n      blocks[3] =\n      blocks[4] =\n      blocks[5] =\n      blocks[6] =\n      blocks[7] =\n      blocks[8] =\n      blocks[9] =\n      blocks[10] =\n      blocks[11] =\n      blocks[12] =\n      blocks[13] =\n      blocks[14] =\n      blocks[15] =\n        0;\n  }\n  blocks[14] = (this.hBytes << 3) | (this.bytes >>> 29);\n  blocks[15] = this.bytes << 3;\n  this.hash();\n};\n\nSha256.prototype.hash = function () {\n  var a = this.h0,\n    b = this.h1,\n    c = this.h2,\n    d = this.h3,\n    e = this.h4,\n    f = this.h5,\n    g = this.h6,\n    h = this.h7,\n    blocks = this.blocks,\n    j,\n    s0,\n    s1,\n    maj,\n    t1,\n    t2,\n    ch,\n    ab,\n    da,\n    cd,\n    bc;\n\n  for (j = 16; j < 64; ++j) {\n    // rightrotate\n    t1 = blocks[j - 15];\n    s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n    t1 = blocks[j - 2];\n    s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n    blocks[j] = (blocks[j - 16] + s0 + blocks[j - 7] + s1) << 0;\n  }\n\n  bc = b & c;\n  for (j = 0; j < 64; j += 4) {\n    if (this.first) {\n      if (this.is224) {\n        ab = 300032;\n        t1 = blocks[0] - 1413257819;\n        h = (t1 - 150054599) << 0;\n        d = (t1 + 24177077) << 0;\n      } else {\n        ab = 704751109;\n        t1 = blocks[0] - 210244248;\n        h = (t1 - 1521486534) << 0;\n        d = (t1 + 143694565) << 0;\n      }\n      this.first = false;\n    } else {\n      s0 =\n        ((a >>> 2) | (a << 30)) ^\n        ((a >>> 13) | (a << 19)) ^\n        ((a >>> 22) | (a << 10));\n      s1 =\n        ((e >>> 6) | (e << 26)) ^\n        ((e >>> 11) | (e << 21)) ^\n        ((e >>> 25) | (e << 7));\n      ab = a & b;\n      maj = ab ^ (a & c) ^ bc;\n      ch = (e & f) ^ (~e & g);\n      t1 = h + s1 + ch + K[j] + blocks[j];\n      t2 = s0 + maj;\n      h = (d + t1) << 0;\n      d = (t1 + t2) << 0;\n    }\n    s0 =\n      ((d >>> 2) | (d << 30)) ^\n      ((d >>> 13) | (d << 19)) ^\n      ((d >>> 22) | (d << 10));\n    s1 =\n      ((h >>> 6) | (h << 26)) ^\n      ((h >>> 11) | (h << 21)) ^\n      ((h >>> 25) | (h << 7));\n    da = d & a;\n    maj = da ^ (d & b) ^ ab;\n    ch = (g & h) ^ (~g & e);\n    t1 = f + s1 + ch + K[j + 1] + blocks[j + 1];\n    t2 = s0 + maj;\n    g = (c + t1) << 0;\n    c = (t1 + t2) << 0;\n    s0 =\n      ((c >>> 2) | (c << 30)) ^\n      ((c >>> 13) | (c << 19)) ^\n      ((c >>> 22) | (c << 10));\n    s1 =\n      ((g >>> 6) | (g << 26)) ^\n      ((g >>> 11) | (g << 21)) ^\n      ((g >>> 25) | (g << 7));\n    cd = c & d;\n    maj = cd ^ (c & a) ^ da;\n    ch = (f & g) ^ (~f & h);\n    t1 = e + s1 + ch + K[j + 2] + blocks[j + 2];\n    t2 = s0 + maj;\n    f = (b + t1) << 0;\n    b = (t1 + t2) << 0;\n    s0 =\n      ((b >>> 2) | (b << 30)) ^\n      ((b >>> 13) | (b << 19)) ^\n      ((b >>> 22) | (b << 10));\n    s1 =\n      ((f >>> 6) | (f << 26)) ^\n      ((f >>> 11) | (f << 21)) ^\n      ((f >>> 25) | (f << 7));\n    bc = b & c;\n    maj = bc ^ (b & d) ^ cd;\n    ch = (f & g) ^ (~f & h);\n    t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n    t2 = s0 + maj;\n    e = (a + t1) << 0;\n    a = (t1 + t2) << 0;\n    this.chromeBugWorkAround = true;\n  }\n\n  this.h0 = (this.h0 + a) << 0;\n  this.h1 = (this.h1 + b) << 0;\n  this.h2 = (this.h2 + c) << 0;\n  this.h3 = (this.h3 + d) << 0;\n  this.h4 = (this.h4 + e) << 0;\n  this.h5 = (this.h5 + f) << 0;\n  this.h6 = (this.h6 + g) << 0;\n  this.h7 = (this.h7 + h) << 0;\n};\n\nSha256.prototype.hex = function () {\n  this.finalize();\n\n  var h0 = this.h0,\n    h1 = this.h1,\n    h2 = this.h2,\n    h3 = this.h3,\n    h4 = this.h4,\n    h5 = this.h5,\n    h6 = this.h6,\n    h7 = this.h7;\n\n  var hex =\n    HEX_CHARS[(h0 >>> 28) & 0x0f] +\n    HEX_CHARS[(h0 >>> 24) & 0x0f] +\n    HEX_CHARS[(h0 >>> 20) & 0x0f] +\n    HEX_CHARS[(h0 >>> 16) & 0x0f] +\n    HEX_CHARS[(h0 >>> 12) & 0x0f] +\n    HEX_CHARS[(h0 >>> 8) & 0x0f] +\n    HEX_CHARS[(h0 >>> 4) & 0x0f] +\n    HEX_CHARS[h0 & 0x0f] +\n    HEX_CHARS[(h1 >>> 28) & 0x0f] +\n    HEX_CHARS[(h1 >>> 24) & 0x0f] +\n    HEX_CHARS[(h1 >>> 20) & 0x0f] +\n    HEX_CHARS[(h1 >>> 16) & 0x0f] +\n    HEX_CHARS[(h1 >>> 12) & 0x0f] +\n    HEX_CHARS[(h1 >>> 8) & 0x0f] +\n    HEX_CHARS[(h1 >>> 4) & 0x0f] +\n    HEX_CHARS[h1 & 0x0f] +\n    HEX_CHARS[(h2 >>> 28) & 0x0f] +\n    HEX_CHARS[(h2 >>> 24) & 0x0f] +\n    HEX_CHARS[(h2 >>> 20) & 0x0f] +\n    HEX_CHARS[(h2 >>> 16) & 0x0f] +\n    HEX_CHARS[(h2 >>> 12) & 0x0f] +\n    HEX_CHARS[(h2 >>> 8) & 0x0f] +\n    HEX_CHARS[(h2 >>> 4) & 0x0f] +\n    HEX_CHARS[h2 & 0x0f] +\n    HEX_CHARS[(h3 >>> 28) & 0x0f] +\n    HEX_CHARS[(h3 >>> 24) & 0x0f] +\n    HEX_CHARS[(h3 >>> 20) & 0x0f] +\n    HEX_CHARS[(h3 >>> 16) & 0x0f] +\n    HEX_CHARS[(h3 >>> 12) & 0x0f] +\n    HEX_CHARS[(h3 >>> 8) & 0x0f] +\n    HEX_CHARS[(h3 >>> 4) & 0x0f] +\n    HEX_CHARS[h3 & 0x0f] +\n    HEX_CHARS[(h4 >>> 28) & 0x0f] +\n    HEX_CHARS[(h4 >>> 24) & 0x0f] +\n    HEX_CHARS[(h4 >>> 20) & 0x0f] +\n    HEX_CHARS[(h4 >>> 16) & 0x0f] +\n    HEX_CHARS[(h4 >>> 12) & 0x0f] +\n    HEX_CHARS[(h4 >>> 8) & 0x0f] +\n    HEX_CHARS[(h4 >>> 4) & 0x0f] +\n    HEX_CHARS[h4 & 0x0f] +\n    HEX_CHARS[(h5 >>> 28) & 0x0f] +\n    HEX_CHARS[(h5 >>> 24) & 0x0f] +\n    HEX_CHARS[(h5 >>> 20) & 0x0f] +\n    HEX_CHARS[(h5 >>> 16) & 0x0f] +\n    HEX_CHARS[(h5 >>> 12) & 0x0f] +\n    HEX_CHARS[(h5 >>> 8) & 0x0f] +\n    HEX_CHARS[(h5 >>> 4) & 0x0f] +\n    HEX_CHARS[h5 & 0x0f] +\n    HEX_CHARS[(h6 >>> 28) & 0x0f] +\n    HEX_CHARS[(h6 >>> 24) & 0x0f] +\n    HEX_CHARS[(h6 >>> 20) & 0x0f] +\n    HEX_CHARS[(h6 >>> 16) & 0x0f] +\n    HEX_CHARS[(h6 >>> 12) & 0x0f] +\n    HEX_CHARS[(h6 >>> 8) & 0x0f] +\n    HEX_CHARS[(h6 >>> 4) & 0x0f] +\n    HEX_CHARS[h6 & 0x0f];\n  if (!this.is224) {\n    hex +=\n      HEX_CHARS[(h7 >>> 28) & 0x0f] +\n      HEX_CHARS[(h7 >>> 24) & 0x0f] +\n      HEX_CHARS[(h7 >>> 20) & 0x0f] +\n      HEX_CHARS[(h7 >>> 16) & 0x0f] +\n      HEX_CHARS[(h7 >>> 12) & 0x0f] +\n      HEX_CHARS[(h7 >>> 8) & 0x0f] +\n      HEX_CHARS[(h7 >>> 4) & 0x0f] +\n      HEX_CHARS[h7 & 0x0f];\n  }\n  return hex;\n};\n\nSha256.prototype.toString = Sha256.prototype.hex;\n\nSha256.prototype.digest = function () {\n  this.finalize();\n\n  var h0 = this.h0,\n    h1 = this.h1,\n    h2 = this.h2,\n    h3 = this.h3,\n    h4 = this.h4,\n    h5 = this.h5,\n    h6 = this.h6,\n    h7 = this.h7;\n\n  var arr = [\n    (h0 >>> 24) & 0xff,\n    (h0 >>> 16) & 0xff,\n    (h0 >>> 8) & 0xff,\n    h0 & 0xff,\n    (h1 >>> 24) & 0xff,\n    (h1 >>> 16) & 0xff,\n    (h1 >>> 8) & 0xff,\n    h1 & 0xff,\n    (h2 >>> 24) & 0xff,\n    (h2 >>> 16) & 0xff,\n    (h2 >>> 8) & 0xff,\n    h2 & 0xff,\n    (h3 >>> 24) & 0xff,\n    (h3 >>> 16) & 0xff,\n    (h3 >>> 8) & 0xff,\n    h3 & 0xff,\n    (h4 >>> 24) & 0xff,\n    (h4 >>> 16) & 0xff,\n    (h4 >>> 8) & 0xff,\n    h4 & 0xff,\n    (h5 >>> 24) & 0xff,\n    (h5 >>> 16) & 0xff,\n    (h5 >>> 8) & 0xff,\n    h5 & 0xff,\n    (h6 >>> 24) & 0xff,\n    (h6 >>> 16) & 0xff,\n    (h6 >>> 8) & 0xff,\n    h6 & 0xff,\n  ];\n  if (!this.is224) {\n    arr.push(\n      (h7 >>> 24) & 0xff,\n      (h7 >>> 16) & 0xff,\n      (h7 >>> 8) & 0xff,\n      h7 & 0xff\n    );\n  }\n  return arr;\n};\n\nSha256.prototype.array = Sha256.prototype.digest;\n\nSha256.prototype.arrayBuffer = function () {\n  this.finalize();\n\n  var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n  var dataView = new DataView(buffer);\n  dataView.setUint32(0, this.h0);\n  dataView.setUint32(4, this.h1);\n  dataView.setUint32(8, this.h2);\n  dataView.setUint32(12, this.h3);\n  dataView.setUint32(16, this.h4);\n  dataView.setUint32(20, this.h5);\n  dataView.setUint32(24, this.h6);\n  if (!this.is224) {\n    dataView.setUint32(28, this.h7);\n  }\n  return buffer;\n};\n\nexport const sha256 = (...strings: string[]) => {\n  return new Sha256(false, true).update(strings.join(\"\")).hex();\n};\n","import { RunnableLike } from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { BinaryOperator, BinaryOperatorAggregate } from \"../channels/binop.js\";\nimport { LastValue } from \"../channels/last_value.js\";\n\nexport type SingleReducer<ValueType, UpdateType = ValueType> =\n  | {\n      reducer: BinaryOperator<ValueType, UpdateType>;\n      default?: () => ValueType;\n    }\n  | {\n      /**\n       * @deprecated Use `reducer` instead\n       */\n      value: BinaryOperator<ValueType, UpdateType>;\n      default?: () => ValueType;\n    }\n  | null;\n\nexport interface StateDefinition {\n  [key: string]: BaseChannel | (() => BaseChannel);\n}\n\ntype ExtractValueType<C> = C extends BaseChannel\n  ? C[\"ValueType\"]\n  : C extends () => BaseChannel\n  ? ReturnType<C>[\"ValueType\"]\n  : never;\n\ntype ExtractUpdateType<C> = C extends BaseChannel\n  ? C[\"UpdateType\"]\n  : C extends () => BaseChannel\n  ? ReturnType<C>[\"UpdateType\"]\n  : never;\n\nexport type StateType<SD extends StateDefinition> = {\n  [key in keyof SD]: ExtractValueType<SD[key]>;\n};\n\nexport type UpdateType<SD extends StateDefinition> = {\n  [key in keyof SD]?: ExtractUpdateType<SD[key]>;\n};\n\nexport type NodeType<SD extends StateDefinition> = RunnableLike<\n  StateType<SD>,\n  UpdateType<SD> | Partial<StateType<SD>>\n>;\n\n/** @ignore */\nexport interface AnnotationFunction {\n  <ValueType>(): LastValue<ValueType>;\n  <ValueType, UpdateType = ValueType>(\n    annotation: SingleReducer<ValueType, UpdateType>\n  ): BinaryOperatorAggregate<ValueType, UpdateType>;\n  Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;\n}\n\n/**\n * Should not be instantiated directly. See {@link Annotation}.\n */\nexport class AnnotationRoot<SD extends StateDefinition> {\n  lc_graph_name = \"AnnotationRoot\";\n\n  declare State: StateType<SD>;\n\n  declare Update: UpdateType<SD>;\n\n  declare Node: NodeType<SD>;\n\n  spec: SD;\n\n  constructor(s: SD) {\n    this.spec = s;\n  }\n}\n\n/**\n * Helper that instantiates channels within a StateGraph state.\n *\n * Can be used as a field in an {@link Annotation.Root} wrapper in one of two ways:\n * 1. **Directly**: Creates a channel that stores the most recent value returned from a node.\n * 2. **With a reducer**: Creates a channel that applies the reducer on a node's return value.\n *\n * @example\n * ```ts\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single string key named \"currentOutput\"\n * const SimpleAnnotation = Annotation.Root({\n *   currentOutput: Annotation<string>,\n * });\n *\n * const graphBuilder = new StateGraph(SimpleAnnotation);\n *\n * // A node in the graph that returns an object with a \"currentOutput\" key\n * // replaces the value in the state. You can get the state type as shown below:\n * const myNode = (state: typeof SimpleAnnotation.State) => {\n *   return {\n *     currentOutput: \"some_new_value\",\n *   };\n * }\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n *\n * @example\n * ```ts\n * import { type BaseMessage, AIMessage } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const AnnotationWithReducer = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     // Different types are allowed for updates\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(AnnotationWithReducer);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof AnnotationWithReducer.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n * @namespace\n * @property Root\n * Helper function that instantiates a StateGraph state. See {@link Annotation} for usage.\n */\nexport const Annotation: AnnotationFunction = function <\n  ValueType,\n  UpdateType = ValueType\n>(\n  annotation?: SingleReducer<ValueType, UpdateType>\n): BaseChannel<ValueType, UpdateType> {\n  if (annotation) {\n    return getChannel<ValueType, UpdateType>(annotation);\n  } else {\n    // @ts-expect-error - Annotation without reducer\n    return new LastValue<ValueType>();\n  }\n} as AnnotationFunction;\n\nAnnotation.Root = <S extends StateDefinition>(sd: S) => new AnnotationRoot(sd);\n\nexport function getChannel<V, U = V>(\n  reducer: SingleReducer<V, U>\n): BaseChannel<V, U> {\n  if (\n    typeof reducer === \"object\" &&\n    reducer &&\n    \"reducer\" in reducer &&\n    reducer.reducer\n  ) {\n    return new BinaryOperatorAggregate(reducer.reducer, reducer.default);\n  }\n  if (\n    typeof reducer === \"object\" &&\n    reducer &&\n    \"value\" in reducer &&\n    reducer.value\n  ) {\n    return new BinaryOperatorAggregate(reducer.value, reducer.default);\n  }\n  // @ts-expect-error - Annotation without reducer\n  return new LastValue<V>();\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { _coerceToRunnable, Runnable } from \"@langchain/core/runnables\";\nimport {\n  All,\n  type BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  type InteropZodObject,\n  interopParse,\n  interopZodObjectPartial,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n  Runtime,\n} from \"../pregel/runnable_types.js\";\nimport { BaseChannel, isBaseChannel } from \"../channels/base.js\";\nimport {\n  CompiledGraph,\n  Graph,\n  Branch,\n  AddNodeOptions,\n  NodeSpec,\n} from \"./graph.js\";\nimport {\n  ChannelWrite,\n  ChannelWriteEntry,\n  ChannelWriteTupleEntry,\n  PASSTHROUGH,\n} from \"../pregel/write.js\";\nimport { ChannelRead, PregelNode } from \"../pregel/read.js\";\nimport {\n  NamedBarrierValue,\n  NamedBarrierValueAfterFinish,\n} from \"../channels/named_barrier_value.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport {\n  isCommand,\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  END,\n  SELF,\n  Send,\n  START,\n  TAG_HIDDEN,\n  CommandInstance,\n  isInterrupted,\n  Interrupt,\n  INTERRUPT,\n} from \"../constants.js\";\nimport { InvalidUpdateError, ParentCommand } from \"../errors.js\";\nimport {\n  AnnotationRoot,\n  getChannel,\n  SingleReducer,\n  StateDefinition,\n  StateType,\n  UpdateType,\n} from \"./annotation.js\";\nimport type { CachePolicy, RetryPolicy } from \"../pregel/utils/index.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\nimport { LastValueAfterFinish } from \"../channels/last_value.js\";\nimport {\n  type SchemaMetaRegistry,\n  InteropZodToStateDefinition,\n  schemaMetaRegistry,\n} from \"./zod/meta.js\";\nimport type {\n  InferInterruptResumeType,\n  InferInterruptInputType,\n} from \"../interrupt.js\";\nimport type { InferWriterType } from \"../writer.js\";\n\nconst ROOT = \"__root__\";\n\nexport type ChannelReducers<Channels extends object> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof Channels]: SingleReducer<Channels[K], any>;\n};\n\nexport interface StateGraphArgs<Channels extends object | unknown> {\n  channels: Channels extends object\n    ? Channels extends unknown[]\n      ? ChannelReducers<{ __root__: Channels }>\n      : ChannelReducers<Channels>\n    : ChannelReducers<{ __root__: Channels }>;\n}\n\nexport type StateGraphNodeSpec<RunInput, RunOutput> = NodeSpec<\n  RunInput,\n  RunOutput\n> & {\n  input?: StateDefinition;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n};\n\nexport type StateGraphAddNodeOptions<Nodes extends string = string> = {\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy | boolean;\n  // TODO: Fix generic typing for annotations\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: AnnotationRoot<any> | InteropZodObject;\n} & AddNodeOptions<Nodes>;\n\nexport type StateGraphArgsWithStateSchema<\n  SD extends StateDefinition,\n  I extends StateDefinition,\n  O extends StateDefinition\n> = {\n  stateSchema: AnnotationRoot<SD>;\n  input?: AnnotationRoot<I>;\n  output?: AnnotationRoot<O>;\n};\n\nexport type StateGraphArgsWithInputOutputSchemas<\n  SD extends StateDefinition,\n  O extends StateDefinition = SD\n> = {\n  input: AnnotationRoot<SD>;\n  output: AnnotationRoot<O>;\n};\n\ntype ZodStateGraphArgsWithStateSchema<\n  SD extends InteropZodObject,\n  I extends SDZod,\n  O extends SDZod\n> = { state: SD; input?: I; output?: O };\n\ntype SDZod = StateDefinition | InteropZodObject;\n\ntype ToStateDefinition<T> = T extends InteropZodObject\n  ? InteropZodToStateDefinition<T>\n  : T extends StateDefinition\n  ? T\n  : never;\n\ntype NodeAction<\n  S,\n  U,\n  C extends SDZod,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\ntype StrictNodeAction<\n  S,\n  U,\n  C extends SDZod,\n  Nodes extends string,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  Prettify<S>,\n  | U\n  | Command<\n      InferInterruptResumeType<InterruptType>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      U & Record<string, any>,\n      Nodes\n    >,\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\nconst PartialStateSchema = Symbol.for(\"langgraph.state.partial\");\ntype PartialStateSchema = typeof PartialStateSchema;\n\ntype MergeReturnType<Prev, Curr> = Prev & Curr extends infer T\n  ? { [K in keyof T]: T[K] } & unknown\n  : never;\n\ntype Prettify<T> = {\n  [K in keyof T]: T[K];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\n/**\n * A graph whose nodes communicate by reading and writing to a shared state.\n * Each node takes a defined `State` as input and returns a `Partial<State>`.\n *\n * Each state key can optionally be annotated with a reducer function that\n * will be used to aggregate the values of that key received from multiple nodes.\n * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.\n *\n * See {@link Annotation} for more on defining state.\n *\n * After adding nodes and edges to your graph, you must call `.compile()` on it before\n * you can use it.\n *\n * @example\n * ```ts\n * import {\n *   type BaseMessage,\n *   AIMessage,\n *   HumanMessage,\n * } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const StateAnnotation = Annotation.Root({\n *   sentiment: Annotation<string>,\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(StateAnnotation);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof StateAnnotation.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *     sentiment: \"positive\",\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   .addEdge(\"__start__\", \"myNode\")\n *   .addEdge(\"myNode\", \"__end__\")\n *   .compile();\n *\n * await graph.invoke({ messages: [new HumanMessage(\"how are you?\")] });\n *\n * // {\n * //   messages: [HumanMessage(\"how are you?\"), AIMessage(\"Some new response\")],\n * //   sentiment: \"positive\",\n * // }\n * ```\n */\nexport class StateGraph<\n  SD extends SDZod | unknown,\n  S = SD extends SDZod ? StateType<ToStateDefinition<SD>> : SD,\n  U = SD extends SDZod ? UpdateType<ToStateDefinition<SD>> : Partial<S>,\n  N extends string = typeof START,\n  I extends SDZod = SD extends SDZod ? ToStateDefinition<SD> : StateDefinition,\n  O extends SDZod = SD extends SDZod ? ToStateDefinition<SD> : StateDefinition,\n  C extends SDZod = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends Graph<N, S, U, StateGraphNodeSpec<S, U>, ToStateDefinition<C>> {\n  channels: Record<string, BaseChannel> = {};\n\n  // TODO: this doesn't dedupe edges as in py, so worth fixing at some point\n  waitingEdges: Set<[N[], N]> = new Set();\n\n  /** @internal */\n  _schemaDefinition: StateDefinition;\n\n  /** @internal */\n  _schemaRuntimeDefinition: InteropZodObject | undefined;\n\n  /** @internal */\n  _inputDefinition: I;\n\n  /** @internal */\n  _inputRuntimeDefinition: InteropZodObject | PartialStateSchema | undefined;\n\n  /** @internal */\n  _outputDefinition: O;\n\n  /** @internal */\n  _outputRuntimeDefinition: InteropZodObject | undefined;\n\n  /**\n   * Map schemas to managed values\n   * @internal\n   */\n  _schemaDefinitions = new Map();\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  /** @internal Used only for typing. */\n  _configSchema: ToStateDefinition<C> | undefined;\n\n  /** @internal */\n  _configRuntimeSchema: InteropZodObject | undefined;\n\n  /** @internal */\n  _interrupt: InterruptType;\n\n  /** @internal */\n  _writer: WriterType;\n\n  declare Node: StrictNodeAction<S, U, C, N, InterruptType, WriterType>;\n\n  constructor(\n    state: SD extends StateDefinition ? AnnotationRoot<SD> : never,\n    options?: {\n      context?: C | AnnotationRoot<ToStateDefinition<C>>;\n      input?: I | AnnotationRoot<ToStateDefinition<I>>;\n      output?: O | AnnotationRoot<ToStateDefinition<O>>;\n\n      interrupt?: InterruptType;\n      writer?: WriterType;\n\n      nodes?: N[];\n    }\n  );\n\n  constructor(\n    state: SD extends InteropZodObject ? SD : never,\n    options?: {\n      context?: C | AnnotationRoot<ToStateDefinition<C>>;\n      input?: I | AnnotationRoot<ToStateDefinition<I>>;\n      output?: O | AnnotationRoot<ToStateDefinition<O>>;\n\n      interrupt?: InterruptType;\n      writer?: WriterType;\n\n      nodes?: N[];\n    }\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ? StateGraphArgsWithInputOutputSchemas<SD, ToStateDefinition<O>>\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ?\n          | AnnotationRoot<SD>\n          | StateGraphArgsWithStateSchema<\n              SD,\n              ToStateDefinition<I>,\n              ToStateDefinition<O>\n            >\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  /** @deprecated Use `Annotation.Root` or `zod` for state definition instead. */\n  constructor(\n    fields: SD extends StateDefinition\n      ? SD | StateGraphArgs<S>\n      : StateGraphArgs<S>,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends InteropZodObject\n      ? SD | ZodStateGraphArgsWithStateSchema<SD, I, O>\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends InteropZodObject\n      ? SD | ZodStateGraphArgsWithStateSchema<SD, I, O>\n      : SD extends StateDefinition\n      ?\n          | SD\n          | AnnotationRoot<SD>\n          | StateGraphArgs<S>\n          | StateGraphArgsWithStateSchema<\n              SD,\n              ToStateDefinition<I>,\n              ToStateDefinition<O>\n            >\n          | StateGraphArgsWithInputOutputSchemas<SD, ToStateDefinition<O>>\n      : StateGraphArgs<S>,\n    contextSchema?:\n      | C\n      | AnnotationRoot<ToStateDefinition<C>>\n      | {\n          input?: I | AnnotationRoot<ToStateDefinition<I>>;\n          output?: O | AnnotationRoot<ToStateDefinition<O>>;\n          context?: C | AnnotationRoot<ToStateDefinition<C>>;\n          interrupt?: InterruptType;\n          writer?: WriterType;\n          nodes?: N[];\n        }\n  ) {\n    super();\n\n    if (isZodStateGraphArgsWithStateSchema(fields)) {\n      const stateDef = this._metaRegistry.getChannelsForSchema(fields.state);\n      const inputDef =\n        fields.input != null\n          ? this._metaRegistry.getChannelsForSchema(fields.input)\n          : stateDef;\n      const outputDef =\n        fields.output != null\n          ? this._metaRegistry.getChannelsForSchema(fields.output)\n          : stateDef;\n\n      this._schemaDefinition = stateDef;\n      this._schemaRuntimeDefinition = fields.state;\n\n      this._inputDefinition = inputDef as I;\n      this._inputRuntimeDefinition = fields.input ?? PartialStateSchema;\n\n      this._outputDefinition = outputDef as O;\n      this._outputRuntimeDefinition = fields.output ?? fields.state;\n    } else if (isInteropZodObject(fields)) {\n      const stateDef = this._metaRegistry.getChannelsForSchema(fields);\n\n      this._schemaDefinition = stateDef;\n      this._schemaRuntimeDefinition = fields;\n\n      this._inputDefinition = stateDef as I;\n      this._inputRuntimeDefinition = PartialStateSchema;\n\n      this._outputDefinition = stateDef as O;\n      this._outputRuntimeDefinition = fields;\n    } else if (\n      isStateGraphArgsWithInputOutputSchemas<\n        SD extends StateDefinition ? SD : never,\n        O extends StateDefinition ? O : never\n      >(fields)\n    ) {\n      this._schemaDefinition = fields.input.spec;\n      this._inputDefinition = fields.input.spec as unknown as I;\n      this._outputDefinition = fields.output.spec;\n    } else if (isStateGraphArgsWithStateSchema(fields)) {\n      this._schemaDefinition = fields.stateSchema.spec;\n      this._inputDefinition = (fields.input?.spec ??\n        this._schemaDefinition) as I;\n      this._outputDefinition = (fields.output?.spec ??\n        this._schemaDefinition) as O;\n    } else if (isStateDefinition(fields) || isAnnotationRoot(fields)) {\n      const spec = isAnnotationRoot(fields) ? fields.spec : fields;\n      this._schemaDefinition = spec;\n    } else if (isStateGraphArgs(fields)) {\n      const spec = _getChannels(fields.channels);\n      this._schemaDefinition = spec;\n    } else {\n      throw new Error(\n        \"Invalid StateGraph input. Make sure to pass a valid Annotation.Root or Zod schema.\"\n      );\n    }\n\n    this._inputDefinition ??= this._schemaDefinition as I;\n    this._outputDefinition ??= this._schemaDefinition as O;\n\n    this._addSchema(this._schemaDefinition);\n    this._addSchema(this._inputDefinition);\n    this._addSchema(this._outputDefinition);\n\n    function isOptions(options: unknown): options is {\n      context?: C | AnnotationRoot<ToStateDefinition<C>>;\n      input?: I | AnnotationRoot<ToStateDefinition<I>>;\n      output?: O | AnnotationRoot<ToStateDefinition<O>>;\n      interrupt?: InterruptType;\n      writer?: WriterType;\n      nodes?: N[];\n    } {\n      return (\n        typeof options === \"object\" &&\n        options != null &&\n        !(\"spec\" in options) &&\n        !isInteropZodObject(options)\n      );\n    }\n\n    // Handle runtime config options\n    if (isOptions(contextSchema)) {\n      if (isInteropZodObject(contextSchema.context)) {\n        this._configRuntimeSchema = contextSchema.context;\n      }\n      this._interrupt = contextSchema.interrupt as InterruptType;\n      this._writer = contextSchema.writer as WriterType;\n    } else if (isInteropZodObject(contextSchema)) {\n      this._configRuntimeSchema = contextSchema;\n    }\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return new Set([\n      ...this.edges,\n      ...Array.from(this.waitingEdges).flatMap(([starts, end]) =>\n        starts.map((start) => [start, end] as [string, string])\n      ),\n    ]);\n  }\n\n  _addSchema(stateDefinition: SDZod) {\n    if (this._schemaDefinitions.has(stateDefinition)) {\n      return;\n    }\n    // TODO: Support managed values\n    this._schemaDefinitions.set(stateDefinition, stateDefinition);\n    for (const [key, val] of Object.entries(stateDefinition)) {\n      let channel;\n      if (typeof val === \"function\") {\n        channel = val();\n      } else {\n        channel = val;\n      }\n      if (this.channels[key] !== undefined) {\n        if (this.channels[key] !== channel) {\n          if (channel.lc_graph_name !== \"LastValue\") {\n            throw new Error(\n              `Channel \"${key}\" already exists with a different type.`\n            );\n          }\n        }\n      } else {\n        this.channels[key] = channel;\n      }\n    }\n  }\n\n  override addNode<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S>(\n    key: K,\n    action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<SD, S, U, N | K, I, O, C, NodeReturnType>;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n                options?: StateGraphAddNodeOptions\n              ][]\n        ]\n  ): StateGraph<SD, S, U, N | K, I, O, C> {\n    function isMultipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n            options?: AddNodeOptions\n          ][]\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMultipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0]).map(([key, action]) => [key, action])\n        : [[args[0], args[1], args[2]]]\n    ) as [\n      K,\n      NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n      StateGraphAddNodeOptions | undefined\n    ][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      if (key in this.channels) {\n        throw new Error(\n          `${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`\n        );\n      }\n\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END || key === START) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      let inputSpec = this._schemaDefinition;\n      if (options?.input !== undefined) {\n        if (isInteropZodObject(options.input)) {\n          inputSpec = this._metaRegistry.getChannelsForSchema(options.input);\n        } else if (options.input.spec !== undefined) {\n          inputSpec = options.input.spec;\n        }\n      }\n      if (inputSpec !== undefined) {\n        this._addSchema(inputSpec);\n      }\n\n      let runnable;\n      if (Runnable.isRunnable(action)) {\n        runnable = action;\n      } else if (typeof action === \"function\") {\n        runnable = new RunnableCallable({\n          func: action,\n          name: key,\n          trace: false,\n        });\n      } else {\n        runnable = _coerceToRunnable(action);\n      }\n\n      let cachePolicy = options?.cachePolicy;\n      if (typeof cachePolicy === \"boolean\") {\n        cachePolicy = cachePolicy ? {} : undefined;\n      }\n\n      const nodeSpec: StateGraphNodeSpec<S, U> = {\n        runnable: runnable as unknown as Runnable<S, U>,\n        retryPolicy: options?.retryPolicy,\n        cachePolicy,\n        metadata: options?.metadata,\n        input: inputSpec ?? this._schemaDefinition,\n        subgraphs: isPregelLike(runnable)\n          ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            [runnable as any]\n          : options?.subgraphs,\n        ends: options?.ends,\n        defer: options?.defer,\n      };\n\n      this.nodes[key as unknown as N] = nodeSpec;\n    }\n\n    return this as StateGraph<SD, S, U, N | K, I, O, C>;\n  }\n\n  override addEdge(\n    startKey: typeof START | N | N[],\n    endKey: N | typeof END\n  ): this {\n    if (typeof startKey === \"string\") {\n      return super.addEdge(startKey, endKey);\n    }\n\n    if (this.compiled) {\n      console.warn(\n        \"Adding an edge to a graph that has already been compiled. This will \" +\n          \"not be reflected in the compiled graph.\"\n      );\n    }\n\n    for (const start of startKey) {\n      if (start === END) {\n        throw new Error(\"END cannot be a start node\");\n      }\n      if (!Object.keys(this.nodes).some((node) => node === start)) {\n        throw new Error(`Need to add a node named \"${start}\" first`);\n      }\n    }\n    if (endKey === END) {\n      throw new Error(\"END cannot be an end node\");\n    }\n    if (!Object.keys(this.nodes).some((node) => node === endKey)) {\n      throw new Error(`Need to add a node named \"${endKey}\" first`);\n    }\n\n    this.waitingEdges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes: [\n      key: K,\n      action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n      options?: StateGraphAddNodeOptions\n    ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  addSequence<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n      | Record<\n          K,\n          NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>\n        >\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  > {\n    const parsedNodes = Array.isArray(nodes) ? nodes : Object.entries(nodes);\n\n    if (parsedNodes.length === 0) {\n      throw new Error(\"Sequence requires at least one node.\");\n    }\n\n    let previousNode: N | undefined;\n    for (const [key, action, options] of parsedNodes) {\n      if (key in this.nodes) {\n        throw new Error(\n          `Node names must be unique: node with the name \"${key}\" already exists.`\n        );\n      }\n\n      const validKey = key as unknown as N;\n      this.addNode(\n        validKey,\n        action as NodeAction<S, U, C, InterruptType, WriterType>,\n        options\n      );\n      if (previousNode != null) {\n        this.addEdge(previousNode, validKey);\n      }\n\n      previousNode = validKey;\n    }\n\n    return this as StateGraph<\n      SD,\n      S,\n      U,\n      N | K,\n      I,\n      O,\n      C,\n      MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n    >;\n  }\n\n  override compile({\n    checkpointer,\n    store,\n    cache,\n    interruptBefore,\n    interruptAfter,\n    name,\n    description,\n  }: {\n    checkpointer?: BaseCheckpointSaver | boolean;\n    store?: BaseStore;\n    cache?: BaseCache;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n    description?: string;\n  } = {}): CompiledStateGraph<\n    Prettify<S>,\n    Prettify<U>,\n    N,\n    I,\n    O,\n    C,\n    NodeReturnType,\n    InterruptType,\n    WriterType\n  > {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // prepare output channels\n    const outputKeys = Object.keys(\n      this._schemaDefinitions.get(this._outputDefinition)\n    );\n    const outputChannels =\n      outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;\n\n    const streamKeys = Object.keys(this.channels);\n    const streamChannels =\n      streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;\n\n    const userInterrupt = this._interrupt;\n    // create empty compiled graph\n    const compiled = new CompiledStateGraph<\n      S,\n      U,\n      N,\n      I,\n      O,\n      C,\n      NodeReturnType,\n      InterruptType,\n      WriterType\n    >({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<S, U>>,\n      channels: {\n        ...this.channels,\n        [START]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels,\n      streamChannels,\n      streamMode: \"updates\",\n      store,\n      cache,\n      name,\n      description,\n      userInterrupt,\n    });\n\n    // attach nodes, edges and branches\n    compiled.attachNode(START);\n    for (const [key, node] of Object.entries<StateGraphNodeSpec<S, U>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    compiled.attachBranch(START, SELF, _getControlBranch() as Branch<S, N>, {\n      withReader: false,\n    });\n    for (const [key] of Object.entries<StateGraphNodeSpec<S, U>>(this.nodes)) {\n      compiled.attachBranch(\n        key as N,\n        SELF,\n        _getControlBranch() as Branch<S, N>,\n        {\n          withReader: false,\n        }\n      );\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [starts, end] of this.waitingEdges) {\n      compiled.attachEdge(starts, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n}\n\nfunction _getChannels<Channels extends Record<string, unknown> | unknown>(\n  schema: StateGraphArgs<Channels>[\"channels\"]\n): Record<string, BaseChannel> {\n  const channels: Record<string, BaseChannel> = {};\n  for (const [name, val] of Object.entries(schema)) {\n    if (name === ROOT) {\n      channels[name] = getChannel<Channels>(val as SingleReducer<Channels>);\n    } else {\n      const key = name as keyof Channels;\n      channels[name] = getChannel<Channels[typeof key]>(\n        val as SingleReducer<Channels[typeof key]>\n      );\n    }\n  }\n  return channels;\n}\n\n/**\n * Final result from building and compiling a {@link StateGraph}.\n * Should not be instantiated directly, only using the StateGraph `.compile()`\n * instance method.\n */\nexport class CompiledStateGraph<\n  S,\n  U,\n  N extends string = typeof START,\n  I extends SDZod = StateDefinition,\n  O extends SDZod = StateDefinition,\n  C extends SDZod = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends CompiledGraph<\n  N,\n  S,\n  U,\n  StateType<ToStateDefinition<C>>,\n  UpdateType<ToStateDefinition<I>>,\n  StateType<ToStateDefinition<O>>,\n  NodeReturnType,\n  CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n  InferWriterType<WriterType>\n> {\n  declare builder: StateGraph<unknown, S, U, N, I, O, C, NodeReturnType>;\n\n  /**\n   * The description of the compiled graph.\n   * This is used by the supervisor agent to describe the handoff to the agent.\n   */\n  description?: string;\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  constructor({\n    description,\n    ...rest\n  }: { description?: string } & ConstructorParameters<\n    typeof CompiledGraph<\n      N,\n      S,\n      U,\n      StateType<ToStateDefinition<C>>,\n      UpdateType<ToStateDefinition<I>>,\n      StateType<ToStateDefinition<O>>,\n      NodeReturnType,\n      CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n      InferWriterType<WriterType>\n    >\n  >[0]) {\n    super(rest);\n    this.description = description;\n  }\n\n  attachNode(key: typeof START, node?: never): void;\n\n  attachNode(key: N, node: StateGraphNodeSpec<S, U>): void;\n\n  attachNode(key: N | typeof START, node?: StateGraphNodeSpec<S, U>): void {\n    let outputKeys: string[];\n    if (key === START) {\n      // Get input schema keys excluding managed values\n      outputKeys = Object.entries(\n        this.builder._schemaDefinitions.get(this.builder._inputDefinition)\n      ).map(([k]) => k);\n    } else {\n      outputKeys = Object.keys(this.builder.channels);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getRoot(input: unknown): [string, any][] | null {\n      if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples();\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some((i) => isCommand(i))\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const i of input) {\n          if (isCommand(i)) {\n            if (i.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(...i._updateAsTuples());\n          } else {\n            updates.push([ROOT, i]);\n          }\n        }\n        return updates;\n      } else if (input != null) {\n        return [[ROOT, input]];\n      }\n      return null;\n    }\n\n    // to avoid name collision below\n    const nodeKey = key;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getUpdates(input: U): [string, any][] | null {\n      if (!input) {\n        return null;\n      } else if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some(isCommand)\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const item of input) {\n          if (isCommand(item)) {\n            if (item.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(\n              ...item._updateAsTuples().filter(([k]) => outputKeys.includes(k))\n            );\n          } else {\n            const itemUpdates = _getUpdates(item);\n            if (itemUpdates) {\n              updates.push(...(itemUpdates ?? []));\n            }\n          }\n        }\n        return updates;\n      } else if (typeof input === \"object\" && !Array.isArray(input)) {\n        return Object.entries(input).filter(([k]) => outputKeys.includes(k));\n      } else {\n        const typeofInput = Array.isArray(input) ? \"array\" : typeof input;\n        throw new InvalidUpdateError(\n          `Expected node \"${nodeKey.toString()}\" to return an object or an array containing at least one Command object, received ${typeofInput}`,\n          {\n            lc_error_code: \"INVALID_GRAPH_NODE_RETURN_VALUE\",\n          }\n        );\n      }\n    }\n\n    const stateWriteEntries: (ChannelWriteTupleEntry | ChannelWriteEntry)[] = [\n      {\n        value: PASSTHROUGH,\n        mapper: new RunnableCallable({\n          func:\n            outputKeys.length && outputKeys[0] === ROOT\n              ? _getRoot\n              : _getUpdates,\n          trace: false,\n          recurse: false,\n        }),\n      },\n    ];\n\n    // add node and output channel\n    if (key === START) {\n      this.nodes[key] = new PregelNode<S, U>({\n        tags: [TAG_HIDDEN],\n        triggers: [START],\n        channels: [START],\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n      });\n    } else {\n      const inputDefinition = node?.input ?? this.builder._schemaDefinition;\n      const inputValues = Object.fromEntries(\n        Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map(\n          (k) => [k, k]\n        )\n      );\n      const isSingleInput =\n        Object.keys(inputValues).length === 1 && ROOT in inputValues;\n      const branchChannel = `branch:to:${key}` as string | N;\n      this.channels[branchChannel] = node?.defer\n        ? new LastValueAfterFinish()\n        : new EphemeralValue(false);\n      this.nodes[key] = new PregelNode<S, U>({\n        triggers: [branchChannel],\n        // read state keys\n        channels: isSingleInput ? Object.keys(inputValues) : inputValues,\n        // publish to state keys\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n        mapper: isSingleInput\n          ? undefined\n          : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (input: Record<string, any>) => {\n              return Object.fromEntries(\n                Object.entries(input).filter(([k]) => k in inputValues)\n              );\n            },\n        bound: node?.runnable,\n        metadata: node?.metadata,\n        retryPolicy: node?.retryPolicy,\n        cachePolicy: node?.cachePolicy,\n        subgraphs: node?.subgraphs,\n        ends: node?.ends,\n      });\n    }\n  }\n\n  attachEdge(starts: N | N[] | \"__start__\", end: N | \"__end__\"): void {\n    if (end === END) return;\n    if (typeof starts === \"string\") {\n      this.nodes[starts].writers.push(\n        new ChannelWrite(\n          [{ channel: `branch:to:${end}`, value: null }],\n          [TAG_HIDDEN]\n        )\n      );\n    } else if (Array.isArray(starts)) {\n      const channelName = `join:${starts.join(\"+\")}:${end}`;\n      // register channel\n      this.channels[channelName as string | N] = this.builder.nodes[end].defer\n        ? new NamedBarrierValueAfterFinish(new Set(starts))\n        : new NamedBarrierValue(new Set(starts));\n      // subscribe to channel\n      this.nodes[end].triggers.push(channelName);\n      // publish to channel\n      for (const start of starts) {\n        this.nodes[start].writers.push(\n          new ChannelWrite(\n            [{ channel: channelName, value: start }],\n            [TAG_HIDDEN]\n          )\n        );\n      }\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    _: string,\n    branch: Branch<S, N>,\n    options: { withReader?: boolean } = { withReader: true }\n  ): void {\n    const branchWriter = async (\n      packets: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => {\n      const filteredPackets = packets.filter((p) => p !== END);\n      if (!filteredPackets.length) return;\n\n      const writes: (ChannelWriteEntry | Send)[] = filteredPackets.map((p) => {\n        if (_isSend(p)) return p;\n        return { channel: p === END ? p : `branch:to:${p}`, value: start };\n      });\n      await ChannelWrite.doWrite(\n        { ...config, tags: (config.tags ?? []).concat([TAG_HIDDEN]) },\n        writes\n      );\n    };\n    // attach branch publisher\n    this.nodes[start].writers.push(\n      branch.run(\n        branchWriter,\n        // reader\n        options.withReader\n          ? (config) =>\n              ChannelRead.doRead<S>(\n                config,\n                this.streamChannels ?? this.outputChannels,\n                true\n              )\n          : undefined\n      )\n    );\n  }\n\n  protected async _validateInput(\n    input: UpdateType<ToStateDefinition<I>>\n  ): Promise<UpdateType<ToStateDefinition<I>>> {\n    if (input == null) return input;\n\n    const schema = (() => {\n      const input = this.builder._inputRuntimeDefinition;\n      const schema = this.builder._schemaRuntimeDefinition;\n\n      const apply = (schema: InteropZodObject | undefined) => {\n        if (schema == null) return undefined;\n        return this._metaRegistry.getExtendedChannelSchemas(schema, {\n          withReducerSchema: true,\n        });\n      };\n\n      if (isInteropZodObject(input)) return apply(input);\n      if (input === PartialStateSchema) {\n        return interopZodObjectPartial(apply(schema)!);\n      }\n      return undefined;\n    })();\n\n    if (isCommand(input)) {\n      const parsedInput = input;\n      if (input.update && schema != null)\n        parsedInput.update = interopParse(schema, input.update);\n      return parsedInput;\n    }\n    if (schema != null) return interopParse(schema, input);\n    return input;\n  }\n\n  public isInterrupted(input: unknown): input is {\n    [INTERRUPT]: Interrupt<InferInterruptInputType<InterruptType>>[];\n  } {\n    return isInterrupted(input);\n  }\n\n  protected async _validateContext(\n    config: Partial<Record<string, unknown>>\n  ): Promise<Partial<Record<string, unknown>>> {\n    const configSchema = this.builder._configRuntimeSchema;\n    if (isInteropZodObject(configSchema)) interopParse(configSchema, config);\n    return config;\n  }\n}\n\nfunction isStateDefinition(obj: unknown): obj is StateDefinition {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    !Array.isArray(obj) &&\n    Object.keys(obj).length > 0 &&\n    Object.values(obj).every((v) => typeof v === \"function\" || isBaseChannel(v))\n  );\n}\n\nfunction isAnnotationRoot<SD extends StateDefinition>(\n  obj: unknown | AnnotationRoot<SD>\n): obj is AnnotationRoot<SD> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"lc_graph_name\" in obj &&\n    obj.lc_graph_name === \"AnnotationRoot\"\n  );\n}\n\nfunction isStateGraphArgs<Channels extends object | unknown>(\n  obj: unknown | StateGraphArgs<Channels>\n): obj is StateGraphArgs<Channels> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    (obj as StateGraphArgs<Channels>).channels !== undefined\n  );\n}\n\nfunction isStateGraphArgsWithStateSchema<\n  SD extends StateDefinition,\n  I extends StateDefinition,\n  O extends StateDefinition\n>(\n  obj: unknown | StateGraphArgsWithStateSchema<SD, I, O>\n): obj is StateGraphArgsWithStateSchema<SD, I, O> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    (obj as StateGraphArgsWithStateSchema<SD, I, O>).stateSchema !== undefined\n  );\n}\n\nfunction isStateGraphArgsWithInputOutputSchemas<\n  SD extends StateDefinition,\n  O extends StateDefinition\n>(\n  obj: unknown | StateGraphArgsWithInputOutputSchemas<SD, O>\n): obj is StateGraphArgsWithInputOutputSchemas<SD, O> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (obj as any).stateSchema === undefined &&\n    (obj as StateGraphArgsWithInputOutputSchemas<SD, O>).input !== undefined &&\n    (obj as StateGraphArgsWithInputOutputSchemas<SD, O>).output !== undefined\n  );\n}\n\nfunction isZodStateGraphArgsWithStateSchema<\n  SD extends InteropZodObject,\n  I extends InteropZodObject,\n  O extends InteropZodObject\n>(value: unknown): value is ZodStateGraphArgsWithStateSchema<SD, I, O> {\n  if (typeof value !== \"object\" || value == null) {\n    return false;\n  }\n\n  if (!(\"state\" in value) || !isInteropZodObject(value.state)) {\n    return false;\n  }\n\n  if (\"input\" in value && !isInteropZodObject(value.input)) {\n    return false;\n  }\n\n  if (\"output\" in value && !isInteropZodObject(value.output)) {\n    return false;\n  }\n\n  return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _controlBranch(value: any): (string | Send)[] {\n  if (_isSend(value)) {\n    return [value];\n  }\n  const commands = [];\n  if (isCommand(value)) {\n    commands.push(value);\n  } else if (Array.isArray(value)) {\n    commands.push(...value.filter(isCommand));\n  }\n  const destinations: (string | Send)[] = [];\n\n  for (const command of commands) {\n    if (command.graph === Command.PARENT) {\n      throw new ParentCommand(command);\n    }\n\n    if (_isSend(command.goto)) {\n      destinations.push(command.goto);\n    } else if (typeof command.goto === \"string\") {\n      destinations.push(command.goto);\n    } else {\n      if (Array.isArray(command.goto)) {\n        destinations.push(...command.goto);\n      }\n    }\n  }\n  return destinations;\n}\n\nfunction _getControlBranch() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const CONTROL_BRANCH_PATH = new RunnableCallable<any, (string | Send)[]>({\n    func: _controlBranch,\n    tags: [TAG_HIDDEN],\n    trace: false,\n    recurse: false,\n    name: \"<control_branch>\",\n  });\n  return new Branch({\n    path: CONTROL_BRANCH_PATH,\n  });\n}\n","import type { EmbeddingsInterface } from \"./embeddings.js\";\nimport type { DocumentInterface } from \"./documents/document.js\";\nimport {\n  BaseRetriever,\n  BaseRetrieverInterface,\n  type BaseRetrieverInput,\n} from \"./retrievers/index.js\";\nimport { Serializable } from \"./load/serializable.js\";\nimport {\n  CallbackManagerForRetrieverRun,\n  Callbacks,\n} from \"./callbacks/manager.js\";\n\n/**\n * Type for options when adding a document to the VectorStore.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AddDocumentOptions = Record<string, any>;\n\n/**\n * Options for configuring a maximal marginal relevance (MMR) search.\n *\n * MMR search optimizes for both similarity to the query and diversity\n * among the results, balancing the retrieval of relevant documents\n * with variation in the content returned.\n *\n * Fields:\n *\n * - `fetchK` (optional): The initial number of documents to retrieve from the\n *   vector store before applying the MMR algorithm. This larger set provides a\n *   pool of documents from which the algorithm can select the most diverse\n *   results based on relevance to the query.\n *\n * - `filter` (optional): A filter of type `FilterType` to refine the search\n *   results, allowing additional conditions to target specific subsets\n *   of documents.\n *\n * - `k`: The number of documents to return in the final results. This is the\n *   primary count of documents that are most relevant to the query.\n *\n * - `lambda` (optional): A value between 0 and 1 that determines the balance\n *   between relevance and diversity:\n *   - A `lambda` of 0 emphasizes diversity, maximizing content variation.\n *   - A `lambda` of 1 emphasizes similarity to the query, focusing on relevance.\n *    Values between 0 and 1 provide a mix of relevance and diversity.\n *\n * @template FilterType - The type used for filtering results, as defined\n *                        by the vector store.\n */\nexport type MaxMarginalRelevanceSearchOptions<FilterType> = {\n  k: number;\n  fetchK?: number;\n  lambda?: number;\n  filter?: FilterType;\n};\n\n/**\n * Options for configuring a maximal marginal relevance (MMR) search\n * when using the `VectorStoreRetriever`.\n *\n * These parameters control how the MMR algorithm balances relevance to the\n * query and diversity among the retrieved documents.\n *\n * Fields:\n * - `fetchK` (optional): Specifies the initial number of documents to fetch\n *   before applying the MMR algorithm. This larger set provides a pool of\n *   documents from which the algorithm can select the most diverse results\n *   based on relevance to the query.\n *\n * - `lambda` (optional): A value between 0 and 1 that determines the balance\n *   between relevance and diversity:\n *   - A `lambda` of 0 maximizes diversity among the results, prioritizing varied content.\n *   - A `lambda` of 1 maximizes similarity to the query, prioritizing relevance.\n *   Values between 0 and 1 provide a mix of relevance and diversity.\n */\nexport type VectorStoreRetrieverMMRSearchKwargs = {\n  fetchK?: number;\n  lambda?: number;\n};\n\n/**\n * Input configuration options for creating a `VectorStoreRetriever` instance.\n *\n * This type combines properties from `BaseRetrieverInput` with specific settings\n * for the `VectorStoreRetriever`, including options for similarity or maximal\n * marginal relevance (MMR) search types.\n *\n * Fields:\n *\n * - `callbacks` (optional): An array of callback functions that handle various\n *   events during retrieval, such as logging, error handling, or progress updates.\n *\n * - `tags` (optional): An array of strings used to add contextual tags to\n *   retrieval operations, allowing for easier categorization and tracking.\n *\n * - `metadata` (optional): A record of key-value pairs to store additional\n *   contextual information for retrieval operations, which can be useful\n *   for logging or auditing purposes.\n *\n * - `verbose` (optional): A boolean flag that, if set to `true`, enables\n *   detailed logging and output during the retrieval process. Defaults to `false`.\n *\n * - `vectorStore`: The `VectorStore` instance implementing `VectorStoreInterface`\n *   that will be used for document storage and retrieval.\n *\n * - `k` (optional): Specifies the number of documents to retrieve per search\n *   query. Defaults to 4 if not specified.\n *\n * - `filter` (optional): A filter of type `FilterType` (defined by the vector store)\n *   to refine the set of documents returned, allowing for targeted search results.\n *\n * - `searchType`: Determines the type of search to perform:\n *   - `\"similarity\"`: Executes a similarity search, retrieving documents based purely\n *     on vector similarity to the query.\n *   - `\"mmr\"`: Executes a maximal marginal relevance (MMR) search, balancing similarity\n *     and diversity in the search results.\n *\n * - `searchKwargs` (optional): Used only if `searchType` is `\"mmr\"`, this object\n *   provides additional options for MMR search, including:\n *   - `fetchK`: Specifies the number of documents to initially fetch before applying\n *     the MMR algorithm, providing a pool from which the most diverse results are selected.\n *   - `lambda`: A diversity parameter, where 0 emphasizes diversity and 1 emphasizes\n *     relevance to the query. Values between 0 and 1 provide a balance of relevance and diversity.\n *\n * @template V - The type of vector store implementing `VectorStoreInterface`.\n */\nexport type VectorStoreRetrieverInput<V extends VectorStoreInterface> =\n  BaseRetrieverInput &\n    (\n      | {\n          vectorStore: V;\n          k?: number;\n          filter?: V[\"FilterType\"];\n          searchType?: \"similarity\";\n        }\n      | {\n          vectorStore: V;\n          k?: number;\n          filter?: V[\"FilterType\"];\n          searchType: \"mmr\";\n          searchKwargs?: VectorStoreRetrieverMMRSearchKwargs;\n        }\n    );\n\n/**\n * Interface for a retriever that uses a vector store to store and retrieve\n * document embeddings. This retriever interface allows for adding documents\n * to the underlying vector store and conducting retrieval operations.\n *\n * `VectorStoreRetrieverInterface` extends `BaseRetrieverInterface` to provide\n * document retrieval capabilities based on vector similarity.\n *\n * @interface VectorStoreRetrieverInterface\n * @extends BaseRetrieverInterface\n */\nexport interface VectorStoreRetrieverInterface<\n  V extends VectorStoreInterface = VectorStoreInterface\n> extends BaseRetrieverInterface {\n  vectorStore: V;\n\n  /**\n   * Adds an array of documents to the vector store.\n   *\n   * This method embeds the provided documents and stores them within the\n   * vector store. Additional options can be specified for custom behavior\n   * during the addition process.\n   *\n   * @param documents - An array of documents to embed and add to the vector store.\n   * @param options - Optional settings to customize document addition.\n   * @returns A promise that resolves to an array of document IDs or `void`,\n   *          depending on the implementation.\n   */\n  addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n}\n\n/**\n * Class for retrieving documents from a `VectorStore` based on vector similarity\n * or maximal marginal relevance (MMR).\n *\n * `VectorStoreRetriever` extends `BaseRetriever`, implementing methods for\n * adding documents to the underlying vector store and performing document\n * retrieval with optional configurations.\n *\n * @class VectorStoreRetriever\n * @extends BaseRetriever\n * @implements VectorStoreRetrieverInterface\n * @template V - Type of vector store implementing `VectorStoreInterface`.\n */\nexport class VectorStoreRetriever<\n    V extends VectorStoreInterface = VectorStoreInterface\n  >\n  extends BaseRetriever\n  implements VectorStoreRetrieverInterface\n{\n  static lc_name() {\n    return \"VectorStoreRetriever\";\n  }\n\n  get lc_namespace() {\n    return [\"langchain_core\", \"vectorstores\"];\n  }\n\n  /**\n   * The instance of `VectorStore` used for storing and retrieving document embeddings.\n   * This vector store must implement the `VectorStoreInterface` to be compatible\n   * with the retrievers operations.\n   */\n  vectorStore: V;\n\n  /**\n   * Specifies the number of documents to retrieve for each search query.\n   * Defaults to 4 if not specified, providing a basic result count for similarity or MMR searches.\n   */\n  k = 4;\n\n  /**\n   * Determines the type of search operation to perform on the vector store.\n   *\n   * - `\"similarity\"` (default): Conducts a similarity search based purely on vector similarity\n   *   to the query.\n   * - `\"mmr\"`: Executes a maximal marginal relevance (MMR) search, balancing relevance and\n   *   diversity in the retrieved results.\n   */\n  searchType = \"similarity\";\n\n  /**\n   * Additional options specific to maximal marginal relevance (MMR) search, applicable\n   * only if `searchType` is set to `\"mmr\"`.\n   *\n   * Includes:\n   * - `fetchK`: The initial number of documents fetched before applying the MMR algorithm,\n   *   allowing for a larger selection from which to choose the most diverse results.\n   * - `lambda`: A parameter between 0 and 1 to adjust the relevance-diversity balance,\n   *   where 0 prioritizes diversity and 1 prioritizes relevance.\n   */\n  searchKwargs?: VectorStoreRetrieverMMRSearchKwargs;\n\n  /**\n   * Optional filter applied to search results, defined by the `FilterType` of the vector store.\n   * Allows for refined, targeted results by restricting the returned documents based\n   * on specified filter criteria.\n   */\n  filter?: V[\"FilterType\"];\n\n  /**\n   * Returns the type of vector store, as defined by the `vectorStore` instance.\n   *\n   * @returns {string} The vector store type.\n   */\n  _vectorstoreType(): string {\n    return this.vectorStore._vectorstoreType();\n  }\n\n  /**\n   * Initializes a new instance of `VectorStoreRetriever` with the specified configuration.\n   *\n   * This constructor configures the retriever to interact with a given `VectorStore`\n   * and supports different retrieval strategies, including similarity search and maximal\n   * marginal relevance (MMR) search. Various options allow customization of the number\n   * of documents retrieved per query, filtering based on conditions, and fine-tuning\n   * MMR-specific parameters.\n   *\n   * @param fields - Configuration options for setting up the retriever:\n   *\n   *   - `vectorStore` (required): The `VectorStore` instance implementing `VectorStoreInterface`\n   *     that will be used to store and retrieve document embeddings. This is the core component\n   *     of the retriever, enabling vector-based similarity and MMR searches.\n   *\n   *   - `k` (optional): Specifies the number of documents to retrieve per search query. If not\n   *     provided, defaults to 4. This count determines the number of most relevant documents returned\n   *     for each search operation, balancing performance with comprehensiveness.\n   *\n   *   - `searchType` (optional): Defines the search approach used by the retriever, allowing for\n   *     flexibility between two methods:\n   *       - `\"similarity\"` (default): A similarity-based search, retrieving documents with high vector\n   *         similarity to the query. This type prioritizes relevance and is often used when diversity\n   *         among results is less critical.\n   *       - `\"mmr\"`: Maximal Marginal Relevance search, which combines relevance with diversity. MMR\n   *         is useful for scenarios where varied content is essential, as it selects results that\n   *         both match the query and introduce content diversity.\n   *\n   *   - `filter` (optional): A filter of type `FilterType`, defined by the vector store, that allows\n   *     for refined and targeted search results. This filter applies specified conditions to limit\n   *     which documents are eligible for retrieval, offering control over the scope of results.\n   *\n   *   - `searchKwargs` (optional, applicable only if `searchType` is `\"mmr\"`): Additional settings\n   *     for configuring MMR-specific behavior. These parameters allow further tuning of the MMR\n   *     search process:\n   *       - `fetchK`: The initial number of documents fetched from the vector store before the MMR\n   *         algorithm is applied. Fetching a larger set enables the algorithm to select a more\n   *         diverse subset of documents.\n   *       - `lambda`: A parameter controlling the relevance-diversity balance, where 0 emphasizes\n   *         diversity and 1 prioritizes relevance. Intermediate values provide a blend of the two,\n   *         allowing customization based on the importance of content variety relative to query relevance.\n   */\n  constructor(fields: VectorStoreRetrieverInput<V>) {\n    super(fields);\n    this.vectorStore = fields.vectorStore;\n    this.k = fields.k ?? this.k;\n    this.searchType = fields.searchType ?? this.searchType;\n    this.filter = fields.filter;\n    if (fields.searchType === \"mmr\") {\n      this.searchKwargs = fields.searchKwargs;\n    }\n  }\n\n  /**\n   * Retrieves relevant documents based on the specified query, using either\n   * similarity or maximal marginal relevance (MMR) search.\n   *\n   * If `searchType` is set to `\"mmr\"`, performs an MMR search to balance\n   * similarity and diversity among results. If `searchType` is `\"similarity\"`,\n   * retrieves results purely based on similarity to the query.\n   *\n   * @param query - The query string used to find relevant documents.\n   * @param runManager - Optional callback manager for tracking retrieval progress.\n   * @returns A promise that resolves to an array of `DocumentInterface` instances\n   *          representing the most relevant documents to the query.\n   * @throws {Error} Throws an error if MMR search is requested but not supported\n   *                 by the vector store.\n   * @protected\n   */\n  async _getRelevantDocuments(\n    query: string,\n    runManager?: CallbackManagerForRetrieverRun\n  ): Promise<DocumentInterface[]> {\n    if (this.searchType === \"mmr\") {\n      if (typeof this.vectorStore.maxMarginalRelevanceSearch !== \"function\") {\n        throw new Error(\n          `The vector store backing this retriever, ${this._vectorstoreType()} does not support max marginal relevance search.`\n        );\n      }\n      return this.vectorStore.maxMarginalRelevanceSearch(\n        query,\n        {\n          k: this.k,\n          filter: this.filter,\n          ...this.searchKwargs,\n        },\n        runManager?.getChild(\"vectorstore\")\n      );\n    }\n    return this.vectorStore.similaritySearch(\n      query,\n      this.k,\n      this.filter,\n      runManager?.getChild(\"vectorstore\")\n    );\n  }\n\n  /**\n   * Adds an array of documents to the vector store, embedding them as part of\n   * the storage process.\n   *\n   * This method delegates document embedding and storage to the `addDocuments`\n   * method of the underlying vector store.\n   *\n   * @param documents - An array of documents to embed and add to the vector store.\n   * @param options - Optional settings to customize document addition.\n   * @returns A promise that resolves to an array of document IDs or `void`,\n   *          depending on the vector store's implementation.\n   */\n  async addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void> {\n    return this.vectorStore.addDocuments(documents, options);\n  }\n}\n\n/**\n * Interface defining the structure and operations of a vector store, which\n * facilitates the storage, retrieval, and similarity search of document vectors.\n *\n * `VectorStoreInterface` provides methods for adding, deleting, and searching\n * documents based on vector embeddings, including support for similarity\n * search with optional filtering and relevance-based retrieval.\n *\n * @extends Serializable\n */\nexport interface VectorStoreInterface extends Serializable {\n  /**\n   * Defines the filter type used in search and delete operations. Can be an\n   * object for structured conditions or a string for simpler filtering.\n   */\n  FilterType: object | string;\n\n  /**\n   * Instance of `EmbeddingsInterface` used to generate vector embeddings for\n   * documents, enabling vector-based search operations.\n   */\n  embeddings: EmbeddingsInterface;\n\n  /**\n   * Returns a string identifying the type of vector store implementation,\n   * useful for distinguishing between different vector storage backends.\n   *\n   * @returns {string} A string indicating the vector store type.\n   */\n  _vectorstoreType(): string;\n\n  /**\n   * Adds precomputed vectors and their corresponding documents to the vector store.\n   *\n   * @param vectors - An array of vectors, with each vector representing a document.\n   * @param documents - An array of `DocumentInterface` instances corresponding to each vector.\n   * @param options - Optional configurations for adding documents, potentially covering indexing or metadata handling.\n   * @returns A promise that resolves to an array of document IDs or void, depending on implementation.\n   */\n  addVectors(\n    vectors: number[][],\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Adds an array of documents to the vector store.\n   *\n   * @param documents - An array of documents to be embedded and stored in the vector store.\n   * @param options - Optional configurations for embedding and storage operations.\n   * @returns A promise that resolves to an array of document IDs or void, depending on implementation.\n   */\n  addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Deletes documents from the vector store based on the specified parameters.\n   *\n   * @param _params - A flexible object containing key-value pairs that define\n   *                  the conditions for selecting documents to delete.\n   * @returns A promise that resolves once the deletion operation is complete.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  delete(_params?: Record<string, any>): Promise<void>;\n\n  /**\n   * Searches for documents similar to a given vector query and returns them\n   * with similarity scores.\n   *\n   * @param query - A vector representing the query for similarity search.\n   * @param k - The number of similar documents to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @returns A promise that resolves to an array of tuples, each containing a\n   *          `DocumentInterface` and its corresponding similarity score.\n   */\n  similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[DocumentInterface, number][]>;\n\n  /**\n   * Searches for documents similar to a text query, embedding the query\n   * and retrieving documents based on vector similarity.\n   *\n   * @param query - The text query to search for.\n   * @param k - Optional number of similar documents to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @param callbacks - Optional callbacks for tracking progress or events\n   *                    during the search process.\n   * @returns A promise that resolves to an array of `DocumentInterface`\n   *          instances representing similar documents.\n   */\n  similaritySearch(\n    query: string,\n    k?: number,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks\n  ): Promise<DocumentInterface[]>;\n\n  /**\n   * Searches for documents similar to a text query and includes similarity\n   * scores in the result.\n   *\n   * @param query - The text query to search for.\n   * @param k - Optional number of similar documents to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @param callbacks - Optional callbacks for tracking progress or events\n   *                    during the search process.\n   * @returns A promise that resolves to an array of tuples, each containing\n   *          a `DocumentInterface` and its similarity score.\n   */\n  similaritySearchWithScore(\n    query: string,\n    k?: number,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks\n  ): Promise<[DocumentInterface, number][]>;\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {this[\"FilterType\"]} options.filter - Optional filter\n   * @param _callbacks\n   *\n   * @returns {Promise<DocumentInterface[]>} - List of documents selected by maximal marginal relevance.\n   */\n  maxMarginalRelevanceSearch?(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>,\n    callbacks: Callbacks | undefined\n  ): Promise<DocumentInterface[]>;\n\n  /**\n   * Converts the vector store into a retriever, making it suitable for use in\n   * retrieval-based workflows and allowing additional configuration.\n   *\n   * @param kOrFields - Optional parameter for specifying either the number of\n   *                    documents to retrieve or partial retriever configurations.\n   * @param filter - Optional filter based on `FilterType` for retrieval restriction.\n   * @param callbacks - Optional callbacks for tracking retrieval events or progress.\n   * @param tags - General-purpose tags to add contextual information to the retriever.\n   * @param metadata - General-purpose metadata providing additional context\n   *                   for retrieval.\n   * @param verbose - If `true`, enables detailed logging during retrieval.\n   * @returns An instance of `VectorStoreRetriever` configured with the specified options.\n   */\n  asRetriever(\n    kOrFields?: number | Partial<VectorStoreRetrieverInput<this>>,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    verbose?: boolean\n  ): VectorStoreRetriever<this>;\n}\n\n/**\n * Abstract class representing a vector storage system for performing\n * similarity searches on embedded documents.\n *\n * `VectorStore` provides methods for adding precomputed vectors or documents,\n * removing documents based on criteria, and performing similarity searches\n * with optional scoring. Subclasses are responsible for implementing specific\n * storage mechanisms and the exact behavior of certain abstract methods.\n *\n * @abstract\n * @extends Serializable\n * @implements VectorStoreInterface\n */\nexport abstract class VectorStore\n  extends Serializable\n  implements VectorStoreInterface\n{\n  declare FilterType: object | string;\n\n  /**\n   * Namespace within LangChain to uniquely identify this vector store's\n   * location, based on the vector store type.\n   *\n   * @internal\n   */\n  // Only ever instantiated in main LangChain\n  lc_namespace = [\"langchain\", \"vectorstores\", this._vectorstoreType()];\n\n  /**\n   * Embeddings interface for generating vector embeddings from text queries,\n   * enabling vector-based similarity searches.\n   */\n  embeddings: EmbeddingsInterface;\n\n  /**\n   * Initializes a new vector store with embeddings and database configuration.\n   *\n   * @param embeddings - Instance of `EmbeddingsInterface` used to embed queries.\n   * @param dbConfig - Configuration settings for the database or storage system.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(embeddings: EmbeddingsInterface, dbConfig: Record<string, any>) {\n    super(dbConfig);\n    this.embeddings = embeddings;\n  }\n\n  /**\n   * Returns a string representing the type of vector store, which subclasses\n   * must implement to identify their specific vector storage type.\n   *\n   * @returns {string} A string indicating the vector store type.\n   * @abstract\n   */\n  abstract _vectorstoreType(): string;\n\n  /**\n   * Adds precomputed vectors and corresponding documents to the vector store.\n   *\n   * @param vectors - An array of vectors representing each document.\n   * @param documents - Array of documents associated with each vector.\n   * @param options - Optional configuration for adding vectors, such as indexing.\n   * @returns A promise resolving to an array of document IDs or void, based on implementation.\n   * @abstract\n   */\n  abstract addVectors(\n    vectors: number[][],\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Adds documents to the vector store, embedding them first through the\n   * `embeddings` instance.\n   *\n   * @param documents - Array of documents to embed and add.\n   * @param options - Optional configuration for embedding and storing documents.\n   * @returns A promise resolving to an array of document IDs or void, based on implementation.\n   * @abstract\n   */\n  abstract addDocuments(\n    documents: DocumentInterface[],\n    options?: AddDocumentOptions\n  ): Promise<string[] | void>;\n\n  /**\n   * Deletes documents from the vector store based on the specified parameters.\n   *\n   * @param _params - Flexible key-value pairs defining conditions for document deletion.\n   * @returns A promise that resolves once the deletion is complete.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async delete(_params?: Record<string, any>): Promise<void> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  /**\n   * Performs a similarity search using a vector query and returns results\n   * along with their similarity scores.\n   *\n   * @param query - Vector representing the search query.\n   * @param k - Number of similar results to return.\n   * @param filter - Optional filter based on `FilterType` to restrict results.\n   * @returns A promise resolving to an array of tuples containing documents and their similarity scores.\n   * @abstract\n   */\n  abstract similaritySearchVectorWithScore(\n    query: number[],\n    k: number,\n    filter?: this[\"FilterType\"]\n  ): Promise<[DocumentInterface, number][]>;\n\n  /**\n   * Searches for documents similar to a text query by embedding the query and\n   * performing a similarity search on the resulting vector.\n   *\n   * @param query - Text query for finding similar documents.\n   * @param k - Number of similar results to return. Defaults to 4.\n   * @param filter - Optional filter based on `FilterType`.\n   * @param _callbacks - Optional callbacks for monitoring search progress\n   * @returns A promise resolving to an array of `DocumentInterface` instances representing similar documents.\n   */\n  async similaritySearch(\n    query: string,\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined,\n    _callbacks: Callbacks | undefined = undefined // implement passing to embedQuery later\n  ): Promise<DocumentInterface[]> {\n    const results = await this.similaritySearchVectorWithScore(\n      await this.embeddings.embedQuery(query),\n      k,\n      filter\n    );\n\n    return results.map((result) => result[0]);\n  }\n\n  /**\n   * Searches for documents similar to a text query by embedding the query,\n   * and returns results with similarity scores.\n   *\n   * @param query - Text query for finding similar documents.\n   * @param k - Number of similar results to return. Defaults to 4.\n   * @param filter - Optional filter based on `FilterType`.\n   * @param _callbacks - Optional callbacks for monitoring search progress\n   * @returns A promise resolving to an array of tuples, each containing a\n   *          document and its similarity score.\n   */\n  async similaritySearchWithScore(\n    query: string,\n    k = 4,\n    filter: this[\"FilterType\"] | undefined = undefined,\n    _callbacks: Callbacks | undefined = undefined // implement passing to embedQuery later\n  ): Promise<[DocumentInterface, number][]> {\n    return this.similaritySearchVectorWithScore(\n      await this.embeddings.embedQuery(query),\n      k,\n      filter\n    );\n  }\n\n  /**\n   * Return documents selected using the maximal marginal relevance.\n   * Maximal marginal relevance optimizes for similarity to the query AND diversity\n   * among selected documents.\n   *\n   * @param {string} query - Text to look up documents similar to.\n   * @param {number} options.k - Number of documents to return.\n   * @param {number} options.fetchK - Number of documents to fetch before passing to the MMR algorithm.\n   * @param {number} options.lambda - Number between 0 and 1 that determines the degree of diversity among the results,\n   *                 where 0 corresponds to maximum diversity and 1 to minimum diversity.\n   * @param {this[\"FilterType\"]} options.filter - Optional filter\n   * @param _callbacks\n   *\n   * @returns {Promise<DocumentInterface[]>} - List of documents selected by maximal marginal relevance.\n   */\n  async maxMarginalRelevanceSearch?(\n    query: string,\n    options: MaxMarginalRelevanceSearchOptions<this[\"FilterType\"]>,\n    _callbacks: Callbacks | undefined // implement passing to embedQuery later\n  ): Promise<DocumentInterface[]>;\n\n  /**\n   * Creates a `VectorStore` instance from an array of text strings and optional\n   * metadata, using the specified embeddings and database configuration.\n   *\n   * Subclasses must implement this method to define how text and metadata\n   * are embedded and stored in the vector store. Throws an error if not overridden.\n   *\n   * @param _texts - Array of strings representing the text documents to be stored.\n   * @param _metadatas - Metadata for the texts, either as an array (one for each text)\n   *                     or a single object (applied to all texts).\n   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the texts.\n   * @param _dbConfig - Database configuration settings.\n   * @returns A promise that resolves to a new `VectorStore` instance.\n   * @throws {Error} Throws an error if this method is not overridden by a subclass.\n   */\n  static fromTexts(\n    _texts: string[],\n    _metadatas: object[] | object,\n    _embeddings: EmbeddingsInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _dbConfig: Record<string, any>\n  ): Promise<VectorStore> {\n    throw new Error(\n      \"the Langchain vectorstore implementation you are using forgot to override this, please report a bug\"\n    );\n  }\n\n  /**\n   * Creates a `VectorStore` instance from an array of documents, using the specified\n   * embeddings and database configuration.\n   *\n   * Subclasses must implement this method to define how documents are embedded\n   * and stored. Throws an error if not overridden.\n   *\n   * @param _docs - Array of `DocumentInterface` instances representing the documents to be stored.\n   * @param _embeddings - Instance of `EmbeddingsInterface` to embed the documents.\n   * @param _dbConfig - Database configuration settings.\n   * @returns A promise that resolves to a new `VectorStore` instance.\n   * @throws {Error} Throws an error if this method is not overridden by a subclass.\n   */\n  static fromDocuments(\n    _docs: DocumentInterface[],\n    _embeddings: EmbeddingsInterface,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _dbConfig: Record<string, any>\n  ): Promise<VectorStore> {\n    throw new Error(\n      \"the Langchain vectorstore implementation you are using forgot to override this, please report a bug\"\n    );\n  }\n\n  /**\n   * Creates a `VectorStoreRetriever` instance with flexible configuration options.\n   *\n   * @param kOrFields\n   *    - If a number is provided, it sets the `k` parameter (number of items to retrieve).\n   *    - If an object is provided, it should contain various configuration options.\n   * @param filter\n   *    - Optional filter criteria to limit the items retrieved based on the specified filter type.\n   * @param callbacks\n   *    - Optional callbacks that may be triggered at specific stages of the retrieval process.\n   * @param tags\n   *    - Tags to categorize or label the `VectorStoreRetriever`. Defaults to an empty array if not provided.\n   * @param metadata\n   *    - Additional metadata as key-value pairs to add contextual information for the retrieval process.\n   * @param verbose\n   *    - If `true`, enables detailed logging for the retrieval process. Defaults to `false`.\n   *\n   * @returns\n   *    - A configured `VectorStoreRetriever` instance based on the provided parameters.\n   *\n   * @example\n   * Basic usage with a `k` value:\n   * ```typescript\n   * const retriever = myVectorStore.asRetriever(5);\n   * ```\n   *\n   * Usage with a configuration object:\n   * ```typescript\n   * const retriever = myVectorStore.asRetriever({\n   *   k: 10,\n   *   filter: myFilter,\n   *   tags: ['example', 'test'],\n   *   verbose: true,\n   *   searchType: 'mmr',\n   *   searchKwargs: { alpha: 0.5 },\n   * });\n   * ```\n   */\n  asRetriever(\n    kOrFields?: number | Partial<VectorStoreRetrieverInput<this>>,\n    filter?: this[\"FilterType\"],\n    callbacks?: Callbacks,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    verbose?: boolean\n  ): VectorStoreRetriever<this> {\n    if (typeof kOrFields === \"number\") {\n      return new VectorStoreRetriever({\n        vectorStore: this,\n        k: kOrFields,\n        filter,\n        tags: [...(tags ?? []), this._vectorstoreType()],\n        metadata,\n        verbose,\n        callbacks,\n      });\n    } else {\n      const params = {\n        vectorStore: this,\n        k: kOrFields?.k,\n        filter: kOrFields?.filter,\n        tags: [...(kOrFields?.tags ?? []), this._vectorstoreType()],\n        metadata: kOrFields?.metadata,\n        verbose: kOrFields?.verbose,\n        callbacks: kOrFields?.callbacks,\n        searchType: kOrFields?.searchType,\n      };\n      if (kOrFields?.searchType === \"mmr\") {\n        return new VectorStoreRetriever({\n          ...params,\n          searchKwargs: kOrFields.searchKwargs,\n        });\n      }\n      return new VectorStoreRetriever({ ...params });\n    }\n  }\n}\n\n/**\n * Abstract class extending `VectorStore` that defines a contract for saving\n * and loading vector store instances.\n *\n * The `SaveableVectorStore` class allows vector store implementations to\n * persist their data and retrieve it when needed.The format for saving and\n * loading data is left to the implementing subclass.\n *\n * Subclasses must implement the `save` method to handle their custom\n * serialization logic, while the `load` method enables reconstruction of a\n * vector store from saved data, requiring compatible embeddings through the\n * `EmbeddingsInterface`.\n *\n * @abstract\n * @extends VectorStore\n */\nexport abstract class SaveableVectorStore extends VectorStore {\n  /**\n   * Saves the current state of the vector store to the specified directory.\n   *\n   * This method must be implemented by subclasses to define their own\n   * serialization process for persisting vector data. The implementation\n   * determines the structure and format of the saved data.\n   *\n   * @param directory - The directory path where the vector store data\n   * will be saved.\n   * @abstract\n   */\n  abstract save(directory: string): Promise<void>;\n\n  /**\n   * Loads a vector store instance from the specified directory, using the\n   * provided embeddings to ensure compatibility.\n   *\n   * This static method reconstructs a `SaveableVectorStore` from previously\n   * saved data. Implementations should interpret the saved data format to\n   * recreate the vector store instance.\n   *\n   * @param _directory - The directory path from which the vector store\n   * data will be loaded.\n   * @param _embeddings - An instance of `EmbeddingsInterface` to align\n   * the embeddings with the loaded vector data.\n   * @returns A promise that resolves to a `SaveableVectorStore` instance\n   * constructed from the saved data.\n   */\n  static load(\n    _directory: string,\n    _embeddings: EmbeddingsInterface\n  ): Promise<SaveableVectorStore> {\n    throw new Error(\"Not implemented\");\n  }\n}\n"],"names":["s: string","refs: Refs","message: T","acc: { [key: string]: JsonSchema7Type }","name","schema","candidate","i","block: ContentBlock","vectors: number[][]","inheritableMetadata: Record<string, unknown>","_parentRunId?: string","obj","input: AsyncGenerator<RunInput>","sax","data: Record<string, unknown>","a: string | number","n","b: ValueType[C]","_tags?: string[]","prompt: string","options: Partial<O> | Partial<O>[]","callbacks?: Callbacks","value","text: string","msgs: BaseMessage[]","llmOutput?: string","runConfig: LangGraphRunnableConfig","tags?: string[]","metadata?: KVMap","name?: string","x: unknown","_messages: BaseMessage[]","config: Partial<CallOptions>","x: BaseMessage","fields?: HandleLLMNewTokenCallbackFields","key","call","description","result","runId: string","parentRunId?: string","acc: string","item","err","banPrototypeModifications: boolean","index: number","tokens","blocks","e: any","messages: BaseMessageLike[][]","handledOptions: RunnableConfig","message: string | undefined","run: Run","stream: ReadableStream","input: T","options?: Partial<CallOptions> & { runType?: string }","kwargs?: { inputs?: Record<string, unknown> }","generations: ChatGeneration[]","options?: AddDocumentOptions","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n  }","regex: RegExp","extraParams?: KVMap","additionalOptions?: _StringImageMessagePromptTemplateOptions","options: {\n    maxTokens: number;\n    tokenCounter: (messages: BaseMessage[]) => Promise<number>;\n    textSplitter: (text: string) => Promise<string[]>;\n    /**\n     * @default {false}\n     */\n    allowPartial?: boolean;\n    /**\n     * @default {false}\n     */\n    includeSystem?: boolean;\n    startOn?: MessageTypeOrClass | MessageTypeOrClass[];\n    endOn?: MessageTypeOrClass | MessageTypeOrClass[];\n  }","result: ParsedToolCall","message: EventSourceMessage","batchOptions?: RunnableBatchOptions","value?: unknown","textContent: string","extraParams?: Record<string, unknown>","chunk: AIMessageChunk<TStructure>","runManager?: CallbackManagerForToolRun","found: Node[]","inputGenerator: AsyncGenerator<I>","transformer: (\n      generator: AsyncGenerator<I>,\n      runManager?: CallbackManagerForChainRun,\n      options?: Partial<CallOptions>\n    ) => AsyncGenerator<O>","inputs: ChainValues","runType?: string","input: BaseLanguageModelInput","obj: unknown","fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>","messageType: MessageType","patch: ReadonlyArray<Operation>","_config?: StructuredOutputMethodOptions<boolean>","parsedTemplate: ParsedTemplateNode[]","chunks","filter: this[\"FilterType\"] | undefined","operation: Operation","input: TypedPromptInputValues<RunInput>","_embeddings: EmbeddingsInterface","_dbConfig: Record<string, any>","messageLike?: unknown","existingValue: any","content","llm: Serialized","runId: string | undefined","extraParams: Record<string, unknown> | undefined","_tags: string[] | undefined","runName: string | undefined","uuidv4","chunk: BaseMessageChunk","document?: T","externalValidator?: Validator<T>","mapping: RunnableMapLike<Record<string, unknown>, Record<string, unknown>>","tool: Serialized","input: string","_metadata: Record<string, unknown> | undefined","a: any","b: any","parsedOptions: CallOptions | undefined","error: unknown","verbose?: boolean","meta","chain: Serialized","runType: string | undefined","eventName: string","data: any","_options?: this[\"ParsedCallOptions\"]","retriever: Serialized","_parentRunId: string | undefined","query: string","isUuid","options: Partial<CallOptions> & {\n      version: \"v1\" | \"v2\";\n      encoding?: \"text/event-stream\" | undefined;\n    }","outputSchema:\n      | InteropZodType<RunOutput>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      | Record<string, any>","streamOptions?: Omit<EventStreamCallbackHandlerInput, \"autoClose\">","messagePromptTemplateLike: BaseMessagePromptTemplateLike","extra?: Extra","_metadata?: Record<string, any>","_directory: string","schema: T","documents: Document<Record<string, unknown>>[]","task","tags: string[]","schema: InteropZodType","input: any","config","recursive: boolean","x: BaseMessagePromptTemplate | BaseMessage","messages: BaseMessage[]","options: this[\"ParsedCallOptions\"]","runManager?: CallbackManagerForLLMRun","additionalHandlers: BaseCallbackHandler[]","input","input: RunInput","options: Partial<CallOptions> & { version: \"v1\" | \"v2\" }","streamOptions?: Omit<LogStreamCallbackHandlerInput, \"autoClose\">","input: ChatPromptTemplateInput<RunInput, PartialVariableName>","handlers: CallbackHandlerMethods","config: RunnableConfig","localHandlers?: Callbacks","inheritableTags?: string[]","localTags?: string[]","inheritableMetadata?: Record<string, unknown>","localMetadata?: Record<string, unknown>","options?: CallbackManagerOptions","message: BaseMessage","state","predicate: (key: string, value: InteropZodType) => boolean","values: TypedPromptInputValues<RunInput>","destinations: (string | Send)[]","tasksWithWrites","values: PartialValues<NewPartialVariableName>","e: unknown","checkpointNamespace: string","template: T","options?: Omit<\n      PromptTemplateInput<RunInput, string, TemplateFormat>,\n      \"template\" | \"inputVariables\"\n    >","handler: BaseCallbackHandler | CallbackHandlerMethods","promptMessages: (\n      | ChatPromptTemplate<InputValues, string>\n      | BaseMessagePromptTemplateLike\n    )[]","extra?: Omit<\n      Extra,\n      \"inputVariables\" | \"promptMessages\" | \"partialVariables\"\n    >","s","resume","checkpointer: BaseCheckpointSaver | undefined","nextConfig","fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions>","suffix?: string | undefined","fields?: {\n    stopAfterAttempt?: number;\n    onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n  }","values","options?: Partial<CallOptions> | Partial<CallOptions>[]","first: O","options?: Partial<CallOptions> | undefined","asNode","thing: any","tasks","validUpdates: Array<{\n        values: Record<string, unknown> | unknown;\n        asNode: keyof Nodes | string;\n        taskId?: string;\n      }>","fields: {\n    bound: Runnable<RunInputItem, RunOutputItem, CallOptions>;\n  }","inputs: RunInputItem[]","tasks: PregelExecutableTask<keyof Nodes, keyof Channels>[]","config?: Partial<CallOptions>","runManager?: CallbackManagerForChainRun","fields: RunnableBindingArgs<RunInput, RunOutput, CallOptions> & {\n      maxAttemptNumber?: number;\n      onFailedAttempt?: RunnableRetryFailedAttemptHandler;\n    }","attempt: number","config?: CallOptions","attemptNumber: number","defaultStreamMode: StreamMode[]","inputs: RunInput[]","configs?: RunnableConfig[]","runManagers?: (CallbackManagerForChainRun | undefined)[]","defaultCheckpointer: BaseCheckpointSaver | undefined","checkpointDuringDurability: Durability | undefined","defaultDurability: Durability","fields: RunnableSequenceFields<RunInput, RunOutput>","options?: RunnableConfig","finalOutput: RunOutput","options?: Partial<RunnableConfig> | Partial<RunnableConfig>[]","loopError: unknown","config?: RunnableConfig","currentLastNode: any","nameOrFields?:\n      | string\n      | Omit<\n          RunnableSequenceFields<RunInput, RunOutput>,\n          \"first\" | \"middle\" | \"last\"\n        >","fields: { steps: RunnableMapLike<RunInput, RunOutput> }","steps: RunnableMapLike<RunInput, RunOutput>","output: Record<string, any>","interruptChunks: Interrupt[][]","latest: OutputType | undefined","generator: AsyncGenerator<RunInput>","options?: Partial<RunnableConfig>","fields: { func: AnyTraceableFunction }","state: IteratorResult<unknown>","func: AnyTraceableFunction","func:\n    | RunnableFunc<\n        RunInput,\n        RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n        CallOptions\n      >\n    | TraceableFunction<\n        RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      >","fields: {\n    func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >;\n  }","func:\n      | RunnableFunc<\n          RunInput,\n          RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n          CallOptions\n        >\n      | TraceableFunction<\n          RunnableFunc<\n            RunInput,\n            RunOutput | Runnable<RunInput, RunOutput, CallOptions>,\n            CallOptions\n          >\n        >","finalOutput: RunOutput | undefined","options?: Partial<CallOptions>","finalChunk: RunInput | undefined","fields: {\n    runnable: Runnable<RunInput, RunOutput>;\n    fallbacks: Runnable<RunInput, RunOutput>[];\n  }","options?: Partial<RunnableConfig> | undefined","firstError: any","coerceable: RunnableLike<RunInput, RunOutput, CallOptions>","fields: RunnableMap<RunInput> | RunnableAssignFields<RunInput>","fields: string | string[] | RunnablePickFields","fields: RunnableToolLikeArgs<RunInput, RunOutput>","toolInput: InferInteropZodOutput<RunInput>","runnable: Runnable<RunInput, RunOutput>","fields: {\n    name?: string;\n    description?: string;\n    schema: InteropZodType<RunInput>;\n  }"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,148,149,150,151,152,153,154,155,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,204,205,206,207,208,209,210,211,212,213,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385]}